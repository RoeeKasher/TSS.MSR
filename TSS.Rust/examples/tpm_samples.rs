use std::io::{self, Write};
use tss_rust::{
    device::{TpmDevice, TpmTbsDevice},
    tpm2_impl::*,
    tpm_structure::TpmEnum,
    tpm_types::{TPMU_CAPABILITIES, TPM_CAP, TPM_CC},
};

fn set_color(color: u8) {
    // This function simulates setting text color. In a real application, you can use libraries like `termcolor` or `colored`.
    // This is just a placeholder since color setting is typically platform-dependent (like ANSI codes on Linux/macOS).
    if color == 0 {
        print!("\x1b[0m"); // Reset color (for simplicity, this is just a reset for terminal color)
    } else {
        print!("\x1b[1;32m"); // Green color (for example, setting to green)
    }
}

fn announce(test_name: &str) {
    set_color(1); // Reset color (probably to default)
    println!();
    println!("==============================================================================================================================");
    println!("               {}", test_name);
    println!("==============================================================================================================================");
    println!();
    io::stdout().flush().unwrap(); // Ensure everything is printed out
    set_color(0); // Set color (e.g., green)
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Example usage of the TSS.Rust library
    let mut device = Box::new(TpmTbsDevice::new());
    device.connect()?;
    let mut tpm = create_tpm_with_device(device);

    let mut start_val = 0;

    announce("************************* Algorithms *************************");

    // For the first example we show how to get a batch (8) properties at a time.
    // For simplicity, subsequent samples just get one at a time: avoiding the
    // nested loop.

    loop {
        let addition_to_start_val: u32;

        let caps = tpm.GetCapability(TPM_CAP::ALGS, start_val, 8)?;
        if let Some(caps) = caps.capabilityData {
            if let TPMU_CAPABILITIES::algorithms(props) = caps {
                for p in props.algProperties.iter() {
                    println!("{}: {}", p.alg, p.algProperties);
                }

                addition_to_start_val = (props.algProperties[props.algProperties.len() - 1]
                    .alg
                    .get_value()
                    + 1)
                .into();
            } else {
                break;
            }
        } else {
            break;
        }

        if (caps.moreData == 0) {
            break;
        }

        start_val += addition_to_start_val;
    }

    start_val = 0;

    let mut supported_commands: Vec<String> = Vec::new();

    loop {
        let caps = tpm.GetCapability(TPM_CAP::COMMANDS, start_val, 32)?;

        if let Some(caps) = caps.capabilityData {
            if let TPMU_CAPABILITIES::command(props) = caps {
                for p in props.commandAttributes.iter() {
                    let command_value = p.get_value() & 0xFFFF;
                    // Decode the packed structure
                    if let Ok(cc) = TPM_CC::try_from(command_value) {
                        supported_commands.push(format!("TPM_CC_{}", cc.to_string()));
                    }
                    // let masked_attr = TPMA_CC::try_from(p.get_value() & 0xFFff0000)?;

                    // println!("Command {}", cc);

                    start_val = command_value;
                }
            } else {
                break;
            }
        } else {
            break;
        }

        if (caps.moreData == 0) {
            break;
        }

        start_val += 1;
    }

    supported_commands.sort();

    let announcement = format!("TPM supports {} commands", supported_commands.len());

    announce(&announcement);
    let column_width = 35;
    let columns = 3;
    let rows = (supported_commands.len() + columns - 1) / columns;

    for row in 0..rows {
        for col in 0..columns {
            let index = row + col * rows;
            if index < supported_commands.len() {
                let cmd = &supported_commands[index];
                print!("{:<width$}", cmd, width = column_width);
            }
        }
        println!(); // Print newline after each row
    }

    announce(
        "************************* ðŸ¦€ðŸ¦€ðŸ¦€ Generated by Tss.Rust ðŸ¦€ðŸ¦€ðŸ¦€ *************************",
    );

    Ok(())
    // startVal = 0;
    // cout << "PCRS: " << endl;
    // auto caps2 = tpm.GetCapability(TPM_CAP::PCRS, 0, 1);
    // auto pcrs = dynamic_cast<TPML_PCR_SELECTION*>(&*caps2.capabilityData);

    // for (auto it = pcrs->pcrSelections.begin(); it != pcrs->pcrSelections.end(); it++)
    // {
    //     cout << EnumToStr(it->hash) << "\t";
    //     auto pcrsWithThisHash = it->ToArray();

    //     for (auto p = pcrsWithThisHash.begin(); p != pcrsWithThisHash.end(); p++)
    //         cout << *p << " ";
    //     cout << endl;
    // }
}
