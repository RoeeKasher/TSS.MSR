/*
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See the LICENSE file in the project root for full license information.
 */

/*
 * NOTE: this file is partially auto generated!
 *
 * All code after the point marked with the '// <<AUTOGEN_BEGIN>>' comment
 * is autogenerated from the TPM 2.0 Specification docs.
 *
 * DO NOT EDIT AUTOGENERATED PART - all manual changes will be lost!
 */

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        // <<AUTOGEN_BEGIN>>
// ------------------------------------------------------------------------------------------------
// DO NOT REMOVE the <<AUTOGEN_BEGIN>> comment!
// DO NOT MODIFY any code below this point - all manual changes will be lost!
// ------------------------------------------------------------------------------------------------

//! TPM type definitions

use crate::error::TpmError;
use crate::tpm_buffer::TpmBuffer;
use std::fmt;
use num_enum::TryFromPrimitive;

/// Table 2 is the list of algorithms to which the TCG has assigned an algorithm
/// identifier along with its numeric identifier.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, TryFromPrimitive)]
#[repr(i16)]
pub enum TPM_ALG_ID {
    /// Should not occur
    ERROR = 0x0, // Original value: 0x0000

    /// An object type that contains an RSA key
    FIRST = 0x1, // Original value: 0x0001

    /// An object type that contains an RSA key
    // WARNING: RSA has duplicate value 0x1 - using name + value pattern
    RSAValue = 0x1, // Original value: 0x0001

    /// Block cipher with various key sizes (Triple Data Encryption Algorithm, commonly called
    /// Triple Data Encryption Standard)
    TDES = 0x3, // Original value: 0x0003

    /// Hash algorithm producing a 160-bit digest
    SHA = 0x4, // Original value: 0x0004

    /// Redefinition for documentation consistency
    // WARNING: SHA1 has duplicate value 0x4 - using name + value pattern
    SHA1Value = 0x4, // Original value: 0x0004

    /// Hash Message Authentication Code (HMAC) algorithm
    HMAC = 0x5, // Original value: 0x0005

    /// Block cipher with various key sizes
    AES = 0x6, // Original value: 0x0006

    /// Hash-based mask-generation function
    MGF1 = 0x7, // Original value: 0x0007

    /// An object type that may use XOR for encryption or an HMAC for signing and may also
    /// refer to a data object that is neither signing nor encrypting
    KEYEDHASH = 0x8, // Original value: 0x0008

    /// Hash-based stream cipher
    XOR = 0xA, // Original value: 0x000A

    /// Hash algorithm producing a 256-bit digest
    SHA256 = 0xB, // Original value: 0x000B

    /// Hash algorithm producing a 384-bit digest
    SHA384 = 0xC, // Original value: 0x000C

    /// Hash algorithm producing a 512-bit digest
    SHA512 = 0xD, // Original value: 0x000D

    /// Indication that no algorithm is selected
    NULL = 0x10, // Original value: 0x0010

    /// Hash algorithm producing a 256-bit digest
    SM3_256 = 0x12, // Original value: 0x0012

    /// Symmetric block cipher with 128 bit key
    SM4 = 0x13, // Original value: 0x0013

    /// A signature algorithm defined in section 8.2 (RSASSA-PKCS1-v1_5)
    RSASSA = 0x14, // Original value: 0x0014

    /// A padding algorithm defined in section 7.2 (RSAES-PKCS1-v1_5)
    RSAES = 0x15, // Original value: 0x0015

    /// A signature algorithm defined in section 8.1 (RSASSA-PSS)
    RSAPSS = 0x16, // Original value: 0x0016

    /// A padding algorithm defined in Section 7.1 (RSAES_OAEP)
    OAEP = 0x17, // Original value: 0x0017

    /// Signature algorithm using elliptic curve cryptography (ECC)
    ECDSA = 0x18, // Original value: 0x0018

    /// Secret sharing using ECC Based on context, this can be either One-Pass Diffie-Hellman,
    /// C(1, 1, ECC CDH) defined in 6.2.2.2 or Full Unified Model C(2, 2, ECC CDH) defined in 6.1.1.2
    ECDH = 0x19, // Original value: 0x0019

    /// Elliptic-curve based, anonymous signing scheme
    ECDAA = 0x1A, // Original value: 0x001A

    /// Depending on context, either an elliptic-curve-based signature algorithm, encryption
    /// algorithm, or key exchange protocol
    SM2 = 0x1B, // Original value: 0x001B

    /// Elliptic-curve based Schnorr signature
    ECSCHNORR = 0x1C, // Original value: 0x001C

    /// Two-phase elliptic-curve key exchange C(2, 2, ECC MQV) Section 6.1.1.4
    ECMQV = 0x1D, // Original value: 0x001D

    /// Concatenation key derivation function (approved alternative 1) Section 5.8.1
    KDF1_SP800_56A = 0x20, // Original value: 0x0020

    /// Key derivation function KDF2 Section 13.2
    KDF2 = 0x21, // Original value: 0x0021

    /// A key derivation method SP800-108, Section 5.1 KDF in Counter Mode
    KDF1_SP800_108 = 0x22, // Original value: 0x0022

    /// Prime field ECC
    ECC = 0x23, // Original value: 0x0023

    /// The object type for a symmetric block cipher key
    SYMCIPHER = 0x25, // Original value: 0x0025

    /// Symmetric block cipher with various key sizes
    CAMELLIA = 0x26, // Original value: 0x0026

    /// Hash algorithm producing a 256-bit digest
    SHA3_256 = 0x27, // Original value: 0x0027

    /// Hash algorithm producing a 384-bit digest
    SHA3_384 = 0x28, // Original value: 0x0028

    /// Hash algorithm producing a 512-bit digest
    SHA3_512 = 0x29, // Original value: 0x0029
    CMAC = 0x3F, // Original value: 0x003F

    /// Counter mode if implemented, all symmetric block ciphers (S type) implemented shall be
    /// capable of using this mode.
    CTR = 0x40, // Original value: 0x0040

    /// Output Feedback mode if implemented, all symmetric block ciphers (S type) implemented
    /// shall be capable of using this mode.
    OFB = 0x41, // Original value: 0x0041

    /// Cipher Block Chaining mode if implemented, all symmetric block ciphers (S type)
    /// implemented shall be capable of using this mode.
    CBC = 0x42, // Original value: 0x0042

    /// Cipher Feedback mode if implemented, all symmetric block ciphers (S type) implemented
    /// shall be capable of using this mode.
    CFB = 0x43, // Original value: 0x0043

    /// Electronic Codebook mode if implemented, all implemented symmetric block ciphers (S
    /// type) shall be capable of using this mode.
    /// NOTE This mode is not recommended for uses unless the key is frequently rotated such
    /// as in video codecs
    ECB = 0x44, // Original value: 0x0044
    // WARNING: LAST has duplicate value 0x44 - using name + value pattern
    LASTValue = 0x44, // Original value: 0x0044

    /// Phony alg ID to be used for the first union member with no selector
    ANY = 0x7FFF,

    /// Phony alg ID to be used for the second union member with no selector
    ANY2 = 0x7FFE
}

impl fmt::Display for TPM_ALG_ID {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::ERROR => write!(f, "ERROR"),
            Self::FIRST => write!(f, "FIRST"),
            Self::RSA => write!(f, "RSA"),
            Self::TDES => write!(f, "TDES"),
            Self::SHA => write!(f, "SHA"),
            Self::SHA1 => write!(f, "SHA1"),
            Self::HMAC => write!(f, "HMAC"),
            Self::AES => write!(f, "AES"),
            Self::MGF1 => write!(f, "MGF1"),
            Self::KEYEDHASH => write!(f, "KEYEDHASH"),
            Self::XOR => write!(f, "XOR"),
            Self::SHA256 => write!(f, "SHA256"),
            Self::SHA384 => write!(f, "SHA384"),
            Self::SHA512 => write!(f, "SHA512"),
            Self::NULL => write!(f, "NULL"),
            Self::SM3_256 => write!(f, "SM3_256"),
            Self::SM4 => write!(f, "SM4"),
            Self::RSASSA => write!(f, "RSASSA"),
            Self::RSAES => write!(f, "RSAES"),
            Self::RSAPSS => write!(f, "RSAPSS"),
            Self::OAEP => write!(f, "OAEP"),
            Self::ECDSA => write!(f, "ECDSA"),
            Self::ECDH => write!(f, "ECDH"),
            Self::ECDAA => write!(f, "ECDAA"),
            Self::SM2 => write!(f, "SM2"),
            Self::ECSCHNORR => write!(f, "ECSCHNORR"),
            Self::ECMQV => write!(f, "ECMQV"),
            Self::KDF1_SP800_56A => write!(f, "KDF1_SP800_56A"),
            Self::KDF2 => write!(f, "KDF2"),
            Self::KDF1_SP800_108 => write!(f, "KDF1_SP800_108"),
            Self::ECC => write!(f, "ECC"),
            Self::SYMCIPHER => write!(f, "SYMCIPHER"),
            Self::CAMELLIA => write!(f, "CAMELLIA"),
            Self::SHA3_256 => write!(f, "SHA3_256"),
            Self::SHA3_384 => write!(f, "SHA3_384"),
            Self::SHA3_512 => write!(f, "SHA3_512"),
            Self::CMAC => write!(f, "CMAC"),
            Self::CTR => write!(f, "CTR"),
            Self::OFB => write!(f, "OFB"),
            Self::CBC => write!(f, "CBC"),
            Self::CFB => write!(f, "CFB"),
            Self::ECB => write!(f, "ECB"),
            Self::LAST => write!(f, "LAST"),
            Self::ANY => write!(f, "ANY"),
            Self::ANY2 => write!(f, "ANY2"),
        }
    }
}

/// Table 4 is the list of identifiers for TCG-registered curve ID values for elliptic
/// curve cryptography.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, TryFromPrimitive)]
#[repr(i16)]
pub enum TPM_ECC_CURVE {
    NONE = 0x0, // Original value: 0x0000
    NIST_P192 = 0x1, // Original value: 0x0001
    NIST_P224 = 0x2, // Original value: 0x0002
    NIST_P256 = 0x3, // Original value: 0x0003
    NIST_P384 = 0x4, // Original value: 0x0004
    NIST_P521 = 0x5, // Original value: 0x0005

    /// Curve to support ECDAA
    BN_P256 = 0x10, // Original value: 0x0010

    /// Curve to support ECDAA
    BN_P638 = 0x11, // Original value: 0x0011
    SM2_P256 = 0x20, // Original value: 0x0020
    TEST_P192 = 0x21 // Original value: 0x0021
}

impl fmt::Display for TPM_ECC_CURVE {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::NONE => write!(f, "NONE"),
            Self::NIST_P192 => write!(f, "NIST_P192"),
            Self::NIST_P224 => write!(f, "NIST_P224"),
            Self::NIST_P256 => write!(f, "NIST_P256"),
            Self::NIST_P384 => write!(f, "NIST_P384"),
            Self::NIST_P521 => write!(f, "NIST_P521"),
            Self::BN_P256 => write!(f, "BN_P256"),
            Self::BN_P638 => write!(f, "BN_P638"),
            Self::SM2_P256 => write!(f, "SM2_P256"),
            Self::TEST_P192 => write!(f, "TEST_P192"),
        }
    }
}

/// Table 13 Defines for SHA1 Hash Values
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, TryFromPrimitive)]
#[repr(i32)]
pub enum SHA1 {
    /// Size of digest in octets
    DIGEST_SIZE = 0x14, // Original value: 20

    /// Size of hash block in octets
    BLOCK_SIZE = 0x40 // Original value: 64
}

impl fmt::Display for SHA1 {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::DIGEST_SIZE => write!(f, "DIGEST_SIZE"),
            Self::BLOCK_SIZE => write!(f, "BLOCK_SIZE"),
        }
    }
}

/// Table 14 Defines for SHA256 Hash Values
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, TryFromPrimitive)]
#[repr(i32)]
pub enum SHA256 {
    /// Size of digest
    DIGEST_SIZE = 0x20, // Original value: 32

    /// Size of hash block
    BLOCK_SIZE = 0x40 // Original value: 64
}

impl fmt::Display for SHA256 {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::DIGEST_SIZE => write!(f, "DIGEST_SIZE"),
            Self::BLOCK_SIZE => write!(f, "BLOCK_SIZE"),
        }
    }
}

/// Table 15 Defines for SHA384 Hash Values
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, TryFromPrimitive)]
#[repr(i32)]
pub enum SHA384 {
    /// Size of digest in octets
    DIGEST_SIZE = 0x30, // Original value: 48

    /// Size of hash block in octets
    BLOCK_SIZE = 0x80 // Original value: 128
}

impl fmt::Display for SHA384 {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::DIGEST_SIZE => write!(f, "DIGEST_SIZE"),
            Self::BLOCK_SIZE => write!(f, "BLOCK_SIZE"),
        }
    }
}

/// Table 16 Defines for SHA512 Hash Values
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, TryFromPrimitive)]
#[repr(i32)]
pub enum SHA512 {
    /// Size of digest in octets
    DIGEST_SIZE = 0x40, // Original value: 64

    /// Size of hash block in octets
    BLOCK_SIZE = 0x80 // Original value: 128
}

impl fmt::Display for SHA512 {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::DIGEST_SIZE => write!(f, "DIGEST_SIZE"),
            Self::BLOCK_SIZE => write!(f, "BLOCK_SIZE"),
        }
    }
}

/// Table 17 Defines for SM3_256 Hash Values
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, TryFromPrimitive)]
#[repr(i32)]
pub enum SM3_256 {
    /// Size of digest in octets
    DIGEST_SIZE = 0x20, // Original value: 32

    /// Size of hash block in octets
    BLOCK_SIZE = 0x40 // Original value: 64
}

impl fmt::Display for SM3_256 {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::DIGEST_SIZE => write!(f, "DIGEST_SIZE"),
            Self::BLOCK_SIZE => write!(f, "BLOCK_SIZE"),
        }
    }
}

/// Table 18 Defines for SHA3_256 Hash Values
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, TryFromPrimitive)]
#[repr(i32)]
pub enum SHA3_256 {
    /// Size of digest in octets
    DIGEST_SIZE = 0x20, // Original value: 32

    /// Size of hash block in octets
    BLOCK_SIZE = 0x88 // Original value: 136
}

impl fmt::Display for SHA3_256 {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::DIGEST_SIZE => write!(f, "DIGEST_SIZE"),
            Self::BLOCK_SIZE => write!(f, "BLOCK_SIZE"),
        }
    }
}

/// Table 19 Defines for SHA3_384 Hash Values
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, TryFromPrimitive)]
#[repr(i32)]
pub enum SHA3_384 {
    /// Size of digest in octets
    DIGEST_SIZE = 0x30, // Original value: 48

    /// Size of hash block in octets
    BLOCK_SIZE = 0x68 // Original value: 104
}

impl fmt::Display for SHA3_384 {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::DIGEST_SIZE => write!(f, "DIGEST_SIZE"),
            Self::BLOCK_SIZE => write!(f, "BLOCK_SIZE"),
        }
    }
}

/// Table 20 Defines for SHA3_512 Hash Values
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, TryFromPrimitive)]
#[repr(i32)]
pub enum SHA3_512 {
    /// Size of digest in octets
    DIGEST_SIZE = 0x40, // Original value: 64

    /// Size of hash block in octets
    BLOCK_SIZE = 0x48 // Original value: 72
}

impl fmt::Display for SHA3_512 {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::DIGEST_SIZE => write!(f, "DIGEST_SIZE"),
            Self::BLOCK_SIZE => write!(f, "BLOCK_SIZE"),
        }
    }
}

/// Table 4 Defines for Logic Values
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, TryFromPrimitive)]
#[repr(i8)]
pub enum Logic {
    TRUE = 0x1, // Original value: 1
    FALSE = 0x0, // Original value: 0
    // WARNING: YES has duplicate value 0x1 - using name + value pattern
    YESValue = 0x1, // Original value: 1
    // WARNING: NO has duplicate value 0x0 - using name + value pattern
    NOValue = 0x0, // Original value: 0
    // WARNING: SET has duplicate value 0x1 - using name + value pattern
    SETValue = 0x1, // Original value: 1
    // WARNING: CLEAR has duplicate value 0x0 - using name + value pattern
    CLEARValue = 0x0 // Original value: 0
}

impl fmt::Display for Logic {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::TRUE => write!(f, "TRUE"),
            Self::FALSE => write!(f, "FALSE"),
            Self::YES => write!(f, "YES"),
            Self::NO => write!(f, "NO"),
            Self::SET => write!(f, "SET"),
            Self::CLEAR => write!(f, "CLEAR"),
        }
    }
}

/// These values are readable with TPM2_GetCapability() (see 6.13 for the format).
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, TryFromPrimitive)]
#[repr(i32)]
pub enum TPM_SPEC {
    /// ASCII 2.0 with null terminator
    FAMILY = 0x322E3000,

    /// The level number for the specification
    LEVEL = 0x0, // Original value: 0

    /// The version number of the spec (001.62 * 100)
    VERSION = 0xA2, // Original value: 162

    /// The year of the version
    YEAR = 0x7E3, // Original value: 2019

    /// The day of the year (December 26)
    DAY_OF_YEAR = 0x168 // Original value: 360
}

impl fmt::Display for TPM_SPEC {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::FAMILY => write!(f, "FAMILY"),
            Self::LEVEL => write!(f, "LEVEL"),
            Self::VERSION => write!(f, "VERSION"),
            Self::YEAR => write!(f, "YEAR"),
            Self::DAY_OF_YEAR => write!(f, "DAY_OF_YEAR"),
        }
    }
}

/// This constant value differentiates TPM-generated structures from non-TPM structures.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, TryFromPrimitive)]
#[repr(i32)]
pub enum TPM_GENERATED {
    /// 0xFF TCG (FF 54 43 4716)
    VALUE = 0xFF544347 // Original value: 0xff544347
}

impl fmt::Display for TPM_GENERATED {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::VALUE => write!(f, "VALUE"),
        }
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, TryFromPrimitive)]
#[repr(i32)]
pub enum TPM_CC {
    /// Compile variable. May decrease based on implementation.
    FIRST = 0x11F, // Original value: 0x0000011F
    // WARNING: NV_UndefineSpaceSpecial has duplicate value 0x11F - using name + value pattern
    NV_UndefineSpaceSpecialValue = 0x11F, // Original value: 0x0000011F
    EvictControl = 0x120, // Original value: 0x00000120
    HierarchyControl = 0x121, // Original value: 0x00000121
    NV_UndefineSpace = 0x122, // Original value: 0x00000122
    ChangeEPS = 0x124, // Original value: 0x00000124
    ChangePPS = 0x125, // Original value: 0x00000125
    Clear = 0x126, // Original value: 0x00000126
    ClearControl = 0x127, // Original value: 0x00000127
    ClockSet = 0x128, // Original value: 0x00000128
    HierarchyChangeAuth = 0x129, // Original value: 0x00000129
    NV_DefineSpace = 0x12A, // Original value: 0x0000012A
    PCR_Allocate = 0x12B, // Original value: 0x0000012B
    PCR_SetAuthPolicy = 0x12C, // Original value: 0x0000012C
    PP_Commands = 0x12D, // Original value: 0x0000012D
    SetPrimaryPolicy = 0x12E, // Original value: 0x0000012E
    FieldUpgradeStart = 0x12F, // Original value: 0x0000012F
    ClockRateAdjust = 0x130, // Original value: 0x00000130
    CreatePrimary = 0x131, // Original value: 0x00000131
    NV_GlobalWriteLock = 0x132, // Original value: 0x00000132
    GetCommandAuditDigest = 0x133, // Original value: 0x00000133
    NV_Increment = 0x134, // Original value: 0x00000134
    NV_SetBits = 0x135, // Original value: 0x00000135
    NV_Extend = 0x136, // Original value: 0x00000136
    NV_Write = 0x137, // Original value: 0x00000137
    NV_WriteLock = 0x138, // Original value: 0x00000138
    DictionaryAttackLockReset = 0x139, // Original value: 0x00000139
    DictionaryAttackParameters = 0x13A, // Original value: 0x0000013A
    NV_ChangeAuth = 0x13B, // Original value: 0x0000013B

    /// PCR
    PCR_Event = 0x13C, // Original value: 0x0000013C

    /// PCR
    PCR_Reset = 0x13D, // Original value: 0x0000013D
    SequenceComplete = 0x13E, // Original value: 0x0000013E
    SetAlgorithmSet = 0x13F, // Original value: 0x0000013F
    SetCommandCodeAuditStatus = 0x140, // Original value: 0x00000140
    FieldUpgradeData = 0x141, // Original value: 0x00000141
    IncrementalSelfTest = 0x142, // Original value: 0x00000142
    SelfTest = 0x143, // Original value: 0x00000143
    Startup = 0x144, // Original value: 0x00000144
    Shutdown = 0x145, // Original value: 0x00000145
    StirRandom = 0x146, // Original value: 0x00000146
    ActivateCredential = 0x147, // Original value: 0x00000147
    Certify = 0x148, // Original value: 0x00000148

    /// Policy
    PolicyNV = 0x149, // Original value: 0x00000149
    CertifyCreation = 0x14A, // Original value: 0x0000014A
    Duplicate = 0x14B, // Original value: 0x0000014B
    GetTime = 0x14C, // Original value: 0x0000014C
    GetSessionAuditDigest = 0x14D, // Original value: 0x0000014D
    NV_Read = 0x14E, // Original value: 0x0000014E
    NV_ReadLock = 0x14F, // Original value: 0x0000014F
    ObjectChangeAuth = 0x150, // Original value: 0x00000150

    /// Policy
    PolicySecret = 0x151, // Original value: 0x00000151
    Rewrap = 0x152, // Original value: 0x00000152
    Create = 0x153, // Original value: 0x00000153
    ECDH_ZGen = 0x154, // Original value: 0x00000154

    /// See NOTE 1
    HMAC = 0x155, // Original value: 0x00000155

    /// See NOTE 1
    // WARNING: MAC has duplicate value 0x155 - using name + value pattern
    MACValue = 0x155, // Original value: 0x00000155
    Import = 0x156, // Original value: 0x00000156
    Load = 0x157, // Original value: 0x00000157
    Quote = 0x158, // Original value: 0x00000158
    RSA_Decrypt = 0x159, // Original value: 0x00000159

    /// See NOTE 1
    HMAC_Start = 0x15B, // Original value: 0x0000015B

    /// See NOTE 1
    // WARNING: MAC_Start has duplicate value 0x15B - using name + value pattern
    MAC_StartValue = 0x15B, // Original value: 0x0000015B
    SequenceUpdate = 0x15C, // Original value: 0x0000015C
    Sign = 0x15D, // Original value: 0x0000015D
    Unseal = 0x15E, // Original value: 0x0000015E

    /// Policy
    PolicySigned = 0x160, // Original value: 0x00000160

    /// Context
    ContextLoad = 0x161, // Original value: 0x00000161

    /// Context
    ContextSave = 0x162, // Original value: 0x00000162
    ECDH_KeyGen = 0x163, // Original value: 0x00000163
    EncryptDecrypt = 0x164, // Original value: 0x00000164

    /// Context
    FlushContext = 0x165, // Original value: 0x00000165
    LoadExternal = 0x167, // Original value: 0x00000167
    MakeCredential = 0x168, // Original value: 0x00000168

    /// NV
    NV_ReadPublic = 0x169, // Original value: 0x00000169

    /// Policy
    PolicyAuthorize = 0x16A, // Original value: 0x0000016A

    /// Policy
    PolicyAuthValue = 0x16B, // Original value: 0x0000016B

    /// Policy
    PolicyCommandCode = 0x16C, // Original value: 0x0000016C

    /// Policy
    PolicyCounterTimer = 0x16D, // Original value: 0x0000016D

    /// Policy
    PolicyCpHash = 0x16E, // Original value: 0x0000016E

    /// Policy
    PolicyLocality = 0x16F, // Original value: 0x0000016F

    /// Policy
    PolicyNameHash = 0x170, // Original value: 0x00000170

    /// Policy
    PolicyOR = 0x171, // Original value: 0x00000171

    /// Policy
    PolicyTicket = 0x172, // Original value: 0x00000172
    ReadPublic = 0x173, // Original value: 0x00000173
    RSA_Encrypt = 0x174, // Original value: 0x00000174
    StartAuthSession = 0x176, // Original value: 0x00000176
    VerifySignature = 0x177, // Original value: 0x00000177
    ECC_Parameters = 0x178, // Original value: 0x00000178
    FirmwareRead = 0x179, // Original value: 0x00000179
    GetCapability = 0x17A, // Original value: 0x0000017A
    GetRandom = 0x17B, // Original value: 0x0000017B
    GetTestResult = 0x17C, // Original value: 0x0000017C
    Hash = 0x17D, // Original value: 0x0000017D

    /// PCR
    PCR_Read = 0x17E, // Original value: 0x0000017E

    /// Policy
    PolicyPCR = 0x17F, // Original value: 0x0000017F
    PolicyRestart = 0x180, // Original value: 0x00000180
    ReadClock = 0x181, // Original value: 0x00000181
    PCR_Extend = 0x182, // Original value: 0x00000182
    PCR_SetAuthValue = 0x183, // Original value: 0x00000183
    NV_Certify = 0x184, // Original value: 0x00000184
    EventSequenceComplete = 0x185, // Original value: 0x00000185
    HashSequenceStart = 0x186, // Original value: 0x00000186

    /// Policy
    PolicyPhysicalPresence = 0x187, // Original value: 0x00000187

    /// Policy
    PolicyDuplicationSelect = 0x188, // Original value: 0x00000188

    /// Policy
    PolicyGetDigest = 0x189, // Original value: 0x00000189
    TestParms = 0x18A, // Original value: 0x0000018A
    Commit = 0x18B, // Original value: 0x0000018B

    /// Policy
    PolicyPassword = 0x18C, // Original value: 0x0000018C
    ZGen_2Phase = 0x18D, // Original value: 0x0000018D
    EC_Ephemeral = 0x18E, // Original value: 0x0000018E

    /// Policy
    PolicyNvWritten = 0x18F, // Original value: 0x0000018F

    /// Policy
    PolicyTemplate = 0x190, // Original value: 0x00000190
    CreateLoaded = 0x191, // Original value: 0x00000191

    /// Policy
    PolicyAuthorizeNV = 0x192, // Original value: 0x00000192
    EncryptDecrypt2 = 0x193, // Original value: 0x00000193
    AC_GetCapability = 0x194, // Original value: 0x00000194
    AC_Send = 0x195, // Original value: 0x00000195

    /// Policy
    Policy_AC_SendSelect = 0x196, // Original value: 0x00000196
    CertifyX509 = 0x197, // Original value: 0x00000197
    ACT_SetTimeout = 0x198, // Original value: 0x00000198
    ECC_Encrypt = 0x199, // Original value: 0x00000199
    ECC_Decrypt = 0x19A, // Original value: 0x0000019A

    /// Compile variable. May increase based on implementation.
    // WARNING: LAST has duplicate value 0x19A - using name + value pattern
    LASTValue = 0x19A, // Original value: 0x0000019A
    CC_VEND = 0x20000000,

    /// Used for testing of command dispatch
    // WARNING: Vendor_TCG_Test has duplicate value 0x20000000 - using name + value pattern
    Vendor_TCG_TestValue = 0x20000000 // Original value: CC_VEND+0x0000
}

impl fmt::Display for TPM_CC {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::FIRST => write!(f, "FIRST"),
            Self::NV_UndefineSpaceSpecial => write!(f, "NV_UndefineSpaceSpecial"),
            Self::EvictControl => write!(f, "EvictControl"),
            Self::HierarchyControl => write!(f, "HierarchyControl"),
            Self::NV_UndefineSpace => write!(f, "NV_UndefineSpace"),
            Self::ChangeEPS => write!(f, "ChangeEPS"),
            Self::ChangePPS => write!(f, "ChangePPS"),
            Self::Clear => write!(f, "Clear"),
            Self::ClearControl => write!(f, "ClearControl"),
            Self::ClockSet => write!(f, "ClockSet"),
            Self::HierarchyChangeAuth => write!(f, "HierarchyChangeAuth"),
            Self::NV_DefineSpace => write!(f, "NV_DefineSpace"),
            Self::PCR_Allocate => write!(f, "PCR_Allocate"),
            Self::PCR_SetAuthPolicy => write!(f, "PCR_SetAuthPolicy"),
            Self::PP_Commands => write!(f, "PP_Commands"),
            Self::SetPrimaryPolicy => write!(f, "SetPrimaryPolicy"),
            Self::FieldUpgradeStart => write!(f, "FieldUpgradeStart"),
            Self::ClockRateAdjust => write!(f, "ClockRateAdjust"),
            Self::CreatePrimary => write!(f, "CreatePrimary"),
            Self::NV_GlobalWriteLock => write!(f, "NV_GlobalWriteLock"),
            Self::GetCommandAuditDigest => write!(f, "GetCommandAuditDigest"),
            Self::NV_Increment => write!(f, "NV_Increment"),
            Self::NV_SetBits => write!(f, "NV_SetBits"),
            Self::NV_Extend => write!(f, "NV_Extend"),
            Self::NV_Write => write!(f, "NV_Write"),
            Self::NV_WriteLock => write!(f, "NV_WriteLock"),
            Self::DictionaryAttackLockReset => write!(f, "DictionaryAttackLockReset"),
            Self::DictionaryAttackParameters => write!(f, "DictionaryAttackParameters"),
            Self::NV_ChangeAuth => write!(f, "NV_ChangeAuth"),
            Self::PCR_Event => write!(f, "PCR_Event"),
            Self::PCR_Reset => write!(f, "PCR_Reset"),
            Self::SequenceComplete => write!(f, "SequenceComplete"),
            Self::SetAlgorithmSet => write!(f, "SetAlgorithmSet"),
            Self::SetCommandCodeAuditStatus => write!(f, "SetCommandCodeAuditStatus"),
            Self::FieldUpgradeData => write!(f, "FieldUpgradeData"),
            Self::IncrementalSelfTest => write!(f, "IncrementalSelfTest"),
            Self::SelfTest => write!(f, "SelfTest"),
            Self::Startup => write!(f, "Startup"),
            Self::Shutdown => write!(f, "Shutdown"),
            Self::StirRandom => write!(f, "StirRandom"),
            Self::ActivateCredential => write!(f, "ActivateCredential"),
            Self::Certify => write!(f, "Certify"),
            Self::PolicyNV => write!(f, "PolicyNV"),
            Self::CertifyCreation => write!(f, "CertifyCreation"),
            Self::Duplicate => write!(f, "Duplicate"),
            Self::GetTime => write!(f, "GetTime"),
            Self::GetSessionAuditDigest => write!(f, "GetSessionAuditDigest"),
            Self::NV_Read => write!(f, "NV_Read"),
            Self::NV_ReadLock => write!(f, "NV_ReadLock"),
            Self::ObjectChangeAuth => write!(f, "ObjectChangeAuth"),
            Self::PolicySecret => write!(f, "PolicySecret"),
            Self::Rewrap => write!(f, "Rewrap"),
            Self::Create => write!(f, "Create"),
            Self::ECDH_ZGen => write!(f, "ECDH_ZGen"),
            Self::HMAC => write!(f, "HMAC"),
            Self::MAC => write!(f, "MAC"),
            Self::Import => write!(f, "Import"),
            Self::Load => write!(f, "Load"),
            Self::Quote => write!(f, "Quote"),
            Self::RSA_Decrypt => write!(f, "RSA_Decrypt"),
            Self::HMAC_Start => write!(f, "HMAC_Start"),
            Self::MAC_Start => write!(f, "MAC_Start"),
            Self::SequenceUpdate => write!(f, "SequenceUpdate"),
            Self::Sign => write!(f, "Sign"),
            Self::Unseal => write!(f, "Unseal"),
            Self::PolicySigned => write!(f, "PolicySigned"),
            Self::ContextLoad => write!(f, "ContextLoad"),
            Self::ContextSave => write!(f, "ContextSave"),
            Self::ECDH_KeyGen => write!(f, "ECDH_KeyGen"),
            Self::EncryptDecrypt => write!(f, "EncryptDecrypt"),
            Self::FlushContext => write!(f, "FlushContext"),
            Self::LoadExternal => write!(f, "LoadExternal"),
            Self::MakeCredential => write!(f, "MakeCredential"),
            Self::NV_ReadPublic => write!(f, "NV_ReadPublic"),
            Self::PolicyAuthorize => write!(f, "PolicyAuthorize"),
            Self::PolicyAuthValue => write!(f, "PolicyAuthValue"),
            Self::PolicyCommandCode => write!(f, "PolicyCommandCode"),
            Self::PolicyCounterTimer => write!(f, "PolicyCounterTimer"),
            Self::PolicyCpHash => write!(f, "PolicyCpHash"),
            Self::PolicyLocality => write!(f, "PolicyLocality"),
            Self::PolicyNameHash => write!(f, "PolicyNameHash"),
            Self::PolicyOR => write!(f, "PolicyOR"),
            Self::PolicyTicket => write!(f, "PolicyTicket"),
            Self::ReadPublic => write!(f, "ReadPublic"),
            Self::RSA_Encrypt => write!(f, "RSA_Encrypt"),
            Self::StartAuthSession => write!(f, "StartAuthSession"),
            Self::VerifySignature => write!(f, "VerifySignature"),
            Self::ECC_Parameters => write!(f, "ECC_Parameters"),
            Self::FirmwareRead => write!(f, "FirmwareRead"),
            Self::GetCapability => write!(f, "GetCapability"),
            Self::GetRandom => write!(f, "GetRandom"),
            Self::GetTestResult => write!(f, "GetTestResult"),
            Self::Hash => write!(f, "Hash"),
            Self::PCR_Read => write!(f, "PCR_Read"),
            Self::PolicyPCR => write!(f, "PolicyPCR"),
            Self::PolicyRestart => write!(f, "PolicyRestart"),
            Self::ReadClock => write!(f, "ReadClock"),
            Self::PCR_Extend => write!(f, "PCR_Extend"),
            Self::PCR_SetAuthValue => write!(f, "PCR_SetAuthValue"),
            Self::NV_Certify => write!(f, "NV_Certify"),
            Self::EventSequenceComplete => write!(f, "EventSequenceComplete"),
            Self::HashSequenceStart => write!(f, "HashSequenceStart"),
            Self::PolicyPhysicalPresence => write!(f, "PolicyPhysicalPresence"),
            Self::PolicyDuplicationSelect => write!(f, "PolicyDuplicationSelect"),
            Self::PolicyGetDigest => write!(f, "PolicyGetDigest"),
            Self::TestParms => write!(f, "TestParms"),
            Self::Commit => write!(f, "Commit"),
            Self::PolicyPassword => write!(f, "PolicyPassword"),
            Self::ZGen_2Phase => write!(f, "ZGen_2Phase"),
            Self::EC_Ephemeral => write!(f, "EC_Ephemeral"),
            Self::PolicyNvWritten => write!(f, "PolicyNvWritten"),
            Self::PolicyTemplate => write!(f, "PolicyTemplate"),
            Self::CreateLoaded => write!(f, "CreateLoaded"),
            Self::PolicyAuthorizeNV => write!(f, "PolicyAuthorizeNV"),
            Self::EncryptDecrypt2 => write!(f, "EncryptDecrypt2"),
            Self::AC_GetCapability => write!(f, "AC_GetCapability"),
            Self::AC_Send => write!(f, "AC_Send"),
            Self::Policy_AC_SendSelect => write!(f, "Policy_AC_SendSelect"),
            Self::CertifyX509 => write!(f, "CertifyX509"),
            Self::ACT_SetTimeout => write!(f, "ACT_SetTimeout"),
            Self::ECC_Encrypt => write!(f, "ECC_Encrypt"),
            Self::ECC_Decrypt => write!(f, "ECC_Decrypt"),
            Self::LAST => write!(f, "LAST"),
            Self::CC_VEND => write!(f, "CC_VEND"),
            Self::Vendor_TCG_Test => write!(f, "Vendor_TCG_Test"),
        }
    }
}

/// Architecturally defined constants
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, TryFromPrimitive)]
#[repr(i32)]
pub enum ImplementationConstants {
    Ossl = 0x1, // Original value: 1
    Ltc = 0x2, // Original value: 2
    Msbn = 0x3, // Original value: 3
    Symcrypt = 0x4, // Original value: 4
    // WARNING: HASH_COUNT has duplicate value 0x3 - using name + value pattern
    HASH_COUNTValue = 0x3, // Original value: 3
    MAX_SYM_KEY_BITS = 0x100, // Original value: 256
    MAX_SYM_KEY_BYTES = 0x20, // Original value: ((MAX_SYM_KEY_BITS + 7) / 8)
    MAX_SYM_BLOCK_SIZE = 0x10, // Original value: 16
    MAX_CAP_CC = 0x19A, // Original value: TPM_CC::LAST
    // WARNING: MAX_RSA_KEY_BYTES has duplicate value 0x100 - using name + value pattern
    MAX_RSA_KEY_BYTESValue = 0x100, // Original value: 256
    // WARNING: MAX_AES_KEY_BYTES has duplicate value 0x20 - using name + value pattern
    MAX_AES_KEY_BYTESValue = 0x20, // Original value: 32
    MAX_ECC_KEY_BYTES = 0x30, // Original value: 48
    // WARNING: LABEL_MAX_BUFFER has duplicate value 0x20 - using name + value pattern
    LABEL_MAX_BUFFERValue = 0x20, // Original value: 32
    // WARNING: _TPM_CAP_SIZE has duplicate value 0x4 - using name + value pattern
    _TPM_CAP_SIZEValue = 0x4, // Original value: 0x4 /* sizeof(UINT32) */
    MAX_CAP_DATA = 0x3F8, // Original value: (Implementation::MAX_CAP_BUFFER-_TPM_CAP_SIZE-0x4) /* (MAX_CAP_BUFFER-_TPM_CAP_SIZE-sizeof(UINT32)) */
    MAX_CAP_ALGS = 0xA9, // Original value: (MAX_CAP_DATA / 0x6) /* (MAX_CAP_DATA / sizeof(TPMS_ALG_PROPERTY)) */
    MAX_CAP_HANDLES = 0xFE, // Original value: (MAX_CAP_DATA / 0x4) /* (MAX_CAP_DATA / sizeof(TPM_HANDLE)) */
    MAX_TPM_PROPERTIES = 0x7F, // Original value: (MAX_CAP_DATA / 0x8) /* (MAX_CAP_DATA / sizeof(TPMS_TAGGED_PROPERTY)) */
    MAX_PCR_PROPERTIES = 0xCB, // Original value: (MAX_CAP_DATA / 0x5) /* (MAX_CAP_DATA / sizeof(TPMS_TAGGED_PCR_SELECT)) */
    MAX_ECC_CURVES = 0x1FC, // Original value: (MAX_CAP_DATA / 0x2) /* (MAX_CAP_DATA / sizeof(TPM_ECC_CURVE)) */
    MAX_TAGGED_POLICIES = 0xE, // Original value: (MAX_CAP_DATA / 0x46) /* (MAX_CAP_DATA / sizeof(TPMS_TAGGED_POLICY)) */
    // WARNING: MAX_AC_CAPABILITIES has duplicate value 0x7F - using name + value pattern
    MAX_AC_CAPABILITIESValue = 0x7F, // Original value: (MAX_CAP_DATA / 0x8) /* (MAX_CAP_DATA / sizeof(TPMS_AC_OUTPUT)) */
    MAX_ACT_DATA = 0x54 // Original value: MAX_CAP_DATA / 0xC /* MAX_CAP_DATA / sizeof(TPMS_ACT_DATA) */
}

impl fmt::Display for ImplementationConstants {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::Ossl => write!(f, "Ossl"),
            Self::Ltc => write!(f, "Ltc"),
            Self::Msbn => write!(f, "Msbn"),
            Self::Symcrypt => write!(f, "Symcrypt"),
            Self::HASH_COUNT => write!(f, "HASH_COUNT"),
            Self::MAX_SYM_KEY_BITS => write!(f, "MAX_SYM_KEY_BITS"),
            Self::MAX_SYM_KEY_BYTES => write!(f, "MAX_SYM_KEY_BYTES"),
            Self::MAX_SYM_BLOCK_SIZE => write!(f, "MAX_SYM_BLOCK_SIZE"),
            Self::MAX_CAP_CC => write!(f, "MAX_CAP_CC"),
            Self::MAX_RSA_KEY_BYTES => write!(f, "MAX_RSA_KEY_BYTES"),
            Self::MAX_AES_KEY_BYTES => write!(f, "MAX_AES_KEY_BYTES"),
            Self::MAX_ECC_KEY_BYTES => write!(f, "MAX_ECC_KEY_BYTES"),
            Self::LABEL_MAX_BUFFER => write!(f, "LABEL_MAX_BUFFER"),
            Self::_TPM_CAP_SIZE => write!(f, "_TPM_CAP_SIZE"),
            Self::MAX_CAP_DATA => write!(f, "MAX_CAP_DATA"),
            Self::MAX_CAP_ALGS => write!(f, "MAX_CAP_ALGS"),
            Self::MAX_CAP_HANDLES => write!(f, "MAX_CAP_HANDLES"),
            Self::MAX_TPM_PROPERTIES => write!(f, "MAX_TPM_PROPERTIES"),
            Self::MAX_PCR_PROPERTIES => write!(f, "MAX_PCR_PROPERTIES"),
            Self::MAX_ECC_CURVES => write!(f, "MAX_ECC_CURVES"),
            Self::MAX_TAGGED_POLICIES => write!(f, "MAX_TAGGED_POLICIES"),
            Self::MAX_AC_CAPABILITIES => write!(f, "MAX_AC_CAPABILITIES"),
            Self::MAX_ACT_DATA => write!(f, "MAX_ACT_DATA"),
        }
    }
}

/// In general, response codes defined in TPM 2.0 Part 2 will be unmarshaling errors and
/// will have the F (format) bit SET. Codes that are unique to TPM 2.0 Part 3 will have
/// the F bit CLEAR but the V (version) attribute will be SET to indicate that it is a TPM
/// 2.0 response code. See Response Code Details in TPM 2.0 Part 1.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, TryFromPrimitive)]
#[repr(i32)]
pub enum TPM_RC {
    SUCCESS = 0x0, // Original value: 0x000

    /// Defined for compatibility with TPM 1.2
    BAD_TAG = 0x1E, // Original value: 0x01E

    /// Set for all format 0 response codes
    RC_VER1 = 0x100,

    /// TPM not initialized by TPM2_Startup or already initialized
    // WARNING: INITIALIZE has duplicate value 0x100 - using name + value pattern
    INITIALIZEValue = 0x100, // Original value: RC_VER1 + 0x000

    /// Commands not being accepted because of a TPM failure
    /// NOTE This may be returned by TPM2_GetTestResult() as the testResult parameter.
    FAILURE = 0x101, // Original value: RC_VER1 + 0x001

    /// Improper use of a sequence handle
    SEQUENCE = 0x103, // Original value: RC_VER1 + 0x003

    /// Not currently used
    PRIVATE = 0x10B, // Original value: RC_VER1 + 0x00B

    /// Not currently used
    HMAC = 0x119, // Original value: RC_VER1 + 0x019

    /// The command is disabled
    DISABLED = 0x120, // Original value: RC_VER1 + 0x020

    /// Command failed because audit sequence required exclusivity
    EXCLUSIVE = 0x121, // Original value: RC_VER1 + 0x021

    /// Authorization handle is not correct for command
    AUTH_TYPE = 0x124, // Original value: RC_VER1 + 0x024

    /// Command requires an authorization session for handle and it is not present.
    AUTH_MISSING = 0x125, // Original value: RC_VER1 + 0x025

    /// Policy failure in math operation or an invalid authPolicy value
    POLICY = 0x126, // Original value: RC_VER1 + 0x026

    /// PCR check fail
    PCR = 0x127, // Original value: RC_VER1 + 0x027

    /// PCR have changed since checked.
    PCR_CHANGED = 0x128, // Original value: RC_VER1 + 0x028

    /// For all commands other than TPM2_FieldUpgradeData(), this code indicates that the TPM
    /// is in field upgrade mode; for TPM2_FieldUpgradeData(), this code indicates that the
    /// TPM is not in field upgrade mode
    UPGRADE = 0x12D, // Original value: RC_VER1 + 0x02D

    /// Context ID counter is at maximum.
    TOO_MANY_CONTEXTS = 0x12E, // Original value: RC_VER1 + 0x02E

    /// AuthValue or authPolicy is not available for selected entity.
    AUTH_UNAVAILABLE = 0x12F, // Original value: RC_VER1 + 0x02F

    /// A _TPM_Init and Startup(CLEAR) is required before the TPM can resume operation.
    REBOOT = 0x130, // Original value: RC_VER1 + 0x030

    /// The protection algorithms (hash and symmetric) are not reasonably balanced. The digest
    /// size of the hash must be larger than the key size of the symmetric algorithm.
    UNBALANCED = 0x131, // Original value: RC_VER1 + 0x031

    /// Command commandSize value is inconsistent with contents of the command buffer; either
    /// the size is not the same as the octets loaded by the hardware interface layer or the
    /// value is not large enough to hold a command header
    COMMAND_SIZE = 0x142, // Original value: RC_VER1 + 0x042

    /// Command code not supported
    COMMAND_CODE = 0x143, // Original value: RC_VER1 + 0x043

    /// The value of authorizationSize is out of range or the number of octets in the
    /// Authorization Area is greater than required
    AUTHSIZE = 0x144, // Original value: RC_VER1 + 0x044

    /// Use of an authorization session with a context command or another command that cannot
    /// have an authorization session.
    AUTH_CONTEXT = 0x145, // Original value: RC_VER1 + 0x045

    /// NV offset+size is out of range.
    NV_RANGE = 0x146, // Original value: RC_VER1 + 0x046

    /// Requested allocation size is larger than allowed.
    NV_SIZE = 0x147, // Original value: RC_VER1 + 0x047

    /// NV access locked.
    NV_LOCKED = 0x148, // Original value: RC_VER1 + 0x048

    /// NV access authorization fails in command actions (this failure does not affect lockout.action)
    NV_AUTHORIZATION = 0x149, // Original value: RC_VER1 + 0x049

    /// An NV Index is used before being initialized or the state saved by
    /// TPM2_Shutdown(STATE) could not be restored
    NV_UNINITIALIZED = 0x14A, // Original value: RC_VER1 + 0x04A

    /// Insufficient space for NV allocation
    NV_SPACE = 0x14B, // Original value: RC_VER1 + 0x04B

    /// NV Index or persistent object already defined
    NV_DEFINED = 0x14C, // Original value: RC_VER1 + 0x04C

    /// Context in TPM2_ContextLoad() is not valid
    BAD_CONTEXT = 0x150, // Original value: RC_VER1 + 0x050

    /// CpHash value already set or not correct for use
    CPHASH = 0x151, // Original value: RC_VER1 + 0x051

    /// Handle for parent is not a valid parent
    PARENT = 0x152, // Original value: RC_VER1 + 0x052

    /// Some function needs testing.
    NEEDS_TEST = 0x153, // Original value: RC_VER1 + 0x053

    /// Returned when an internal function cannot process a request due to an unspecified
    /// problem. This code is usually related to invalid parameters that are not properly
    /// filtered by the input unmarshaling code.
    NO_RESULT = 0x154, // Original value: RC_VER1 + 0x054

    /// The sensitive area did not unmarshal correctly after decryption this code is used in
    /// lieu of the other unmarshaling errors so that an attacker cannot determine where the
    /// unmarshaling error occurred
    SENSITIVE = 0x155, // Original value: RC_VER1 + 0x055

    /// Largest version 1 code that is not a warning
    RC_MAX_FM0 = 0x17F, // Original value: RC_VER1 + 0x07F

    /// This bit is SET in all format 1 response codes
    /// The codes in this group may have a value added to them to indicate the handle,
    /// session, or parameter to which they apply.
    RC_FMT1 = 0x80, // Original value: 0x080

    /// Asymmetric algorithm not supported or not correct
    ASYMMETRIC = 0x81, // Original value: RC_FMT1 + 0x001

    /// Inconsistent attributes
    ATTRIBUTES = 0x82, // Original value: RC_FMT1 + 0x002

    /// Hash algorithm not supported or not appropriate
    HASH = 0x83, // Original value: RC_FMT1 + 0x003

    /// Value is out of range or is not correct for the context
    VALUE = 0x84, // Original value: RC_FMT1 + 0x004

    /// Hierarchy is not enabled or is not correct for the use
    HIERARCHY = 0x85, // Original value: RC_FMT1 + 0x005

    /// Key size is not supported
    KEY_SIZE = 0x87, // Original value: RC_FMT1 + 0x007

    /// Mask generation function not supported
    MGF = 0x88, // Original value: RC_FMT1 + 0x008

    /// Mode of operation not supported
    MODE = 0x89, // Original value: RC_FMT1 + 0x009

    /// The type of the value is not appropriate for the use
    TYPE = 0x8A, // Original value: RC_FMT1 + 0x00A

    /// The handle is not correct for the use
    HANDLE = 0x8B, // Original value: RC_FMT1 + 0x00B

    /// Unsupported key derivation function or function not appropriate for use
    KDF = 0x8C, // Original value: RC_FMT1 + 0x00C

    /// Value was out of allowed range.
    RANGE = 0x8D, // Original value: RC_FMT1 + 0x00D

    /// The authorization HMAC check failed and DA counter incremented
    AUTH_FAIL = 0x8E, // Original value: RC_FMT1 + 0x00E

    /// Invalid nonce size or nonce value mismatch
    NONCE = 0x8F, // Original value: RC_FMT1 + 0x00F

    /// Authorization requires assertion of PP
    PP = 0x90, // Original value: RC_FMT1 + 0x010

    /// Unsupported or incompatible scheme
    SCHEME = 0x92, // Original value: RC_FMT1 + 0x012

    /// Structure is the wrong size
    SIZE = 0x95, // Original value: RC_FMT1 + 0x015

    /// Unsupported symmetric algorithm or key size, or not appropriate for instance
    SYMMETRIC = 0x96, // Original value: RC_FMT1 + 0x016

    /// Incorrect structure tag
    TAG = 0x97, // Original value: RC_FMT1 + 0x017

    /// Union selector is incorrect
    SELECTOR = 0x98, // Original value: RC_FMT1 + 0x018

    /// The TPM was unable to unmarshal a value because there were not enough octets in the
    /// input buffer
    INSUFFICIENT = 0x9A, // Original value: RC_FMT1 + 0x01A

    /// The signature is not valid
    SIGNATURE = 0x9B, // Original value: RC_FMT1 + 0x01B

    /// Key fields are not compatible with the selected use
    KEY = 0x9C, // Original value: RC_FMT1 + 0x01C

    /// A policy check failed
    POLICY_FAIL = 0x9D, // Original value: RC_FMT1 + 0x01D

    /// Integrity check failed
    INTEGRITY = 0x9F, // Original value: RC_FMT1 + 0x01F

    /// Invalid ticket
    TICKET = 0xA0, // Original value: RC_FMT1 + 0x020

    /// Reserved bits not set to zero as required
    RESERVED_BITS = 0xA1, // Original value: RC_FMT1 + 0x021

    /// Authorization failure without DA implications
    BAD_AUTH = 0xA2, // Original value: RC_FMT1 + 0x022

    /// The policy has expired
    EXPIRED = 0xA3, // Original value: RC_FMT1 + 0x023

    /// The commandCode in the policy is not the commandCode of the command or the command
    /// code in a policy command references a command that is not implemented
    POLICY_CC = 0xA4, // Original value: RC_FMT1 + 0x024

    /// Public and sensitive portions of an object are not cryptographically bound
    BINDING = 0xA5, // Original value: RC_FMT1 + 0x025

    /// Curve not supported
    CURVE = 0xA6, // Original value: RC_FMT1 + 0x026

    /// Point is not on the required curve.
    ECC_POINT = 0xA7, // Original value: RC_FMT1 + 0x027

    /// Set for warning response codes
    RC_WARN = 0x900,

    /// Gap for context ID is too large
    CONTEXT_GAP = 0x901, // Original value: RC_WARN + 0x001

    /// Out of memory for object contexts
    OBJECT_MEMORY = 0x902, // Original value: RC_WARN + 0x002

    /// Out of memory for session contexts
    SESSION_MEMORY = 0x903, // Original value: RC_WARN + 0x003

    /// Out of shared object/session memory or need space for internal operations
    MEMORY = 0x904, // Original value: RC_WARN + 0x004

    /// Out of session handles a session must be flushed before a new session may be created
    SESSION_HANDLES = 0x905, // Original value: RC_WARN + 0x005

    /// Out of object handles the handle space for objects is depleted and a reboot is required
    /// NOTE 1 This cannot occur on the reference implementation.
    /// NOTE 2 There is no reason why an implementation would implement a design that would
    /// deplete handle space. Platform specifications are encouraged to forbid it.
    OBJECT_HANDLES = 0x906, // Original value: RC_WARN + 0x006

    /// Bad locality
    LOCALITY = 0x907, // Original value: RC_WARN + 0x007

    /// The TPM has suspended operation on the command; forward progress was made and the
    /// command may be retried
    /// See TPM 2.0 Part 1, Multi-tasking.
    /// NOTE This cannot occur on the reference implementation.
    YIELDED = 0x908, // Original value: RC_WARN + 0x008

    /// The command was canceled
    CANCELED = 0x909, // Original value: RC_WARN + 0x009

    /// TPM is performing self-tests
    TESTING = 0x90A, // Original value: RC_WARN + 0x00A

    /// The 1st handle in the handle area references a transient object or session that is not
    /// loaded
    REFERENCE_H0 = 0x910, // Original value: RC_WARN + 0x010

    /// The 2nd handle in the handle area references a transient object or session that is not
    /// loaded
    REFERENCE_H1 = 0x911, // Original value: RC_WARN + 0x011

    /// The 3rd handle in the handle area references a transient object or session that is not
    /// loaded
    REFERENCE_H2 = 0x912, // Original value: RC_WARN + 0x012

    /// The 4th handle in the handle area references a transient object or session that is not
    /// loaded
    REFERENCE_H3 = 0x913, // Original value: RC_WARN + 0x013

    /// The 5th handle in the handle area references a transient object or session that is not
    /// loaded
    REFERENCE_H4 = 0x914, // Original value: RC_WARN + 0x014

    /// The 6th handle in the handle area references a transient object or session that is not
    /// loaded
    REFERENCE_H5 = 0x915, // Original value: RC_WARN + 0x015

    /// The 7th handle in the handle area references a transient object or session that is not
    /// loaded
    REFERENCE_H6 = 0x916, // Original value: RC_WARN + 0x016

    /// The 1st authorization session handle references a session that is not loaded
    REFERENCE_S0 = 0x918, // Original value: RC_WARN + 0x018

    /// The 2nd authorization session handle references a session that is not loaded
    REFERENCE_S1 = 0x919, // Original value: RC_WARN + 0x019

    /// The 3rd authorization session handle references a session that is not loaded
    REFERENCE_S2 = 0x91A, // Original value: RC_WARN + 0x01A

    /// The 4th authorization session handle references a session that is not loaded
    REFERENCE_S3 = 0x91B, // Original value: RC_WARN + 0x01B

    /// The 5th session handle references a session that is not loaded
    REFERENCE_S4 = 0x91C, // Original value: RC_WARN + 0x01C

    /// The 6th session handle references a session that is not loaded
    REFERENCE_S5 = 0x91D, // Original value: RC_WARN + 0x01D

    /// The 7th authorization session handle references a session that is not loaded
    REFERENCE_S6 = 0x91E, // Original value: RC_WARN + 0x01E

    /// The TPM is rate-limiting accesses to prevent wearout of NV
    NV_RATE = 0x920, // Original value: RC_WARN + 0x020

    /// Authorizations for objects subject to DA protection are not allowed at this time
    /// because the TPM is in DA lockout mode
    LOCKOUT = 0x921, // Original value: RC_WARN + 0x021

    /// The TPM was not able to start the command
    RETRY = 0x922, // Original value: RC_WARN + 0x022

    /// The command may require writing of NV and NV is not current accessible
    NV_UNAVAILABLE = 0x923, // Original value: RC_WARN + 0x023

    /// This value is reserved and shall not be returned by the TPM
    NOT_USED = 0x97F, // Original value: RC_WARN + 0x7F

    /// Add to a handle-related error
    // WARNING: H has duplicate value 0x0 - using name + value pattern
    HValue = 0x0, // Original value: 0x000

    /// Add to a parameter-related error
    P = 0x40, // Original value: 0x040

    /// Add to a session-related error
    S = 0x800,

    /// Add to a parameter-, handle-, or session-related error
    // WARNING: _1 has duplicate value 0x100 - using name + value pattern
    _1Value = 0x100,

    /// Add to a parameter-, handle-, or session-related error
    _2 = 0x200,

    /// Add to a parameter-, handle-, or session-related error
    _3 = 0x300,

    /// Add to a parameter-, handle-, or session-related error
    _4 = 0x400,

    /// Add to a parameter-, handle-, or session-related error
    _5 = 0x500,

    /// Add to a parameter-, handle-, or session-related error
    _6 = 0x600,

    /// Add to a parameter-, handle-, or session-related error
    _7 = 0x700,

    /// Add to a parameter-related error
    // WARNING: _8 has duplicate value 0x800 - using name + value pattern
    _8Value = 0x800,

    /// Add to a parameter-related error
    // WARNING: _9 has duplicate value 0x900 - using name + value pattern
    _9Value = 0x900,

    /// Add to a parameter-related error
    A = 0xA00,

    /// Add to a parameter-related error
    B = 0xB00,

    /// Add to a parameter-related error
    C = 0xC00,

    /// Add to a parameter-related error
    D = 0xD00,

    /// Add to a parameter-related error
    E = 0xE00,

    /// Add to a parameter-related error
    F = 0xF00,

    /// Number mask
    // WARNING: N_MASK has duplicate value 0xF00 - using name + value pattern
    N_MASKValue = 0xF00,

    /// Response buffer returned by the TPM is too short
    TSS_TCP_BAD_HANDSHAKE_RESP = 0x40280001,

    /// Too old TCP server version
    TSS_TCP_SERVER_TOO_OLD = 0x40280002,

    /// Bad ack from the TCP end point
    TSS_TCP_BAD_ACK = 0x40280003,

    /// Wrong length of the response buffer returned by the TPM
    TSS_TCP_BAD_RESP_LEN = 0x40280004,

    /// TPM2_Startup returned unexpected response code
    TSS_TCP_UNEXPECTED_STARTUP_RESP = 0x40280005,

    /// Invalid size tag in the TPM response TCP packet
    TSS_TCP_INVALID_SIZE_TAG = 0x40280006,

    /// TPM over TCP device is not connected
    TSS_TCP_DISCONNECTED = 0x40280007,

    /// General TPM command dispatch failure
    TSS_DISPATCH_FAILED = 0x40280010,

    /// Sending data to TPM failed
    TSS_SEND_OP_FAILED = 0x40280011,

    /// Response buffer returned by the TPM is too short
    TSS_RESP_BUF_TOO_SHORT = 0x40280021,

    /// Invalid tag in the response buffer returned by the TPM
    TSS_RESP_BUF_INVALID_SESSION_TAG = 0x40280022,

    /// Inconsistent TPM response parameters size
    TSS_RESP_BUF_INVALID_SIZE = 0x40280023,

    /// Windows TBS error TPM_E_COMMAND_BLOCKED
    TBS_COMMAND_BLOCKED = 0x80280400,

    /// Windows TBS error TPM_E_INVALID_HANDLE
    TBS_INVALID_HANDLE = 0x80280401,

    /// Windows TBS error TPM_E_DUPLICATE_VHANDLE
    TBS_DUPLICATE_V_HANDLE = 0x80280402,

    /// Windows TBS error TPM_E_EMBEDDED_COMMAND_BLOCKED
    TBS_EMBEDDED_COMMAND_BLOCKED = 0x80280403,

    /// Windows TBS error TPM_E_EMBEDDED_COMMAND_UNSUPPORTED
    TBS_EMBEDDED_COMMAND_UNSUPPORTED = 0x80280404,

    /// Windows TBS returned success but empty response buffer
    TBS_UNKNOWN_ERROR = 0x80284000,

    /// Windows TBS error TBS_E_INTERNAL_ERROR
    TBS_INTERNAL_ERROR = 0x80284001,

    /// Windows TBS error TBS_E_BAD_PARAMETER
    TBS_BAD_PARAMETER = 0x80284002,

    /// Windows TBS error TBS_E_INVALID_OUTPUT_POINTER
    TBS_INVALID_OUTPUT_POINTER = 0x80284003,

    /// Windows TBS error TBS_E_INVALID_CONTEXT
    TBS_INVALID_CONTEXT = 0x80284004,

    /// Windows TBS error TBS_E_INSUFFICIENT_BUFFER
    TBS_INSUFFICIENT_BUFFER = 0x80284005,

    /// Windows TBS error TBS_E_IOERROR
    TBS_IO_ERROR = 0x80284006,

    /// Windows TBS error TBS_E_INVALID_CONTEXT_PARAM
    TBS_INVALID_CONTEXT_PARAM = 0x80284007,

    /// Windows TBS error TBS_E_SERVICE_NOT_RUNNING
    TBS_SERVICE_NOT_RUNNING = 0x80284008,

    /// Windows TBS error TBS_E_TOO_MANY_TBS_CONTEXTS
    TBS_TOO_MANY_CONTEXTS = 0x80284009,

    /// Windows TBS error TBS_E_TOO_MANY_TBS_RESOURCES
    TBS_TOO_MANY_RESOURCES = 0x8028400A,

    /// Windows TBS error TBS_E_SERVICE_START_PENDING
    TBS_SERVICE_START_PENDING = 0x8028400B,

    /// Windows TBS error TBS_E_PPI_NOT_SUPPORTED
    TBS_PPI_NOT_SUPPORTED = 0x8028400C,

    /// Windows TBS error TBS_E_COMMAND_CANCELED
    TBS_COMMAND_CANCELED = 0x8028400D,

    /// Windows TBS error TBS_E_BUFFER_TOO_LARGE
    TBS_BUFFER_TOO_LARGE = 0x8028400E,

    /// Windows TBS error TBS_E_TPM_NOT_FOUND
    TBS_TPM_NOT_FOUND = 0x8028400F,

    /// Windows TBS error TBS_E_SERVICE_DISABLED
    TBS_SERVICE_DISABLED = 0x80284010,

    /// Windows TBS error TBS_E_ACCESS_DENIED
    TBS_ACCESS_DENIED = 0x80284012,

    /// Windows TBS error TBS_E_PPI_FUNCTION_UNSUPPORTED
    TBS_PPI_FUNCTION_NOT_SUPPORTED = 0x80284014,

    /// Windows TBS error TBS_E_OWNERAUTH_NOT_FOUND
    TBS_OWNER_AUTH_NOT_FOUND = 0x80284015
}

impl fmt::Display for TPM_RC {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::SUCCESS => write!(f, "SUCCESS"),
            Self::BAD_TAG => write!(f, "BAD_TAG"),
            Self::RC_VER1 => write!(f, "RC_VER1"),
            Self::INITIALIZE => write!(f, "INITIALIZE"),
            Self::FAILURE => write!(f, "FAILURE"),
            Self::SEQUENCE => write!(f, "SEQUENCE"),
            Self::PRIVATE => write!(f, "PRIVATE"),
            Self::HMAC => write!(f, "HMAC"),
            Self::DISABLED => write!(f, "DISABLED"),
            Self::EXCLUSIVE => write!(f, "EXCLUSIVE"),
            Self::AUTH_TYPE => write!(f, "AUTH_TYPE"),
            Self::AUTH_MISSING => write!(f, "AUTH_MISSING"),
            Self::POLICY => write!(f, "POLICY"),
            Self::PCR => write!(f, "PCR"),
            Self::PCR_CHANGED => write!(f, "PCR_CHANGED"),
            Self::UPGRADE => write!(f, "UPGRADE"),
            Self::TOO_MANY_CONTEXTS => write!(f, "TOO_MANY_CONTEXTS"),
            Self::AUTH_UNAVAILABLE => write!(f, "AUTH_UNAVAILABLE"),
            Self::REBOOT => write!(f, "REBOOT"),
            Self::UNBALANCED => write!(f, "UNBALANCED"),
            Self::COMMAND_SIZE => write!(f, "COMMAND_SIZE"),
            Self::COMMAND_CODE => write!(f, "COMMAND_CODE"),
            Self::AUTHSIZE => write!(f, "AUTHSIZE"),
            Self::AUTH_CONTEXT => write!(f, "AUTH_CONTEXT"),
            Self::NV_RANGE => write!(f, "NV_RANGE"),
            Self::NV_SIZE => write!(f, "NV_SIZE"),
            Self::NV_LOCKED => write!(f, "NV_LOCKED"),
            Self::NV_AUTHORIZATION => write!(f, "NV_AUTHORIZATION"),
            Self::NV_UNINITIALIZED => write!(f, "NV_UNINITIALIZED"),
            Self::NV_SPACE => write!(f, "NV_SPACE"),
            Self::NV_DEFINED => write!(f, "NV_DEFINED"),
            Self::BAD_CONTEXT => write!(f, "BAD_CONTEXT"),
            Self::CPHASH => write!(f, "CPHASH"),
            Self::PARENT => write!(f, "PARENT"),
            Self::NEEDS_TEST => write!(f, "NEEDS_TEST"),
            Self::NO_RESULT => write!(f, "NO_RESULT"),
            Self::SENSITIVE => write!(f, "SENSITIVE"),
            Self::RC_MAX_FM0 => write!(f, "RC_MAX_FM0"),
            Self::RC_FMT1 => write!(f, "RC_FMT1"),
            Self::ASYMMETRIC => write!(f, "ASYMMETRIC"),
            Self::ATTRIBUTES => write!(f, "ATTRIBUTES"),
            Self::HASH => write!(f, "HASH"),
            Self::VALUE => write!(f, "VALUE"),
            Self::HIERARCHY => write!(f, "HIERARCHY"),
            Self::KEY_SIZE => write!(f, "KEY_SIZE"),
            Self::MGF => write!(f, "MGF"),
            Self::MODE => write!(f, "MODE"),
            Self::TYPE => write!(f, "TYPE"),
            Self::HANDLE => write!(f, "HANDLE"),
            Self::KDF => write!(f, "KDF"),
            Self::RANGE => write!(f, "RANGE"),
            Self::AUTH_FAIL => write!(f, "AUTH_FAIL"),
            Self::NONCE => write!(f, "NONCE"),
            Self::PP => write!(f, "PP"),
            Self::SCHEME => write!(f, "SCHEME"),
            Self::SIZE => write!(f, "SIZE"),
            Self::SYMMETRIC => write!(f, "SYMMETRIC"),
            Self::TAG => write!(f, "TAG"),
            Self::SELECTOR => write!(f, "SELECTOR"),
            Self::INSUFFICIENT => write!(f, "INSUFFICIENT"),
            Self::SIGNATURE => write!(f, "SIGNATURE"),
            Self::KEY => write!(f, "KEY"),
            Self::POLICY_FAIL => write!(f, "POLICY_FAIL"),
            Self::INTEGRITY => write!(f, "INTEGRITY"),
            Self::TICKET => write!(f, "TICKET"),
            Self::RESERVED_BITS => write!(f, "RESERVED_BITS"),
            Self::BAD_AUTH => write!(f, "BAD_AUTH"),
            Self::EXPIRED => write!(f, "EXPIRED"),
            Self::POLICY_CC => write!(f, "POLICY_CC"),
            Self::BINDING => write!(f, "BINDING"),
            Self::CURVE => write!(f, "CURVE"),
            Self::ECC_POINT => write!(f, "ECC_POINT"),
            Self::RC_WARN => write!(f, "RC_WARN"),
            Self::CONTEXT_GAP => write!(f, "CONTEXT_GAP"),
            Self::OBJECT_MEMORY => write!(f, "OBJECT_MEMORY"),
            Self::SESSION_MEMORY => write!(f, "SESSION_MEMORY"),
            Self::MEMORY => write!(f, "MEMORY"),
            Self::SESSION_HANDLES => write!(f, "SESSION_HANDLES"),
            Self::OBJECT_HANDLES => write!(f, "OBJECT_HANDLES"),
            Self::LOCALITY => write!(f, "LOCALITY"),
            Self::YIELDED => write!(f, "YIELDED"),
            Self::CANCELED => write!(f, "CANCELED"),
            Self::TESTING => write!(f, "TESTING"),
            Self::REFERENCE_H0 => write!(f, "REFERENCE_H0"),
            Self::REFERENCE_H1 => write!(f, "REFERENCE_H1"),
            Self::REFERENCE_H2 => write!(f, "REFERENCE_H2"),
            Self::REFERENCE_H3 => write!(f, "REFERENCE_H3"),
            Self::REFERENCE_H4 => write!(f, "REFERENCE_H4"),
            Self::REFERENCE_H5 => write!(f, "REFERENCE_H5"),
            Self::REFERENCE_H6 => write!(f, "REFERENCE_H6"),
            Self::REFERENCE_S0 => write!(f, "REFERENCE_S0"),
            Self::REFERENCE_S1 => write!(f, "REFERENCE_S1"),
            Self::REFERENCE_S2 => write!(f, "REFERENCE_S2"),
            Self::REFERENCE_S3 => write!(f, "REFERENCE_S3"),
            Self::REFERENCE_S4 => write!(f, "REFERENCE_S4"),
            Self::REFERENCE_S5 => write!(f, "REFERENCE_S5"),
            Self::REFERENCE_S6 => write!(f, "REFERENCE_S6"),
            Self::NV_RATE => write!(f, "NV_RATE"),
            Self::LOCKOUT => write!(f, "LOCKOUT"),
            Self::RETRY => write!(f, "RETRY"),
            Self::NV_UNAVAILABLE => write!(f, "NV_UNAVAILABLE"),
            Self::NOT_USED => write!(f, "NOT_USED"),
            Self::H => write!(f, "H"),
            Self::P => write!(f, "P"),
            Self::S => write!(f, "S"),
            Self::_1 => write!(f, "_1"),
            Self::_2 => write!(f, "_2"),
            Self::_3 => write!(f, "_3"),
            Self::_4 => write!(f, "_4"),
            Self::_5 => write!(f, "_5"),
            Self::_6 => write!(f, "_6"),
            Self::_7 => write!(f, "_7"),
            Self::_8 => write!(f, "_8"),
            Self::_9 => write!(f, "_9"),
            Self::A => write!(f, "A"),
            Self::B => write!(f, "B"),
            Self::C => write!(f, "C"),
            Self::D => write!(f, "D"),
            Self::E => write!(f, "E"),
            Self::F => write!(f, "F"),
            Self::N_MASK => write!(f, "N_MASK"),
            Self::TSS_TCP_BAD_HANDSHAKE_RESP => write!(f, "TSS_TCP_BAD_HANDSHAKE_RESP"),
            Self::TSS_TCP_SERVER_TOO_OLD => write!(f, "TSS_TCP_SERVER_TOO_OLD"),
            Self::TSS_TCP_BAD_ACK => write!(f, "TSS_TCP_BAD_ACK"),
            Self::TSS_TCP_BAD_RESP_LEN => write!(f, "TSS_TCP_BAD_RESP_LEN"),
            Self::TSS_TCP_UNEXPECTED_STARTUP_RESP => write!(f, "TSS_TCP_UNEXPECTED_STARTUP_RESP"),
            Self::TSS_TCP_INVALID_SIZE_TAG => write!(f, "TSS_TCP_INVALID_SIZE_TAG"),
            Self::TSS_TCP_DISCONNECTED => write!(f, "TSS_TCP_DISCONNECTED"),
            Self::TSS_DISPATCH_FAILED => write!(f, "TSS_DISPATCH_FAILED"),
            Self::TSS_SEND_OP_FAILED => write!(f, "TSS_SEND_OP_FAILED"),
            Self::TSS_RESP_BUF_TOO_SHORT => write!(f, "TSS_RESP_BUF_TOO_SHORT"),
            Self::TSS_RESP_BUF_INVALID_SESSION_TAG => write!(f, "TSS_RESP_BUF_INVALID_SESSION_TAG"),
            Self::TSS_RESP_BUF_INVALID_SIZE => write!(f, "TSS_RESP_BUF_INVALID_SIZE"),
            Self::TBS_COMMAND_BLOCKED => write!(f, "TBS_COMMAND_BLOCKED"),
            Self::TBS_INVALID_HANDLE => write!(f, "TBS_INVALID_HANDLE"),
            Self::TBS_DUPLICATE_V_HANDLE => write!(f, "TBS_DUPLICATE_V_HANDLE"),
            Self::TBS_EMBEDDED_COMMAND_BLOCKED => write!(f, "TBS_EMBEDDED_COMMAND_BLOCKED"),
            Self::TBS_EMBEDDED_COMMAND_UNSUPPORTED => write!(f, "TBS_EMBEDDED_COMMAND_UNSUPPORTED"),
            Self::TBS_UNKNOWN_ERROR => write!(f, "TBS_UNKNOWN_ERROR"),
            Self::TBS_INTERNAL_ERROR => write!(f, "TBS_INTERNAL_ERROR"),
            Self::TBS_BAD_PARAMETER => write!(f, "TBS_BAD_PARAMETER"),
            Self::TBS_INVALID_OUTPUT_POINTER => write!(f, "TBS_INVALID_OUTPUT_POINTER"),
            Self::TBS_INVALID_CONTEXT => write!(f, "TBS_INVALID_CONTEXT"),
            Self::TBS_INSUFFICIENT_BUFFER => write!(f, "TBS_INSUFFICIENT_BUFFER"),
            Self::TBS_IO_ERROR => write!(f, "TBS_IO_ERROR"),
            Self::TBS_INVALID_CONTEXT_PARAM => write!(f, "TBS_INVALID_CONTEXT_PARAM"),
            Self::TBS_SERVICE_NOT_RUNNING => write!(f, "TBS_SERVICE_NOT_RUNNING"),
            Self::TBS_TOO_MANY_CONTEXTS => write!(f, "TBS_TOO_MANY_CONTEXTS"),
            Self::TBS_TOO_MANY_RESOURCES => write!(f, "TBS_TOO_MANY_RESOURCES"),
            Self::TBS_SERVICE_START_PENDING => write!(f, "TBS_SERVICE_START_PENDING"),
            Self::TBS_PPI_NOT_SUPPORTED => write!(f, "TBS_PPI_NOT_SUPPORTED"),
            Self::TBS_COMMAND_CANCELED => write!(f, "TBS_COMMAND_CANCELED"),
            Self::TBS_BUFFER_TOO_LARGE => write!(f, "TBS_BUFFER_TOO_LARGE"),
            Self::TBS_TPM_NOT_FOUND => write!(f, "TBS_TPM_NOT_FOUND"),
            Self::TBS_SERVICE_DISABLED => write!(f, "TBS_SERVICE_DISABLED"),
            Self::TBS_ACCESS_DENIED => write!(f, "TBS_ACCESS_DENIED"),
            Self::TBS_PPI_FUNCTION_NOT_SUPPORTED => write!(f, "TBS_PPI_FUNCTION_NOT_SUPPORTED"),
            Self::TBS_OWNER_AUTH_NOT_FOUND => write!(f, "TBS_OWNER_AUTH_NOT_FOUND"),
        }
    }
}

/// A TPM_CLOCK_ADJUST value is used to change the rate at which the TPM internal
/// oscillator is divided. A change to the divider will change the rate at which Clock and
/// Time change.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, TryFromPrimitive)]
#[repr(i8)]
pub enum TPM_CLOCK_ADJUST {
    /// Slow the Clock update rate by one coarse adjustment step.
    COARSE_SLOWER = 0xFFFFFFFFFFFFFFFD, // Original value: -3

    /// Slow the Clock update rate by one medium adjustment step.
    MEDIUM_SLOWER = 0xFFFFFFFFFFFFFFFE, // Original value: -2

    /// Slow the Clock update rate by one fine adjustment step.
    FINE_SLOWER = 0xFFFFFFFFFFFFFFFF, // Original value: -1

    /// No change to the Clock update rate.
    NO_CHANGE = 0x0, // Original value: 0

    /// Speed the Clock update rate by one fine adjustment step.
    FINE_FASTER = 0x1, // Original value: 1

    /// Speed the Clock update rate by one medium adjustment step.
    MEDIUM_FASTER = 0x2, // Original value: 2

    /// Speed the Clock update rate by one coarse adjustment step.
    COARSE_FASTER = 0x3 // Original value: 3
}

impl fmt::Display for TPM_CLOCK_ADJUST {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::COARSE_SLOWER => write!(f, "COARSE_SLOWER"),
            Self::MEDIUM_SLOWER => write!(f, "MEDIUM_SLOWER"),
            Self::FINE_SLOWER => write!(f, "FINE_SLOWER"),
            Self::NO_CHANGE => write!(f, "NO_CHANGE"),
            Self::FINE_FASTER => write!(f, "FINE_FASTER"),
            Self::MEDIUM_FASTER => write!(f, "MEDIUM_FASTER"),
            Self::COARSE_FASTER => write!(f, "COARSE_FASTER"),
        }
    }
}

/// Table 18 Definition of (UINT16) TPM_EO Constants [IN/OUT]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, TryFromPrimitive)]
#[repr(i16)]
pub enum TPM_EO {
    /// A = B
    EQ = 0x0, // Original value: 0x0000

    /// A B
    NEQ = 0x1, // Original value: 0x0001

    /// A ˃ B signed
    SIGNED_GT = 0x2, // Original value: 0x0002

    /// A ˃ B unsigned
    UNSIGNED_GT = 0x3, // Original value: 0x0003

    /// A ˂ B signed
    SIGNED_LT = 0x4, // Original value: 0x0004

    /// A ˂ B unsigned
    UNSIGNED_LT = 0x5, // Original value: 0x0005

    /// A B signed
    SIGNED_GE = 0x6, // Original value: 0x0006

    /// A B unsigned
    UNSIGNED_GE = 0x7, // Original value: 0x0007

    /// A B signed
    SIGNED_LE = 0x8, // Original value: 0x0008

    /// A B unsigned
    UNSIGNED_LE = 0x9, // Original value: 0x0009

    /// All bits SET in B are SET in A. ((A∧B)=B)
    BITSET = 0xA, // Original value: 0x000A

    /// All bits SET in B are CLEAR in A. ((A∧B)=0)
    BITCLEAR = 0xB // Original value: 0x000B
}

impl fmt::Display for TPM_EO {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::EQ => write!(f, "EQ"),
            Self::NEQ => write!(f, "NEQ"),
            Self::SIGNED_GT => write!(f, "SIGNED_GT"),
            Self::UNSIGNED_GT => write!(f, "UNSIGNED_GT"),
            Self::SIGNED_LT => write!(f, "SIGNED_LT"),
            Self::UNSIGNED_LT => write!(f, "UNSIGNED_LT"),
            Self::SIGNED_GE => write!(f, "SIGNED_GE"),
            Self::UNSIGNED_GE => write!(f, "UNSIGNED_GE"),
            Self::SIGNED_LE => write!(f, "SIGNED_LE"),
            Self::UNSIGNED_LE => write!(f, "UNSIGNED_LE"),
            Self::BITSET => write!(f, "BITSET"),
            Self::BITCLEAR => write!(f, "BITCLEAR"),
        }
    }
}

/// Structure tags are used to disambiguate structures. They are 16-bit values with the
/// most significant bit SET so that they do not overlap TPM_ALG_ID values. A single
/// exception is made for the value associated with TPM_ST_RSP_COMMAND (0x00C4), which has
/// the same value as the TPM_TAG_RSP_COMMAND tag from earlier versions of this
/// specification. This value is used when the TPM is compatible with a previous TPM
/// specification and the TPM cannot determine which family of response code to return
/// because the command tag is not valid.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, TryFromPrimitive)]
#[repr(i16)]
pub enum TPM_ST {
    /// Tag value for a response; used when there is an error in the tag. This is also the
    /// value returned from a TPM 1.2 when an error occurs. This value is used in this
    /// specification because an error in the command tag may prevent determination of the
    /// family. When this tag is used in the response, the response code will be
    /// TPM_RC_BAD_TAG (0 1E16), which has the same numeric value as the TPM 1.2 response code
    /// for TPM_BADTAG.
    /// NOTE In a previously published version of this specification, TPM_RC_BAD_TAG was
    /// incorrectly assigned a value of 0x030 instead of 30 (0x01e). Some implementations my
    /// return the old value instead of the new value.
    RSP_COMMAND = 0xC4, // Original value: 0x00C4

    /// No structure type specified
    NULL = 0x8000, // Original value: 0X8000

    /// Tag value for a command/response for a command defined in this specification;
    /// indicating that the command/response has no attached sessions and no
    /// authorizationSize/parameterSize value is present
    /// If the responseCode from the TPM is not TPM_RC_SUCCESS, then the response tag shall
    /// have this value.
    NO_SESSIONS = 0x8001,

    /// Tag value for a command/response for a command defined in this specification;
    /// indicating that the command/response has one or more attached sessions and the
    /// authorizationSize/parameterSize field is present
    SESSIONS = 0x8002,

    /// Tag for an attestation structure
    ATTEST_NV = 0x8014,

    /// Tag for an attestation structure
    ATTEST_COMMAND_AUDIT = 0x8015,

    /// Tag for an attestation structure
    ATTEST_SESSION_AUDIT = 0x8016,

    /// Tag for an attestation structure
    ATTEST_CERTIFY = 0x8017,

    /// Tag for an attestation structure
    ATTEST_QUOTE = 0x8018,

    /// Tag for an attestation structure
    ATTEST_TIME = 0x8019,

    /// Tag for an attestation structure
    ATTEST_CREATION = 0x801A,

    /// Tag for an attestation structure
    ATTEST_NV_DIGEST = 0x801C,

    /// Tag for a ticket type
    CREATION = 0x8021,

    /// Tag for a ticket type
    VERIFIED = 0x8022,

    /// Tag for a ticket type
    AUTH_SECRET = 0x8023,

    /// Tag for a ticket type
    HASHCHECK = 0x8024,

    /// Tag for a ticket type
    AUTH_SIGNED = 0x8025,

    /// Tag for a structure describing a Field Upgrade Policy
    FU_MANIFEST = 0x8029
}

impl fmt::Display for TPM_ST {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::RSP_COMMAND => write!(f, "RSP_COMMAND"),
            Self::NULL => write!(f, "NULL"),
            Self::NO_SESSIONS => write!(f, "NO_SESSIONS"),
            Self::SESSIONS => write!(f, "SESSIONS"),
            Self::ATTEST_NV => write!(f, "ATTEST_NV"),
            Self::ATTEST_COMMAND_AUDIT => write!(f, "ATTEST_COMMAND_AUDIT"),
            Self::ATTEST_SESSION_AUDIT => write!(f, "ATTEST_SESSION_AUDIT"),
            Self::ATTEST_CERTIFY => write!(f, "ATTEST_CERTIFY"),
            Self::ATTEST_QUOTE => write!(f, "ATTEST_QUOTE"),
            Self::ATTEST_TIME => write!(f, "ATTEST_TIME"),
            Self::ATTEST_CREATION => write!(f, "ATTEST_CREATION"),
            Self::ATTEST_NV_DIGEST => write!(f, "ATTEST_NV_DIGEST"),
            Self::CREATION => write!(f, "CREATION"),
            Self::VERIFIED => write!(f, "VERIFIED"),
            Self::AUTH_SECRET => write!(f, "AUTH_SECRET"),
            Self::HASHCHECK => write!(f, "HASHCHECK"),
            Self::AUTH_SIGNED => write!(f, "AUTH_SIGNED"),
            Self::FU_MANIFEST => write!(f, "FU_MANIFEST"),
        }
    }
}

/// These values are used in TPM2_Startup() to indicate the shutdown and startup mode. The
/// defined startup sequences are:
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, TryFromPrimitive)]
#[repr(i16)]
pub enum TPM_SU {
    /// On TPM2_Shutdown(), indicates that the TPM should prepare for loss of power and save
    /// state required for an orderly startup (TPM Reset).
    /// on TPM2_Startup(), indicates that the TPM should perform TPM Reset or TPM Restart
    CLEAR = 0x0, // Original value: 0x0000

    /// On TPM2_Shutdown(), indicates that the TPM should prepare for loss of power and save
    /// state required for an orderly startup (TPM Restart or TPM Resume)
    /// on TPM2_Startup(), indicates that the TPM should restore the state saved by
    /// TPM2_Shutdown(TPM_SU_STATE)
    STATE = 0x1 // Original value: 0x0001
}

impl fmt::Display for TPM_SU {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::CLEAR => write!(f, "CLEAR"),
            Self::STATE => write!(f, "STATE"),
        }
    }
}

/// This type is used in TPM2_StartAuthSession() to indicate the type of the session to be
/// created.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, TryFromPrimitive)]
#[repr(i8)]
pub enum TPM_SE {
    HMAC = 0x0, // Original value: 0x00
    POLICY = 0x1, // Original value: 0x01

    /// The policy session is being used to compute the policyHash and not for command authorization.
    /// This setting modifies some policy commands and prevents session from being used to
    /// authorize a command.
    TRIAL = 0x3 // Original value: 0x03
}

impl fmt::Display for TPM_SE {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::HMAC => write!(f, "HMAC"),
            Self::POLICY => write!(f, "POLICY"),
            Self::TRIAL => write!(f, "TRIAL"),
        }
    }
}

/// The TPM_CAP values are used in TPM2_GetCapability() to select the type of the value to
/// be returned. The format of the response varies according to the type of the value.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, TryFromPrimitive)]
#[repr(i32)]
pub enum TPM_CAP {
    FIRST = 0x0, // Original value: 0x00000000

    /// TPML_ALG_PROPERTY
    // WARNING: ALGS has duplicate value 0x0 - using name + value pattern
    ALGSValue = 0x0, // Original value: 0x00000000

    /// TPML_HANDLE
    HANDLES = 0x1, // Original value: 0x00000001

    /// TPML_CCA
    COMMANDS = 0x2, // Original value: 0x00000002

    /// TPML_CC
    PP_COMMANDS = 0x3, // Original value: 0x00000003

    /// TPML_CC
    AUDIT_COMMANDS = 0x4, // Original value: 0x00000004

    /// TPML_PCR_SELECTION
    PCRS = 0x5, // Original value: 0x00000005

    /// TPML_TAGGED_TPM_PROPERTY
    TPM_PROPERTIES = 0x6, // Original value: 0x00000006

    /// TPML_TAGGED_PCR_PROPERTY
    PCR_PROPERTIES = 0x7, // Original value: 0x00000007

    /// TPML_ECC_CURVE
    ECC_CURVES = 0x8, // Original value: 0x00000008

    /// TPML_TAGGED_POLICY
    AUTH_POLICIES = 0x9, // Original value: 0x00000009

    /// TPML_ACT_DATA
    ACT = 0xA, // Original value: 0x0000000A
    // WARNING: LAST has duplicate value 0xA - using name + value pattern
    LASTValue = 0xA, // Original value: 0x0000000A

    /// Manufacturer-specific values
    VENDOR_PROPERTY = 0x100 // Original value: 0x00000100
}

impl fmt::Display for TPM_CAP {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::FIRST => write!(f, "FIRST"),
            Self::ALGS => write!(f, "ALGS"),
            Self::HANDLES => write!(f, "HANDLES"),
            Self::COMMANDS => write!(f, "COMMANDS"),
            Self::PP_COMMANDS => write!(f, "PP_COMMANDS"),
            Self::AUDIT_COMMANDS => write!(f, "AUDIT_COMMANDS"),
            Self::PCRS => write!(f, "PCRS"),
            Self::TPM_PROPERTIES => write!(f, "TPM_PROPERTIES"),
            Self::PCR_PROPERTIES => write!(f, "PCR_PROPERTIES"),
            Self::ECC_CURVES => write!(f, "ECC_CURVES"),
            Self::AUTH_POLICIES => write!(f, "AUTH_POLICIES"),
            Self::ACT => write!(f, "ACT"),
            Self::LAST => write!(f, "LAST"),
            Self::VENDOR_PROPERTY => write!(f, "VENDOR_PROPERTY"),
        }
    }
}

/// The TPM_PT constants are used in TPM2_GetCapability(capability =
/// TPM_CAP_TPM_PROPERTIES) to indicate the property being selected or returned.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, TryFromPrimitive)]
#[repr(i32)]
pub enum TPM_PT {
    /// Indicates no property type
    NONE = 0x0, // Original value: 0x00000000

    /// The number of properties in each group.
    /// NOTE The first group with any properties is group 1 (PT_GROUP * 1). Group 0 is reserved.
    PT_GROUP = 0x100, // Original value: 0x00000100

    /// The group of fixed properties returned as TPMS_TAGGED_PROPERTY
    /// The values in this group are only changed due to a firmware change in the TPM.
    // WARNING: PT_FIXED has duplicate value 0x100 - using name + value pattern
    PT_FIXEDValue = 0x100, // Original value: PT_GROUP * 1

    /// A 4-octet character string containing the TPM Family value (TPM_SPEC_FAMILY)
    // WARNING: FAMILY_INDICATOR has duplicate value 0x100 - using name + value pattern
    FAMILY_INDICATORValue = 0x100, // Original value: PT_FIXED + 0

    /// The level of the specification
    /// NOTE 1 For this specification, the level is zero.
    /// NOTE 2 The level is on the title page of the specification.
    LEVEL = 0x101, // Original value: PT_FIXED + 1

    /// The specification Revision times 100
    /// EXAMPLE Revision 01.01 would have a value of 101.
    /// NOTE The Revision value is on the title page of the specification.
    REVISION = 0x102, // Original value: PT_FIXED + 2

    /// The specification day of year using TCG calendar
    /// EXAMPLE November 15, 2010, has a day of year value of 319 (0000013F16).
    /// NOTE The specification date is on the title page of the specification or errata (see 6.1).
    DAY_OF_YEAR = 0x103, // Original value: PT_FIXED + 3

    /// The specification year using the CE
    /// EXAMPLE The year 2010 has a value of 000007DA16.
    /// NOTE The specification date is on the title page of the specification or errata (see 6.1).
    YEAR = 0x104, // Original value: PT_FIXED + 4

    /// The vendor ID unique to each TPM manufacturer
    MANUFACTURER = 0x105, // Original value: PT_FIXED + 5

    /// The first four characters of the vendor ID string
    /// NOTE When the vendor string is fewer than 16 octets, the additional property values do
    /// not have to be present. A vendor string of 4 octets can be represented in one 32-bit
    /// value and no null terminating character is required.
    VENDOR_STRING_1 = 0x106, // Original value: PT_FIXED + 6

    /// The second four characters of the vendor ID string
    VENDOR_STRING_2 = 0x107, // Original value: PT_FIXED + 7

    /// The third four characters of the vendor ID string
    VENDOR_STRING_3 = 0x108, // Original value: PT_FIXED + 8

    /// The fourth four characters of the vendor ID sting
    VENDOR_STRING_4 = 0x109, // Original value: PT_FIXED + 9

    /// Vendor-defined value indicating the TPM model
    VENDOR_TPM_TYPE = 0x10A, // Original value: PT_FIXED + 10

    /// The most-significant 32 bits of a TPM vendor-specific value indicating the version
    /// number of the firmware. See 10.12.2 and 10.12.12.
    FIRMWARE_VERSION_1 = 0x10B, // Original value: PT_FIXED + 11

    /// The least-significant 32 bits of a TPM vendor-specific value indicating the version
    /// number of the firmware. See 10.12.2 and 10.12.12.
    FIRMWARE_VERSION_2 = 0x10C, // Original value: PT_FIXED + 12

    /// The maximum size of a parameter (typically, a TPM2B_MAX_BUFFER)
    INPUT_BUFFER = 0x10D, // Original value: PT_FIXED + 13

    /// The minimum number of transient objects that can be held in TPM RAM
    /// NOTE This minimum shall be no less than the minimum value required by the
    /// platform-specific specification to which the TPM is built.
    HR_TRANSIENT_MIN = 0x10E, // Original value: PT_FIXED + 14

    /// The minimum number of persistent objects that can be held in TPM NV memory
    /// NOTE This minimum shall be no less than the minimum value required by the
    /// platform-specific specification to which the TPM is built.
    HR_PERSISTENT_MIN = 0x10F, // Original value: PT_FIXED + 15

    /// The minimum number of authorization sessions that can be held in TPM RAM
    /// NOTE This minimum shall be no less than the minimum value required by the
    /// platform-specific specification to which the TPM is built.
    HR_LOADED_MIN = 0x110, // Original value: PT_FIXED + 16

    /// The number of authorization sessions that may be active at a time
    /// A session is active when it has a context associated with its handle. The context may
    /// either be in TPM RAM or be context saved.
    /// NOTE This value shall be no less than the minimum value required by the
    /// platform-specific specification to which the TPM is built.
    ACTIVE_SESSIONS_MAX = 0x111, // Original value: PT_FIXED + 17

    /// The number of PCR implemented
    /// NOTE This number is determined by the defined attributes, not the number of PCR that
    /// are populated.
    PCR_COUNT = 0x112, // Original value: PT_FIXED + 18

    /// The minimum number of octets in a TPMS_PCR_SELECT.sizeOfSelect
    /// NOTE This value is not determined by the number of PCR implemented but by the number
    /// of PCR required by the platform-specific specification with which the TPM is compliant
    /// or by the implementer if not adhering to a platform-specific specification.
    PCR_SELECT_MIN = 0x113, // Original value: PT_FIXED + 19

    /// The maximum allowed difference (unsigned) between the contextID values of two saved
    /// session contexts
    /// This value shall be 2n-1, where n is at least 16.
    CONTEXT_GAP_MAX = 0x114, // Original value: PT_FIXED + 20

    /// The maximum number of NV Indexes that are allowed to have the TPM_NT_COUNTER attribute
    /// NOTE 1 It is allowed for this value to be larger than the number of NV Indexes that
    /// can be defined. This would be indicative of a TPM implementation that did not use
    /// different implementation technology for different NV Index types.
    /// NOTE 2 The value zero indicates that there is no fixed maximum. The number of counter
    /// indexes is determined by the available NV memory pool.
    NV_COUNTERS_MAX = 0x116, // Original value: PT_FIXED + 22

    /// The maximum size of an NV Index data area
    NV_INDEX_MAX = 0x117, // Original value: PT_FIXED + 23

    /// A TPMA_MEMORY indicating the memory management method for the TPM
    MEMORY = 0x118, // Original value: PT_FIXED + 24

    /// Interval, in milliseconds, between updates to the copy of TPMS_CLOCK_INFO.clock in NV
    CLOCK_UPDATE = 0x119, // Original value: PT_FIXED + 25

    /// The algorithm used for the integrity HMAC on saved contexts and for hashing the fuData
    /// of TPM2_FirmwareRead()
    CONTEXT_HASH = 0x11A, // Original value: PT_FIXED + 26

    /// TPM_ALG_ID, the algorithm used for encryption of saved contexts
    CONTEXT_SYM = 0x11B, // Original value: PT_FIXED + 27

    /// TPM_KEY_BITS, the size of the key used for encryption of saved contexts
    CONTEXT_SYM_SIZE = 0x11C, // Original value: PT_FIXED + 28

    /// The modulus - 1 of the count for NV update of an orderly counter
    /// The returned value is MAX_ORDERLY_COUNT.
    /// This will have a value of 2N 1 where 1 N 32
    /// NOTE 1 An orderly counter is an NV Index with an TPM_NT of TPM_NV_COUNTER and
    /// TPMA_NV_ORDERLY SET.
    /// NOTE 2 When the low-order bits of a counter equal this value, an NV write occurs on
    /// the next increment.
    ORDERLY_COUNT = 0x11D, // Original value: PT_FIXED + 29

    /// The maximum value for commandSize in a command
    MAX_COMMAND_SIZE = 0x11E, // Original value: PT_FIXED + 30

    /// The maximum value for responseSize in a response
    MAX_RESPONSE_SIZE = 0x11F, // Original value: PT_FIXED + 31

    /// The maximum size of a digest that can be produced by the TPM
    MAX_DIGEST = 0x120, // Original value: PT_FIXED + 32

    /// The maximum size of an object context that will be returned by TPM2_ContextSave
    MAX_OBJECT_CONTEXT = 0x121, // Original value: PT_FIXED + 33

    /// The maximum size of a session context that will be returned by TPM2_ContextSave
    MAX_SESSION_CONTEXT = 0x122, // Original value: PT_FIXED + 34

    /// Platform-specific family (a TPM_PS value)(see Table 25)
    /// NOTE The platform-specific values for the TPM_PT_PS parameters are in the relevant
    /// platform-specific specification. In the reference implementation, all of these values
    /// are 0.
    PS_FAMILY_INDICATOR = 0x123, // Original value: PT_FIXED + 35

    /// The level of the platform-specific specification
    PS_LEVEL = 0x124, // Original value: PT_FIXED + 36

    /// A platform specific value
    PS_REVISION = 0x125, // Original value: PT_FIXED + 37

    /// The platform-specific TPM specification day of year using TCG calendar
    /// EXAMPLE November 15, 2010, has a day of year value of 319 (0000013F16).
    PS_DAY_OF_YEAR = 0x126, // Original value: PT_FIXED + 38

    /// The platform-specific TPM specification year using the CE
    /// EXAMPLE The year 2010 has a value of 000007DA16.
    PS_YEAR = 0x127, // Original value: PT_FIXED + 39

    /// The number of split signing operations supported by the TPM
    SPLIT_MAX = 0x128, // Original value: PT_FIXED + 40

    /// Total number of commands implemented in the TPM
    TOTAL_COMMANDS = 0x129, // Original value: PT_FIXED + 41

    /// Number of commands from the TPM library that are implemented
    LIBRARY_COMMANDS = 0x12A, // Original value: PT_FIXED + 42

    /// Number of vendor commands that are implemented
    VENDOR_COMMANDS = 0x12B, // Original value: PT_FIXED + 43

    /// The maximum data size in one NV write, NV read, NV extend, or NV certify command
    NV_BUFFER_MAX = 0x12C, // Original value: PT_FIXED + 44

    /// A TPMA_MODES value, indicating that the TPM is designed for these modes.
    MODES = 0x12D, // Original value: PT_FIXED + 45

    /// The maximum size of a TPMS_CAPABILITY_DATA structure returned in TPM2_GetCapability().
    MAX_CAP_BUFFER = 0x12E, // Original value: PT_FIXED + 46

    /// The group of variable properties returned as TPMS_TAGGED_PROPERTY
    /// The properties in this group change because of a Protected Capability other than a
    /// firmware update. The values are not necessarily persistent across all power transitions.
    PT_VAR = 0x200, // Original value: PT_GROUP * 2

    /// TPMA_PERMANENT
    // WARNING: PERMANENT has duplicate value 0x200 - using name + value pattern
    PERMANENTValue = 0x200, // Original value: PT_VAR + 0

    /// TPMA_STARTUP_CLEAR
    STARTUP_CLEAR = 0x201, // Original value: PT_VAR + 1

    /// The number of NV Indexes currently defined
    HR_NV_INDEX = 0x202, // Original value: PT_VAR + 2

    /// The number of authorization sessions currently loaded into TPM RAM
    HR_LOADED = 0x203, // Original value: PT_VAR + 3

    /// The number of additional authorization sessions, of any type, that could be loaded
    /// into TPM RAM
    /// This value is an estimate. If this value is at least 1, then at least one
    /// authorization session of any type may be loaded. Any command that changes the RAM
    /// memory allocation can make this estimate invalid.
    /// NOTE A valid implementation may return 1 even if more than one authorization session
    /// would fit into RAM.
    HR_LOADED_AVAIL = 0x204, // Original value: PT_VAR + 4

    /// The number of active authorization sessions currently being tracked by the TPM
    /// This is the sum of the loaded and saved sessions.
    HR_ACTIVE = 0x205, // Original value: PT_VAR + 5

    /// The number of additional authorization sessions, of any type, that could be created
    /// This value is an estimate. If this value is at least 1, then at least one
    /// authorization session of any type may be created. Any command that changes the RAM
    /// memory allocation can make this estimate invalid.
    /// NOTE A valid implementation may return 1 even if more than one authorization session
    /// could be created.
    HR_ACTIVE_AVAIL = 0x206, // Original value: PT_VAR + 6

    /// Estimate of the number of additional transient objects that could be loaded into TPM RAM
    /// This value is an estimate. If this value is at least 1, then at least one object of
    /// any type may be loaded. Any command that changes the memory allocation can make this
    /// estimate invalid.
    /// NOTE A valid implementation may return 1 even if more than one transient object would
    /// fit into RAM.
    HR_TRANSIENT_AVAIL = 0x207, // Original value: PT_VAR + 7

    /// The number of persistent objects currently loaded into TPM NV memory
    HR_PERSISTENT = 0x208, // Original value: PT_VAR + 8

    /// The number of additional persistent objects that could be loaded into NV memory
    /// This value is an estimate. If this value is at least 1, then at least one object of
    /// any type may be made persistent. Any command that changes the NV memory allocation can
    /// make this estimate invalid.
    /// NOTE A valid implementation may return 1 even if more than one persistent object would
    /// fit into NV memory.
    HR_PERSISTENT_AVAIL = 0x209, // Original value: PT_VAR + 9

    /// The number of defined NV Indexes that have NV the TPM_NT_COUNTER attribute
    NV_COUNTERS = 0x20A, // Original value: PT_VAR + 10

    /// The number of additional NV Indexes that can be defined with their TPM_NT of
    /// TPM_NV_COUNTER and the TPMA_NV_ORDERLY attribute SET
    /// This value is an estimate. If this value is at least 1, then at least one NV Index may
    /// be created with a TPM_NT of TPM_NV_COUNTER and the TPMA_NV_ORDERLY attributes. Any
    /// command that changes the NV memory allocation can make this estimate invalid.
    /// NOTE A valid implementation may return 1 even if more than one NV counter could be defined.
    NV_COUNTERS_AVAIL = 0x20B, // Original value: PT_VAR + 11

    /// Code that limits the algorithms that may be used with the TPM
    ALGORITHM_SET = 0x20C, // Original value: PT_VAR + 12

    /// The number of loaded ECC curves
    LOADED_CURVES = 0x20D, // Original value: PT_VAR + 13

    /// The current value of the lockout counter (failedTries)
    LOCKOUT_COUNTER = 0x20E, // Original value: PT_VAR + 14

    /// The number of authorization failures before DA lockout is invoked
    MAX_AUTH_FAIL = 0x20F, // Original value: PT_VAR + 15

    /// The number of seconds before the value reported by TPM_PT_LOCKOUT_COUNTER is decremented
    LOCKOUT_INTERVAL = 0x210, // Original value: PT_VAR + 16

    /// The number of seconds after a lockoutAuth failure before use of lockoutAuth may be
    /// attempted again
    LOCKOUT_RECOVERY = 0x211, // Original value: PT_VAR + 17

    /// Number of milliseconds before the TPM will accept another command that will modify NV
    /// This value is an approximation and may go up or down over time.
    NV_WRITE_RECOVERY = 0x212, // Original value: PT_VAR + 18

    /// The high-order 32 bits of the command audit counter
    AUDIT_COUNTER_0 = 0x213, // Original value: PT_VAR + 19

    /// The low-order 32 bits of the command audit counter
    AUDIT_COUNTER_1 = 0x214 // Original value: PT_VAR + 20
}

impl fmt::Display for TPM_PT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::NONE => write!(f, "NONE"),
            Self::PT_GROUP => write!(f, "PT_GROUP"),
            Self::PT_FIXED => write!(f, "PT_FIXED"),
            Self::FAMILY_INDICATOR => write!(f, "FAMILY_INDICATOR"),
            Self::LEVEL => write!(f, "LEVEL"),
            Self::REVISION => write!(f, "REVISION"),
            Self::DAY_OF_YEAR => write!(f, "DAY_OF_YEAR"),
            Self::YEAR => write!(f, "YEAR"),
            Self::MANUFACTURER => write!(f, "MANUFACTURER"),
            Self::VENDOR_STRING_1 => write!(f, "VENDOR_STRING_1"),
            Self::VENDOR_STRING_2 => write!(f, "VENDOR_STRING_2"),
            Self::VENDOR_STRING_3 => write!(f, "VENDOR_STRING_3"),
            Self::VENDOR_STRING_4 => write!(f, "VENDOR_STRING_4"),
            Self::VENDOR_TPM_TYPE => write!(f, "VENDOR_TPM_TYPE"),
            Self::FIRMWARE_VERSION_1 => write!(f, "FIRMWARE_VERSION_1"),
            Self::FIRMWARE_VERSION_2 => write!(f, "FIRMWARE_VERSION_2"),
            Self::INPUT_BUFFER => write!(f, "INPUT_BUFFER"),
            Self::HR_TRANSIENT_MIN => write!(f, "HR_TRANSIENT_MIN"),
            Self::HR_PERSISTENT_MIN => write!(f, "HR_PERSISTENT_MIN"),
            Self::HR_LOADED_MIN => write!(f, "HR_LOADED_MIN"),
            Self::ACTIVE_SESSIONS_MAX => write!(f, "ACTIVE_SESSIONS_MAX"),
            Self::PCR_COUNT => write!(f, "PCR_COUNT"),
            Self::PCR_SELECT_MIN => write!(f, "PCR_SELECT_MIN"),
            Self::CONTEXT_GAP_MAX => write!(f, "CONTEXT_GAP_MAX"),
            Self::NV_COUNTERS_MAX => write!(f, "NV_COUNTERS_MAX"),
            Self::NV_INDEX_MAX => write!(f, "NV_INDEX_MAX"),
            Self::MEMORY => write!(f, "MEMORY"),
            Self::CLOCK_UPDATE => write!(f, "CLOCK_UPDATE"),
            Self::CONTEXT_HASH => write!(f, "CONTEXT_HASH"),
            Self::CONTEXT_SYM => write!(f, "CONTEXT_SYM"),
            Self::CONTEXT_SYM_SIZE => write!(f, "CONTEXT_SYM_SIZE"),
            Self::ORDERLY_COUNT => write!(f, "ORDERLY_COUNT"),
            Self::MAX_COMMAND_SIZE => write!(f, "MAX_COMMAND_SIZE"),
            Self::MAX_RESPONSE_SIZE => write!(f, "MAX_RESPONSE_SIZE"),
            Self::MAX_DIGEST => write!(f, "MAX_DIGEST"),
            Self::MAX_OBJECT_CONTEXT => write!(f, "MAX_OBJECT_CONTEXT"),
            Self::MAX_SESSION_CONTEXT => write!(f, "MAX_SESSION_CONTEXT"),
            Self::PS_FAMILY_INDICATOR => write!(f, "PS_FAMILY_INDICATOR"),
            Self::PS_LEVEL => write!(f, "PS_LEVEL"),
            Self::PS_REVISION => write!(f, "PS_REVISION"),
            Self::PS_DAY_OF_YEAR => write!(f, "PS_DAY_OF_YEAR"),
            Self::PS_YEAR => write!(f, "PS_YEAR"),
            Self::SPLIT_MAX => write!(f, "SPLIT_MAX"),
            Self::TOTAL_COMMANDS => write!(f, "TOTAL_COMMANDS"),
            Self::LIBRARY_COMMANDS => write!(f, "LIBRARY_COMMANDS"),
            Self::VENDOR_COMMANDS => write!(f, "VENDOR_COMMANDS"),
            Self::NV_BUFFER_MAX => write!(f, "NV_BUFFER_MAX"),
            Self::MODES => write!(f, "MODES"),
            Self::MAX_CAP_BUFFER => write!(f, "MAX_CAP_BUFFER"),
            Self::PT_VAR => write!(f, "PT_VAR"),
            Self::PERMANENT => write!(f, "PERMANENT"),
            Self::STARTUP_CLEAR => write!(f, "STARTUP_CLEAR"),
            Self::HR_NV_INDEX => write!(f, "HR_NV_INDEX"),
            Self::HR_LOADED => write!(f, "HR_LOADED"),
            Self::HR_LOADED_AVAIL => write!(f, "HR_LOADED_AVAIL"),
            Self::HR_ACTIVE => write!(f, "HR_ACTIVE"),
            Self::HR_ACTIVE_AVAIL => write!(f, "HR_ACTIVE_AVAIL"),
            Self::HR_TRANSIENT_AVAIL => write!(f, "HR_TRANSIENT_AVAIL"),
            Self::HR_PERSISTENT => write!(f, "HR_PERSISTENT"),
            Self::HR_PERSISTENT_AVAIL => write!(f, "HR_PERSISTENT_AVAIL"),
            Self::NV_COUNTERS => write!(f, "NV_COUNTERS"),
            Self::NV_COUNTERS_AVAIL => write!(f, "NV_COUNTERS_AVAIL"),
            Self::ALGORITHM_SET => write!(f, "ALGORITHM_SET"),
            Self::LOADED_CURVES => write!(f, "LOADED_CURVES"),
            Self::LOCKOUT_COUNTER => write!(f, "LOCKOUT_COUNTER"),
            Self::MAX_AUTH_FAIL => write!(f, "MAX_AUTH_FAIL"),
            Self::LOCKOUT_INTERVAL => write!(f, "LOCKOUT_INTERVAL"),
            Self::LOCKOUT_RECOVERY => write!(f, "LOCKOUT_RECOVERY"),
            Self::NV_WRITE_RECOVERY => write!(f, "NV_WRITE_RECOVERY"),
            Self::AUDIT_COUNTER_0 => write!(f, "AUDIT_COUNTER_0"),
            Self::AUDIT_COUNTER_1 => write!(f, "AUDIT_COUNTER_1"),
        }
    }
}

/// The TPM_PT_PCR constants are used in TPM2_GetCapability() to indicate the property
/// being selected or returned. The PCR properties can be read when capability ==
/// TPM_CAP_PCR_PROPERTIES. If there is no property that corresponds to the value of
/// property, the next higher value is returned, if it exists.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, TryFromPrimitive)]
#[repr(i32)]
pub enum TPM_PT_PCR {
    /// Bottom of the range of TPM_PT_PCR properties
    FIRST = 0x0, // Original value: 0x00000000

    /// A SET bit in the TPMS_PCR_SELECT indicates that the PCR is saved and restored by TPM_SU_STATE
    // WARNING: SAVE has duplicate value 0x0 - using name + value pattern
    SAVEValue = 0x0, // Original value: 0x00000000

    /// A SET bit in the TPMS_PCR_SELECT indicates that the PCR may be extended from locality 0
    /// This property is only present if a locality other than 0 is implemented.
    EXTEND_L0 = 0x1, // Original value: 0x00000001

    /// A SET bit in the TPMS_PCR_SELECT indicates that the PCR may be reset by
    /// TPM2_PCR_Reset() from locality 0
    RESET_L0 = 0x2, // Original value: 0x00000002

    /// A SET bit in the TPMS_PCR_SELECT indicates that the PCR may be extended from locality 1
    /// This property is only present if locality 1 is implemented.
    EXTEND_L1 = 0x3, // Original value: 0x00000003

    /// A SET bit in the TPMS_PCR_SELECT indicates that the PCR may be reset by
    /// TPM2_PCR_Reset() from locality 1
    /// This property is only present if locality 1 is implemented.
    RESET_L1 = 0x4, // Original value: 0x00000004

    /// A SET bit in the TPMS_PCR_SELECT indicates that the PCR may be extended from locality 2
    /// This property is only present if localities 1 and 2 are implemented.
    EXTEND_L2 = 0x5, // Original value: 0x00000005

    /// A SET bit in the TPMS_PCR_SELECT indicates that the PCR may be reset by
    /// TPM2_PCR_Reset() from locality 2
    /// This property is only present if localities 1 and 2 are implemented.
    RESET_L2 = 0x6, // Original value: 0x00000006

    /// A SET bit in the TPMS_PCR_SELECT indicates that the PCR may be extended from locality 3
    /// This property is only present if localities 1, 2, and 3 are implemented.
    EXTEND_L3 = 0x7, // Original value: 0x00000007

    /// A SET bit in the TPMS_PCR_SELECT indicates that the PCR may be reset by
    /// TPM2_PCR_Reset() from locality 3
    /// This property is only present if localities 1, 2, and 3 are implemented.
    RESET_L3 = 0x8, // Original value: 0x00000008

    /// A SET bit in the TPMS_PCR_SELECT indicates that the PCR may be extended from locality 4
    /// This property is only present if localities 1, 2, 3, and 4 are implemented.
    EXTEND_L4 = 0x9, // Original value: 0x00000009

    /// A SET bit in the TPMS_PCR_SELECT indicates that the PCR may be reset by
    /// TPM2_PCR_Reset() from locality 4
    /// This property is only present if localities 1, 2, 3, and 4 are implemented.
    RESET_L4 = 0xA, // Original value: 0x0000000A

    /// A SET bit in the TPMS_PCR_SELECT indicates that modifications to this PCR (reset or
    /// Extend) will not increment the pcrUpdateCounter
    NO_INCREMENT = 0x11, // Original value: 0x00000011

    /// A SET bit in the TPMS_PCR_SELECT indicates that the PCR is reset by a D-RTM event
    /// These PCR are reset to -1 on TPM2_Startup() and reset to 0 on a _TPM_Hash_End event
    /// following a _TPM_Hash_Start event.
    DRTM_RESET = 0x12, // Original value: 0x00000012

    /// A SET bit in the TPMS_PCR_SELECT indicates that the PCR is controlled by policy
    /// This property is only present if the TPM supports policy control of a PCR.
    POLICY = 0x13, // Original value: 0x00000013

    /// A SET bit in the TPMS_PCR_SELECT indicates that the PCR is controlled by an
    /// authorization value
    /// This property is only present if the TPM supports authorization control of a PCR.
    AUTH = 0x14, // Original value: 0x00000014

    /// Top of the range of TPM_PT_PCR properties of the implementation
    /// If the TPM receives a request for a PCR property with a value larger than this, the
    /// TPM will return a zero length list and set the moreData parameter to NO.
    /// NOTE This is an implementation-specific value. The value shown reflects the reference
    /// code implementation.
    // WARNING: LAST has duplicate value 0x14 - using name + value pattern
    LASTValue = 0x14 // Original value: 0x00000014
}

impl fmt::Display for TPM_PT_PCR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::FIRST => write!(f, "FIRST"),
            Self::SAVE => write!(f, "SAVE"),
            Self::EXTEND_L0 => write!(f, "EXTEND_L0"),
            Self::RESET_L0 => write!(f, "RESET_L0"),
            Self::EXTEND_L1 => write!(f, "EXTEND_L1"),
            Self::RESET_L1 => write!(f, "RESET_L1"),
            Self::EXTEND_L2 => write!(f, "EXTEND_L2"),
            Self::RESET_L2 => write!(f, "RESET_L2"),
            Self::EXTEND_L3 => write!(f, "EXTEND_L3"),
            Self::RESET_L3 => write!(f, "RESET_L3"),
            Self::EXTEND_L4 => write!(f, "EXTEND_L4"),
            Self::RESET_L4 => write!(f, "RESET_L4"),
            Self::NO_INCREMENT => write!(f, "NO_INCREMENT"),
            Self::DRTM_RESET => write!(f, "DRTM_RESET"),
            Self::POLICY => write!(f, "POLICY"),
            Self::AUTH => write!(f, "AUTH"),
            Self::LAST => write!(f, "LAST"),
        }
    }
}

/// The platform values in Table 25 are used for the TPM_PT_PS_FAMILY_INDICATOR.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, TryFromPrimitive)]
#[repr(i32)]
pub enum TPM_PS {
    /// Not platform specific
    MAIN = 0x0, // Original value: 0x00000000

    /// PC Client
    PC = 0x1, // Original value: 0x00000001

    /// PDA (includes all mobile devices that are not specifically cell phones)
    PDA = 0x2, // Original value: 0x00000002

    /// Cell Phone
    CELL_PHONE = 0x3, // Original value: 0x00000003

    /// Server WG
    SERVER = 0x4, // Original value: 0x00000004

    /// Peripheral WG
    PERIPHERAL = 0x5, // Original value: 0x00000005

    /// TSS WG (deprecated)
    TSS = 0x6, // Original value: 0x00000006

    /// Storage WG
    STORAGE = 0x7, // Original value: 0x00000007

    /// Authentication WG
    AUTHENTICATION = 0x8, // Original value: 0x00000008

    /// Embedded WG
    EMBEDDED = 0x9, // Original value: 0x00000009

    /// Hardcopy WG
    HARDCOPY = 0xA, // Original value: 0x0000000A

    /// Infrastructure WG (deprecated)
    INFRASTRUCTURE = 0xB, // Original value: 0x0000000B

    /// Virtualization WG
    VIRTUALIZATION = 0xC, // Original value: 0x0000000C

    /// Trusted Network Connect WG (deprecated)
    TNC = 0xD, // Original value: 0x0000000D

    /// Multi-tenant WG (deprecated)
    MULTI_TENANT = 0xE, // Original value: 0x0000000E

    /// Technical Committee (deprecated)
    TC = 0xF // Original value: 0x0000000F
}

impl fmt::Display for TPM_PS {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::MAIN => write!(f, "MAIN"),
            Self::PC => write!(f, "PC"),
            Self::PDA => write!(f, "PDA"),
            Self::CELL_PHONE => write!(f, "CELL_PHONE"),
            Self::SERVER => write!(f, "SERVER"),
            Self::PERIPHERAL => write!(f, "PERIPHERAL"),
            Self::TSS => write!(f, "TSS"),
            Self::STORAGE => write!(f, "STORAGE"),
            Self::AUTHENTICATION => write!(f, "AUTHENTICATION"),
            Self::EMBEDDED => write!(f, "EMBEDDED"),
            Self::HARDCOPY => write!(f, "HARDCOPY"),
            Self::INFRASTRUCTURE => write!(f, "INFRASTRUCTURE"),
            Self::VIRTUALIZATION => write!(f, "VIRTUALIZATION"),
            Self::TNC => write!(f, "TNC"),
            Self::MULTI_TENANT => write!(f, "MULTI_TENANT"),
            Self::TC => write!(f, "TC"),
        }
    }
}

/// The 32-bit handle space is divided into 256 regions of equal size with 224 values in
/// each. Each of these ranges represents a handle type.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, TryFromPrimitive)]
#[repr(i8)]
pub enum TPM_HT {
    /// PCR consecutive numbers, starting at 0, that reference the PCR registers
    /// A platform-specific specification will set the minimum number of PCR and an
    /// implementation may have more.
    PCR = 0x0, // Original value: 0x00

    /// NV Index assigned by the caller
    NV_INDEX = 0x1, // Original value: 0x01

    /// HMAC Authorization Session assigned by the TPM when the session is created
    HMAC_SESSION = 0x2, // Original value: 0x02

    /// Loaded Authorization Session used only in the context of TPM2_GetCapability
    /// This type references both loaded HMAC and loaded policy authorization sessions.
    // WARNING: LOADED_SESSION has duplicate value 0x2 - using name + value pattern
    LOADED_SESSIONValue = 0x2, // Original value: 0x02

    /// Policy Authorization Session assigned by the TPM when the session is created
    POLICY_SESSION = 0x3, // Original value: 0x03

    /// Saved Authorization Session used only in the context of TPM2_GetCapability
    /// This type references saved authorization session contexts for which the TPM is
    /// maintaining tracking information.
    // WARNING: SAVED_SESSION has duplicate value 0x3 - using name + value pattern
    SAVED_SESSIONValue = 0x3, // Original value: 0x03

    /// Permanent Values assigned by this specification in Table 28
    PERMANENT = 0x40,

    /// Transient Objects assigned by the TPM when an object is loaded into transient-object
    /// memory or when a persistent object is converted to a transient object
    TRANSIENT = 0x80,

    /// Persistent Objects assigned by the TPM when a loaded transient object is made persistent
    PERSISTENT = 0x81,

    /// Attached Component handle for an Attached Component.
    AC = 0x90
}

impl fmt::Display for TPM_HT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::PCR => write!(f, "PCR"),
            Self::NV_INDEX => write!(f, "NV_INDEX"),
            Self::HMAC_SESSION => write!(f, "HMAC_SESSION"),
            Self::LOADED_SESSION => write!(f, "LOADED_SESSION"),
            Self::POLICY_SESSION => write!(f, "POLICY_SESSION"),
            Self::SAVED_SESSION => write!(f, "SAVED_SESSION"),
            Self::PERMANENT => write!(f, "PERMANENT"),
            Self::TRANSIENT => write!(f, "TRANSIENT"),
            Self::PERSISTENT => write!(f, "PERSISTENT"),
            Self::AC => write!(f, "AC"),
        }
    }
}

/// Table 28 lists the architecturally defined handles that cannot be changed. The handles
/// include authorization handles, and special handles.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, TryFromPrimitive)]
#[repr(i32)]
pub enum TPM_RH {
    FIRST = 0x40000000,

    /// Not used1
    // WARNING: SRK has duplicate value 0x40000000 - using name + value pattern
    SRKValue = 0x40000000,

    /// Handle references the Storage Primary Seed (SPS), the ownerAuth, and the ownerPolicy
    OWNER = 0x40000001,

    /// Not used1
    REVOKE = 0x40000002,

    /// Not used1
    TRANSPORT = 0x40000003,

    /// Not used1
    OPERATOR = 0x40000004,

    /// Not used1
    ADMIN = 0x40000005,

    /// Not used1
    EK = 0x40000006,

    /// A handle associated with the null hierarchy, an EmptyAuth authValue, and an Empty
    /// Policy authPolicy.
    NULL = 0x40000007,

    /// Value reserved to the TPM to indicate a handle location that has not been initialized
    /// or assigned
    UNASSIGNED = 0x40000008,

    /// Authorization value used to indicate a password authorization session
    PW = 0x40000009,

    /// References the authorization associated with the dictionary attack lockout reset
    LOCKOUT = 0x4000000A,

    /// References the Endorsement Primary Seed (EPS), endorsementAuth, and endorsementPolicy
    ENDORSEMENT = 0x4000000B,

    /// References the Platform Primary Seed (PPS), platformAuth, and platformPolicy
    PLATFORM = 0x4000000C,

    /// For phEnableNV
    PLATFORM_NV = 0x4000000D,

    /// Start of a range of authorization values that are vendor-specific. A TPM may support
    /// any of the values in this range as are needed for vendor-specific purposes.
    /// Disabled if ehEnable is CLEAR.
    /// NOTE Any includes none.
    AUTH_00 = 0x40000010,

    /// End of the range of vendor-specific authorization values.
    AUTH_FF = 0x4000010F,

    /// Start of the range of authenticated timers
    ACT_0 = 0x40000110,

    /// End of the range of authenticated timers
    ACT_F = 0x4000011F,

    /// The top of the reserved handle area
    /// This is set to allow TPM2_GetCapability() to know where to stop. It may vary as
    /// implementations add to the permanent handle area.
    // WARNING: LAST has duplicate value 0x4000011F - using name + value pattern
    LASTValue = 0x4000011F
}

impl fmt::Display for TPM_RH {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::FIRST => write!(f, "FIRST"),
            Self::SRK => write!(f, "SRK"),
            Self::OWNER => write!(f, "OWNER"),
            Self::REVOKE => write!(f, "REVOKE"),
            Self::TRANSPORT => write!(f, "TRANSPORT"),
            Self::OPERATOR => write!(f, "OPERATOR"),
            Self::ADMIN => write!(f, "ADMIN"),
            Self::EK => write!(f, "EK"),
            Self::NULL => write!(f, "NULL"),
            Self::UNASSIGNED => write!(f, "UNASSIGNED"),
            Self::PW => write!(f, "PW"),
            Self::LOCKOUT => write!(f, "LOCKOUT"),
            Self::ENDORSEMENT => write!(f, "ENDORSEMENT"),
            Self::PLATFORM => write!(f, "PLATFORM"),
            Self::PLATFORM_NV => write!(f, "PLATFORM_NV"),
            Self::AUTH_00 => write!(f, "AUTH_00"),
            Self::AUTH_FF => write!(f, "AUTH_FF"),
            Self::ACT_0 => write!(f, "ACT_0"),
            Self::ACT_F => write!(f, "ACT_F"),
            Self::LAST => write!(f, "LAST"),
        }
    }
}

/// This table lists the values of the TPM_NT field of a TPMA_NV. See Table 215 for usage.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, TryFromPrimitive)]
#[repr(i32)]
pub enum TPM_NT {
    /// Ordinary contains data that is opaque to the TPM that can only be modified using TPM2_NV_Write().
    ORDINARY = 0x0,

    /// Counter contains an 8-octet value that is to be used as a counter and can only be
    /// modified with TPM2_NV_Increment()
    COUNTER = 0x1,

    /// Bit Field contains an 8-octet value to be used as a bit field and can only be modified
    /// with TPM2_NV_SetBits().
    BITS = 0x2,

    /// Extend contains a digest-sized value used like a PCR. The Index can only be modified
    /// using TPM2_NV_Extend(). The extend will use the nameAlg of the Index.
    EXTEND = 0x4,

    /// PIN Fail - contains pinCount that increments on a PIN authorization failure and a pinLimit
    PIN_FAIL = 0x8,

    /// PIN Pass - contains pinCount that increments on a PIN authorization success and a pinLimit
    PIN_PASS = 0x9
}

impl fmt::Display for TPM_NT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::ORDINARY => write!(f, "ORDINARY"),
            Self::COUNTER => write!(f, "COUNTER"),
            Self::BITS => write!(f, "BITS"),
            Self::EXTEND => write!(f, "EXTEND"),
            Self::PIN_FAIL => write!(f, "PIN_FAIL"),
            Self::PIN_PASS => write!(f, "PIN_PASS"),
        }
    }
}

/// These constants are used in TPM2_AC_GetCapability() to indicate the first tagged value
/// returned from an attached component.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, TryFromPrimitive)]
#[repr(i32)]
pub enum TPM_AT {
    /// In a command, a non-specific request for AC information; in a response, indicates that
    /// outputData is not meaningful
    ANY = 0x0, // Original value: 0x00000000

    /// Indicates a TCG defined, device-specific error
    ERROR = 0x1, // Original value: 0x00000001

    /// Indicates the most significant 32 bits of a pairing value for the AC
    PV1 = 0x2, // Original value: 0x00000002

    /// Value added to a TPM_AT to indicate a vendor-specific tag value
    VEND = 0x80000000
}

impl fmt::Display for TPM_AT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::ANY => write!(f, "ANY"),
            Self::ERROR => write!(f, "ERROR"),
            Self::PV1 => write!(f, "PV1"),
            Self::VEND => write!(f, "VEND"),
        }
    }
}

/// These constants are the TCG-defined error values returned by an AC.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, TryFromPrimitive)]
#[repr(i32)]
pub enum TPM_AE {
    /// In a command, a non-specific request for AC information; in a response, indicates that
    /// outputData is not meaningful
    NONE = 0x0 // Original value: 0x00000000
}

impl fmt::Display for TPM_AE {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::NONE => write!(f, "NONE"),
        }
    }
}

/// These values are readable with TPM2_GetCapability(). They are the TPM_PT_PS_xxx values.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, TryFromPrimitive)]
#[repr(i32)]
pub enum PLATFORM {
    FAMILY = 0x322E3000, // Original value: TPM_SPEC::FAMILY
    LEVEL = 0x0, // Original value: TPM_SPEC::LEVEL
    VERSION = 0xA2, // Original value: TPM_SPEC::VERSION
    YEAR = 0x7E3, // Original value: TPM_SPEC::YEAR
    DAY_OF_YEAR = 0x168 // Original value: TPM_SPEC::DAY_OF_YEAR
}

impl fmt::Display for PLATFORM {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::FAMILY => write!(f, "FAMILY"),
            Self::LEVEL => write!(f, "LEVEL"),
            Self::VERSION => write!(f, "VERSION"),
            Self::YEAR => write!(f, "YEAR"),
            Self::DAY_OF_YEAR => write!(f, "DAY_OF_YEAR"),
        }
    }
}

/// This table contains a collection of values used in various parts of the reference
/// code. The values shown are illustrative.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, TryFromPrimitive)]
#[repr(i32)]
pub enum Implementation {
    /// Temporary define
    FIELD_UPGRADE_IMPLEMENTED = 0x0, // Original value: Logic::NO

    /// Selection of the library that provides the basic hashing functions.
    HASH_LIB = 0x1, // Original value: ImplementationConstants::Ossl

    /// Selection of the library that provides the low-level symmetric cryptography. Choices
    /// are determined by the vendor (See LibSupport.h for implications).
    // WARNING: SYM_LIB has duplicate value 0x1 - using name + value pattern
    SYM_LIBValue = 0x1, // Original value: ImplementationConstants::Ossl

    /// Selection of the library that provides the big number math including ECC. Choices are
    /// determined by the vendor (See LibSupport.h for implications).
    // WARNING: MATH_LIB has duplicate value 0x1 - using name + value pattern
    MATH_LIBValue = 0x1, // Original value: ImplementationConstants::Ossl

    /// The number of PCR in the TPM
    IMPLEMENTATION_PCR = 0x18, // Original value: 24
    PCR_SELECT_MAX = 0x3, // Original value: ((IMPLEMENTATION_PCR+7)/8)

    /// The number of PCR required by the relevant platform specification
    // WARNING: PLATFORM_PCR has duplicate value 0x18 - using name + value pattern
    PLATFORM_PCRValue = 0x18, // Original value: 24
    // WARNING: PCR_SELECT_MIN has duplicate value 0x3 - using name + value pattern
    PCR_SELECT_MINValue = 0x3, // Original value: ((PLATFORM_PCR + 7) / 8)

    /// The D-RTM PCR
    /// NOTE This value is not defined when the TPM does not implement D-RTM
    DRTM_PCR = 0x11, // Original value: 17

    /// The PCR that will receive the H-CRTM value at TPM2_Startup. This value should not be changed.
    // WARNING: HCRTM_PCR has duplicate value 0x0 - using name + value pattern
    HCRTM_PCRValue = 0x0, // Original value: 0

    /// The number of localities supported by the TPM
    /// This is expected to be either 5 for a PC, or 1 for just about everything else.
    NUM_LOCALITIES = 0x5, // Original value: 5

    /// The maximum number of handles in the handle area
    /// This should be produced by the Part 3 parser but is here for now.
    // WARNING: MAX_HANDLE_NUM has duplicate value 0x3 - using name + value pattern
    MAX_HANDLE_NUMValue = 0x3, // Original value: 3

    /// The number of simultaneously active sessions that are supported by the TPM implementation
    MAX_ACTIVE_SESSIONS = 0x40, // Original value: 64

    /// The number of sessions that the TPM may have in memory
    // WARNING: MAX_LOADED_SESSIONS has duplicate value 0x3 - using name + value pattern
    MAX_LOADED_SESSIONSValue = 0x3, // Original value: 3

    /// This is the current maximum value
    // WARNING: MAX_SESSION_NUM has duplicate value 0x3 - using name + value pattern
    MAX_SESSION_NUMValue = 0x3, // Original value: 3

    /// The number of simultaneously loaded objects that are supported by the TPM; this number
    /// does not include the objects that may be placed in NV memory by TPM2_EvictControl().
    // WARNING: MAX_LOADED_OBJECTS has duplicate value 0x3 - using name + value pattern
    MAX_LOADED_OBJECTSValue = 0x3, // Original value: 3

    /// The minimum number of evict objects supported by the TPM
    MIN_EVICT_OBJECTS = 0x2, // Original value: 2

    /// Number of PCR groups that have individual policies
    // WARNING: NUM_POLICY_PCR_GROUP has duplicate value 0x1 - using name + value pattern
    NUM_POLICY_PCR_GROUPValue = 0x1, // Original value: 1

    /// Number of PCR groups that have individual authorization values
    // WARNING: NUM_AUTHVALUE_PCR_GROUP has duplicate value 0x1 - using name + value pattern
    NUM_AUTHVALUE_PCR_GROUPValue = 0x1, // Original value: 1
    MAX_CONTEXT_SIZE = 0x4F0, // Original value: 1264
    MAX_DIGEST_BUFFER = 0x400, // Original value: 1024

    /// Maximum data size allowed in an NV Index
    MAX_NV_INDEX_SIZE = 0x800, // Original value: 2048

    /// Maximum data size in one NV read or write command
    // WARNING: MAX_NV_BUFFER_SIZE has duplicate value 0x400 - using name + value pattern
    MAX_NV_BUFFER_SIZEValue = 0x400, // Original value: 1024

    /// Maximum size of a capability buffer
    // WARNING: MAX_CAP_BUFFER has duplicate value 0x400 - using name + value pattern
    MAX_CAP_BUFFERValue = 0x400, // Original value: 1024

    /// Size of NV memory in octets
    NV_MEMORY_SIZE = 0x4000, // Original value: 16384

    /// The TPM will not allocate a non-counter index if it would prevent allocation of this
    /// number of indices.
    MIN_COUNTER_INDICES = 0x8, // Original value: 8
    NUM_STATIC_PCR = 0x10, // Original value: 16

    /// Number of algorithms that can be in a list
    // WARNING: MAX_ALG_LIST_SIZE has duplicate value 0x40 - using name + value pattern
    MAX_ALG_LIST_SIZEValue = 0x40, // Original value: 64

    /// Size of the Primary Seed in octets
    PRIMARY_SEED_SIZE = 0x20, // Original value: 32

    /// Context encryption algorithm
    /// Just use the root so that the macros in GpMacros.h will work correctly.
    CONTEXT_ENCRYPT_ALGORITHM = 0x6, // Original value: TPM_ALG_ID::AES

    /// The update interval expressed as a power of 2 seconds
    /// A value of 12 is 4,096 seconds (~68 minutes).
    NV_CLOCK_UPDATE_INTERVAL = 0xC, // Original value: 12

    /// Number of PCR groups that allow policy/auth
    // WARNING: NUM_POLICY_PCR has duplicate value 0x1 - using name + value pattern
    NUM_POLICY_PCRValue = 0x1, // Original value: 1

    /// Maximum size of a command
    MAX_COMMAND_SIZE = 0x1000, // Original value: 4096

    /// Maximum size of a response
    // WARNING: MAX_RESPONSE_SIZE has duplicate value 0x1000 - using name + value pattern
    MAX_RESPONSE_SIZEValue = 0x1000, // Original value: 4096

    /// Number between 1 and 32 inclusive
    // WARNING: ORDERLY_BITS has duplicate value 0x8 - using name + value pattern
    ORDERLY_BITSValue = 0x8, // Original value: 8

    /// The maximum number of octets that may be in a sealed blob; 128 is the minimum allowed value
    MAX_SYM_DATA = 0x80, // Original value: 128
    // WARNING: MAX_RNG_ENTROPY_SIZE has duplicate value 0x40 - using name + value pattern
    MAX_RNG_ENTROPY_SIZEValue = 0x40, // Original value: 64

    /// Number of bytes used for the RAM index space. If this is not large enough, it might
    /// not be possible to allocate orderly indices.
    RAM_INDEX_SPACE = 0x200, // Original value: 512

    /// 216 + 1
    RSA_DEFAULT_PUBLIC_EXPONENT = 0x10001, // Original value: 0x00010001

    /// Indicates if the TPM_PT_PCR_NO_INCREMENT group is implemented
    // WARNING: ENABLE_PCR_NO_INCREMENT has duplicate value 0x1 - using name + value pattern
    ENABLE_PCR_NO_INCREMENTValue = 0x1, // Original value: Logic::YES
    // WARNING: CRT_FORMAT_RSA has duplicate value 0x1 - using name + value pattern
    CRT_FORMAT_RSAValue = 0x1, // Original value: Logic::YES
    // WARNING: VENDOR_COMMAND_COUNT has duplicate value 0x0 - using name + value pattern
    VENDOR_COMMAND_COUNTValue = 0x0, // Original value: 0

    /// Maximum size of the vendor-specific buffer
    // WARNING: MAX_VENDOR_BUFFER_SIZE has duplicate value 0x400 - using name + value pattern
    MAX_VENDOR_BUFFER_SIZEValue = 0x400, // Original value: 1024

    /// L value for a derivation. This is the
    /// maximum number of bits allowed from an instantiation of a KDF-DRBG. This is size is OK
    /// because RSA keys are never derived keys
    MAX_DERIVATION_BITS = 0x2000, // Original value: 8192
    // WARNING: RSA_MAX_PRIME has duplicate value 0x80 - using name + value pattern
    RSA_MAX_PRIMEValue = 0x80, // Original value: (ImplementationConstants::MAX_RSA_KEY_BYTES/2)
    RSA_PRIVATE_SIZE = 0x280, // Original value: (RSA_MAX_PRIME * 5)
    SIZE_OF_X509_SERIAL_NUMBER = 0x14, // Original value: 20

    /// This is a vendor-specific value so it is in this vendor-speific table. When this is
    /// used, RSA_PRIVATE_SIZE will have been defined
    // WARNING: PRIVATE_VENDOR_SPECIFIC_BYTES has duplicate value 0x280 - using name + value pattern
    PRIVATE_VENDOR_SPECIFIC_BYTESValue = 0x280 // Original value: RSA_PRIVATE_SIZE
}

impl fmt::Display for Implementation {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::FIELD_UPGRADE_IMPLEMENTED => write!(f, "FIELD_UPGRADE_IMPLEMENTED"),
            Self::HASH_LIB => write!(f, "HASH_LIB"),
            Self::SYM_LIB => write!(f, "SYM_LIB"),
            Self::MATH_LIB => write!(f, "MATH_LIB"),
            Self::IMPLEMENTATION_PCR => write!(f, "IMPLEMENTATION_PCR"),
            Self::PCR_SELECT_MAX => write!(f, "PCR_SELECT_MAX"),
            Self::PLATFORM_PCR => write!(f, "PLATFORM_PCR"),
            Self::PCR_SELECT_MIN => write!(f, "PCR_SELECT_MIN"),
            Self::DRTM_PCR => write!(f, "DRTM_PCR"),
            Self::HCRTM_PCR => write!(f, "HCRTM_PCR"),
            Self::NUM_LOCALITIES => write!(f, "NUM_LOCALITIES"),
            Self::MAX_HANDLE_NUM => write!(f, "MAX_HANDLE_NUM"),
            Self::MAX_ACTIVE_SESSIONS => write!(f, "MAX_ACTIVE_SESSIONS"),
            Self::MAX_LOADED_SESSIONS => write!(f, "MAX_LOADED_SESSIONS"),
            Self::MAX_SESSION_NUM => write!(f, "MAX_SESSION_NUM"),
            Self::MAX_LOADED_OBJECTS => write!(f, "MAX_LOADED_OBJECTS"),
            Self::MIN_EVICT_OBJECTS => write!(f, "MIN_EVICT_OBJECTS"),
            Self::NUM_POLICY_PCR_GROUP => write!(f, "NUM_POLICY_PCR_GROUP"),
            Self::NUM_AUTHVALUE_PCR_GROUP => write!(f, "NUM_AUTHVALUE_PCR_GROUP"),
            Self::MAX_CONTEXT_SIZE => write!(f, "MAX_CONTEXT_SIZE"),
            Self::MAX_DIGEST_BUFFER => write!(f, "MAX_DIGEST_BUFFER"),
            Self::MAX_NV_INDEX_SIZE => write!(f, "MAX_NV_INDEX_SIZE"),
            Self::MAX_NV_BUFFER_SIZE => write!(f, "MAX_NV_BUFFER_SIZE"),
            Self::MAX_CAP_BUFFER => write!(f, "MAX_CAP_BUFFER"),
            Self::NV_MEMORY_SIZE => write!(f, "NV_MEMORY_SIZE"),
            Self::MIN_COUNTER_INDICES => write!(f, "MIN_COUNTER_INDICES"),
            Self::NUM_STATIC_PCR => write!(f, "NUM_STATIC_PCR"),
            Self::MAX_ALG_LIST_SIZE => write!(f, "MAX_ALG_LIST_SIZE"),
            Self::PRIMARY_SEED_SIZE => write!(f, "PRIMARY_SEED_SIZE"),
            Self::CONTEXT_ENCRYPT_ALGORITHM => write!(f, "CONTEXT_ENCRYPT_ALGORITHM"),
            Self::NV_CLOCK_UPDATE_INTERVAL => write!(f, "NV_CLOCK_UPDATE_INTERVAL"),
            Self::NUM_POLICY_PCR => write!(f, "NUM_POLICY_PCR"),
            Self::MAX_COMMAND_SIZE => write!(f, "MAX_COMMAND_SIZE"),
            Self::MAX_RESPONSE_SIZE => write!(f, "MAX_RESPONSE_SIZE"),
            Self::ORDERLY_BITS => write!(f, "ORDERLY_BITS"),
            Self::MAX_SYM_DATA => write!(f, "MAX_SYM_DATA"),
            Self::MAX_RNG_ENTROPY_SIZE => write!(f, "MAX_RNG_ENTROPY_SIZE"),
            Self::RAM_INDEX_SPACE => write!(f, "RAM_INDEX_SPACE"),
            Self::RSA_DEFAULT_PUBLIC_EXPONENT => write!(f, "RSA_DEFAULT_PUBLIC_EXPONENT"),
            Self::ENABLE_PCR_NO_INCREMENT => write!(f, "ENABLE_PCR_NO_INCREMENT"),
            Self::CRT_FORMAT_RSA => write!(f, "CRT_FORMAT_RSA"),
            Self::VENDOR_COMMAND_COUNT => write!(f, "VENDOR_COMMAND_COUNT"),
            Self::MAX_VENDOR_BUFFER_SIZE => write!(f, "MAX_VENDOR_BUFFER_SIZE"),
            Self::MAX_DERIVATION_BITS => write!(f, "MAX_DERIVATION_BITS"),
            Self::RSA_MAX_PRIME => write!(f, "RSA_MAX_PRIME"),
            Self::RSA_PRIVATE_SIZE => write!(f, "RSA_PRIVATE_SIZE"),
            Self::SIZE_OF_X509_SERIAL_NUMBER => write!(f, "SIZE_OF_X509_SERIAL_NUMBER"),
            Self::PRIVATE_VENDOR_SPECIFIC_BYTES => write!(f, "PRIVATE_VENDOR_SPECIFIC_BYTES"),
        }
    }
}

/// The definitions in Table 29 are used to define many of the interface data types.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, TryFromPrimitive)]
#[repr(i32)]
pub enum TPM_HC {
    /// To mask off the HR
    HR_HANDLE_MASK = 0xFFFFFF, // Original value: 0x00FFFFFF

    /// To mask off the variable part
    HR_RANGE_MASK = 0xFF000000,
    HR_SHIFT = 0x18, // Original value: 24
    HR_PCR = 0x0, // Original value: (TPM_HT::PCR  <<  HR_SHIFT)
    HR_HMAC_SESSION = 0x2000000, // Original value: (TPM_HT::HMAC_SESSION  <<  HR_SHIFT)
    HR_POLICY_SESSION = 0x3000000, // Original value: (TPM_HT::POLICY_SESSION  <<  HR_SHIFT)
    HR_TRANSIENT = 0x80000000, // Original value: (TPM_HT::TRANSIENT  <<  HR_SHIFT)
    HR_PERSISTENT = 0x81000000, // Original value: (TPM_HT::PERSISTENT  <<  HR_SHIFT)
    HR_NV_INDEX = 0x1000000, // Original value: (TPM_HT::NV_INDEX  <<  HR_SHIFT)
    HR_PERMANENT = 0x40000000, // Original value: (TPM_HT::PERMANENT  <<  HR_SHIFT)

    /// First PCR
    // WARNING: PCR_FIRST has duplicate value 0x0 - using name + value pattern
    PCR_FIRSTValue = 0x0, // Original value: (HR_PCR + 0)

    /// Last PCR
    PCR_LAST = 0x17, // Original value: (PCR_FIRST + Implementation::IMPLEMENTATION_PCR-1)

    /// First HMAC session
    // WARNING: HMAC_SESSION_FIRST has duplicate value 0x2000000 - using name + value pattern
    HMAC_SESSION_FIRSTValue = 0x2000000, // Original value: (HR_HMAC_SESSION + 0)

    /// Last HMAC session
    HMAC_SESSION_LAST = 0x200003F, // Original value: (HMAC_SESSION_FIRST+Implementation::MAX_ACTIVE_SESSIONS-1)

    /// Used in GetCapability
    // WARNING: LOADED_SESSION_FIRST has duplicate value 0x2000000 - using name + value pattern
    LOADED_SESSION_FIRSTValue = 0x2000000, // Original value: HMAC_SESSION_FIRST

    /// Used in GetCapability
    // WARNING: LOADED_SESSION_LAST has duplicate value 0x200003F - using name + value pattern
    LOADED_SESSION_LASTValue = 0x200003F, // Original value: HMAC_SESSION_LAST

    /// First policy session
    // WARNING: POLICY_SESSION_FIRST has duplicate value 0x3000000 - using name + value pattern
    POLICY_SESSION_FIRSTValue = 0x3000000, // Original value: (HR_POLICY_SESSION + 0)

    /// Last policy session
    POLICY_SESSION_LAST = 0x300003F, // Original value: (POLICY_SESSION_FIRST + Implementation::MAX_ACTIVE_SESSIONS-1)

    /// First transient object
    // WARNING: TRANSIENT_FIRST has duplicate value 0x80000000 - using name + value pattern
    TRANSIENT_FIRSTValue = 0x80000000, // Original value: (HR_TRANSIENT + 0)

    /// Used in GetCapability
    // WARNING: ACTIVE_SESSION_FIRST has duplicate value 0x3000000 - using name + value pattern
    ACTIVE_SESSION_FIRSTValue = 0x3000000, // Original value: POLICY_SESSION_FIRST

    /// Used in GetCapability
    // WARNING: ACTIVE_SESSION_LAST has duplicate value 0x300003F - using name + value pattern
    ACTIVE_SESSION_LASTValue = 0x300003F, // Original value: POLICY_SESSION_LAST

    /// Last transient object
    TRANSIENT_LAST = 0x80000002, // Original value: (TRANSIENT_FIRST+Implementation::MAX_LOADED_OBJECTS-1)

    /// First persistent object
    // WARNING: PERSISTENT_FIRST has duplicate value 0x81000000 - using name + value pattern
    PERSISTENT_FIRSTValue = 0x81000000, // Original value: (HR_PERSISTENT + 0)

    /// Last persistent object
    PERSISTENT_LAST = 0x81FFFFFF, // Original value: (PERSISTENT_FIRST + 0x00FFFFFF)

    /// First platform persistent object
    PLATFORM_PERSISTENT = 0x81800000, // Original value: (PERSISTENT_FIRST + 0x00800000)

    /// First allowed NV Index
    // WARNING: NV_INDEX_FIRST has duplicate value 0x1000000 - using name + value pattern
    NV_INDEX_FIRSTValue = 0x1000000, // Original value: (HR_NV_INDEX + 0)

    /// Last allowed NV Index
    NV_INDEX_LAST = 0x1FFFFFF, // Original value: (NV_INDEX_FIRST + 0x00FFFFFF)
    // WARNING: PERMANENT_FIRST has duplicate value 0x40000000 - using name + value pattern
    PERMANENT_FIRSTValue = 0x40000000, // Original value: TPM_RH::FIRST
    PERMANENT_LAST = 0x4000011F, // Original value: TPM_RH::LAST

    /// AC aliased NV Index
    HR_NV_AC = 0x1D00000, // Original value: ((TPM_HT::NV_INDEX  <<  HR_SHIFT) + 0xD00000)

    /// First NV Index aliased to Attached Component
    // WARNING: NV_AC_FIRST has duplicate value 0x1D00000 - using name + value pattern
    NV_AC_FIRSTValue = 0x1D00000, // Original value: (HR_NV_AC + 0)

    /// Last NV Index aliased to Attached Component
    NV_AC_LAST = 0x1D0FFFF, // Original value: (HR_NV_AC + 0x0000FFFF)

    /// AC Handle
    HR_AC = 0x90000000, // Original value: (TPM_HT::AC  <<  HR_SHIFT)

    /// First Attached Component
    // WARNING: AC_FIRST has duplicate value 0x90000000 - using name + value pattern
    AC_FIRSTValue = 0x90000000, // Original value: (HR_AC + 0)

    /// Last Attached Component
    AC_LAST = 0x9000FFFF // Original value: (HR_AC + 0x0000FFFF)
}

impl fmt::Display for TPM_HC {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::HR_HANDLE_MASK => write!(f, "HR_HANDLE_MASK"),
            Self::HR_RANGE_MASK => write!(f, "HR_RANGE_MASK"),
            Self::HR_SHIFT => write!(f, "HR_SHIFT"),
            Self::HR_PCR => write!(f, "HR_PCR"),
            Self::HR_HMAC_SESSION => write!(f, "HR_HMAC_SESSION"),
            Self::HR_POLICY_SESSION => write!(f, "HR_POLICY_SESSION"),
            Self::HR_TRANSIENT => write!(f, "HR_TRANSIENT"),
            Self::HR_PERSISTENT => write!(f, "HR_PERSISTENT"),
            Self::HR_NV_INDEX => write!(f, "HR_NV_INDEX"),
            Self::HR_PERMANENT => write!(f, "HR_PERMANENT"),
            Self::PCR_FIRST => write!(f, "PCR_FIRST"),
            Self::PCR_LAST => write!(f, "PCR_LAST"),
            Self::HMAC_SESSION_FIRST => write!(f, "HMAC_SESSION_FIRST"),
            Self::HMAC_SESSION_LAST => write!(f, "HMAC_SESSION_LAST"),
            Self::LOADED_SESSION_FIRST => write!(f, "LOADED_SESSION_FIRST"),
            Self::LOADED_SESSION_LAST => write!(f, "LOADED_SESSION_LAST"),
            Self::POLICY_SESSION_FIRST => write!(f, "POLICY_SESSION_FIRST"),
            Self::POLICY_SESSION_LAST => write!(f, "POLICY_SESSION_LAST"),
            Self::TRANSIENT_FIRST => write!(f, "TRANSIENT_FIRST"),
            Self::ACTIVE_SESSION_FIRST => write!(f, "ACTIVE_SESSION_FIRST"),
            Self::ACTIVE_SESSION_LAST => write!(f, "ACTIVE_SESSION_LAST"),
            Self::TRANSIENT_LAST => write!(f, "TRANSIENT_LAST"),
            Self::PERSISTENT_FIRST => write!(f, "PERSISTENT_FIRST"),
            Self::PERSISTENT_LAST => write!(f, "PERSISTENT_LAST"),
            Self::PLATFORM_PERSISTENT => write!(f, "PLATFORM_PERSISTENT"),
            Self::NV_INDEX_FIRST => write!(f, "NV_INDEX_FIRST"),
            Self::NV_INDEX_LAST => write!(f, "NV_INDEX_LAST"),
            Self::PERMANENT_FIRST => write!(f, "PERMANENT_FIRST"),
            Self::PERMANENT_LAST => write!(f, "PERMANENT_LAST"),
            Self::HR_NV_AC => write!(f, "HR_NV_AC"),
            Self::NV_AC_FIRST => write!(f, "NV_AC_FIRST"),
            Self::NV_AC_LAST => write!(f, "NV_AC_LAST"),
            Self::HR_AC => write!(f, "HR_AC"),
            Self::AC_FIRST => write!(f, "AC_FIRST"),
            Self::AC_LAST => write!(f, "AC_LAST"),
        }
    }
}

/// This structure defines the attributes of an algorithm.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, TryFromPrimitive)]
#[repr(i32)]
pub enum TPMA_ALGORITHM {
    /// SET (1): an asymmetric algorithm with public and private portions
    /// CLEAR (0): not an asymmetric algorithm
    asymmetric = 0x1,

    /// SET (1): a symmetric block cipher
    /// CLEAR (0): not a symmetric block cipher
    symmetric = 0x2,

    /// SET (1): a hash algorithm
    /// CLEAR (0): not a hash algorithm
    hash = 0x4,

    /// SET (1): an algorithm that may be used as an object type
    /// CLEAR (0): an algorithm that is not used as an object type
    object = 0x8,

    /// SET (1): a signing algorithm. The setting of asymmetric, symmetric, and hash will
    /// indicate the type of signing algorithm.
    /// CLEAR (0): not a signing algorithm
    signing = 0x100,

    /// SET (1): an encryption/decryption algorithm. The setting of asymmetric, symmetric, and
    /// hash will indicate the type of encryption/decryption algorithm.
    /// CLEAR (0): not an encryption/decryption algorithm
    encrypting = 0x200,

    /// SET (1): a method such as a key derivative function (KDF)
    /// CLEAR (0): not a method
    method = 0x400
}

impl fmt::Display for TPMA_ALGORITHM {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::asymmetric => write!(f, "asymmetric"),
            Self::symmetric => write!(f, "symmetric"),
            Self::hash => write!(f, "hash"),
            Self::object => write!(f, "object"),
            Self::signing => write!(f, "signing"),
            Self::encrypting => write!(f, "encrypting"),
            Self::method => write!(f, "method"),
        }
    }
}

impl std::ops::BitOr for TPMA_ALGORITHM {
type Output = Self;
    fn bitor(self, rhs: Self) -> Self::Output {
    unsafe { std::mem::transmute(self as u32 | rhs as u32) }
    }

}

impl From<u32> for TPMA_ALGORITHM {
fn from(value: u32) -> Self {
    unsafe { std::mem::transmute(value) }
    }

}

/// This attribute structure indicates an objects use, its authorization types, and its
/// relationship to other objects.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, TryFromPrimitive)]
#[repr(i32)]
pub enum TPMA_OBJECT {
    /// SET (1): The hierarchy of the object, as indicated by its Qualified Name, may not change.
    /// CLEAR (0): The hierarchy of the object may change as a result of this object or an
    /// ancestor key being duplicated for use in another hierarchy.
    /// NOTE fixedTPM does not indicate that key material resides on a single TPM (see
    /// sensitiveDataOrigin).
    fixedTPM = 0x2,

    /// SET (1): Previously saved contexts of this object may not be loaded after Startup(CLEAR).
    /// CLEAR (0): Saved contexts of this object may be used after a Shutdown(STATE) and
    /// subsequent Startup().
    stClear = 0x4,

    /// SET (1): The parent of the object may not change.
    /// CLEAR (0): The parent of the object may change as the result of a TPM2_Duplicate() of
    /// the object.
    fixedParent = 0x10,

    /// SET (1): Indicates that, when the object was created with TPM2_Create() or
    /// TPM2_CreatePrimary(), the TPM generated all of the sensitive data other than the authValue.
    /// CLEAR (0): A portion of the sensitive data, other than the authValue, was provided by
    /// the caller.
    sensitiveDataOrigin = 0x20,

    /// SET (1): Approval of USER role actions with this object may be with an HMAC session or
    /// with a password using the authValue of the object or a policy session.
    /// CLEAR (0): Approval of USER role actions with this object may only be done with a
    /// policy session.
    userWithAuth = 0x40,

    /// SET (1): Approval of ADMIN role actions with this object may only be done with a
    /// policy session.
    /// CLEAR (0): Approval of ADMIN role actions with this object may be with an HMAC session
    /// or with a password using the authValue of the object or a policy session.
    adminWithPolicy = 0x80,

    /// SET (1): The object is not subject to dictionary attack protections.
    /// CLEAR (0): The object is subject to dictionary attack protections.
    noDA = 0x400,

    /// SET (1): If the object is duplicated, then symmetricAlg shall not be TPM_ALG_NULL and
    /// newParentHandle shall not be TPM_RH_NULL.
    /// CLEAR (0): The object may be duplicated without an inner wrapper on the private
    /// portion of the object and the new parent may be TPM_RH_NULL.
    encryptedDuplication = 0x800,

    /// SET (1): Key usage is restricted to manipulate structures of known format; the parent
    /// of this key shall have restricted SET.
    /// CLEAR (0): Key usage is not restricted to use on special formats.
    restricted = 0x10000,

    /// SET (1): The private portion of the key may be used to decrypt.
    /// CLEAR (0): The private portion of the key may not be used to decrypt.
    decrypt = 0x20000,

    /// SET (1): For a symmetric cipher object, the private portion of the key may be used to
    /// encrypt. For other objects, the private portion of the key may be used to sign.
    /// CLEAR (0): The private portion of the key may not be used to sign or encrypt.
    sign = 0x40000,

    /// Alias to the sign value.
    // WARNING: encrypt has duplicate value 0x40000 - using name + value pattern
    encryptValue = 0x40000,

    /// SET (1): An asymmetric key that may not be used to sign with TPM2_Sign()
    /// CLEAR (0): A key that may be used with TPM2_Sign() if sign is SET
    /// NOTE: This attribute only has significance if sign is SET.
    x509sign = 0x80000
}

impl fmt::Display for TPMA_OBJECT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::fixedTPM => write!(f, "fixedTPM"),
            Self::stClear => write!(f, "stClear"),
            Self::fixedParent => write!(f, "fixedParent"),
            Self::sensitiveDataOrigin => write!(f, "sensitiveDataOrigin"),
            Self::userWithAuth => write!(f, "userWithAuth"),
            Self::adminWithPolicy => write!(f, "adminWithPolicy"),
            Self::noDA => write!(f, "noDA"),
            Self::encryptedDuplication => write!(f, "encryptedDuplication"),
            Self::restricted => write!(f, "restricted"),
            Self::decrypt => write!(f, "decrypt"),
            Self::sign => write!(f, "sign"),
            Self::encrypt => write!(f, "encrypt"),
            Self::x509sign => write!(f, "x509sign"),
        }
    }
}

impl std::ops::BitOr for TPMA_OBJECT {
type Output = Self;
    fn bitor(self, rhs: Self) -> Self::Output {
    unsafe { std::mem::transmute(self as u32 | rhs as u32) }
    }

}

impl From<u32> for TPMA_OBJECT {
fn from(value: u32) -> Self {
    unsafe { std::mem::transmute(value) }
    }

}

/// This octet in each session is used to identify the session type, indicate its
/// relationship to any handles in the command, and indicate its use in parameter encryption.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, TryFromPrimitive)]
#[repr(i8)]
pub enum TPMA_SESSION {
    /// SET (1): In a command, this setting indicates that the session is to remain active
    /// after successful completion of the command. In a response, it indicates that the
    /// session is still active. If SET in the command, this attribute shall be SET in the response.
    /// CLEAR (0): In a command, this setting indicates that the TPM should close the session
    /// and flush any related context when the command completes successfully. In a response,
    /// it indicates that the session is closed and the context is no longer active.
    /// This attribute has no meaning for a password authorization and the TPM will allow any
    /// setting of the attribute in the command and SET the attribute in the response.
    /// This attribute will only be CLEAR in one response for a logical session. If the
    /// attribute is CLEAR, the context associated with the session is no longer in use and
    /// the space is available. A session created after another session is ended may have the
    /// same handle but logically is not the same session.
    /// This attribute has no effect if the command does not complete successfully.
    continueSession = 0x1,

    /// SET (1): In a command, this setting indicates that the command should only be executed
    /// if the session is exclusive at the start of the command. In a response, it indicates
    /// that the session is exclusive. This setting is only allowed if the audit attribute is
    /// SET (TPM_RC_ATTRIBUTES).
    /// CLEAR (0): In a command, indicates that the session need not be exclusive at the start
    /// of the command. In a response, indicates that the session is not exclusive.
    auditExclusive = 0x2,

    /// SET (1): In a command, this setting indicates that the audit digest of the session
    /// should be initialized and the exclusive status of the session SET. This setting is
    /// only allowed if the audit attribute is SET (TPM_RC_ATTRIBUTES).
    /// CLEAR (0): In a command, indicates that the audit digest should not be initialized.
    /// This bit is always CLEAR in a response.
    auditReset = 0x4,

    /// SET (1): In a command, this setting indicates that the first parameter in the command
    /// is symmetrically encrypted using the parameter encryption scheme described in TPM 2.0
    /// Part 1. The TPM will decrypt the parameter after performing any HMAC computations and
    /// before unmarshaling the parameter. In a response, the attribute is copied from the
    /// request but has no effect on the response.
    /// CLEAR (0): Session not used for encryption.
    /// For a password authorization, this attribute will be CLEAR in both the command and response.
    /// This attribute may be SET in a session that is not associated with a command handle.
    /// Such a session is provided for purposes of encrypting a parameter and not for authorization.
    /// This attribute may be SET in combination with any other session attributes.
    decrypt = 0x20,

    /// SET (1): In a command, this setting indicates that the TPM should use this session to
    /// encrypt the first parameter in the response. In a response, it indicates that the
    /// attribute was set in the command and that the TPM used the session to encrypt the
    /// first parameter in the response using the parameter encryption scheme described in TPM
    /// 2.0 Part 1.
    /// CLEAR (0): Session not used for encryption.
    /// For a password authorization, this attribute will be CLEAR in both the command and response.
    /// This attribute may be SET in a session that is not associated with a command handle.
    /// Such a session is provided for purposes of encrypting a parameter and not for authorization.
    encrypt = 0x40,

    /// SET (1): In a command or response, this setting indicates that the session is for
    /// audit and that auditExclusive and auditReset have meaning. This session may also be
    /// used for authorization, encryption, or decryption. The encrypted and encrypt fields
    /// may be SET or CLEAR.
    /// CLEAR (0): Session is not used for audit.
    /// If SET in the command, then this attribute will be SET in the response.
    audit = 0x80
}

impl fmt::Display for TPMA_SESSION {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::continueSession => write!(f, "continueSession"),
            Self::auditExclusive => write!(f, "auditExclusive"),
            Self::auditReset => write!(f, "auditReset"),
            Self::decrypt => write!(f, "decrypt"),
            Self::encrypt => write!(f, "encrypt"),
            Self::audit => write!(f, "audit"),
        }
    }
}

impl std::ops::BitOr for TPMA_SESSION {
type Output = Self;
    fn bitor(self, rhs: Self) -> Self::Output {
    unsafe { std::mem::transmute(self as u8 | rhs as u8) }
    }

}

impl From<u8> for TPMA_SESSION {
fn from(value: u8) -> Self {
    unsafe { std::mem::transmute(value) }
    }

}

/// In a TPMS_CREATION_DATA structure, this structure is used to indicate the locality of
/// the command that created the object. No more than one of the locality attributes shall
/// be set in the creation data.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, TryFromPrimitive)]
#[repr(i8)]
pub enum TPMA_LOCALITY {
    LOC_ZERO = 0x1,
    LOC_ONE = 0x2,
    LOC_TWO = 0x4,
    LOC_THREE = 0x8,
    LOC_FOUR = 0x10,

    /// If any of these bits is set, an extended locality is indicated
    Extended_BIT_MASK = 0xE0,
    Extended_BIT_OFFSET = 0x5, // Original value: 5
    Extended_BIT_LENGTH = 0x3 // Original value: 3
}

impl fmt::Display for TPMA_LOCALITY {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::LOC_ZERO => write!(f, "LOC_ZERO"),
            Self::LOC_ONE => write!(f, "LOC_ONE"),
            Self::LOC_TWO => write!(f, "LOC_TWO"),
            Self::LOC_THREE => write!(f, "LOC_THREE"),
            Self::LOC_FOUR => write!(f, "LOC_FOUR"),
            Self::Extended_BIT_MASK => write!(f, "Extended_BIT_MASK"),
            Self::Extended_BIT_OFFSET => write!(f, "Extended_BIT_OFFSET"),
            Self::Extended_BIT_LENGTH => write!(f, "Extended_BIT_LENGTH"),
        }
    }
}

impl std::ops::BitOr for TPMA_LOCALITY {
type Output = Self;
    fn bitor(self, rhs: Self) -> Self::Output {
    unsafe { std::mem::transmute(self as u8 | rhs as u8) }
    }

}

impl From<u8> for TPMA_LOCALITY {
fn from(value: u8) -> Self {
    unsafe { std::mem::transmute(value) }
    }

}

/// The attributes in this structure are persistent and are not changed as a result of
/// _TPM_Init or any TPM2_Startup(). Some of the attributes in this structure may change
/// as the result of specific Protected Capabilities. This structure may be read using
/// TPM2_GetCapability(capability = TPM_CAP_TPM_PROPERTIES, property = TPM_PT_PERMANENT).
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, TryFromPrimitive)]
#[repr(i32)]
pub enum TPMA_PERMANENT {
    /// SET (1): TPM2_HierarchyChangeAuth() with ownerAuth has been executed since the last TPM2_Clear().
    /// CLEAR (0): ownerAuth has not been changed since TPM2_Clear().
    ownerAuthSet = 0x1,

    /// SET (1): TPM2_HierarchyChangeAuth() with endorsementAuth has been executed since the
    /// last TPM2_Clear().
    /// CLEAR (0): endorsementAuth has not been changed since TPM2_Clear().
    endorsementAuthSet = 0x2,

    /// SET (1): TPM2_HierarchyChangeAuth() with lockoutAuth has been executed since the last
    /// TPM2_Clear().
    /// CLEAR (0): lockoutAuth has not been changed since TPM2_Clear().
    lockoutAuthSet = 0x4,

    /// SET (1): TPM2_Clear() is disabled.
    /// CLEAR (0): TPM2_Clear() is enabled.
    /// NOTE See TPM2_ClearControl in TPM 2.0 Part 3 for details on changing this attribute.
    disableClear = 0x100,

    /// SET (1): The TPM is in lockout, when failedTries is equal to maxTries.
    inLockout = 0x200,

    /// SET (1): The EPS was created by the TPM.
    /// CLEAR (0): The EPS was created outside of the TPM using a manufacturer-specific process.
    tpmGeneratedEPS = 0x400
}

impl fmt::Display for TPMA_PERMANENT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::ownerAuthSet => write!(f, "ownerAuthSet"),
            Self::endorsementAuthSet => write!(f, "endorsementAuthSet"),
            Self::lockoutAuthSet => write!(f, "lockoutAuthSet"),
            Self::disableClear => write!(f, "disableClear"),
            Self::inLockout => write!(f, "inLockout"),
            Self::tpmGeneratedEPS => write!(f, "tpmGeneratedEPS"),
        }
    }
}

impl std::ops::BitOr for TPMA_PERMANENT {
type Output = Self;
    fn bitor(self, rhs: Self) -> Self::Output {
    unsafe { std::mem::transmute(self as u32 | rhs as u32) }
    }

}

impl From<u32> for TPMA_PERMANENT {
fn from(value: u32) -> Self {
    unsafe { std::mem::transmute(value) }
    }

}

/// This structure may be read using TPM2_GetCapability(capability =
/// TPM_CAP_TPM_PROPERTIES, property = TPM_PT_STARTUP_CLEAR).
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, TryFromPrimitive)]
#[repr(i32)]
pub enum TPMA_STARTUP_CLEAR {
    /// SET (1): The platform hierarchy is enabled and platformAuth or platformPolicy may be
    /// used for authorization.
    /// CLEAR (0): platformAuth and platformPolicy may not be used for authorizations, and
    /// objects in the platform hierarchy, including persistent objects, cannot be used.
    /// NOTE See TPM2_HierarchyControl in TPM 2.0 Part 3 for details on changing this attribute.
    phEnable = 0x1,

    /// SET (1): The Storage hierarchy is enabled and ownerAuth or ownerPolicy may be used for
    /// authorization. NV indices defined using owner authorization are accessible.
    /// CLEAR (0): ownerAuth and ownerPolicy may not be used for authorizations, and objects
    /// in the Storage hierarchy, persistent objects, and NV indices defined using owner
    /// authorization cannot be used.
    /// NOTE See TPM2_HierarchyControl in TPM 2.0 Part 3 for details on changing this attribute.
    shEnable = 0x2,

    /// SET (1): The EPS hierarchy is enabled and Endorsement Authorization may be used to
    /// authorize commands.
    /// CLEAR (0): Endorsement Authorization may not be used for authorizations, and objects
    /// in the endorsement hierarchy, including persistent objects, cannot be used.
    /// NOTE See TPM2_HierarchyControl in TPM 2.0 Part 3 for details on changing this attribute.
    ehEnable = 0x4,

    /// SET (1): NV indices that have TPMA_NV_PLATFORMCREATE SET may be read or written. The
    /// platform can create define and undefine indices.
    /// CLEAR (0): NV indices that have TPMA_NV_PLATFORMCREATE SET may not be read or written
    /// (TPM_RC_HANDLE). The platform cannot define (TPM_RC_HIERARCHY) or undefined
    /// (TPM_RC_HANDLE) indices.
    /// NOTE See TPM2_HierarchyControl in TPM 2.0 Part 3 for details on changing this attribute.
    /// NOTE
    /// read refers to these commands: TPM2_NV_Read, TPM2_NV_ReadPublic, TPM_NV_Certify, TPM2_PolicyNV
    /// write refers to these commands: TPM2_NV_Write, TPM2_NV_Increment, TPM2_NV_Extend, TPM2_NV_SetBits
    /// NOTE The TPM must query the index TPMA_NV_PLATFORMCREATE attribute to determine
    /// whether phEnableNV is applicable. Since the TPM will return TPM_RC_HANDLE if the index
    /// does not exist, it also returns this error code if the index is disabled. Otherwise,
    /// the TPM would leak the existence of an index even when disabled.
    phEnableNV = 0x8,

    /// SET (1): The TPM received a TPM2_Shutdown() and a matching TPM2_Startup().
    /// CLEAR (0): TPM2_Startup(TPM_SU_CLEAR) was not preceded by a TPM2_Shutdown() of any type.
    /// NOTE A shutdown is orderly if the TPM receives a TPM2_Shutdown() of any type followed
    /// by a TPM2_Startup() of any type. However, the TPM will return an error if
    /// TPM2_Startup(TPM_SU_STATE) was not preceded by TPM2_Shutdown(TPM_SU_STATE).
    orderly = 0xFFFFFFFF80000000
}

impl fmt::Display for TPMA_STARTUP_CLEAR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::phEnable => write!(f, "phEnable"),
            Self::shEnable => write!(f, "shEnable"),
            Self::ehEnable => write!(f, "ehEnable"),
            Self::phEnableNV => write!(f, "phEnableNV"),
            Self::orderly => write!(f, "orderly"),
        }
    }
}

impl std::ops::BitOr for TPMA_STARTUP_CLEAR {
type Output = Self;
    fn bitor(self, rhs: Self) -> Self::Output {
    unsafe { std::mem::transmute(self as u32 | rhs as u32) }
    }

}

impl From<u32> for TPMA_STARTUP_CLEAR {
fn from(value: u32) -> Self {
    unsafe { std::mem::transmute(value) }
    }

}

/// This structure of this attribute is used to report the memory management method used
/// by the TPM for transient objects and authorization sessions. This structure may be
/// read using TPM2_GetCapability(capability = TPM_CAP_TPM_PROPERTIES, property = TPM_PT_MEMORY).
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, TryFromPrimitive)]
#[repr(i32)]
pub enum TPMA_MEMORY {
    /// SET (1): indicates that the RAM memory used for authorization session contexts is
    /// shared with the memory used for transient objects
    /// CLEAR (0): indicates that the memory used for authorization sessions is not shared
    /// with memory used for transient objects
    sharedRAM = 0x1,

    /// SET (1): indicates that the NV memory used for persistent objects is shared with the
    /// NV memory used for NV Index values
    /// CLEAR (0): indicates that the persistent objects and NV Index values are allocated
    /// from separate sections of NV
    sharedNV = 0x2,

    /// SET (1): indicates that the TPM copies persistent objects to a transient-object slot
    /// in RAM when the persistent object is referenced in a command. The TRM is required to
    /// make sure that an object slot is available.
    /// CLEAR (0): indicates that the TPM does not use transient-object slots when persistent
    /// objects are referenced
    objectCopiedToRam = 0x4
}

impl fmt::Display for TPMA_MEMORY {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::sharedRAM => write!(f, "sharedRAM"),
            Self::sharedNV => write!(f, "sharedNV"),
            Self::objectCopiedToRam => write!(f, "objectCopiedToRam"),
        }
    }
}

impl std::ops::BitOr for TPMA_MEMORY {
type Output = Self;
    fn bitor(self, rhs: Self) -> Self::Output {
    unsafe { std::mem::transmute(self as u32 | rhs as u32) }
    }

}

impl From<u32> for TPMA_MEMORY {
fn from(value: u32) -> Self {
    unsafe { std::mem::transmute(value) }
    }

}

/// This structure defines the attributes of a command from a context management
/// perspective. The fields of the structure indicate to the TPM Resource Manager (TRM)
/// the number of resources required by a command and how the command affects the TPMs resources.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, TryFromPrimitive)]
#[repr(i32)]
pub enum TPMA_CC {
    /// Indicates the command being selected
    commandIndex_BIT_MASK = 0xFFFF,
    commandIndex_BIT_OFFSET = 0x0, // Original value: 0
    commandIndex_BIT_LENGTH = 0x10, // Original value: 16

    /// SET (1): indicates that the command may write to NV
    /// CLEAR (0): indicates that the command does not write to NV
    nv = 0x400000,

    /// SET (1): This command could flush any number of loaded contexts.
    /// CLEAR (0): no additional changes other than indicated by the flushed attribute
    extensive = 0x800000,

    /// SET (1): The context associated with any transient handle in the command will be
    /// flushed when this command completes.
    /// CLEAR (0): No context is flushed as a side effect of this command.
    flushed = 0x1000000,

    /// Indicates the number of the handles in the handle area for this command
    cHandles_BIT_MASK = 0xE000000,
    cHandles_BIT_OFFSET = 0x19, // Original value: 25
    cHandles_BIT_LENGTH = 0x3, // Original value: 3

    /// SET (1): indicates the presence of the handle area in the response
    rHandle = 0x10000000,

    /// SET (1): indicates that the command is vendor-specific
    /// CLEAR (0): indicates that the command is defined in a version of this specification
    V = 0x20000000,

    /// Allocated for software; shall be zero
    Res_BIT_MASK = 0xFFFFFFFFC0000000,
    Res_BIT_OFFSET = 0x1E, // Original value: 30
    Res_BIT_LENGTH = 0x2 // Original value: 2
}

impl fmt::Display for TPMA_CC {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::commandIndex_BIT_MASK => write!(f, "commandIndex_BIT_MASK"),
            Self::commandIndex_BIT_OFFSET => write!(f, "commandIndex_BIT_OFFSET"),
            Self::commandIndex_BIT_LENGTH => write!(f, "commandIndex_BIT_LENGTH"),
            Self::nv => write!(f, "nv"),
            Self::extensive => write!(f, "extensive"),
            Self::flushed => write!(f, "flushed"),
            Self::cHandles_BIT_MASK => write!(f, "cHandles_BIT_MASK"),
            Self::cHandles_BIT_OFFSET => write!(f, "cHandles_BIT_OFFSET"),
            Self::cHandles_BIT_LENGTH => write!(f, "cHandles_BIT_LENGTH"),
            Self::rHandle => write!(f, "rHandle"),
            Self::V => write!(f, "V"),
            Self::Res_BIT_MASK => write!(f, "Res_BIT_MASK"),
            Self::Res_BIT_OFFSET => write!(f, "Res_BIT_OFFSET"),
            Self::Res_BIT_LENGTH => write!(f, "Res_BIT_LENGTH"),
        }
    }
}

impl std::ops::BitOr for TPMA_CC {
type Output = Self;
    fn bitor(self, rhs: Self) -> Self::Output {
    unsafe { std::mem::transmute(self as u32 | rhs as u32) }
    }

}

impl From<u32> for TPMA_CC {
fn from(value: u32) -> Self {
    unsafe { std::mem::transmute(value) }
    }

}

/// This structure of this attribute is used to report that the TPM is designed for these
/// modes. This structure may be read using TPM2_GetCapability(capability =
/// TPM_CAP_TPM_PROPERTIES, property = TPM_PT_MODES).
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, TryFromPrimitive)]
#[repr(i32)]
pub enum TPMA_MODES {
    /// SET (1): indicates that the TPM is designed to comply with all of the FIPS 140-2
    /// requirements at Level 1 or higher.
    FIPS_140_2 = 0x1
}

impl fmt::Display for TPMA_MODES {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::FIPS_140_2 => write!(f, "FIPS_140_2"),
        }
    }
}

impl std::ops::BitOr for TPMA_MODES {
type Output = Self;
    fn bitor(self, rhs: Self) -> Self::Output {
    unsafe { std::mem::transmute(self as u32 | rhs as u32) }
    }

}

impl From<u32> for TPMA_MODES {
fn from(value: u32) -> Self {
    unsafe { std::mem::transmute(value) }
    }

}

/// These attributes are as specified in clause 4.2.1.3. of RFC 5280 Internet X.509 Public
/// Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile. For
/// TPM2_CertifyX509, when a caller provides a DER encoded Key Usage in
/// partialCertificate, the TPM will validate that the key to be certified meets the
/// requirements of Key Usage.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, TryFromPrimitive)]
#[repr(i32)]
pub enum TPMA_X509_KEY_USAGE {
    /// Attributes.Decrypt SET
    decipherOnly = 0x800000,

    /// Attributes.Decrypt SET
    encipherOnly = 0x1000000,

    /// Attributes.sign SET
    cRLSign = 0x2000000,

    /// Attributes.sign SET
    keyCertSign = 0x4000000,

    /// Attributes.Decrypt SET
    keyAgreement = 0x8000000,

    /// Attributes.Decrypt SET
    dataEncipherment = 0x10000000,

    /// Asymmetric key with decrypt and restricted SET key has the attributes of a parent key
    keyEncipherment = 0x20000000,

    /// FixedTPM SET in Subject Key (objectHandle)
    nonrepudiation = 0x40000000,

    /// Alias to the nonrepudiation value.
    // WARNING: contentCommitment has duplicate value 0x40000000 - using name + value pattern
    contentCommitmentValue = 0x40000000,

    /// Sign SET in Subject Key (objectHandle)
    digitalSignature = 0xFFFFFFFF80000000
}

impl fmt::Display for TPMA_X509_KEY_USAGE {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::decipherOnly => write!(f, "decipherOnly"),
            Self::encipherOnly => write!(f, "encipherOnly"),
            Self::cRLSign => write!(f, "cRLSign"),
            Self::keyCertSign => write!(f, "keyCertSign"),
            Self::keyAgreement => write!(f, "keyAgreement"),
            Self::dataEncipherment => write!(f, "dataEncipherment"),
            Self::keyEncipherment => write!(f, "keyEncipherment"),
            Self::nonrepudiation => write!(f, "nonrepudiation"),
            Self::contentCommitment => write!(f, "contentCommitment"),
            Self::digitalSignature => write!(f, "digitalSignature"),
        }
    }
}

impl std::ops::BitOr for TPMA_X509_KEY_USAGE {
type Output = Self;
    fn bitor(self, rhs: Self) -> Self::Output {
    unsafe { std::mem::transmute(self as u32 | rhs as u32) }
    }

}

impl From<u32> for TPMA_X509_KEY_USAGE {
fn from(value: u32) -> Self {
    unsafe { std::mem::transmute(value) }
    }

}

/// This attribute is used to report the ACT state. This attribute may be read using
/// TPM2_GetCapability(capability = TPM_CAP_ACT, property = TPM_RH_ACT_x where x is the
/// ACT number (0-F)). The signaled value must be preserved across TPM Resume or if the
/// TPM has not lost power. The signaled value may be preserved over a power cycle of a TPM.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, TryFromPrimitive)]
#[repr(i32)]
pub enum TPMA_ACT {
    /// SET (1): The ACT has signaled
    /// CLEAR (0): The ACT has not signaled
    signaled = 0x1,

    /// Preserves the state of signaled, depending on the power cycle
    preserveSignaled = 0x2
}

impl fmt::Display for TPMA_ACT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::signaled => write!(f, "signaled"),
            Self::preserveSignaled => write!(f, "preserveSignaled"),
        }
    }
}

impl std::ops::BitOr for TPMA_ACT {
type Output = Self;
    fn bitor(self, rhs: Self) -> Self::Output {
    unsafe { std::mem::transmute(self as u32 | rhs as u32) }
    }

}

impl From<u32> for TPMA_ACT {
fn from(value: u32) -> Self {
    unsafe { std::mem::transmute(value) }
    }

}

/// A TPM_NV_INDEX is used to reference a defined location in NV memory. The format of the
/// Index is changed from TPM 1.2 in order to include the Index in the reserved handle
/// space. Handles in this range use the digest of the public area of the Index as the
/// Name of the entity in authorization computations
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, TryFromPrimitive)]
#[repr(i32)]
pub enum TPM_NV_INDEX {
    /// The Index of the NV location
    index_BIT_MASK = 0xFFFFFF,
    index_BIT_OFFSET = 0x0, // Original value: 0
    index_BIT_LENGTH = 0x18, // Original value: 24

    /// Constant value of TPM_HT_NV_INDEX indicating the NV Index range
    RhNv_BIT_MASK = 0xFFFFFFFFFF000000,
    // WARNING: RhNv_BIT_OFFSET has duplicate value 0x18 - using name + value pattern
    RhNv_BIT_OFFSETValue = 0x18, // Original value: 24
    RhNv_BIT_LENGTH = 0x8 // Original value: 8
}

impl fmt::Display for TPM_NV_INDEX {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::index_BIT_MASK => write!(f, "index_BIT_MASK"),
            Self::index_BIT_OFFSET => write!(f, "index_BIT_OFFSET"),
            Self::index_BIT_LENGTH => write!(f, "index_BIT_LENGTH"),
            Self::RhNv_BIT_MASK => write!(f, "RhNv_BIT_MASK"),
            Self::RhNv_BIT_OFFSET => write!(f, "RhNv_BIT_OFFSET"),
            Self::RhNv_BIT_LENGTH => write!(f, "RhNv_BIT_LENGTH"),
        }
    }
}

impl std::ops::BitOr for TPM_NV_INDEX {
type Output = Self;
    fn bitor(self, rhs: Self) -> Self::Output {
    unsafe { std::mem::transmute(self as u32 | rhs as u32) }
    }

}

impl From<u32> for TPM_NV_INDEX {
fn from(value: u32) -> Self {
    unsafe { std::mem::transmute(value) }
    }

}

/// This structure allows the TPM to keep track of the data and permissions to manipulate
/// an NV Index.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, TryFromPrimitive)]
#[repr(i32)]
pub enum TPMA_NV {
    /// SET (1): The Index data can be written if Platform Authorization is provided.
    /// CLEAR (0): Writing of the Index data cannot be authorized with Platform Authorization.
    PPWRITE = 0x1,

    /// SET (1): The Index data can be written if Owner Authorization is provided.
    /// CLEAR (0): Writing of the Index data cannot be authorized with Owner Authorization.
    OWNERWRITE = 0x2,

    /// SET (1): Authorizations to change the Index contents that require USER role may be
    /// provided with an HMAC session or password.
    /// CLEAR (0): Authorizations to change the Index contents that require USER role may not
    /// be provided with an HMAC session or password.
    AUTHWRITE = 0x4,

    /// SET (1): Authorizations to change the Index contents that require USER role may be
    /// provided with a policy session.
    /// CLEAR (0): Authorizations to change the Index contents that require USER role may not
    /// be provided with a policy session.
    /// NOTE TPM2_NV_ChangeAuth() always requires that authorization be provided in a policy session.
    POLICYWRITE = 0x8,

    /// Ordinary contains data that is opaque to the TPM that can only be modified using TPM2_NV_Write().
    ORDINARY = 0x0,

    /// Counter contains an 8-octet value that is to be used as a counter and can only be
    /// modified with TPM2_NV_Increment()
    COUNTER = 0x10,

    /// Bit Field contains an 8-octet value to be used as a bit field and can only be modified
    /// with TPM2_NV_SetBits().
    BITS = 0x20,

    /// Extend contains a digest-sized value used like a PCR. The Index can only be modified
    /// using TPM2_NV_Extend(). The extend will use the nameAlg of the Index.
    EXTEND = 0x40,

    /// PIN Fail - contains pinCount that increments on a PIN authorization failure and a pinLimit
    PIN_FAIL = 0x80,

    /// PIN Pass - contains pinCount that increments on a PIN authorization success and a pinLimit
    PIN_PASS = 0x90,

    /// The type of the index.
    /// NOTE A TPM is not required to support all TPM_NT values
    TpmNt_BIT_MASK = 0xF0,
    // WARNING: TpmNt_BIT_OFFSET has duplicate value 0x4 - using name + value pattern
    TpmNt_BIT_OFFSETValue = 0x4, // Original value: 4
    // WARNING: TpmNt_BIT_LENGTH has duplicate value 0x4 - using name + value pattern
    TpmNt_BIT_LENGTHValue = 0x4, // Original value: 4

    /// SET (1): Index may not be deleted unless the authPolicy is satisfied using
    /// TPM2_NV_UndefineSpaceSpecial().
    /// CLEAR (0): Index may be deleted with proper platform or owner authorization using
    /// TPM2_NV_UndefineSpace().
    /// NOTE An Index with this attribute and a policy that cannot be satisfied (e.g., an
    /// Empty Policy) cannot be deleted.
    POLICY_DELETE = 0x400,

    /// SET (1): Index cannot be written.
    /// CLEAR (0): Index can be written.
    WRITELOCKED = 0x800,

    /// SET (1): A partial write of the Index data is not allowed. The write size shall match
    /// the defined space size.
    /// CLEAR (0): Partial writes are allowed. This setting is required if the .dataSize of
    /// the Index is larger than NV_MAX_BUFFER_SIZE for the implementation.
    WRITEALL = 0x1000,

    /// SET (1): TPM2_NV_WriteLock() may be used to prevent further writes to this location.
    /// CLEAR (0): TPM2_NV_WriteLock() does not block subsequent writes if
    /// TPMA_NV_WRITE_STCLEAR is also CLEAR.
    WRITEDEFINE = 0x2000,

    /// SET (1): TPM2_NV_WriteLock() may be used to prevent further writes to this location
    /// until the next TPM Reset or TPM Restart.
    /// CLEAR (0): TPM2_NV_WriteLock() does not block subsequent writes if TPMA_NV_WRITEDEFINE
    /// is also CLEAR.
    WRITE_STCLEAR = 0x4000,

    /// SET (1): If TPM2_NV_GlobalWriteLock() is successful, TPMA_NV_WRITELOCKED is set.
    /// CLEAR (0): TPM2_NV_GlobalWriteLock() has no effect on the writing of the data at this Index.
    GLOBALLOCK = 0x8000,

    /// SET (1): The Index data can be read if Platform Authorization is provided.
    /// CLEAR (0): Reading of the Index data cannot be authorized with Platform Authorization.
    PPREAD = 0x10000,

    /// SET (1): The Index data can be read if Owner Authorization is provided.
    /// CLEAR (0): Reading of the Index data cannot be authorized with Owner Authorization.
    OWNERREAD = 0x20000,

    /// SET (1): The Index data may be read if the authValue is provided.
    /// CLEAR (0): Reading of the Index data cannot be authorized with the Index authValue.
    AUTHREAD = 0x40000,

    /// SET (1): The Index data may be read if the authPolicy is satisfied.
    /// CLEAR (0): Reading of the Index data cannot be authorized with the Index authPolicy.
    POLICYREAD = 0x80000,

    /// SET (1): Authorization failures of the Index do not affect the DA logic and
    /// authorization of the Index is not blocked when the TPM is in Lockout mode.
    /// CLEAR (0): Authorization failures of the Index will increment the authorization
    /// failure counter and authorizations of this Index are not allowed when the TPM is in
    /// Lockout mode.
    NO_DA = 0x2000000,

    /// SET (1): NV Index state is only required to be saved when the TPM performs an orderly
    /// shutdown (TPM2_Shutdown()).
    /// CLEAR (0): NV Index state is required to be persistent after the command to update the
    /// Index completes successfully (that is, the NV update is synchronous with the update command).
    ORDERLY = 0x4000000,

    /// SET (1): TPMA_NV_WRITTEN for the Index is CLEAR by TPM Reset or TPM Restart.
    /// CLEAR (0): TPMA_NV_WRITTEN is not changed by TPM Restart.
    /// NOTE This attribute may only be SET if TPM_NT is not TPM_NT_COUNTER.
    CLEAR_STCLEAR = 0x8000000,

    /// SET (1): Reads of the Index are blocked until the next TPM Reset or TPM Restart.
    /// CLEAR (0): Reads of the Index are allowed if proper authorization is provided.
    READLOCKED = 0x10000000,

    /// SET (1): Index has been written.
    /// CLEAR (0): Index has not been written.
    WRITTEN = 0x20000000,

    /// SET (1): This Index may be undefined with Platform Authorization but not with Owner
    /// Authorization.
    /// CLEAR (0): This Index may be undefined using Owner Authorization but not with Platform
    /// Authorization.
    /// The TPM will validate that this attribute is SET when the Index is defined using
    /// Platform Authorization and will validate that this attribute is CLEAR when the Index
    /// is defined using Owner Authorization.
    PLATFORMCREATE = 0x40000000,

    /// SET (1): TPM2_NV_ReadLock() may be used to SET TPMA_NV_READLOCKED for this Index.
    /// CLEAR (0): TPM2_NV_ReadLock() has no effect on this Index.
    READ_STCLEAR = 0xFFFFFFFF80000000
}

impl fmt::Display for TPMA_NV {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::PPWRITE => write!(f, "PPWRITE"),
            Self::OWNERWRITE => write!(f, "OWNERWRITE"),
            Self::AUTHWRITE => write!(f, "AUTHWRITE"),
            Self::POLICYWRITE => write!(f, "POLICYWRITE"),
            Self::ORDINARY => write!(f, "ORDINARY"),
            Self::COUNTER => write!(f, "COUNTER"),
            Self::BITS => write!(f, "BITS"),
            Self::EXTEND => write!(f, "EXTEND"),
            Self::PIN_FAIL => write!(f, "PIN_FAIL"),
            Self::PIN_PASS => write!(f, "PIN_PASS"),
            Self::TpmNt_BIT_MASK => write!(f, "TpmNt_BIT_MASK"),
            Self::TpmNt_BIT_OFFSET => write!(f, "TpmNt_BIT_OFFSET"),
            Self::TpmNt_BIT_LENGTH => write!(f, "TpmNt_BIT_LENGTH"),
            Self::POLICY_DELETE => write!(f, "POLICY_DELETE"),
            Self::WRITELOCKED => write!(f, "WRITELOCKED"),
            Self::WRITEALL => write!(f, "WRITEALL"),
            Self::WRITEDEFINE => write!(f, "WRITEDEFINE"),
            Self::WRITE_STCLEAR => write!(f, "WRITE_STCLEAR"),
            Self::GLOBALLOCK => write!(f, "GLOBALLOCK"),
            Self::PPREAD => write!(f, "PPREAD"),
            Self::OWNERREAD => write!(f, "OWNERREAD"),
            Self::AUTHREAD => write!(f, "AUTHREAD"),
            Self::POLICYREAD => write!(f, "POLICYREAD"),
            Self::NO_DA => write!(f, "NO_DA"),
            Self::ORDERLY => write!(f, "ORDERLY"),
            Self::CLEAR_STCLEAR => write!(f, "CLEAR_STCLEAR"),
            Self::READLOCKED => write!(f, "READLOCKED"),
            Self::WRITTEN => write!(f, "WRITTEN"),
            Self::PLATFORMCREATE => write!(f, "PLATFORMCREATE"),
            Self::READ_STCLEAR => write!(f, "READ_STCLEAR"),
        }
    }
}

impl std::ops::BitOr for TPMA_NV {
type Output = Self;
    fn bitor(self, rhs: Self) -> Self::Output {
    unsafe { std::mem::transmute(self as u32 | rhs as u32) }
    }

}

impl From<u32> for TPMA_NV {
fn from(value: u32) -> Self {
    unsafe { std::mem::transmute(value) }
    }

}

/// Base trait for TPM union types
pub trait TpmUnion {
/// Get the union selector value
    fn get_union_selector(&self) -> u32;
}

/// Table 119 Definition of TPMU_CAPABILITIES Union [OUT]
/// One of: TPML_ALG_PROPERTY, TPML_HANDLE, TPML_CCA, TPML_CC, TPML_PCR_SELECTION,
/// TPML_TAGGED_TPM_PROPERTY, TPML_TAGGED_PCR_PROPERTY, TPML_ECC_CURVE,
/// TPML_TAGGED_POLICY, TPML_ACT_DATA.
pub enum TPMU_CAPABILITIES {
    algorithms(TPML_ALG_PROPERTY),
    handles(TPML_HANDLE),
    command(TPML_CCA),
    ppCommands(TPML_CC),
    auditCommands(TPML_CC),
    assignedPCR(TPML_PCR_SELECTION),
    tpmProperties(TPML_TAGGED_TPM_PROPERTY),
    pcrProperties(TPML_TAGGED_PCR_PROPERTY),
    eccCurves(TPML_ECC_CURVE),
    authPolicies(TPML_TAGGED_POLICY),
    actData(TPML_ACT_DATA),
}

impl TpmUnion for TPMU_CAPABILITIES {
    fn get_union_selector(&self) -> u32 {
        match self {
            Self::algorithms(_) => TPM_CAP:ALGS as u32,
            Self::handles(_) => TPM_CAP:HANDLES as u32,
            Self::command(_) => TPM_CAP:COMMANDS as u32,
            Self::ppCommands(_) => TPM_CAP:PP_COMMANDS as u32,
            Self::auditCommands(_) => TPM_CAP:AUDIT_COMMANDS as u32,
            Self::assignedPCR(_) => TPM_CAP:PCRS as u32,
            Self::tpmProperties(_) => TPM_CAP:TPM_PROPERTIES as u32,
            Self::pcrProperties(_) => TPM_CAP:PCR_PROPERTIES as u32,
            Self::eccCurves(_) => TPM_CAP:ECC_CURVES as u32,
            Self::authPolicies(_) => TPM_CAP:AUTH_POLICIES as u32,
            Self::actData(_) => TPM_CAP:ACT as u32,
        }
    }
}

impl fmt::Debug for TPMU_CAPABILITIES {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::algorithms(inner) => write!(f, "TPMU_CAPABILITIES::algorithms({:?})", inner),
            Self::handles(inner) => write!(f, "TPMU_CAPABILITIES::handles({:?})", inner),
            Self::command(inner) => write!(f, "TPMU_CAPABILITIES::command({:?})", inner),
            Self::ppCommands(inner) => write!(f, "TPMU_CAPABILITIES::ppCommands({:?})", inner),
            Self::auditCommands(inner) => write!(f, "TPMU_CAPABILITIES::auditCommands({:?})", inner),
            Self::assignedPCR(inner) => write!(f, "TPMU_CAPABILITIES::assignedPCR({:?})", inner),
            Self::tpmProperties(inner) => write!(f, "TPMU_CAPABILITIES::tpmProperties({:?})", inner),
            Self::pcrProperties(inner) => write!(f, "TPMU_CAPABILITIES::pcrProperties({:?})", inner),
            Self::eccCurves(inner) => write!(f, "TPMU_CAPABILITIES::eccCurves({:?})", inner),
            Self::authPolicies(inner) => write!(f, "TPMU_CAPABILITIES::authPolicies({:?})", inner),
            Self::actData(inner) => write!(f, "TPMU_CAPABILITIES::actData({:?})", inner),
        }
    }
}

/// Table 132 Definition of TPMU_ATTEST Union [OUT]
/// One of: TPMS_CERTIFY_INFO, TPMS_CREATION_INFO, TPMS_QUOTE_INFO,
/// TPMS_COMMAND_AUDIT_INFO, TPMS_SESSION_AUDIT_INFO, TPMS_TIME_ATTEST_INFO,
/// TPMS_NV_CERTIFY_INFO, TPMS_NV_DIGEST_CERTIFY_INFO.
pub enum TPMU_ATTEST {
    certify(TPMS_CERTIFY_INFO),
    creation(TPMS_CREATION_INFO),
    quote(TPMS_QUOTE_INFO),
    commandAudit(TPMS_COMMAND_AUDIT_INFO),
    sessionAudit(TPMS_SESSION_AUDIT_INFO),
    time(TPMS_TIME_ATTEST_INFO),
    nv(TPMS_NV_CERTIFY_INFO),
    nvDigest(TPMS_NV_DIGEST_CERTIFY_INFO),
}

impl TpmUnion for TPMU_ATTEST {
    fn get_union_selector(&self) -> u32 {
        match self {
            Self::certify(_) => TPM_ST:ATTEST_CERTIFY as u32,
            Self::creation(_) => TPM_ST:ATTEST_CREATION as u32,
            Self::quote(_) => TPM_ST:ATTEST_QUOTE as u32,
            Self::commandAudit(_) => TPM_ST:ATTEST_COMMAND_AUDIT as u32,
            Self::sessionAudit(_) => TPM_ST:ATTEST_SESSION_AUDIT as u32,
            Self::time(_) => TPM_ST:ATTEST_TIME as u32,
            Self::nv(_) => TPM_ST:ATTEST_NV as u32,
            Self::nvDigest(_) => TPM_ST:ATTEST_NV_DIGEST as u32,
        }
    }
}

impl fmt::Debug for TPMU_ATTEST {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::certify(inner) => write!(f, "TPMU_ATTEST::certify({:?})", inner),
            Self::creation(inner) => write!(f, "TPMU_ATTEST::creation({:?})", inner),
            Self::quote(inner) => write!(f, "TPMU_ATTEST::quote({:?})", inner),
            Self::commandAudit(inner) => write!(f, "TPMU_ATTEST::commandAudit({:?})", inner),
            Self::sessionAudit(inner) => write!(f, "TPMU_ATTEST::sessionAudit({:?})", inner),
            Self::time(inner) => write!(f, "TPMU_ATTEST::time({:?})", inner),
            Self::nv(inner) => write!(f, "TPMU_ATTEST::nv({:?})", inner),
            Self::nvDigest(inner) => write!(f, "TPMU_ATTEST::nvDigest({:?})", inner),
        }
    }
}

/// This union allows additional parameters to be added for a symmetric cipher. Currently,
/// no additional parameters are required for any of the symmetric algorithms.
/// One of: TPMS_TDES_SYM_DETAILS, TPMS_AES_SYM_DETAILS, TPMS_SM4_SYM_DETAILS,
/// TPMS_CAMELLIA_SYM_DETAILS, TPMS_ANY_SYM_DETAILS, TPMS_XOR_SYM_DETAILS, TPMS_NULL_SYM_DETAILS.
pub enum TPMU_SYM_DETAILS {
    tdes(TPMS_TDES_SYM_DETAILS),
    aes(TPMS_AES_SYM_DETAILS),
    sm4(TPMS_SM4_SYM_DETAILS),
    camellia(TPMS_CAMELLIA_SYM_DETAILS),
    sym(TPMS_ANY_SYM_DETAILS),
    xor(TPMS_XOR_SYM_DETAILS),
    null(TPMS_NULL_SYM_DETAILS),
}

impl TpmUnion for TPMU_SYM_DETAILS {
    fn get_union_selector(&self) -> u32 {
        match self {
            Self::tdes(_) => TPM_ALG_ID:TDES as u32,
            Self::aes(_) => TPM_ALG_ID:AES as u32,
            Self::sm4(_) => TPM_ALG_ID:SM4 as u32,
            Self::camellia(_) => TPM_ALG_ID:CAMELLIA as u32,
            Self::sym(_) => TPM_ALG_ID:ANY as u32,
            Self::xor(_) => TPM_ALG_ID:XOR as u32,
            Self::null(_) => TPM_ALG_ID:NULL as u32,
        }
    }
}

impl fmt::Debug for TPMU_SYM_DETAILS {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::tdes(inner) => write!(f, "TPMU_SYM_DETAILS::tdes({:?})", inner),
            Self::aes(inner) => write!(f, "TPMU_SYM_DETAILS::aes({:?})", inner),
            Self::sm4(inner) => write!(f, "TPMU_SYM_DETAILS::sm4({:?})", inner),
            Self::camellia(inner) => write!(f, "TPMU_SYM_DETAILS::camellia({:?})", inner),
            Self::sym(inner) => write!(f, "TPMU_SYM_DETAILS::sym({:?})", inner),
            Self::xor(inner) => write!(f, "TPMU_SYM_DETAILS::xor({:?})", inner),
            Self::null(inner) => write!(f, "TPMU_SYM_DETAILS::null({:?})", inner),
        }
    }
}

/// This structure allows a TPM2B_SENSITIVE_CREATE structure to carry either a
/// TPM2B_SENSITVE_DATA or a TPM2B_DERIVE structure. The contents of the union are
/// determined by context. When an object is being derived, the derivation values are present.
/// One of: u8, TPMS_DERIVE.
pub enum TPMU_SENSITIVE_CREATE {
    create,
    derive(TPMS_DERIVE),
}

impl TpmUnion for TPMU_SENSITIVE_CREATE {
    fn get_union_selector(&self) -> u32 {
        match self {
            Self::create => TPM_ALG_ID:ANY as u32,
            Self::derive(_) => TPM_ALG_ID:ANY2 as u32,
        }
    }
}

impl fmt::Debug for TPMU_SENSITIVE_CREATE {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::create => write!(f, "TPMU_SENSITIVE_CREATE::create"),
            Self::derive(inner) => write!(f, "TPMU_SENSITIVE_CREATE::derive({:?})", inner),
        }
    }
}

/// Table 157 Definition of TPMU_SCHEME_KEYEDHASH Union [IN/OUT]
/// One of: TPMS_SCHEME_HMAC, TPMS_SCHEME_XOR, TPMS_NULL_SCHEME_KEYEDHASH.
pub enum TPMU_SCHEME_KEYEDHASH {
    hmac(TPMS_SCHEME_HMAC),
    xor(TPMS_SCHEME_XOR),
    null(TPMS_NULL_SCHEME_KEYEDHASH),
}

impl TpmUnion for TPMU_SCHEME_KEYEDHASH {
    fn get_union_selector(&self) -> u32 {
        match self {
            Self::hmac(_) => TPM_ALG_ID:HMAC as u32,
            Self::xor(_) => TPM_ALG_ID:XOR as u32,
            Self::null(_) => TPM_ALG_ID:NULL as u32,
        }
    }
}

impl fmt::Debug for TPMU_SCHEME_KEYEDHASH {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::hmac(inner) => write!(f, "TPMU_SCHEME_KEYEDHASH::hmac({:?})", inner),
            Self::xor(inner) => write!(f, "TPMU_SCHEME_KEYEDHASH::xor({:?})", inner),
            Self::null(inner) => write!(f, "TPMU_SCHEME_KEYEDHASH::null({:?})", inner),
        }
    }
}

/// This is the union of all of the signature schemes.
/// One of: TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA,
/// TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR,
/// TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME.
pub enum TPMU_SIG_SCHEME {
    rsassa(TPMS_SIG_SCHEME_RSASSA),
    rsapss(TPMS_SIG_SCHEME_RSAPSS),
    ecdsa(TPMS_SIG_SCHEME_ECDSA),
    ecdaa(TPMS_SIG_SCHEME_ECDAA),
    sm2(TPMS_SIG_SCHEME_SM2),
    ecschnorr(TPMS_SIG_SCHEME_ECSCHNORR),
    hmac(TPMS_SCHEME_HMAC),
    any(TPMS_SCHEME_HASH),
    null(TPMS_NULL_SIG_SCHEME),
}

impl TpmUnion for TPMU_SIG_SCHEME {
    fn get_union_selector(&self) -> u32 {
        match self {
            Self::rsassa(_) => TPM_ALG_ID:RSASSA as u32,
            Self::rsapss(_) => TPM_ALG_ID:RSAPSS as u32,
            Self::ecdsa(_) => TPM_ALG_ID:ECDSA as u32,
            Self::ecdaa(_) => TPM_ALG_ID:ECDAA as u32,
            Self::sm2(_) => TPM_ALG_ID:SM2 as u32,
            Self::ecschnorr(_) => TPM_ALG_ID:ECSCHNORR as u32,
            Self::hmac(_) => TPM_ALG_ID:HMAC as u32,
            Self::any(_) => TPM_ALG_ID:ANY as u32,
            Self::null(_) => TPM_ALG_ID:NULL as u32,
        }
    }
}

impl fmt::Debug for TPMU_SIG_SCHEME {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::rsassa(inner) => write!(f, "TPMU_SIG_SCHEME::rsassa({:?})", inner),
            Self::rsapss(inner) => write!(f, "TPMU_SIG_SCHEME::rsapss({:?})", inner),
            Self::ecdsa(inner) => write!(f, "TPMU_SIG_SCHEME::ecdsa({:?})", inner),
            Self::ecdaa(inner) => write!(f, "TPMU_SIG_SCHEME::ecdaa({:?})", inner),
            Self::sm2(inner) => write!(f, "TPMU_SIG_SCHEME::sm2({:?})", inner),
            Self::ecschnorr(inner) => write!(f, "TPMU_SIG_SCHEME::ecschnorr({:?})", inner),
            Self::hmac(inner) => write!(f, "TPMU_SIG_SCHEME::hmac({:?})", inner),
            Self::any(inner) => write!(f, "TPMU_SIG_SCHEME::any({:?})", inner),
            Self::null(inner) => write!(f, "TPMU_SIG_SCHEME::null({:?})", inner),
        }
    }
}

/// Table 166 Definition of TPMU_KDF_SCHEME Union [IN/OUT]
/// One of: TPMS_KDF_SCHEME_MGF1, TPMS_KDF_SCHEME_KDF1_SP800_56A, TPMS_KDF_SCHEME_KDF2,
/// TPMS_KDF_SCHEME_KDF1_SP800_108, TPMS_SCHEME_HASH, TPMS_NULL_KDF_SCHEME.
pub enum TPMU_KDF_SCHEME {
    mgf1(TPMS_KDF_SCHEME_MGF1),
    kdf1_sp800_56a(TPMS_KDF_SCHEME_KDF1_SP800_56A),
    kdf2(TPMS_KDF_SCHEME_KDF2),
    kdf1_sp800_108(TPMS_KDF_SCHEME_KDF1_SP800_108),
    anyKdf(TPMS_SCHEME_HASH),
    null(TPMS_NULL_KDF_SCHEME),
}

impl TpmUnion for TPMU_KDF_SCHEME {
    fn get_union_selector(&self) -> u32 {
        match self {
            Self::mgf1(_) => TPM_ALG_ID:MGF1 as u32,
            Self::kdf1_sp800_56a(_) => TPM_ALG_ID:KDF1_SP800_56A as u32,
            Self::kdf2(_) => TPM_ALG_ID:KDF2 as u32,
            Self::kdf1_sp800_108(_) => TPM_ALG_ID:KDF1_SP800_108 as u32,
            Self::anyKdf(_) => TPM_ALG_ID:ANY as u32,
            Self::null(_) => TPM_ALG_ID:NULL as u32,
        }
    }
}

impl fmt::Debug for TPMU_KDF_SCHEME {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::mgf1(inner) => write!(f, "TPMU_KDF_SCHEME::mgf1({:?})", inner),
            Self::kdf1_sp800_56a(inner) => write!(f, "TPMU_KDF_SCHEME::kdf1_sp800_56a({:?})", inner),
            Self::kdf2(inner) => write!(f, "TPMU_KDF_SCHEME::kdf2({:?})", inner),
            Self::kdf1_sp800_108(inner) => write!(f, "TPMU_KDF_SCHEME::kdf1_sp800_108({:?})", inner),
            Self::anyKdf(inner) => write!(f, "TPMU_KDF_SCHEME::anyKdf({:?})", inner),
            Self::null(inner) => write!(f, "TPMU_KDF_SCHEME::null({:?})", inner),
        }
    }
}

/// This union of all asymmetric schemes is used in each of the asymmetric scheme
/// structures. The actual scheme structure is defined by the interface type used for the
/// selector (TPMI_ALG_ASYM_SCHEME).
/// One of: TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA,
/// TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA,
/// TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES,
/// TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME.
pub enum TPMU_ASYM_SCHEME {
    ecdh(TPMS_KEY_SCHEME_ECDH),
    ecmqv(TPMS_KEY_SCHEME_ECMQV),
    rsassa(TPMS_SIG_SCHEME_RSASSA),
    rsapss(TPMS_SIG_SCHEME_RSAPSS),
    ecdsa(TPMS_SIG_SCHEME_ECDSA),
    ecdaa(TPMS_SIG_SCHEME_ECDAA),
    sm2(TPMS_SIG_SCHEME_SM2),
    ecschnorr(TPMS_SIG_SCHEME_ECSCHNORR),
    rsaes(TPMS_ENC_SCHEME_RSAES),
    oaep(TPMS_ENC_SCHEME_OAEP),
    anySig(TPMS_SCHEME_HASH),
    null(TPMS_NULL_ASYM_SCHEME),
}

impl TpmUnion for TPMU_ASYM_SCHEME {
    fn get_union_selector(&self) -> u32 {
        match self {
            Self::ecdh(_) => TPM_ALG_ID:ECDH as u32,
            Self::ecmqv(_) => TPM_ALG_ID:ECMQV as u32,
            Self::rsassa(_) => TPM_ALG_ID:RSASSA as u32,
            Self::rsapss(_) => TPM_ALG_ID:RSAPSS as u32,
            Self::ecdsa(_) => TPM_ALG_ID:ECDSA as u32,
            Self::ecdaa(_) => TPM_ALG_ID:ECDAA as u32,
            Self::sm2(_) => TPM_ALG_ID:SM2 as u32,
            Self::ecschnorr(_) => TPM_ALG_ID:ECSCHNORR as u32,
            Self::rsaes(_) => TPM_ALG_ID:RSAES as u32,
            Self::oaep(_) => TPM_ALG_ID:OAEP as u32,
            Self::anySig(_) => TPM_ALG_ID:ANY as u32,
            Self::null(_) => TPM_ALG_ID:NULL as u32,
        }
    }
}

impl fmt::Debug for TPMU_ASYM_SCHEME {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::ecdh(inner) => write!(f, "TPMU_ASYM_SCHEME::ecdh({:?})", inner),
            Self::ecmqv(inner) => write!(f, "TPMU_ASYM_SCHEME::ecmqv({:?})", inner),
            Self::rsassa(inner) => write!(f, "TPMU_ASYM_SCHEME::rsassa({:?})", inner),
            Self::rsapss(inner) => write!(f, "TPMU_ASYM_SCHEME::rsapss({:?})", inner),
            Self::ecdsa(inner) => write!(f, "TPMU_ASYM_SCHEME::ecdsa({:?})", inner),
            Self::ecdaa(inner) => write!(f, "TPMU_ASYM_SCHEME::ecdaa({:?})", inner),
            Self::sm2(inner) => write!(f, "TPMU_ASYM_SCHEME::sm2({:?})", inner),
            Self::ecschnorr(inner) => write!(f, "TPMU_ASYM_SCHEME::ecschnorr({:?})", inner),
            Self::rsaes(inner) => write!(f, "TPMU_ASYM_SCHEME::rsaes({:?})", inner),
            Self::oaep(inner) => write!(f, "TPMU_ASYM_SCHEME::oaep({:?})", inner),
            Self::anySig(inner) => write!(f, "TPMU_ASYM_SCHEME::anySig({:?})", inner),
            Self::null(inner) => write!(f, "TPMU_ASYM_SCHEME::null({:?})", inner),
        }
    }
}

/// A TPMU_SIGNATURE_COMPOSITE is a union of the various signatures that are supported by
/// a particular TPM implementation. The union allows substitution of any signature
/// algorithm wherever a signature is required in a structure.
/// One of: TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA,
/// TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TPMT_HA,
/// TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE.
pub enum TPMU_SIGNATURE {
    rsassa(TPMS_SIGNATURE_RSASSA),
    rsapss(TPMS_SIGNATURE_RSAPSS),
    ecdsa(TPMS_SIGNATURE_ECDSA),
    ecdaa(TPMS_SIGNATURE_ECDAA),
    sm2(TPMS_SIGNATURE_SM2),
    ecschnorr(TPMS_SIGNATURE_ECSCHNORR),
    hmac(TPMT_HA),
    any(TPMS_SCHEME_HASH),
    null(TPMS_NULL_SIGNATURE),
}

impl TpmUnion for TPMU_SIGNATURE {
    fn get_union_selector(&self) -> u32 {
        match self {
            Self::rsassa(_) => TPM_ALG_ID:RSASSA as u32,
            Self::rsapss(_) => TPM_ALG_ID:RSAPSS as u32,
            Self::ecdsa(_) => TPM_ALG_ID:ECDSA as u32,
            Self::ecdaa(_) => TPM_ALG_ID:ECDAA as u32,
            Self::sm2(_) => TPM_ALG_ID:SM2 as u32,
            Self::ecschnorr(_) => TPM_ALG_ID:ECSCHNORR as u32,
            Self::hmac(_) => TPM_ALG_ID:HMAC as u32,
            Self::any(_) => TPM_ALG_ID:ANY as u32,
            Self::null(_) => TPM_ALG_ID:NULL as u32,
        }
    }
}

impl fmt::Debug for TPMU_SIGNATURE {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::rsassa(inner) => write!(f, "TPMU_SIGNATURE::rsassa({:?})", inner),
            Self::rsapss(inner) => write!(f, "TPMU_SIGNATURE::rsapss({:?})", inner),
            Self::ecdsa(inner) => write!(f, "TPMU_SIGNATURE::ecdsa({:?})", inner),
            Self::ecdaa(inner) => write!(f, "TPMU_SIGNATURE::ecdaa({:?})", inner),
            Self::sm2(inner) => write!(f, "TPMU_SIGNATURE::sm2({:?})", inner),
            Self::ecschnorr(inner) => write!(f, "TPMU_SIGNATURE::ecschnorr({:?})", inner),
            Self::hmac(inner) => write!(f, "TPMU_SIGNATURE::hmac({:?})", inner),
            Self::any(inner) => write!(f, "TPMU_SIGNATURE::any({:?})", inner),
            Self::null(inner) => write!(f, "TPMU_SIGNATURE::null({:?})", inner),
        }
    }
}

/// This is the union of all values allowed in in the unique field of a TPMT_PUBLIC.
/// One of: TPM2B_DIGEST_KEYEDHASH, TPM2B_DIGEST_SYMCIPHER, TPM2B_PUBLIC_KEY_RSA,
/// TPMS_ECC_POINT, TPMS_DERIVE.
pub enum TPMU_PUBLIC_ID {
    keyedHash(TPM2B_DIGEST_KEYEDHASH),
    sym(TPM2B_DIGEST_SYMCIPHER),
    rsa(TPM2B_PUBLIC_KEY_RSA),
    ecc(TPMS_ECC_POINT),
    derive(TPMS_DERIVE),
}

impl TpmUnion for TPMU_PUBLIC_ID {
    fn get_union_selector(&self) -> u32 {
        match self {
            Self::keyedHash(_) => TPM_ALG_ID:KEYEDHASH as u32,
            Self::sym(_) => TPM_ALG_ID:SYMCIPHER as u32,
            Self::rsa(_) => TPM_ALG_ID:RSA as u32,
            Self::ecc(_) => TPM_ALG_ID:ECC as u32,
            Self::derive(_) => TPM_ALG_ID:ANY as u32,
        }
    }
}

impl fmt::Debug for TPMU_PUBLIC_ID {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::keyedHash(inner) => write!(f, "TPMU_PUBLIC_ID::keyedHash({:?})", inner),
            Self::sym(inner) => write!(f, "TPMU_PUBLIC_ID::sym({:?})", inner),
            Self::rsa(inner) => write!(f, "TPMU_PUBLIC_ID::rsa({:?})", inner),
            Self::ecc(inner) => write!(f, "TPMU_PUBLIC_ID::ecc({:?})", inner),
            Self::derive(inner) => write!(f, "TPMU_PUBLIC_ID::derive({:?})", inner),
        }
    }
}

/// Table 199 defines the possible parameter definition structures that may be contained
/// in the public portion of a key. If the Object can be a parent, the first field must be
/// a TPMT_SYM_DEF_OBJECT. See 11.1.7.
/// One of: TPMS_KEYEDHASH_PARMS, TPMS_SYMCIPHER_PARMS, TPMS_RSA_PARMS, TPMS_ECC_PARMS,
/// TPMS_ASYM_PARMS.
pub enum TPMU_PUBLIC_PARMS {
    keyedHashDetail(TPMS_KEYEDHASH_PARMS),
    symDetail(TPMS_SYMCIPHER_PARMS),
    rsaDetail(TPMS_RSA_PARMS),
    eccDetail(TPMS_ECC_PARMS),
    asymDetail(TPMS_ASYM_PARMS),
}

impl TpmUnion for TPMU_PUBLIC_PARMS {
    fn get_union_selector(&self) -> u32 {
        match self {
            Self::keyedHashDetail(_) => TPM_ALG_ID:KEYEDHASH as u32,
            Self::symDetail(_) => TPM_ALG_ID:SYMCIPHER as u32,
            Self::rsaDetail(_) => TPM_ALG_ID:RSA as u32,
            Self::eccDetail(_) => TPM_ALG_ID:ECC as u32,
            Self::asymDetail(_) => TPM_ALG_ID:ANY as u32,
        }
    }
}

impl fmt::Debug for TPMU_PUBLIC_PARMS {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::keyedHashDetail(inner) => write!(f, "TPMU_PUBLIC_PARMS::keyedHashDetail({:?})", inner),
            Self::symDetail(inner) => write!(f, "TPMU_PUBLIC_PARMS::symDetail({:?})", inner),
            Self::rsaDetail(inner) => write!(f, "TPMU_PUBLIC_PARMS::rsaDetail({:?})", inner),
            Self::eccDetail(inner) => write!(f, "TPMU_PUBLIC_PARMS::eccDetail({:?})", inner),
            Self::asymDetail(inner) => write!(f, "TPMU_PUBLIC_PARMS::asymDetail({:?})", inner),
        }
    }
}

/// Table 205 Definition of TPMU_SENSITIVE_COMPOSITE Union [IN/OUT]
/// One of: TPM2B_PRIVATE_KEY_RSA, TPM2B_ECC_PARAMETER, TPM2B_SENSITIVE_DATA,
/// TPM2B_SYM_KEY, TPM2B_PRIVATE_VENDOR_SPECIFIC.
pub enum TPMU_SENSITIVE_COMPOSITE {
    rsa(TPM2B_PRIVATE_KEY_RSA),
    ecc(TPM2B_ECC_PARAMETER),
    bits(TPM2B_SENSITIVE_DATA),
    sym(TPM2B_SYM_KEY),
    any(TPM2B_PRIVATE_VENDOR_SPECIFIC),
}

impl TpmUnion for TPMU_SENSITIVE_COMPOSITE {
    fn get_union_selector(&self) -> u32 {
        match self {
            Self::rsa(_) => TPM_ALG_ID:RSA as u32,
            Self::ecc(_) => TPM_ALG_ID:ECC as u32,
            Self::bits(_) => TPM_ALG_ID:KEYEDHASH as u32,
            Self::sym(_) => TPM_ALG_ID:SYMCIPHER as u32,
            Self::any(_) => TPM_ALG_ID:ANY as u32,
        }
    }
}

impl fmt::Debug for TPMU_SENSITIVE_COMPOSITE {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::rsa(inner) => write!(f, "TPMU_SENSITIVE_COMPOSITE::rsa({:?})", inner),
            Self::ecc(inner) => write!(f, "TPMU_SENSITIVE_COMPOSITE::ecc({:?})", inner),
            Self::bits(inner) => write!(f, "TPMU_SENSITIVE_COMPOSITE::bits({:?})", inner),
            Self::sym(inner) => write!(f, "TPMU_SENSITIVE_COMPOSITE::sym({:?})", inner),
            Self::any(inner) => write!(f, "TPMU_SENSITIVE_COMPOSITE::any({:?})", inner),
        }
    }
}

/// Handle of a loaded TPM key or other object [TSS]
#[derive(Debug, Clone)]
pub struct TPM_HANDLE {
    /// Handle value
    pub handle: u32,
}

impl Default for TPM_HANDLE {
    fn default() -> Self {
        Self {
            handle: as u32TPM_RH::NULL,
        }
    }
}

impl TPM_HANDLE {
    /// Creates a new instance with the specified values
    pub fn new(
        handle: u32,
        ) -> Self {
        Self {
            handle,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// Base class for empty union elements.
/// An empty union element does not contain any data to marshal.
/// This data structure can be used in place of any other union
/// initialized with its own empty element.
#[derive(Debug, Clone)]
pub struct TPMS_NULL_UNION {
}

impl Default for TPMS_NULL_UNION {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPMS_NULL_UNION {
    // Union trait implementations
    impl TpmUnion for TPMS_NULL_UNION {
    }

    impl TpmUnion for TPMS_NULL_UNION {
    }

    impl TpmUnion for TPMS_NULL_UNION {
    }

    impl TpmUnion for TPMS_NULL_UNION {
    }

    impl TpmUnion for TPMS_NULL_UNION {
    }

    impl TpmUnion for TPMS_NULL_UNION {
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This structure is used as a placeholder. In some cases, a union will have a selector
/// value with no data to unmarshal when that type is selected. Rather than leave the
/// entry empty, TPMS_EMPTY may be selected.
#[derive(Debug, Clone)]
pub struct TPMS_EMPTY {
}

impl Default for TPMS_EMPTY {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPMS_EMPTY {
    // Union trait implementations
    impl TpmUnion for TPMS_EMPTY {
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This structure is a return value for a TPM2_GetCapability() that reads the installed algorithms.
#[derive(Debug, Clone)]
pub struct TPMS_ALGORITHM_DESCRIPTION {
    /// An algorithm
    pub alg: TPM_ALG_ID,

    /// The attributes of the algorithm
    pub attributes: TPMA_ALGORITHM,
}

impl Default for TPMS_ALGORITHM_DESCRIPTION {
    fn default() -> Self {
        Self {
            alg: TPM_ALG_ID::NULL,
        }
    }
}

impl TPMS_ALGORITHM_DESCRIPTION {
    /// Creates a new instance with the specified values
    pub fn new(
        alg: TPM_ALG_ID,
        attributes: TPMA_ALGORITHM,
        ) -> Self {
        Self {
            alg,
            attributes,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// Table 80 shows the basic hash-agile structure used in this specification. To handle
/// hash agility, this structure uses the hashAlg parameter to indicate the algorithm used
/// to compute the digest and, by implication, the size of the digest.
#[derive(Debug, Clone)]
pub struct TPMT_HA {
    /// Selector of the hash contained in the digest that implies the size of the digest
    /// NOTE The leading + on the type indicates that this structure should pass an indication
    /// to the unmarshaling function for TPMI_ALG_HASH so that TPM_ALG_NULL will be allowed if
    /// a use of a TPMT_HA allows TPM_ALG_NULL.
    pub hash_Alg: TPM_ALG_ID,

    /// Hash value
    pub digest: Vec<u8>,
}

impl Default for TPMT_HA {
    fn default() -> Self {
        Self {
            hashAlg: TPM_ALG_ID::NULL,
        }
    }
}

impl TPMT_HA {
    /// Creates a new instance with the specified values
    pub fn new(
        hash_Alg: TPM_ALG_ID,
        digest: Vec<u8>,
        ) -> Self {
        Self {
            hash_Alg,
            digest,
        }
    }

    // Union trait implementations
    impl TpmUnion for TPMT_HA {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
            TPMU_SIGNATURE::HMAC as u32
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This structure is used for a sized buffer that cannot be larger than the largest
/// digest produced by any hash algorithm implemented on the TPM.
#[derive(Debug, Clone)]
pub struct TPM2B_DIGEST {
    /// The buffer area that can be no larger than a digest
    pub buffer: Vec<u8>,
}

impl Default for TPM2B_DIGEST {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPM2B_DIGEST {
    /// Creates a new instance with the specified values
    pub fn new(
        buffer: Vec<u8>,
        ) -> Self {
        Self {
            buffer,
        }
    }

    // Union trait implementations
    impl TpmUnion for TPM2B_DIGEST {
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This structure is used for a data buffer that is required to be no larger than the
/// size of the Name of an object.
#[derive(Debug, Clone)]
pub struct TPM2B_DATA {
    pub buffer: Vec<u8>,
}

impl Default for TPM2B_DATA {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPM2B_DATA {
    /// Creates a new instance with the specified values
    pub fn new(
        buffer: Vec<u8>,
        ) -> Self {
        Self {
            buffer,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// Table 83 Definition of Types for TPM2B_NONCE
pub type TPM2B_NONCE = TPM2B_DIGEST;

/// This structure is used for an authorization value and limits an authValue to being no
/// larger than the largest digest produced by a TPM. In order to ensure consistency
/// within an object, the authValue may be no larger than the size of the digest produced
/// by the objects nameAlg. This ensures that any TPM that can load the object will be
/// able to handle the authValue of the object.
pub type TPM2B_AUTH = TPM2B_DIGEST;

/// This type is a sized buffer that can hold an operand for a comparison with an NV Index
/// location. The maximum size of the operand is implementation dependent but a TPM is
/// required to support an operand size that is at least as big as the digest produced by
/// any of the hash algorithms implemented on the TPM.
pub type TPM2B_OPERAND = TPM2B_DIGEST;

/// This type is a sized buffer that can hold event data.
#[derive(Debug, Clone)]
pub struct TPM2B_EVENT {
    /// The operand
    pub buffer: Vec<u8>,
}

impl Default for TPM2B_EVENT {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPM2B_EVENT {
    /// Creates a new instance with the specified values
    pub fn new(
        buffer: Vec<u8>,
        ) -> Self {
        Self {
            buffer,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This type is a sized buffer that can hold a maximally sized buffer for commands that
/// use a large data buffer such as TPM2_Hash(), TPM2_SequenceUpdate(), or TPM2_FieldUpgradeData().
#[derive(Debug, Clone)]
pub struct TPM2B_MAX_BUFFER {
    /// The operand
    pub buffer: Vec<u8>,
}

impl Default for TPM2B_MAX_BUFFER {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPM2B_MAX_BUFFER {
    /// Creates a new instance with the specified values
    pub fn new(
        buffer: Vec<u8>,
        ) -> Self {
        Self {
            buffer,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This type is a sized buffer that can hold a maximally sized buffer for NV data
/// commands such as TPM2_NV_Read(), TPM2_NV_Write(), and TPM2_NV_Certify().
#[derive(Debug, Clone)]
pub struct TPM2B_MAX_NV_BUFFER {
    /// The operand
    /// NOTE MAX_NV_BUFFER_SIZE is TPM-dependent
    pub buffer: Vec<u8>,
}

impl Default for TPM2B_MAX_NV_BUFFER {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPM2B_MAX_NV_BUFFER {
    /// Creates a new instance with the specified values
    pub fn new(
        buffer: Vec<u8>,
        ) -> Self {
        Self {
            buffer,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This TPM-dependent structure is used to provide the timeout value for an
/// authorization. The size shall be 8 or less.
#[derive(Debug, Clone)]
pub struct TPM2B_TIMEOUT {
    /// The timeout value
    pub buffer: Vec<u8>,
}

impl Default for TPM2B_TIMEOUT {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPM2B_TIMEOUT {
    /// Creates a new instance with the specified values
    pub fn new(
        buffer: Vec<u8>,
        ) -> Self {
        Self {
            buffer,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This structure is used for passing an initial value for a symmetric block cipher to or
/// from the TPM. The size is set to be the largest block size of any implemented
/// symmetric cipher implemented on the TPM.
#[derive(Debug, Clone)]
pub struct TPM2B_IV {
    /// The IV value
    pub buffer: Vec<u8>,
}

impl Default for TPM2B_IV {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPM2B_IV {
    /// Creates a new instance with the specified values
    pub fn new(
        buffer: Vec<u8>,
        ) -> Self {
        Self {
            buffer,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This buffer holds a Name for any entity type.
#[derive(Debug, Clone)]
pub struct TPM2B_NAME {
    /// The Name structure
    pub name: Vec<u8>,
}

impl Default for TPM2B_NAME {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPM2B_NAME {
    /// Creates a new instance with the specified values
    pub fn new(
        name: Vec<u8>,
        ) -> Self {
        Self {
            name,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This structure provides a standard method of specifying a list of PCR.
#[derive(Debug, Clone)]
pub struct TPMS_PCR_SELECT {
    /// The bit map of selected PCR
    pub pcr_Select: Vec<u8>,
}

impl Default for TPMS_PCR_SELECT {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPMS_PCR_SELECT {
    /// Creates a new instance with the specified values
    pub fn new(
        pcr_Select: Vec<u8>,
        ) -> Self {
        Self {
            pcr_Select,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// Table 94 Definition of TPMS_PCR_SELECTION Structure
#[derive(Debug, Clone)]
pub struct TPMS_PCR_SELECTION {
    /// The hash algorithm associated with the selection
    pub hash: TPM_ALG_ID,

    /// The bit map of selected PCR
    pub pcr_Select: Vec<u8>,
}

impl Default for TPMS_PCR_SELECTION {
    fn default() -> Self {
        Self {
            hash: TPM_ALG_ID::NULL,
        }
    }
}

impl TPMS_PCR_SELECTION {
    /// Creates a new instance with the specified values
    pub fn new(
        hash: TPM_ALG_ID,
        pcr_Select: Vec<u8>,
        ) -> Self {
        Self {
            hash,
            pcr_Select,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This ticket is produced by TPM2_Create() or TPM2_CreatePrimary(). It is used to bind
/// the creation data to the object to which it applies. The ticket is computed by
#[derive(Debug, Clone)]
pub struct TPMT_TK_CREATION {
    /// The hierarchy containing name
    pub hierarchy: TPM_HANDLE,

    /// This shall be the HMAC produced using a proof value of hierarchy.
    pub digest: Vec<u8>,
}

impl Default for TPMT_TK_CREATION {
    fn default() -> Self {
        Self {
            hierarchy: TPM_HANDLE::default(),
        }
    }
}

impl TPMT_TK_CREATION {
    /// Creates a new instance with the specified values
    pub fn new(
        hierarchy: TPM_HANDLE,
        digest: Vec<u8>,
        ) -> Self {
        Self {
            hierarchy,
            digest,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This ticket is produced by TPM2_VerifySignature(). This formulation is used for
/// multiple ticket uses. The ticket provides evidence that the TPM has validated that a
/// digest was signed by a key with the Name of keyName. The ticket is computed by
#[derive(Debug, Clone)]
pub struct TPMT_TK_VERIFIED {
    /// The hierarchy containing keyName
    pub hierarchy: TPM_HANDLE,

    /// This shall be the HMAC produced using a proof value of hierarchy.
    pub digest: Vec<u8>,
}

impl Default for TPMT_TK_VERIFIED {
    fn default() -> Self {
        Self {
            hierarchy: TPM_HANDLE::default(),
        }
    }
}

impl TPMT_TK_VERIFIED {
    /// Creates a new instance with the specified values
    pub fn new(
        hierarchy: TPM_HANDLE,
        digest: Vec<u8>,
        ) -> Self {
        Self {
            hierarchy,
            digest,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This ticket is produced by TPM2_PolicySigned() and TPM2_PolicySecret() when the
/// authorization has an expiration time. If nonceTPM was provided in the policy command,
/// the ticket is computed by
#[derive(Debug, Clone)]
pub struct TPMT_TK_AUTH {
    /// Ticket structure tag
    pub tag: TPM_ST,

    /// The hierarchy of the object used to produce the ticket
    pub hierarchy: TPM_HANDLE,

    /// This shall be the HMAC produced using a proof value of hierarchy.
    pub digest: Vec<u8>,
}

impl Default for TPMT_TK_AUTH {
    fn default() -> Self {
        Self {
            hierarchy: TPM_HANDLE::default(),
        }
    }
}

impl TPMT_TK_AUTH {
    /// Creates a new instance with the specified values
    pub fn new(
        tag: TPM_ST,
        hierarchy: TPM_HANDLE,
        digest: Vec<u8>,
        ) -> Self {
        Self {
            tag,
            hierarchy,
            digest,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This ticket is produced by TPM2_SequenceComplete() or TPM2_Hash() when the message
/// that was digested did not start with TPM_GENERATED_VALUE. The ticket is computed by
#[derive(Debug, Clone)]
pub struct TPMT_TK_HASHCHECK {
    /// The hierarchy
    pub hierarchy: TPM_HANDLE,

    /// This shall be the HMAC produced using a proof value of hierarchy.
    pub digest: Vec<u8>,
}

impl Default for TPMT_TK_HASHCHECK {
    fn default() -> Self {
        Self {
            hierarchy: TPM_HANDLE::default(),
        }
    }
}

impl TPMT_TK_HASHCHECK {
    /// Creates a new instance with the specified values
    pub fn new(
        hierarchy: TPM_HANDLE,
        digest: Vec<u8>,
        ) -> Self {
        Self {
            hierarchy,
            digest,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This structure is used to report the properties of an algorithm identifier. It is
/// returned in response to a TPM2_GetCapability() with capability = TPM_CAP_ALG.
#[derive(Debug, Clone)]
pub struct TPMS_ALG_PROPERTY {
    /// An algorithm identifier
    pub alg: TPM_ALG_ID,

    /// The attributes of the algorithm
    pub alg_Properties: TPMA_ALGORITHM,
}

impl Default for TPMS_ALG_PROPERTY {
    fn default() -> Self {
        Self {
            alg: TPM_ALG_ID::NULL,
        }
    }
}

impl TPMS_ALG_PROPERTY {
    /// Creates a new instance with the specified values
    pub fn new(
        alg: TPM_ALG_ID,
        alg_Properties: TPMA_ALGORITHM,
        ) -> Self {
        Self {
            alg,
            alg_Properties,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This structure is used to report the properties that are UINT32 values. It is returned
/// in response to a TPM2_GetCapability().
#[derive(Debug, Clone)]
pub struct TPMS_TAGGED_PROPERTY {
    /// A property identifier
    pub property: TPM_PT,

    /// The value of the property
    pub value: u32,
}

impl Default for TPMS_TAGGED_PROPERTY {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPMS_TAGGED_PROPERTY {
    /// Creates a new instance with the specified values
    pub fn new(
        property: TPM_PT,
        value: u32,
        ) -> Self {
        Self {
            property,
            value,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This structure is used in TPM2_GetCapability() to return the attributes of the PCR.
#[derive(Debug, Clone)]
pub struct TPMS_TAGGED_PCR_SELECT {
    /// The property identifier
    pub tag: TPM_PT_PCR,

    /// The bit map of PCR with the identified property
    pub pcr_Select: Vec<u8>,
}

impl Default for TPMS_TAGGED_PCR_SELECT {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPMS_TAGGED_PCR_SELECT {
    /// Creates a new instance with the specified values
    pub fn new(
        tag: TPM_PT_PCR,
        pcr_Select: Vec<u8>,
        ) -> Self {
        Self {
            tag,
            pcr_Select,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This structure is used in TPM2_GetCapability() to return the policy associated with a
/// permanent handle.
#[derive(Debug, Clone)]
pub struct TPMS_TAGGED_POLICY {
    /// A permanent handle
    pub handle: TPM_HANDLE,

    /// The policy algorithm and hash
    pub policy_Hash: TPMT_HA,
}

impl Default for TPMS_TAGGED_POLICY {
    fn default() -> Self {
        Self {
            handle: TPM_HANDLE::default(),
        }
    }
}

impl TPMS_TAGGED_POLICY {
    /// Creates a new instance with the specified values
    pub fn new(
        handle: TPM_HANDLE,
        policy_Hash: TPMT_HA,
        ) -> Self {
        Self {
            handle,
            policy_Hash,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This structure is used in TPM2_GetCapability() to return the ACT data.
#[derive(Debug, Clone)]
pub struct TPMS_ACT_DATA {
    /// A permanent handle
    pub handle: TPM_HANDLE,

    /// The current timeout of the ACT
    pub timeout: u32,

    /// The state of the ACT
    pub attributes: TPMA_ACT,
}

impl Default for TPMS_ACT_DATA {
    fn default() -> Self {
        Self {
            handle: TPM_HANDLE::default(),
        }
    }
}

impl TPMS_ACT_DATA {
    /// Creates a new instance with the specified values
    pub fn new(
        handle: TPM_HANDLE,
        timeout: u32,
        attributes: TPMA_ACT,
        ) -> Self {
        Self {
            handle,
            timeout,
            attributes,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// A list of command codes may be input to the TPM or returned by the TPM depending on
/// the command.
#[derive(Debug, Clone)]
pub struct TPML_CC {
    /// A list of command codes
    /// The maximum only applies to a command code list in a command. The response size is
    /// limited only by the size of the parameter buffer.
    pub command_Codes: Vec<TPM_CC>,
}

impl Default for TPML_CC {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPML_CC {
    /// Creates a new instance with the specified values
    pub fn new(
        command_Codes: Vec<TPM_CC>,
        ) -> Self {
        Self {
            command_Codes,
        }
    }

    // Union trait implementations
    impl TpmUnion for TPML_CC {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
            TPMU_CAPABILITIES::PP_COMMANDS as u32
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This list is only used in TPM2_GetCapability(capability = TPM_CAP_COMMANDS).
#[derive(Debug, Clone)]
pub struct TPML_CCA {
    /// A list of command codes attributes
    pub command_Attributes: Vec<TPMA_CC>,
}

impl Default for TPML_CCA {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPML_CCA {
    /// Creates a new instance with the specified values
    pub fn new(
        command_Attributes: Vec<TPMA_CC>,
        ) -> Self {
        Self {
            command_Attributes,
        }
    }

    // Union trait implementations
    impl TpmUnion for TPML_CCA {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
            TPMU_CAPABILITIES::COMMANDS as u32
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This list is returned by TPM2_IncrementalSelfTest().
#[derive(Debug, Clone)]
pub struct TPML_ALG {
    /// A list of algorithm IDs
    /// The maximum only applies to an algorithm list in a command. The response size is
    /// limited only by the size of the parameter buffer.
    pub algorithms: Vec<TPM_ALG_ID>,
}

impl Default for TPML_ALG {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPML_ALG {
    /// Creates a new instance with the specified values
    pub fn new(
        algorithms: Vec<TPM_ALG_ID>,
        ) -> Self {
        Self {
            algorithms,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This structure is used when the TPM returns a list of loaded handles when the
/// capability in TPM2_GetCapability() is TPM_CAP_HANDLE.
#[derive(Debug, Clone)]
pub struct TPML_HANDLE {
    /// An array of handles
    pub handle: Vec<TPM_HANDLE>,
}

impl Default for TPML_HANDLE {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPML_HANDLE {
    /// Creates a new instance with the specified values
    pub fn new(
        handle: Vec<TPM_HANDLE>,
        ) -> Self {
        Self {
            handle,
        }
    }

    // Union trait implementations
    impl TpmUnion for TPML_HANDLE {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
            TPMU_CAPABILITIES::HANDLES as u32
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This list is used to convey a list of digest values. This type is used in
/// TPM2_PolicyOR() and in TPM2_PCR_Read().
#[derive(Debug, Clone)]
pub struct TPML_DIGEST {
    /// A list of digests
    /// For TPM2_PolicyOR(), all digests will have been computed using the digest of the
    /// policy session. For TPM2_PCR_Read(), each digest will be the size of the digest for
    /// the bank containing the PCR.
    pub digests: Vec<TPM2B_DIGEST>,
}

impl Default for TPML_DIGEST {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPML_DIGEST {
    /// Creates a new instance with the specified values
    pub fn new(
        digests: Vec<TPM2B_DIGEST>,
        ) -> Self {
        Self {
            digests,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This list is used to convey a list of digest values. This type is returned by
/// TPM2_PCR_Event() and TPM2_EventSequenceComplete() and is an input for TPM2_PCR_Extend().
#[derive(Debug, Clone)]
pub struct TPML_DIGEST_VALUES {
    /// A list of tagged digests
    pub digests: Vec<TPMT_HA>,
}

impl Default for TPML_DIGEST_VALUES {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPML_DIGEST_VALUES {
    /// Creates a new instance with the specified values
    pub fn new(
        digests: Vec<TPMT_HA>,
        ) -> Self {
        Self {
            digests,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This list is used to indicate the PCR that are included in a selection when more than
/// one PCR value may be selected.
#[derive(Debug, Clone)]
pub struct TPML_PCR_SELECTION {
    /// List of selections
    pub pcr_Selections: Vec<TPMS_PCR_SELECTION>,
}

impl Default for TPML_PCR_SELECTION {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPML_PCR_SELECTION {
    /// Creates a new instance with the specified values
    pub fn new(
        pcr_Selections: Vec<TPMS_PCR_SELECTION>,
        ) -> Self {
        Self {
            pcr_Selections,
        }
    }

    // Union trait implementations
    impl TpmUnion for TPML_PCR_SELECTION {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
            TPMU_CAPABILITIES::PCRS as u32
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This list is used to report on a list of algorithm attributes. It is returned in a
/// TPM2_GetCapability().
#[derive(Debug, Clone)]
pub struct TPML_ALG_PROPERTY {
    /// List of properties
    pub alg_Properties: Vec<TPMS_ALG_PROPERTY>,
}

impl Default for TPML_ALG_PROPERTY {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPML_ALG_PROPERTY {
    /// Creates a new instance with the specified values
    pub fn new(
        alg_Properties: Vec<TPMS_ALG_PROPERTY>,
        ) -> Self {
        Self {
            alg_Properties,
        }
    }

    // Union trait implementations
    impl TpmUnion for TPML_ALG_PROPERTY {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
            TPMU_CAPABILITIES::ALGS as u32
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This list is used to report on a list of properties that are TPMS_TAGGED_PROPERTY
/// values. It is returned by a TPM2_GetCapability().
#[derive(Debug, Clone)]
pub struct TPML_TAGGED_TPM_PROPERTY {
    /// An array of tagged properties
    pub tpm_Property: Vec<TPMS_TAGGED_PROPERTY>,
}

impl Default for TPML_TAGGED_TPM_PROPERTY {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPML_TAGGED_TPM_PROPERTY {
    /// Creates a new instance with the specified values
    pub fn new(
        tpm_Property: Vec<TPMS_TAGGED_PROPERTY>,
        ) -> Self {
        Self {
            tpm_Property,
        }
    }

    // Union trait implementations
    impl TpmUnion for TPML_TAGGED_TPM_PROPERTY {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
            TPMU_CAPABILITIES::TPM_PROPERTIES as u32
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This list is used to report on a list of properties that are TPMS_PCR_SELECT values.
/// It is returned by a TPM2_GetCapability().
#[derive(Debug, Clone)]
pub struct TPML_TAGGED_PCR_PROPERTY {
    /// A tagged PCR selection
    pub pcr_Property: Vec<TPMS_TAGGED_PCR_SELECT>,
}

impl Default for TPML_TAGGED_PCR_PROPERTY {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPML_TAGGED_PCR_PROPERTY {
    /// Creates a new instance with the specified values
    pub fn new(
        pcr_Property: Vec<TPMS_TAGGED_PCR_SELECT>,
        ) -> Self {
        Self {
            pcr_Property,
        }
    }

    // Union trait implementations
    impl TpmUnion for TPML_TAGGED_PCR_PROPERTY {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
            TPMU_CAPABILITIES::PCR_PROPERTIES as u32
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This list is used to report the ECC curve ID values supported by the TPM. It is
/// returned by a TPM2_GetCapability().
#[derive(Debug, Clone)]
pub struct TPML_ECC_CURVE {
    /// Array of ECC curve identifiers
    pub ecc_Curves: Vec<TPM_ECC_CURVE>,
}

impl Default for TPML_ECC_CURVE {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPML_ECC_CURVE {
    /// Creates a new instance with the specified values
    pub fn new(
        ecc_Curves: Vec<TPM_ECC_CURVE>,
        ) -> Self {
        Self {
            ecc_Curves,
        }
    }

    // Union trait implementations
    impl TpmUnion for TPML_ECC_CURVE {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
            TPMU_CAPABILITIES::ECC_CURVES as u32
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This list is used to report the authorization policy values for permanent handles.
/// This is list may be generated by TPM2_GetCapabiltiy(). A permanent handle that cannot
/// have a policy is not included in the list.
#[derive(Debug, Clone)]
pub struct TPML_TAGGED_POLICY {
    /// Array of tagged policies
    pub policies: Vec<TPMS_TAGGED_POLICY>,
}

impl Default for TPML_TAGGED_POLICY {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPML_TAGGED_POLICY {
    /// Creates a new instance with the specified values
    pub fn new(
        policies: Vec<TPMS_TAGGED_POLICY>,
        ) -> Self {
        Self {
            policies,
        }
    }

    // Union trait implementations
    impl TpmUnion for TPML_TAGGED_POLICY {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
            TPMU_CAPABILITIES::AUTH_POLICIES as u32
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This list is used to report the timeout and state for the ACT. This list may be
/// generated by TPM2_GetCapabilty(). Only implemented ACT are present in the list
#[derive(Debug, Clone)]
pub struct TPML_ACT_DATA {
    /// Array of ACT data
    pub act_Data: Vec<TPMS_ACT_DATA>,
}

impl Default for TPML_ACT_DATA {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPML_ACT_DATA {
    /// Creates a new instance with the specified values
    pub fn new(
        act_Data: Vec<TPMS_ACT_DATA>,
        ) -> Self {
        Self {
            act_Data,
        }
    }

    // Union trait implementations
    impl TpmUnion for TPML_ACT_DATA {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
            TPMU_CAPABILITIES::ACT as u32
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This data area is returned in response to a TPM2_GetCapability().
#[derive(Debug, Clone)]
pub struct TPMS_CAPABILITY_DATA {
    /// The capability

    /// The capability data
    /// One of: TPML_ALG_PROPERTY, TPML_HANDLE, TPML_CCA, TPML_CC, TPML_PCR_SELECTION,
    /// TPML_TAGGED_TPM_PROPERTY, TPML_TAGGED_PCR_PROPERTY, TPML_ECC_CURVE,
    /// TPML_TAGGED_POLICY, TPML_ACT_DATA.
    pub data: TPMU_CAPABILITIES,
}

impl Default for TPMS_CAPABILITY_DATA {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPMS_CAPABILITY_DATA {
    /// Creates a new instance with the specified values
    pub fn new(
        data: TPMU_CAPABILITIES,
        ) -> Self {
        Self {
            data,
        }
    }

    /// Get the capability selector value
    pub fn capability(&self) -> TPM_CAP {
        match &self.data {
        Some(u) => u.get_union_selector() as _,
            None => 0 as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This structure is used in each of the attestation commands.
#[derive(Debug, Clone)]
pub struct TPMS_CLOCK_INFO {
    /// Time value in milliseconds that advances while the TPM is powered
    /// NOTE The interpretation of the time-origin (clock=0) is out of the scope of this
    /// specification, although Coordinated Universal Time (UTC) is expected to be a common
    /// convention. This structure element is used to report on the TPM's Clock value.
    /// This value is reset to zero when the Storage Primary Seed is changed (TPM2_Clear()).
    /// This value may be advanced by TPM2_ClockSet().
    pub clock: u64,

    /// Number of occurrences of TPM Reset since the last TPM2_Clear()
    pub reset_Count: u32,

    /// Number of times that TPM2_Shutdown() or _TPM_Hash_Start have occurred since the last
    /// TPM Reset or TPM2_Clear().
    pub restart_Count: u32,

    /// No value of Clock greater than the current value of Clock has been previously reported
    /// by the TPM. Set to YES on TPM2_Clear().
    pub safe: u8,
}

impl Default for TPMS_CLOCK_INFO {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPMS_CLOCK_INFO {
    /// Creates a new instance with the specified values
    pub fn new(
        clock: u64,
        reset_Count: u32,
        restart_Count: u32,
        safe: u8,
        ) -> Self {
        Self {
            clock,
            reset_Count,
            restart_Count,
            safe,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This structure is used in, e.g., the TPM2_GetTime() attestation and TPM2_ReadClock().
#[derive(Debug, Clone)]
pub struct TPMS_TIME_INFO {
    /// Time in milliseconds since the TIme circuit was last reset
    /// This structure element is used to report on the TPM's Time value.
    pub time: u64,

    /// A structure containing the clock information
    pub clock_Info: TPMS_CLOCK_INFO,
}

impl Default for TPMS_TIME_INFO {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPMS_TIME_INFO {
    /// Creates a new instance with the specified values
    pub fn new(
        time: u64,
        clock_Info: TPMS_CLOCK_INFO,
        ) -> Self {
        Self {
            time,
            clock_Info,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This structure is used when the TPM performs TPM2_GetTime.
#[derive(Debug, Clone)]
pub struct TPMS_TIME_ATTEST_INFO {
    /// The Time, Clock, resetCount, restartCount, and Safe indicator
    pub time: TPMS_TIME_INFO,

    /// A TPM vendor-specific value indicating the version number of the firmware
    pub firmware_Version: u64,
}

impl Default for TPMS_TIME_ATTEST_INFO {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPMS_TIME_ATTEST_INFO {
    /// Creates a new instance with the specified values
    pub fn new(
        time: TPMS_TIME_INFO,
        firmware_Version: u64,
        ) -> Self {
        Self {
            time,
            firmware_Version,
        }
    }

    // Union trait implementations
    impl TpmUnion for TPMS_TIME_ATTEST_INFO {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
            TPMU_ATTEST::ATTEST_TIME as u32
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This is the attested data for TPM2_Certify().
#[derive(Debug, Clone)]
pub struct TPMS_CERTIFY_INFO {
    /// Name of the certified object
    pub name: Vec<u8>,

    /// Qualified Name of the certified object
    pub qualified_Name: Vec<u8>,
}

impl Default for TPMS_CERTIFY_INFO {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPMS_CERTIFY_INFO {
    /// Creates a new instance with the specified values
    pub fn new(
        name: Vec<u8>,
        qualified_Name: Vec<u8>,
        ) -> Self {
        Self {
            name,
            qualified_Name,
        }
    }

    // Union trait implementations
    impl TpmUnion for TPMS_CERTIFY_INFO {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
            TPMU_ATTEST::ATTEST_CERTIFY as u32
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This is the attested data for TPM2_Quote().
#[derive(Debug, Clone)]
pub struct TPMS_QUOTE_INFO {
    /// Information on algID, PCR selected and digest
    pub pcr_Select: Vec<TPMS_PCR_SELECTION>,

    /// Digest of the selected PCR using the hash of the signing key
    pub pcr_Digest: Vec<u8>,
}

impl Default for TPMS_QUOTE_INFO {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPMS_QUOTE_INFO {
    /// Creates a new instance with the specified values
    pub fn new(
        pcr_Select: Vec<TPMS_PCR_SELECTION>,
        pcr_Digest: Vec<u8>,
        ) -> Self {
        Self {
            pcr_Select,
            pcr_Digest,
        }
    }

    // Union trait implementations
    impl TpmUnion for TPMS_QUOTE_INFO {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
            TPMU_ATTEST::ATTEST_QUOTE as u32
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This is the attested data for TPM2_GetCommandAuditDigest().
#[derive(Debug, Clone)]
pub struct TPMS_COMMAND_AUDIT_INFO {
    /// The monotonic audit counter
    pub audit_Counter: u64,

    /// Hash algorithm used for the command audit
    pub digest_Alg: TPM_ALG_ID,

    /// The current value of the audit digest
    pub audit_Digest: Vec<u8>,

    /// Digest of the command codes being audited using digestAlg
    pub command_Digest: Vec<u8>,
}

impl Default for TPMS_COMMAND_AUDIT_INFO {
    fn default() -> Self {
        Self {
            digestAlg: TPM_ALG_ID::NULL,
        }
    }
}

impl TPMS_COMMAND_AUDIT_INFO {
    /// Creates a new instance with the specified values
    pub fn new(
        audit_Counter: u64,
        digest_Alg: TPM_ALG_ID,
        audit_Digest: Vec<u8>,
        command_Digest: Vec<u8>,
        ) -> Self {
        Self {
            audit_Counter,
            digest_Alg,
            audit_Digest,
            command_Digest,
        }
    }

    // Union trait implementations
    impl TpmUnion for TPMS_COMMAND_AUDIT_INFO {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
            TPMU_ATTEST::ATTEST_COMMAND_AUDIT as u32
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This is the attested data for TPM2_GetSessionAuditDigest().
#[derive(Debug, Clone)]
pub struct TPMS_SESSION_AUDIT_INFO {
    /// Current exclusive status of the session
    /// TRUE if all of the commands recorded in the sessionDigest were executed without any
    /// intervening TPM command that did not use this audit session
    pub exclusive_Session: u8,

    /// The current value of the session audit digest
    pub session_Digest: Vec<u8>,
}

impl Default for TPMS_SESSION_AUDIT_INFO {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPMS_SESSION_AUDIT_INFO {
    /// Creates a new instance with the specified values
    pub fn new(
        exclusive_Session: u8,
        session_Digest: Vec<u8>,
        ) -> Self {
        Self {
            exclusive_Session,
            session_Digest,
        }
    }

    // Union trait implementations
    impl TpmUnion for TPMS_SESSION_AUDIT_INFO {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
            TPMU_ATTEST::ATTEST_SESSION_AUDIT as u32
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This is the attested data for TPM2_CertifyCreation().
#[derive(Debug, Clone)]
pub struct TPMS_CREATION_INFO {
    /// Name of the object
    pub object_Name: Vec<u8>,

    /// CreationHash
    pub creation_Hash: Vec<u8>,
}

impl Default for TPMS_CREATION_INFO {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPMS_CREATION_INFO {
    /// Creates a new instance with the specified values
    pub fn new(
        object_Name: Vec<u8>,
        creation_Hash: Vec<u8>,
        ) -> Self {
        Self {
            object_Name,
            creation_Hash,
        }
    }

    // Union trait implementations
    impl TpmUnion for TPMS_CREATION_INFO {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
            TPMU_ATTEST::ATTEST_CREATION as u32
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This structure contains the Name and contents of the selected NV Index that is
/// certified by TPM2_NV_Certify().
#[derive(Debug, Clone)]
pub struct TPMS_NV_CERTIFY_INFO {
    /// Name of the NV Index
    pub index_Name: Vec<u8>,

    /// The offset parameter of TPM2_NV_Certify()
    pub offset: u16,

    /// Contents of the NV Index
    pub nv_Contents: Vec<u8>,
}

impl Default for TPMS_NV_CERTIFY_INFO {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPMS_NV_CERTIFY_INFO {
    /// Creates a new instance with the specified values
    pub fn new(
        index_Name: Vec<u8>,
        offset: u16,
        nv_Contents: Vec<u8>,
        ) -> Self {
        Self {
            index_Name,
            offset,
            nv_Contents,
        }
    }

    // Union trait implementations
    impl TpmUnion for TPMS_NV_CERTIFY_INFO {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
            TPMU_ATTEST::ATTEST_NV as u32
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This structure contains the Name and hash of the contents of the selected NV Index
/// that is certified by TPM2_NV_Certify(). The data is hashed using hash of the signing scheme.
#[derive(Debug, Clone)]
pub struct TPMS_NV_DIGEST_CERTIFY_INFO {
    /// Name of the NV Index
    pub index_Name: Vec<u8>,

    /// Hash of the contents of the index
    pub nv_Digest: Vec<u8>,
}

impl Default for TPMS_NV_DIGEST_CERTIFY_INFO {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPMS_NV_DIGEST_CERTIFY_INFO {
    /// Creates a new instance with the specified values
    pub fn new(
        index_Name: Vec<u8>,
        nv_Digest: Vec<u8>,
        ) -> Self {
        Self {
            index_Name,
            nv_Digest,
        }
    }

    // Union trait implementations
    impl TpmUnion for TPMS_NV_DIGEST_CERTIFY_INFO {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
            TPMU_ATTEST::ATTEST_NV_DIGEST as u32
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This structure is used on each TPM-generated signed structure. The signature is over
/// this structure.
#[derive(Debug, Clone)]
pub struct TPMS_ATTEST {
    /// The indication that this structure was created by a TPM (always TPM_GENERATED_VALUE)
    pub magic: TPM_GENERATED,

    /// Type of the attestation structure

    /// Qualified Name of the signing key
    pub qualified_Signer: Vec<u8>,

    /// External information supplied by caller
    /// NOTE A TPM2B_DATA structure provides room for a digest and a method indicator to
    /// indicate the components of the digest. The definition of this method indicator is
    /// outside the scope of this specification.
    pub extra_Data: Vec<u8>,

    /// Clock, resetCount, restartCount, and Safe
    pub clock_Info: TPMS_CLOCK_INFO,

    /// TPM-vendor-specific value identifying the version number of the firmware
    pub firmware_Version: u64,

    /// The type-specific attestation information
    /// One of: TPMS_CERTIFY_INFO, TPMS_CREATION_INFO, TPMS_QUOTE_INFO,
    /// TPMS_COMMAND_AUDIT_INFO, TPMS_SESSION_AUDIT_INFO, TPMS_TIME_ATTEST_INFO,
    /// TPMS_NV_CERTIFY_INFO, TPMS_NV_DIGEST_CERTIFY_INFO.
    pub attested: TPMU_ATTEST,
}

impl Default for TPMS_ATTEST {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPMS_ATTEST {
    /// Creates a new instance with the specified values
    pub fn new(
        magic: TPM_GENERATED,
        qualified_Signer: Vec<u8>,
        extra_Data: Vec<u8>,
        clock_Info: TPMS_CLOCK_INFO,
        firmware_Version: u64,
        attested: TPMU_ATTEST,
        ) -> Self {
        Self {
            magic,
            qualified_Signer,
            extra_Data,
            clock_Info,
            firmware_Version,
            attested,
        }
    }

    /// Get the type selector value
    pub fn type(&self) -> TPM_ST {
        match &self.attested {
        Some(u) => u.get_union_selector() as _,
            None => 0 as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This sized buffer to contain the signed structure. The attestationData is the signed
/// portion of the structure. The size parameter is not signed.
#[derive(Debug, Clone)]
pub struct TPM2B_ATTEST {
    /// The signed structure
    pub attestation_Data: TPMS_ATTEST,
}

impl Default for TPM2B_ATTEST {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPM2B_ATTEST {
    /// Creates a new instance with the specified values
    pub fn new(
        attestation_Data: TPMS_ATTEST,
        ) -> Self {
        Self {
            attestation_Data,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This is the format used for each of the authorizations in the session area of a command.
#[derive(Debug, Clone)]
pub struct TPMS_AUTH_COMMAND {
    /// The session handle
    pub session_Handle: TPM_HANDLE,

    /// The session nonce, may be the Empty Buffer
    pub nonce: Vec<u8>,

    /// The session attributes
    pub session_Attributes: TPMA_SESSION,

    /// Either an HMAC, a password, or an EmptyAuth
    pub hmac: Vec<u8>,
}

impl Default for TPMS_AUTH_COMMAND {
    fn default() -> Self {
        Self {
            sessionHandle: TPM_HANDLE::default(),
        }
    }
}

impl TPMS_AUTH_COMMAND {
    /// Creates a new instance with the specified values
    pub fn new(
        session_Handle: TPM_HANDLE,
        nonce: Vec<u8>,
        session_Attributes: TPMA_SESSION,
        hmac: Vec<u8>,
        ) -> Self {
        Self {
            session_Handle,
            nonce,
            session_Attributes,
            hmac,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This is the format for each of the authorizations in the session area of the response.
/// If the TPM returns TPM_RC_SUCCESS, then the session area of the response contains the
/// same number of authorizations as the command and the authorizations are in the same order.
#[derive(Debug, Clone)]
pub struct TPMS_AUTH_RESPONSE {
    /// The session nonce, may be the Empty Buffer
    pub nonce: Vec<u8>,

    /// The session attributes
    pub session_Attributes: TPMA_SESSION,

    /// Either an HMAC or an EmptyAuth
    pub hmac: Vec<u8>,
}

impl Default for TPMS_AUTH_RESPONSE {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPMS_AUTH_RESPONSE {
    /// Creates a new instance with the specified values
    pub fn new(
        nonce: Vec<u8>,
        session_Attributes: TPMA_SESSION,
        hmac: Vec<u8>,
        ) -> Self {
        Self {
            nonce,
            session_Attributes,
            hmac,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_TDES for the union TPMU_SYM_DETAILS
#[derive(Debug, Clone)]
pub struct TPMS_TDES_SYM_DETAILS {
}

impl Default for TPMS_TDES_SYM_DETAILS {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPMS_TDES_SYM_DETAILS {
    // Union trait implementations
    impl TpmUnion for TPMS_TDES_SYM_DETAILS {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
            TPMU_SYM_DETAILS::TDES as u32
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_AES for the union TPMU_SYM_DETAILS
#[derive(Debug, Clone)]
pub struct TPMS_AES_SYM_DETAILS {
}

impl Default for TPMS_AES_SYM_DETAILS {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPMS_AES_SYM_DETAILS {
    // Union trait implementations
    impl TpmUnion for TPMS_AES_SYM_DETAILS {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
            TPMU_SYM_DETAILS::AES as u32
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_SM4 for the union TPMU_SYM_DETAILS
#[derive(Debug, Clone)]
pub struct TPMS_SM4_SYM_DETAILS {
}

impl Default for TPMS_SM4_SYM_DETAILS {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPMS_SM4_SYM_DETAILS {
    // Union trait implementations
    impl TpmUnion for TPMS_SM4_SYM_DETAILS {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
            TPMU_SYM_DETAILS::SM4 as u32
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_CAMELLIA for the union TPMU_SYM_DETAILS
#[derive(Debug, Clone)]
pub struct TPMS_CAMELLIA_SYM_DETAILS {
}

impl Default for TPMS_CAMELLIA_SYM_DETAILS {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPMS_CAMELLIA_SYM_DETAILS {
    // Union trait implementations
    impl TpmUnion for TPMS_CAMELLIA_SYM_DETAILS {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
            TPMU_SYM_DETAILS::CAMELLIA as u32
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_ANY for the union TPMU_SYM_DETAILS
#[derive(Debug, Clone)]
pub struct TPMS_ANY_SYM_DETAILS {
}

impl Default for TPMS_ANY_SYM_DETAILS {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPMS_ANY_SYM_DETAILS {
    // Union trait implementations
    impl TpmUnion for TPMS_ANY_SYM_DETAILS {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
            TPMU_SYM_DETAILS::ANY as u32
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_XOR for the union TPMU_SYM_DETAILS
#[derive(Debug, Clone)]
pub struct TPMS_XOR_SYM_DETAILS {
}

impl Default for TPMS_XOR_SYM_DETAILS {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPMS_XOR_SYM_DETAILS {
    // Union trait implementations
    impl TpmUnion for TPMS_XOR_SYM_DETAILS {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
            TPMU_SYM_DETAILS::XOR as u32
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TPMU_SYM_DETAILS
#[derive(Debug, Clone)]
pub struct TPMS_NULL_SYM_DETAILS {
}

impl Default for TPMS_NULL_SYM_DETAILS {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPMS_NULL_SYM_DETAILS {
    // Union trait implementations
    impl TpmUnion for TPMS_NULL_SYM_DETAILS {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
            TPMU_SYM_DETAILS::NULL as u32
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// The TPMT_SYM_DEF structure is used to select an algorithm to be used for parameter
/// encryption in those cases when different symmetric algorithms may be selected.
#[derive(Debug, Clone)]
pub struct TPMT_SYM_DEF {
    /// Indicates a symmetric algorithm
    pub algorithm: TPM_ALG_ID,

    /// A supported key size
    pub key_Bits: u16,

    /// The mode for the key
    pub mode: TPM_ALG_ID,
}

impl Default for TPMT_SYM_DEF {
    fn default() -> Self {
        Self {
            algorithm: TPM_ALG_ID::NULL,
            mode: TPM_ALG_ID::NULL,
        }
    }
}

impl TPMT_SYM_DEF {
    /// Creates a new instance with the specified values
    pub fn new(
        algorithm: TPM_ALG_ID,
        key_Bits: u16,
        mode: TPM_ALG_ID,
        ) -> Self {
        Self {
            algorithm,
            key_Bits,
            mode,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This structure is used when different symmetric block cipher (not XOR) algorithms may
/// be selected. If the Object can be an ordinary parent (not a derivation parent), this
/// must be the first field in the Object's parameter (see 12.2.3.7) field.
#[derive(Debug, Clone)]
pub struct TPMT_SYM_DEF_OBJECT {
    /// Selects a symmetric block cipher
    /// When used in the parameter area of a parent object, this shall be a supported block
    /// cipher and not TPM_ALG_NULL
    pub algorithm: TPM_ALG_ID,

    /// The key size
    pub key_Bits: u16,

    /// Default mode
    /// When used in the parameter area of a parent object, this shall be TPM_ALG_CFB.
    pub mode: TPM_ALG_ID,
}

impl Default for TPMT_SYM_DEF_OBJECT {
    fn default() -> Self {
        Self {
            algorithm: TPM_ALG_ID::NULL,
            mode: TPM_ALG_ID::NULL,
        }
    }
}

impl TPMT_SYM_DEF_OBJECT {
    /// Creates a new instance with the specified values
    pub fn new(
        algorithm: TPM_ALG_ID,
        key_Bits: u16,
        mode: TPM_ALG_ID,
        ) -> Self {
        Self {
            algorithm,
            key_Bits,
            mode,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This structure is used to hold a symmetric key in the sensitive area of an asymmetric object.
#[derive(Debug, Clone)]
pub struct TPM2B_SYM_KEY {
    /// The key
    pub buffer: Vec<u8>,
}

impl Default for TPM2B_SYM_KEY {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPM2B_SYM_KEY {
    /// Creates a new instance with the specified values
    pub fn new(
        buffer: Vec<u8>,
        ) -> Self {
        Self {
            buffer,
        }
    }

    // Union trait implementations
    impl TpmUnion for TPM2B_SYM_KEY {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
            TPMU_SENSITIVE_COMPOSITE::SYMCIPHER as u32
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This structure contains the parameters for a symmetric block cipher object.
#[derive(Debug, Clone)]
pub struct TPMS_SYMCIPHER_PARMS {
    /// A symmetric block cipher
    pub sym: TPMT_SYM_DEF_OBJECT,
}

impl Default for TPMS_SYMCIPHER_PARMS {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPMS_SYMCIPHER_PARMS {
    /// Creates a new instance with the specified values
    pub fn new(
        sym: TPMT_SYM_DEF_OBJECT,
        ) -> Self {
        Self {
            sym,
        }
    }

    // Union trait implementations
    impl TpmUnion for TPMS_SYMCIPHER_PARMS {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
            TPMU_PUBLIC_PARMS::SYMCIPHER as u32
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This buffer holds a label or context value. For interoperability and backwards
/// compatibility, LABEL_MAX_BUFFER is the minimum of the largest digest on the device and
/// the largest ECC parameter (MAX_ECC_KEY_BYTES) but no more than 32 bytes.
#[derive(Debug, Clone)]
pub struct TPM2B_LABEL {
    /// Symmetric data for a created object or the label and context for a derived object
    pub buffer: Vec<u8>,
}

impl Default for TPM2B_LABEL {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPM2B_LABEL {
    /// Creates a new instance with the specified values
    pub fn new(
        buffer: Vec<u8>,
        ) -> Self {
        Self {
            buffer,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This structure contains the label and context fields for a derived object. These
/// values are used in the derivation KDF. The values in the unique field of inPublic area
/// template take precedence over the values in the inSensitive parameter.
#[derive(Debug, Clone)]
pub struct TPMS_DERIVE {
    pub label: Vec<u8>,
    pub context: Vec<u8>,
}

impl Default for TPMS_DERIVE {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPMS_DERIVE {
    /// Creates a new instance with the specified values
    pub fn new(
        label: Vec<u8>,
        context: Vec<u8>,
        ) -> Self {
        Self {
            label,
            context,
        }
    }

    // Union trait implementations
    impl TpmUnion for TPMS_DERIVE {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
            TPMU_SENSITIVE_CREATE::ANY2 as u32
        }
    }

    impl TpmUnion for TPMS_DERIVE {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
            TPMU_SENSITIVE_CREATE::ANY2 as u32
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// Table 147 Definition of TPM2B_DERIVE Structure
#[derive(Debug, Clone)]
pub struct TPM2B_DERIVE {
    /// Symmetric data for a created object or the label and context for a derived object
    pub buffer: TPMS_DERIVE,
}

impl Default for TPM2B_DERIVE {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPM2B_DERIVE {
    /// Creates a new instance with the specified values
    pub fn new(
        buffer: TPMS_DERIVE,
        ) -> Self {
        Self {
            buffer,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This buffer wraps the TPMU_SENSITIVE_CREATE structure.
#[derive(Debug, Clone)]
pub struct TPM2B_SENSITIVE_DATA {
    /// Symmetric data for a created object or the label and context for a derived object
    pub buffer: Vec<u8>,
}

impl Default for TPM2B_SENSITIVE_DATA {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPM2B_SENSITIVE_DATA {
    /// Creates a new instance with the specified values
    pub fn new(
        buffer: Vec<u8>,
        ) -> Self {
        Self {
            buffer,
        }
    }

    // Union trait implementations
    impl TpmUnion for TPM2B_SENSITIVE_DATA {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
            TPMU_SENSITIVE_COMPOSITE::KEYEDHASH as u32
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This structure defines the values to be placed in the sensitive area of a created
/// object. This structure is only used within a TPM2B_SENSITIVE_CREATE structure.
#[derive(Debug, Clone)]
pub struct TPMS_SENSITIVE_CREATE {
    /// The USER auth secret value
    pub user_Auth: Vec<u8>,

    /// Data to be sealed, a key, or derivation values
    pub data: Vec<u8>,
}

impl Default for TPMS_SENSITIVE_CREATE {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPMS_SENSITIVE_CREATE {
    /// Creates a new instance with the specified values
    pub fn new(
        user_Auth: Vec<u8>,
        data: Vec<u8>,
        ) -> Self {
        Self {
            user_Auth,
            data,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This structure contains the sensitive creation data in a sized buffer. This structure
/// is defined so that both the userAuth and data values of the TPMS_SENSITIVE_CREATE may
/// be passed as a single parameter for parameter encryption purposes.
#[derive(Debug, Clone)]
pub struct TPM2B_SENSITIVE_CREATE {
    /// Data to be sealed or a symmetric key value.
    pub sensitive: TPMS_SENSITIVE_CREATE,
}

impl Default for TPM2B_SENSITIVE_CREATE {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPM2B_SENSITIVE_CREATE {
    /// Creates a new instance with the specified values
    pub fn new(
        sensitive: TPMS_SENSITIVE_CREATE,
        ) -> Self {
        Self {
            sensitive,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This structure is the scheme data for schemes that only require a hash to complete
/// their definition.
#[derive(Debug, Clone)]
pub struct TPMS_SCHEME_HASH {
    /// The hash algorithm used to digest the message
    pub hash_Alg: TPM_ALG_ID,
}

impl Default for TPMS_SCHEME_HASH {
    fn default() -> Self {
        Self {
            hashAlg: TPM_ALG_ID::NULL,
        }
    }
}

impl TPMS_SCHEME_HASH {
    /// Creates a new instance with the specified values
    pub fn new(
        hash_Alg: TPM_ALG_ID,
        ) -> Self {
        Self {
            hash_Alg,
        }
    }

    // Union trait implementations
    impl TpmUnion for TPMS_SCHEME_HASH {
    }

    impl TpmUnion for TPMS_SCHEME_HASH {
    }

    impl TpmUnion for TPMS_SCHEME_HASH {
    }

    impl TpmUnion for TPMS_SCHEME_HASH {
    }

    impl TpmUnion for TPMS_SCHEME_HASH {
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This definition is for split signing schemes that require a commit count.
#[derive(Debug, Clone)]
pub struct TPMS_SCHEME_ECDAA {
    /// The hash algorithm used to digest the message
    pub hash_Alg: TPM_ALG_ID,

    /// The counter value that is used between TPM2_Commit() and the sign operation
    pub count: u16,
}

impl Default for TPMS_SCHEME_ECDAA {
    fn default() -> Self {
        Self {
            hashAlg: TPM_ALG_ID::NULL,
        }
    }
}

impl TPMS_SCHEME_ECDAA {
    /// Creates a new instance with the specified values
    pub fn new(
        hash_Alg: TPM_ALG_ID,
        count: u16,
        ) -> Self {
        Self {
            hash_Alg,
            count,
        }
    }

    // Union trait implementations
    impl TpmUnion for TPMS_SCHEME_ECDAA {
    }

    impl TpmUnion for TPMS_SCHEME_ECDAA {
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// Table 155 Definition of Types for HMAC_SIG_SCHEME
#[derive(Debug, Clone)]
pub struct TPMS_SCHEME_HMAC {
}

impl Default for TPMS_SCHEME_HMAC {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPMS_SCHEME_HMAC {
    // Union trait implementations
    impl TpmUnion for TPMS_SCHEME_HMAC {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
            TPMU_SCHEME_KEYEDHASH::HMAC as u32
        }
    }

    impl TpmUnion for TPMS_SCHEME_HMAC {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
            TPMU_SCHEME_KEYEDHASH::HMAC as u32
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This structure is for the XOR encryption scheme.
#[derive(Debug, Clone)]
pub struct TPMS_SCHEME_XOR {
    /// The hash algorithm used to digest the message
    pub hash_Alg: TPM_ALG_ID,

    /// The key derivation function
    pub kdf: TPM_ALG_ID,
}

impl Default for TPMS_SCHEME_XOR {
    fn default() -> Self {
        Self {
            hashAlg: TPM_ALG_ID::NULL,
            kdf: TPM_ALG_ID::NULL,
        }
    }
}

impl TPMS_SCHEME_XOR {
    /// Creates a new instance with the specified values
    pub fn new(
        hash_Alg: TPM_ALG_ID,
        kdf: TPM_ALG_ID,
        ) -> Self {
        Self {
            hash_Alg,
            kdf,
        }
    }

    // Union trait implementations
    impl TpmUnion for TPMS_SCHEME_XOR {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
            TPMU_SCHEME_KEYEDHASH::XOR as u32
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TPMU_SCHEME_KEYEDHASH
#[derive(Debug, Clone)]
pub struct TPMS_NULL_SCHEME_KEYEDHASH {
}

impl Default for TPMS_NULL_SCHEME_KEYEDHASH {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPMS_NULL_SCHEME_KEYEDHASH {
    // Union trait implementations
    impl TpmUnion for TPMS_NULL_SCHEME_KEYEDHASH {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
            TPMU_SCHEME_KEYEDHASH::NULL as u32
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This structure is used for a hash signing object.
#[derive(Debug, Clone)]
pub struct TPMT_KEYEDHASH_SCHEME {
    /// Selects the scheme

    /// The scheme parameters
    /// One of: TPMS_SCHEME_HMAC, TPMS_SCHEME_XOR, TPMS_NULL_SCHEME_KEYEDHASH.
    pub details: TPMU_SCHEME_KEYEDHASH,
}

impl Default for TPMT_KEYEDHASH_SCHEME {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPMT_KEYEDHASH_SCHEME {
    /// Creates a new instance with the specified values
    pub fn new(
        details: TPMU_SCHEME_KEYEDHASH,
        ) -> Self {
        Self {
            details,
        }
    }

    /// Get the scheme selector value
    pub fn scheme(&self) -> TPM_ALG_ID {
        match &self.details {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// These are the RSA schemes that only need a hash algorithm as a scheme parameter.
#[derive(Debug, Clone)]
pub struct TPMS_SIG_SCHEME_RSASSA {
}

impl Default for TPMS_SIG_SCHEME_RSASSA {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPMS_SIG_SCHEME_RSASSA {
    // Union trait implementations
    impl TpmUnion for TPMS_SIG_SCHEME_RSASSA {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
            TPMU_SIG_SCHEME::RSASSA as u32
        }
    }

    impl TpmUnion for TPMS_SIG_SCHEME_RSASSA {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
            TPMU_SIG_SCHEME::RSASSA as u32
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// These are the RSA schemes that only need a hash algorithm as a scheme parameter.
#[derive(Debug, Clone)]
pub struct TPMS_SIG_SCHEME_RSAPSS {
}

impl Default for TPMS_SIG_SCHEME_RSAPSS {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPMS_SIG_SCHEME_RSAPSS {
    // Union trait implementations
    impl TpmUnion for TPMS_SIG_SCHEME_RSAPSS {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
            TPMU_SIG_SCHEME::RSAPSS as u32
        }
    }

    impl TpmUnion for TPMS_SIG_SCHEME_RSAPSS {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
            TPMU_SIG_SCHEME::RSAPSS as u32
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// Most of the ECC signature schemes only require a hash algorithm to complete the
/// definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a
/// count value so they are typed to be TPMS_SCHEME_ECDAA.
#[derive(Debug, Clone)]
pub struct TPMS_SIG_SCHEME_ECDSA {
}

impl Default for TPMS_SIG_SCHEME_ECDSA {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPMS_SIG_SCHEME_ECDSA {
    // Union trait implementations
    impl TpmUnion for TPMS_SIG_SCHEME_ECDSA {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
            TPMU_SIG_SCHEME::ECDSA as u32
        }
    }

    impl TpmUnion for TPMS_SIG_SCHEME_ECDSA {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
            TPMU_SIG_SCHEME::ECDSA as u32
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// Most of the ECC signature schemes only require a hash algorithm to complete the
/// definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a
/// count value so they are typed to be TPMS_SCHEME_ECDAA.
#[derive(Debug, Clone)]
pub struct TPMS_SIG_SCHEME_SM2 {
}

impl Default for TPMS_SIG_SCHEME_SM2 {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPMS_SIG_SCHEME_SM2 {
    // Union trait implementations
    impl TpmUnion for TPMS_SIG_SCHEME_SM2 {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
            TPMU_SIG_SCHEME::SM2 as u32
        }
    }

    impl TpmUnion for TPMS_SIG_SCHEME_SM2 {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
            TPMU_SIG_SCHEME::SM2 as u32
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// Most of the ECC signature schemes only require a hash algorithm to complete the
/// definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a
/// count value so they are typed to be TPMS_SCHEME_ECDAA.
#[derive(Debug, Clone)]
pub struct TPMS_SIG_SCHEME_ECSCHNORR {
}

impl Default for TPMS_SIG_SCHEME_ECSCHNORR {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPMS_SIG_SCHEME_ECSCHNORR {
    // Union trait implementations
    impl TpmUnion for TPMS_SIG_SCHEME_ECSCHNORR {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
            TPMU_SIG_SCHEME::ECSCHNORR as u32
        }
    }

    impl TpmUnion for TPMS_SIG_SCHEME_ECSCHNORR {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
            TPMU_SIG_SCHEME::ECSCHNORR as u32
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// Most of the ECC signature schemes only require a hash algorithm to complete the
/// definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a
/// count value so they are typed to be TPMS_SCHEME_ECDAA.
#[derive(Debug, Clone)]
pub struct TPMS_SIG_SCHEME_ECDAA {
}

impl Default for TPMS_SIG_SCHEME_ECDAA {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPMS_SIG_SCHEME_ECDAA {
    // Union trait implementations
    impl TpmUnion for TPMS_SIG_SCHEME_ECDAA {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
            TPMU_SIG_SCHEME::ECDAA as u32
        }
    }

    impl TpmUnion for TPMS_SIG_SCHEME_ECDAA {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
            TPMU_SIG_SCHEME::ECDAA as u32
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TPMU_SIG_SCHEME
#[derive(Debug, Clone)]
pub struct TPMS_NULL_SIG_SCHEME {
}

impl Default for TPMS_NULL_SIG_SCHEME {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPMS_NULL_SIG_SCHEME {
    // Union trait implementations
    impl TpmUnion for TPMS_NULL_SIG_SCHEME {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
            TPMU_SIG_SCHEME::NULL as u32
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// Table 162 Definition of TPMT_SIG_SCHEME Structure
#[derive(Debug, Clone)]
pub struct TPMT_SIG_SCHEME {
    /// Scheme selector

    /// Scheme parameters
    /// One of: TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA,
    /// TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR,
    /// TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME.
    pub details: TPMU_SIG_SCHEME,
}

impl Default for TPMT_SIG_SCHEME {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPMT_SIG_SCHEME {
    /// Creates a new instance with the specified values
    pub fn new(
        details: TPMU_SIG_SCHEME,
        ) -> Self {
        Self {
            details,
        }
    }

    /// Get the scheme selector value
    pub fn scheme(&self) -> TPM_ALG_ID {
        match &self.details {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// These are the RSA encryption schemes that only need a hash algorithm as a controlling parameter.
#[derive(Debug, Clone)]
pub struct TPMS_ENC_SCHEME_OAEP {
}

impl Default for TPMS_ENC_SCHEME_OAEP {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPMS_ENC_SCHEME_OAEP {
    // Union trait implementations
    impl TpmUnion for TPMS_ENC_SCHEME_OAEP {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
            TPMU_ASYM_SCHEME::OAEP as u32
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// These are the RSA encryption schemes that only need a hash algorithm as a controlling parameter.
#[derive(Debug, Clone)]
pub struct TPMS_ENC_SCHEME_RSAES {
}

impl Default for TPMS_ENC_SCHEME_RSAES {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPMS_ENC_SCHEME_RSAES {
    // Union trait implementations
    impl TpmUnion for TPMS_ENC_SCHEME_RSAES {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
            TPMU_ASYM_SCHEME::RSAES as u32
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// These are the ECC schemes that only need a hash algorithm as a controlling parameter.
#[derive(Debug, Clone)]
pub struct TPMS_KEY_SCHEME_ECDH {
}

impl Default for TPMS_KEY_SCHEME_ECDH {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPMS_KEY_SCHEME_ECDH {
    // Union trait implementations
    impl TpmUnion for TPMS_KEY_SCHEME_ECDH {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
            TPMU_ASYM_SCHEME::ECDH as u32
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// These are the ECC schemes that only need a hash algorithm as a controlling parameter.
#[derive(Debug, Clone)]
pub struct TPMS_KEY_SCHEME_ECMQV {
}

impl Default for TPMS_KEY_SCHEME_ECMQV {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPMS_KEY_SCHEME_ECMQV {
    // Union trait implementations
    impl TpmUnion for TPMS_KEY_SCHEME_ECMQV {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
            TPMU_ASYM_SCHEME::ECMQV as u32
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// These structures are used to define the key derivation for symmetric secret sharing
/// using asymmetric methods. A secret sharing scheme is required in any asymmetric key
/// with the decrypt attribute SET.
#[derive(Debug, Clone)]
pub struct TPMS_KDF_SCHEME_MGF1 {
}

impl Default for TPMS_KDF_SCHEME_MGF1 {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPMS_KDF_SCHEME_MGF1 {
    // Union trait implementations
    impl TpmUnion for TPMS_KDF_SCHEME_MGF1 {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
            TPMU_KDF_SCHEME::MGF1 as u32
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// These structures are used to define the key derivation for symmetric secret sharing
/// using asymmetric methods. A secret sharing scheme is required in any asymmetric key
/// with the decrypt attribute SET.
#[derive(Debug, Clone)]
pub struct TPMS_KDF_SCHEME_KDF1_SP800_56A {
}

impl Default for TPMS_KDF_SCHEME_KDF1_SP800_56A {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPMS_KDF_SCHEME_KDF1_SP800_56A {
    // Union trait implementations
    impl TpmUnion for TPMS_KDF_SCHEME_KDF1_SP800_56A {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
            TPMU_KDF_SCHEME::KDF1_SP800_56A as u32
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// These structures are used to define the key derivation for symmetric secret sharing
/// using asymmetric methods. A secret sharing scheme is required in any asymmetric key
/// with the decrypt attribute SET.
#[derive(Debug, Clone)]
pub struct TPMS_KDF_SCHEME_KDF2 {
}

impl Default for TPMS_KDF_SCHEME_KDF2 {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPMS_KDF_SCHEME_KDF2 {
    // Union trait implementations
    impl TpmUnion for TPMS_KDF_SCHEME_KDF2 {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
            TPMU_KDF_SCHEME::KDF2 as u32
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// These structures are used to define the key derivation for symmetric secret sharing
/// using asymmetric methods. A secret sharing scheme is required in any asymmetric key
/// with the decrypt attribute SET.
#[derive(Debug, Clone)]
pub struct TPMS_KDF_SCHEME_KDF1_SP800_108 {
}

impl Default for TPMS_KDF_SCHEME_KDF1_SP800_108 {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPMS_KDF_SCHEME_KDF1_SP800_108 {
    // Union trait implementations
    impl TpmUnion for TPMS_KDF_SCHEME_KDF1_SP800_108 {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
            TPMU_KDF_SCHEME::KDF1_SP800_108 as u32
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TPMU_KDF_SCHEME
#[derive(Debug, Clone)]
pub struct TPMS_NULL_KDF_SCHEME {
}

impl Default for TPMS_NULL_KDF_SCHEME {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPMS_NULL_KDF_SCHEME {
    // Union trait implementations
    impl TpmUnion for TPMS_NULL_KDF_SCHEME {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
            TPMU_KDF_SCHEME::NULL as u32
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// Table 167 Definition of TPMT_KDF_SCHEME Structure
#[derive(Debug, Clone)]
pub struct TPMT_KDF_SCHEME {
    /// Scheme selector

    /// Scheme parameters
    /// One of: TPMS_KDF_SCHEME_MGF1, TPMS_KDF_SCHEME_KDF1_SP800_56A, TPMS_KDF_SCHEME_KDF2,
    /// TPMS_KDF_SCHEME_KDF1_SP800_108, TPMS_SCHEME_HASH, TPMS_NULL_KDF_SCHEME.
    pub details: TPMU_KDF_SCHEME,
}

impl Default for TPMT_KDF_SCHEME {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPMT_KDF_SCHEME {
    /// Creates a new instance with the specified values
    pub fn new(
        details: TPMU_KDF_SCHEME,
        ) -> Self {
        Self {
            details,
        }
    }

    /// Get the scheme selector value
    pub fn scheme(&self) -> TPM_ALG_ID {
        match &self.details {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TPMU_ASYM_SCHEME
#[derive(Debug, Clone)]
pub struct TPMS_NULL_ASYM_SCHEME {
}

impl Default for TPMS_NULL_ASYM_SCHEME {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPMS_NULL_ASYM_SCHEME {
    // Union trait implementations
    impl TpmUnion for TPMS_NULL_ASYM_SCHEME {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
            TPMU_ASYM_SCHEME::NULL as u32
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This structure is defined to allow overlay of all of the schemes for any asymmetric
/// object. This structure is not sent on the interface. It is defined so that common
/// functions may operate on any similar scheme structure.
#[derive(Debug, Clone)]
pub struct TPMT_ASYM_SCHEME {
    /// Scheme selector

    /// Scheme parameters
    /// One of: TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA,
    /// TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA,
    /// TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES,
    /// TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME.
    pub details: TPMU_ASYM_SCHEME,
}

impl Default for TPMT_ASYM_SCHEME {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPMT_ASYM_SCHEME {
    /// Creates a new instance with the specified values
    pub fn new(
        details: TPMU_ASYM_SCHEME,
        ) -> Self {
        Self {
            details,
        }
    }

    /// Get the scheme selector value
    pub fn scheme(&self) -> TPM_ALG_ID {
        match &self.details {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// Table 172 Definition of {RSA} TPMT_RSA_SCHEME Structure
#[derive(Debug, Clone)]
pub struct TPMT_RSA_SCHEME {
    /// Scheme selector

    /// Scheme parameters
    /// One of: TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA,
    /// TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA,
    /// TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES,
    /// TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME.
    pub details: TPMU_ASYM_SCHEME,
}

impl Default for TPMT_RSA_SCHEME {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPMT_RSA_SCHEME {
    /// Creates a new instance with the specified values
    pub fn new(
        details: TPMU_ASYM_SCHEME,
        ) -> Self {
        Self {
            details,
        }
    }

    /// Get the scheme selector value
    pub fn scheme(&self) -> TPM_ALG_ID {
        match &self.details {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// Table 174 Definition of {RSA} TPMT_RSA_DECRYPT Structure
#[derive(Debug, Clone)]
pub struct TPMT_RSA_DECRYPT {
    /// Scheme selector

    /// Scheme parameters
    /// One of: TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA,
    /// TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA,
    /// TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES,
    /// TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME.
    pub details: TPMU_ASYM_SCHEME,
}

impl Default for TPMT_RSA_DECRYPT {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPMT_RSA_DECRYPT {
    /// Creates a new instance with the specified values
    pub fn new(
        details: TPMU_ASYM_SCHEME,
        ) -> Self {
        Self {
            details,
        }
    }

    /// Get the scheme selector value
    pub fn scheme(&self) -> TPM_ALG_ID {
        match &self.details {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This sized buffer holds the largest RSA public key supported by the TPM.
#[derive(Debug, Clone)]
pub struct TPM2B_PUBLIC_KEY_RSA {
    /// Value
    pub buffer: Vec<u8>,
}

impl Default for TPM2B_PUBLIC_KEY_RSA {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPM2B_PUBLIC_KEY_RSA {
    /// Creates a new instance with the specified values
    pub fn new(
        buffer: Vec<u8>,
        ) -> Self {
        Self {
            buffer,
        }
    }

    // Union trait implementations
    impl TpmUnion for TPM2B_PUBLIC_KEY_RSA {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
            TPMU_PUBLIC_ID::RSA as u32
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This sized buffer holds the largest RSA prime number supported by the TPM.
#[derive(Debug, Clone)]
pub struct TPM2B_PRIVATE_KEY_RSA {
    pub buffer: Vec<u8>,
}

impl Default for TPM2B_PRIVATE_KEY_RSA {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPM2B_PRIVATE_KEY_RSA {
    /// Creates a new instance with the specified values
    pub fn new(
        buffer: Vec<u8>,
        ) -> Self {
        Self {
            buffer,
        }
    }

    // Union trait implementations
    impl TpmUnion for TPM2B_PRIVATE_KEY_RSA {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
            TPMU_SENSITIVE_COMPOSITE::RSA as u32
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This sized buffer holds the largest ECC parameter (coordinate) supported by the TPM.
#[derive(Debug, Clone)]
pub struct TPM2B_ECC_PARAMETER {
    /// The parameter data
    pub buffer: Vec<u8>,
}

impl Default for TPM2B_ECC_PARAMETER {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPM2B_ECC_PARAMETER {
    /// Creates a new instance with the specified values
    pub fn new(
        buffer: Vec<u8>,
        ) -> Self {
        Self {
            buffer,
        }
    }

    // Union trait implementations
    impl TpmUnion for TPM2B_ECC_PARAMETER {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
            TPMU_SENSITIVE_COMPOSITE::ECC as u32
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This structure holds two ECC coordinates that, together, make up an ECC point.
#[derive(Debug, Clone)]
pub struct TPMS_ECC_POINT {
    /// X coordinate
    pub x: Vec<u8>,

    /// Y coordinate
    pub y: Vec<u8>,
}

impl Default for TPMS_ECC_POINT {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPMS_ECC_POINT {
    /// Creates a new instance with the specified values
    pub fn new(
        x: Vec<u8>,
        y: Vec<u8>,
        ) -> Self {
        Self {
            x,
            y,
        }
    }

    // Union trait implementations
    impl TpmUnion for TPMS_ECC_POINT {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
            TPMU_PUBLIC_ID::ECC as u32
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This structure is defined to allow a point to be a single sized parameter so that it
/// may be encrypted.
#[derive(Debug, Clone)]
pub struct TPM2B_ECC_POINT {
    /// Coordinates
    pub point: TPMS_ECC_POINT,
}

impl Default for TPM2B_ECC_POINT {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPM2B_ECC_POINT {
    /// Creates a new instance with the specified values
    pub fn new(
        point: TPMS_ECC_POINT,
        ) -> Self {
        Self {
            point,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// Table 183 Definition of (TPMT_SIG_SCHEME) {ECC} TPMT_ECC_SCHEME Structure
#[derive(Debug, Clone)]
pub struct TPMT_ECC_SCHEME {
    /// Scheme selector

    /// Scheme parameters
    /// One of: TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA,
    /// TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA,
    /// TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES,
    /// TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME.
    pub details: TPMU_ASYM_SCHEME,
}

impl Default for TPMT_ECC_SCHEME {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPMT_ECC_SCHEME {
    /// Creates a new instance with the specified values
    pub fn new(
        details: TPMU_ASYM_SCHEME,
        ) -> Self {
        Self {
            details,
        }
    }

    /// Get the scheme selector value
    pub fn scheme(&self) -> TPM_ALG_ID {
        match &self.details {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This structure is used to report on the curve parameters of an ECC curve. It is
/// returned by TPM2_ECC_Parameters().
#[derive(Debug, Clone)]
pub struct TPMS_ALGORITHM_DETAIL_ECC {
    /// Identifier for the curve
    pub curve_ID: TPM_ECC_CURVE,

    /// Size in bits of the key
    pub key_Size: u16,

    /// Scheme selector

    /// If not TPM_ALG_NULL, the required KDF and hash algorithm used in secret sharing operations
    /// One of: TPMS_KDF_SCHEME_MGF1, TPMS_KDF_SCHEME_KDF1_SP800_56A, TPMS_KDF_SCHEME_KDF2,
    /// TPMS_KDF_SCHEME_KDF1_SP800_108, TPMS_SCHEME_HASH, TPMS_NULL_KDF_SCHEME.
    pub kdf: TPMU_KDF_SCHEME,

    /// Scheme selector

    /// If not TPM_ALG_NULL, this is the mandatory signature scheme that is required to be
    /// used with this curve.
    /// One of: TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA,
    /// TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA,
    /// TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES,
    /// TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME.
    pub sign: TPMU_ASYM_SCHEME,

    /// Fp (the modulus)
    pub p: Vec<u8>,

    /// Coefficient of the linear term in the curve equation
    pub a: Vec<u8>,

    /// Constant term for curve equation
    pub b: Vec<u8>,

    /// X coordinate of base point G
    pub gX: Vec<u8>,

    /// Y coordinate of base point G
    pub gY: Vec<u8>,

    /// Order of G
    pub n: Vec<u8>,

    /// Cofactor (a size of zero indicates a cofactor of 1)
    pub h: Vec<u8>,
}

impl Default for TPMS_ALGORITHM_DETAIL_ECC {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPMS_ALGORITHM_DETAIL_ECC {
    /// Creates a new instance with the specified values
    pub fn new(
        curve_ID: TPM_ECC_CURVE,
        key_Size: u16,
        kdf: TPMU_KDF_SCHEME,
        sign: TPMU_ASYM_SCHEME,
        p: Vec<u8>,
        a: Vec<u8>,
        b: Vec<u8>,
        gX: Vec<u8>,
        gY: Vec<u8>,
        n: Vec<u8>,
        h: Vec<u8>,
        ) -> Self {
        Self {
            curve_ID,
            key_Size,
            kdf,
            sign,
            p,
            a,
            b,
            gX,
            gY,
            n,
            h,
        }
    }

    /// Get the kdfScheme selector value
    pub fn kdf_Scheme(&self) -> TPM_ALG_ID {
        match &self.kdf {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    /// Get the signScheme selector value
    pub fn sign_Scheme(&self) -> TPM_ALG_ID {
        match &self.sign {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// Table 185 Definition of {RSA} TPMS_SIGNATURE_RSA Structure
#[derive(Debug, Clone)]
pub struct TPMS_SIGNATURE_RSA {
    /// The hash algorithm used to digest the message
    /// TPM_ALG_NULL is not allowed.
    pub hash: TPM_ALG_ID,

    /// The signature is the size of a public key.
    pub sig: Vec<u8>,
}

impl Default for TPMS_SIGNATURE_RSA {
    fn default() -> Self {
        Self {
            hash: TPM_ALG_ID::NULL,
        }
    }
}

impl TPMS_SIGNATURE_RSA {
    /// Creates a new instance with the specified values
    pub fn new(
        hash: TPM_ALG_ID,
        sig: Vec<u8>,
        ) -> Self {
        Self {
            hash,
            sig,
        }
    }

    // Union trait implementations
    impl TpmUnion for TPMS_SIGNATURE_RSA {
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// Table 185 Definition of {RSA} TPMS_SIGNATURE_RSA Structure
#[derive(Debug, Clone)]
pub struct TPMS_SIGNATURE_RSASSA {
}

impl Default for TPMS_SIGNATURE_RSASSA {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPMS_SIGNATURE_RSASSA {
    // Union trait implementations
    impl TpmUnion for TPMS_SIGNATURE_RSASSA {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
            TPMU_SIGNATURE::RSASSA as u32
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// Table 185 Definition of {RSA} TPMS_SIGNATURE_RSA Structure
#[derive(Debug, Clone)]
pub struct TPMS_SIGNATURE_RSAPSS {
}

impl Default for TPMS_SIGNATURE_RSAPSS {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPMS_SIGNATURE_RSAPSS {
    // Union trait implementations
    impl TpmUnion for TPMS_SIGNATURE_RSAPSS {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
            TPMU_SIGNATURE::RSAPSS as u32
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// Table 187 Definition of {ECC} TPMS_SIGNATURE_ECC Structure
#[derive(Debug, Clone)]
pub struct TPMS_SIGNATURE_ECC {
    /// The hash algorithm used in the signature process
    /// TPM_ALG_NULL is not allowed.
    pub hash: TPM_ALG_ID,
    pub signature_R: Vec<u8>,
    pub signature_S: Vec<u8>,
}

impl Default for TPMS_SIGNATURE_ECC {
    fn default() -> Self {
        Self {
            hash: TPM_ALG_ID::NULL,
        }
    }
}

impl TPMS_SIGNATURE_ECC {
    /// Creates a new instance with the specified values
    pub fn new(
        hash: TPM_ALG_ID,
        signature_R: Vec<u8>,
        signature_S: Vec<u8>,
        ) -> Self {
        Self {
            hash,
            signature_R,
            signature_S,
        }
    }

    // Union trait implementations
    impl TpmUnion for TPMS_SIGNATURE_ECC {
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// Table 187 Definition of {ECC} TPMS_SIGNATURE_ECC Structure
#[derive(Debug, Clone)]
pub struct TPMS_SIGNATURE_ECDSA {
}

impl Default for TPMS_SIGNATURE_ECDSA {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPMS_SIGNATURE_ECDSA {
    // Union trait implementations
    impl TpmUnion for TPMS_SIGNATURE_ECDSA {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
            TPMU_SIGNATURE::ECDSA as u32
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// Table 187 Definition of {ECC} TPMS_SIGNATURE_ECC Structure
#[derive(Debug, Clone)]
pub struct TPMS_SIGNATURE_ECDAA {
}

impl Default for TPMS_SIGNATURE_ECDAA {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPMS_SIGNATURE_ECDAA {
    // Union trait implementations
    impl TpmUnion for TPMS_SIGNATURE_ECDAA {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
            TPMU_SIGNATURE::ECDAA as u32
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// Table 187 Definition of {ECC} TPMS_SIGNATURE_ECC Structure
#[derive(Debug, Clone)]
pub struct TPMS_SIGNATURE_SM2 {
}

impl Default for TPMS_SIGNATURE_SM2 {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPMS_SIGNATURE_SM2 {
    // Union trait implementations
    impl TpmUnion for TPMS_SIGNATURE_SM2 {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
            TPMU_SIGNATURE::SM2 as u32
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// Table 187 Definition of {ECC} TPMS_SIGNATURE_ECC Structure
#[derive(Debug, Clone)]
pub struct TPMS_SIGNATURE_ECSCHNORR {
}

impl Default for TPMS_SIGNATURE_ECSCHNORR {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPMS_SIGNATURE_ECSCHNORR {
    // Union trait implementations
    impl TpmUnion for TPMS_SIGNATURE_ECSCHNORR {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
            TPMU_SIGNATURE::ECSCHNORR as u32
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TPMU_SIGNATURE
#[derive(Debug, Clone)]
pub struct TPMS_NULL_SIGNATURE {
}

impl Default for TPMS_NULL_SIGNATURE {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPMS_NULL_SIGNATURE {
    // Union trait implementations
    impl TpmUnion for TPMS_NULL_SIGNATURE {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
            TPMU_SIGNATURE::NULL as u32
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// Table 190 shows the basic algorithm-agile structure when a symmetric or asymmetric
/// signature is indicated. The sigAlg parameter indicates the algorithm used for the
/// signature. This structure is output from commands such as the attestation commands and
/// TPM2_Sign, and is an input to commands such as TPM2_VerifySignature(),
/// TPM2_PolicySigned(), and TPM2_FieldUpgradeStart().
#[derive(Debug, Clone)]
pub struct TPMT_SIGNATURE {
    /// Selector of the algorithm used to construct the signature

    /// This shall be the actual signature information.
    /// One of: TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA,
    /// TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TPMT_HA,
    /// TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE.
    pub signature: TPMU_SIGNATURE,
}

impl Default for TPMT_SIGNATURE {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPMT_SIGNATURE {
    /// Creates a new instance with the specified values
    pub fn new(
        signature: TPMU_SIGNATURE,
        ) -> Self {
        Self {
            signature,
        }
    }

    /// Get the sigAlg selector value
    pub fn sig_Alg(&self) -> TPM_ALG_ID {
        match &self.signature {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// Table 192 Definition of TPM2B_ENCRYPTED_SECRET Structure
#[derive(Debug, Clone)]
pub struct TPM2B_ENCRYPTED_SECRET {
    /// Secret
    pub secret: Vec<u8>,
}

impl Default for TPM2B_ENCRYPTED_SECRET {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPM2B_ENCRYPTED_SECRET {
    /// Creates a new instance with the specified values
    pub fn new(
        secret: Vec<u8>,
        ) -> Self {
        Self {
            secret,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This structure describes the parameters that would appear in the public area of a
/// KEYEDHASH object.
#[derive(Debug, Clone)]
pub struct TPMS_KEYEDHASH_PARMS {
    /// Selects the scheme

    /// Indicates the signing method used for a keyedHash signing object. This field also
    /// determines the size of the data field for a data object created with TPM2_Create() or
    /// TPM2_CreatePrimary().
    /// One of: TPMS_SCHEME_HMAC, TPMS_SCHEME_XOR, TPMS_NULL_SCHEME_KEYEDHASH.
    pub scheme: TPMU_SCHEME_KEYEDHASH,
}

impl Default for TPMS_KEYEDHASH_PARMS {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPMS_KEYEDHASH_PARMS {
    /// Creates a new instance with the specified values
    pub fn new(
        scheme: TPMU_SCHEME_KEYEDHASH,
        ) -> Self {
        Self {
            scheme,
        }
    }

    /// Get the schemeScheme selector value
    pub fn scheme_Scheme(&self) -> TPM_ALG_ID {
        match &self.scheme {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    // Union trait implementations
    impl TpmUnion for TPMS_KEYEDHASH_PARMS {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
            TPMU_PUBLIC_PARMS::KEYEDHASH as u32
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This structure contains the common public area parameters for an asymmetric key. The
/// first two parameters of the parameter definition structures of an asymmetric key shall
/// have the same two first components.
#[derive(Debug, Clone)]
pub struct TPMS_ASYM_PARMS {
    /// The companion symmetric algorithm for a restricted decryption key and shall be set to
    /// a supported symmetric algorithm
    /// This field is optional for keys that are not decryption keys and shall be set to
    /// TPM_ALG_NULL if not used.
    pub symmetric: TPMT_SYM_DEF_OBJECT,

    /// Scheme selector

    /// For a key with the sign attribute SET, a valid signing scheme for the key type
    /// for a key with the decrypt attribute SET, a valid key exchange protocol
    /// for a key with sign and decrypt attributes, shall be TPM_ALG_NULL
    /// One of: TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA,
    /// TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA,
    /// TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES,
    /// TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME.
    pub scheme: TPMU_ASYM_SCHEME,
}

impl Default for TPMS_ASYM_PARMS {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPMS_ASYM_PARMS {
    /// Creates a new instance with the specified values
    pub fn new(
        symmetric: TPMT_SYM_DEF_OBJECT,
        scheme: TPMU_ASYM_SCHEME,
        ) -> Self {
        Self {
            symmetric,
            scheme,
        }
    }

    /// Get the schemeScheme selector value
    pub fn scheme_Scheme(&self) -> TPM_ALG_ID {
        match &self.scheme {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    // Union trait implementations
    impl TpmUnion for TPMS_ASYM_PARMS {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
            TPMU_PUBLIC_PARMS::ANY as u32
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// A TPM compatible with this specification and supporting RSA shall support two primes
/// and an exponent of zero. An exponent of zero indicates that the exponent is the
/// default of 216 + 1. Support for other values is optional. Use of other exponents in
/// duplicated keys is not recommended because the resulting keys would not be
/// interoperable with other TPMs.
#[derive(Debug, Clone)]
pub struct TPMS_RSA_PARMS {
    /// For a restricted decryption key, shall be set to a supported symmetric algorithm, key
    /// size, and mode.
    /// if the key is not a restricted decryption key, this field shall be set to TPM_ALG_NULL.
    pub symmetric: TPMT_SYM_DEF_OBJECT,

    /// Scheme selector

    /// Scheme.scheme shall be:
    /// for an unrestricted signing key, either TPM_ALG_RSAPSS TPM_ALG_RSASSA or TPM_ALG_NULL
    /// for a restricted signing key, either TPM_ALG_RSAPSS or TPM_ALG_RSASSA
    /// for an unrestricted decryption key, TPM_ALG_RSAES, TPM_ALG_OAEP, or TPM_ALG_NULL
    /// unless the object also has the sign attribute
    /// for a restricted decryption key, TPM_ALG_NULL
    /// NOTE When both sign and decrypt are SET, restricted shall be CLEAR and scheme shall be
    /// TPM_ALG_NULL.
    /// One of: TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA,
    /// TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA,
    /// TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES,
    /// TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME.
    pub scheme: TPMU_ASYM_SCHEME,

    /// Number of bits in the public modulus
    pub key_Bits: u16,

    /// The public exponent
    /// A prime number greater than 2.
    pub exponent: u32,
}

impl Default for TPMS_RSA_PARMS {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPMS_RSA_PARMS {
    /// Creates a new instance with the specified values
    pub fn new(
        symmetric: TPMT_SYM_DEF_OBJECT,
        scheme: TPMU_ASYM_SCHEME,
        key_Bits: u16,
        exponent: u32,
        ) -> Self {
        Self {
            symmetric,
            scheme,
            key_Bits,
            exponent,
        }
    }

    /// Get the schemeScheme selector value
    pub fn scheme_Scheme(&self) -> TPM_ALG_ID {
        match &self.scheme {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    // Union trait implementations
    impl TpmUnion for TPMS_RSA_PARMS {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
            TPMU_PUBLIC_PARMS::RSA as u32
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This structure contains the parameters for prime modulus ECC.
#[derive(Debug, Clone)]
pub struct TPMS_ECC_PARMS {
    /// For a restricted decryption key, shall be set to a supported symmetric algorithm, key
    /// size. and mode.
    /// if the key is not a restricted decryption key, this field shall be set to TPM_ALG_NULL.
    pub symmetric: TPMT_SYM_DEF_OBJECT,

    /// Scheme selector

    /// If the sign attribute of the key is SET, then this shall be a valid signing scheme.
    /// NOTE If the sign parameter in curveID indicates a mandatory scheme, then this field
    /// shall have the same value.
    /// If the decrypt attribute of the key is SET, then this shall be a valid key exchange
    /// scheme or TPM_ALG_NULL.
    /// If the key is a Storage Key, then this field shall be TPM_ALG_NULL.
    /// One of: TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA,
    /// TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA,
    /// TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES,
    /// TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME.
    pub scheme: TPMU_ASYM_SCHEME,

    /// ECC curve ID
    pub curve_ID: TPM_ECC_CURVE,

    /// Scheme selector

    /// An optional key derivation scheme for generating a symmetric key from a Z value
    /// If the kdf parameter associated with curveID is not TPM_ALG_NULL then this is required
    /// to be NULL.
    /// NOTE There are currently no commands where this parameter has effect and, in the
    /// reference code, this field needs to be set to TPM_ALG_NULL.
    /// One of: TPMS_KDF_SCHEME_MGF1, TPMS_KDF_SCHEME_KDF1_SP800_56A, TPMS_KDF_SCHEME_KDF2,
    /// TPMS_KDF_SCHEME_KDF1_SP800_108, TPMS_SCHEME_HASH, TPMS_NULL_KDF_SCHEME.
    pub kdf: TPMU_KDF_SCHEME,
}

impl Default for TPMS_ECC_PARMS {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPMS_ECC_PARMS {
    /// Creates a new instance with the specified values
    pub fn new(
        symmetric: TPMT_SYM_DEF_OBJECT,
        scheme: TPMU_ASYM_SCHEME,
        curve_ID: TPM_ECC_CURVE,
        kdf: TPMU_KDF_SCHEME,
        ) -> Self {
        Self {
            symmetric,
            scheme,
            curve_ID,
            kdf,
        }
    }

    /// Get the schemeScheme selector value
    pub fn scheme_Scheme(&self) -> TPM_ALG_ID {
        match &self.scheme {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    /// Get the kdfScheme selector value
    pub fn kdf_Scheme(&self) -> TPM_ALG_ID {
        match &self.kdf {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    // Union trait implementations
    impl TpmUnion for TPMS_ECC_PARMS {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
            TPMU_PUBLIC_PARMS::ECC as u32
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This structure is used in TPM2_TestParms() to validate that a set of algorithm
/// parameters is supported by the TPM.
#[derive(Debug, Clone)]
pub struct TPMT_PUBLIC_PARMS {
    /// The algorithm to be tested

    /// The algorithm details
    /// One of: TPMS_KEYEDHASH_PARMS, TPMS_SYMCIPHER_PARMS, TPMS_RSA_PARMS, TPMS_ECC_PARMS,
    /// TPMS_ASYM_PARMS.
    pub parameters: TPMU_PUBLIC_PARMS,
}

impl Default for TPMT_PUBLIC_PARMS {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPMT_PUBLIC_PARMS {
    /// Creates a new instance with the specified values
    pub fn new(
        parameters: TPMU_PUBLIC_PARMS,
        ) -> Self {
        Self {
            parameters,
        }
    }

    /// Get the type selector value
    pub fn type(&self) -> TPM_ALG_ID {
        match &self.parameters {
        Some(u) => u.get_union_selector() as _,
            None => 0 as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// Table 201 defines the public area structure. The Name of the object is nameAlg
/// concatenated with the digest of this structure using nameAlg.
#[derive(Debug, Clone)]
pub struct TPMT_PUBLIC {
    /// Algorithm associated with this object

    /// Algorithm used for computing the Name of the object
    /// NOTE The "+" indicates that the instance of a TPMT_PUBLIC may have a "+" to indicate
    /// that the nameAlg may be TPM_ALG_NULL.
    pub name_Alg: TPM_ALG_ID,

    /// Attributes that, along with type, determine the manipulations of this object
    pub object_Attributes: TPMA_OBJECT,

    /// Optional policy for using this key
    /// The policy is computed using the nameAlg of the object.
    /// NOTE Shall be the Empty Policy if no authorization policy is present.
    pub auth_Policy: Vec<u8>,

    /// The algorithm or structure details
    /// One of: TPMS_KEYEDHASH_PARMS, TPMS_SYMCIPHER_PARMS, TPMS_RSA_PARMS, TPMS_ECC_PARMS,
    /// TPMS_ASYM_PARMS.
    pub parameters: TPMU_PUBLIC_PARMS,

    /// The unique identifier of the structure
    /// For an asymmetric key, this would be the public key.
    /// One of: TPM2B_DIGEST_KEYEDHASH, TPM2B_DIGEST_SYMCIPHER, TPM2B_PUBLIC_KEY_RSA,
    /// TPMS_ECC_POINT, TPMS_DERIVE.
    pub unique: TPMU_PUBLIC_ID,
}

impl Default for TPMT_PUBLIC {
    fn default() -> Self {
        Self {
            nameAlg: TPM_ALG_ID::NULL,
        }
    }
}

impl TPMT_PUBLIC {
    /// Creates a new instance with the specified values
    pub fn new(
        name_Alg: TPM_ALG_ID,
        object_Attributes: TPMA_OBJECT,
        auth_Policy: Vec<u8>,
        parameters: TPMU_PUBLIC_PARMS,
        unique: TPMU_PUBLIC_ID,
        ) -> Self {
        Self {
            name_Alg,
            object_Attributes,
            auth_Policy,
            parameters,
            unique,
        }
    }

    /// Get the type selector value
    pub fn type(&self) -> TPM_ALG_ID {
        match &self.parameters {
        Some(u) => u.get_union_selector() as _,
            None => 0 as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This sized buffer is used to embed a TPMT_PUBLIC in a load command and in any response
/// that returns a public area.
#[derive(Debug, Clone)]
pub struct TPM2B_PUBLIC {
    /// The public area
    /// NOTE The + indicates that the caller may specify that use of TPM_ALG_NULL is allowed
    /// for nameAlg.
    pub public_Area: TPMT_PUBLIC,
}

impl Default for TPM2B_PUBLIC {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPM2B_PUBLIC {
    /// Creates a new instance with the specified values
    pub fn new(
        public_Area: TPMT_PUBLIC,
        ) -> Self {
        Self {
            public_Area,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This sized buffer is used to embed a TPMT_TEMPLATE for TPM2_CreateLoaded().
#[derive(Debug, Clone)]
pub struct TPM2B_TEMPLATE {
    /// The public area
    pub buffer: Vec<u8>,
}

impl Default for TPM2B_TEMPLATE {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPM2B_TEMPLATE {
    /// Creates a new instance with the specified values
    pub fn new(
        buffer: Vec<u8>,
        ) -> Self {
        Self {
            buffer,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This structure is defined for coding purposes. For IO to the TPM, the sensitive
/// portion of the key will be in a canonical form. For an RSA key, this will be one of
/// the prime factors of the public modulus. After loading, it is typical that other
/// values will be computed so that computations using the private key will not need to
/// start with just one prime factor. This structure can be used to store the results of
/// such vendor-specific calculations.
#[derive(Debug, Clone)]
pub struct TPM2B_PRIVATE_VENDOR_SPECIFIC {
    pub buffer: Vec<u8>,
}

impl Default for TPM2B_PRIVATE_VENDOR_SPECIFIC {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPM2B_PRIVATE_VENDOR_SPECIFIC {
    /// Creates a new instance with the specified values
    pub fn new(
        buffer: Vec<u8>,
        ) -> Self {
        Self {
            buffer,
        }
    }

    // Union trait implementations
    impl TpmUnion for TPM2B_PRIVATE_VENDOR_SPECIFIC {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
            TPMU_SENSITIVE_COMPOSITE::ANY as u32
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// AuthValue shall not be larger than the size of the digest produced by the nameAlg of
/// the object. seedValue shall be the size of the digest produced by the nameAlg of the object.
#[derive(Debug, Clone)]
pub struct TPMT_SENSITIVE {
    /// Identifier for the sensitive area
    /// This shall be the same as the type parameter of the associated public area.

    /// User authorization data
    /// The authValue may be a zero-length string.
    pub auth_Value: Vec<u8>,

    /// For a parent object, the optional protection seed; for other objects, the obfuscation value
    pub seed_Value: Vec<u8>,

    /// The type-specific private data
    /// One of: TPM2B_PRIVATE_KEY_RSA, TPM2B_ECC_PARAMETER, TPM2B_SENSITIVE_DATA,
    /// TPM2B_SYM_KEY, TPM2B_PRIVATE_VENDOR_SPECIFIC.
    pub sensitive: TPMU_SENSITIVE_COMPOSITE,
}

impl Default for TPMT_SENSITIVE {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPMT_SENSITIVE {
    /// Creates a new instance with the specified values
    pub fn new(
        auth_Value: Vec<u8>,
        seed_Value: Vec<u8>,
        sensitive: TPMU_SENSITIVE_COMPOSITE,
        ) -> Self {
        Self {
            auth_Value,
            seed_Value,
            sensitive,
        }
    }

    /// Get the sensitiveType selector value
    pub fn sensitive_Type(&self) -> TPM_ALG_ID {
        match &self.sensitive {
        Some(u) => u.get_union_selector() as _,
            None => 0 as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// The TPM2B_SENSITIVE structure is used as a parameter in TPM2_LoadExternal(). It is an
/// unencrypted sensitive area but it may be encrypted using parameter encryption.
#[derive(Debug, Clone)]
pub struct TPM2B_SENSITIVE {
    /// An unencrypted sensitive area
    pub sensitive_Area: TPMT_SENSITIVE,
}

impl Default for TPM2B_SENSITIVE {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPM2B_SENSITIVE {
    /// Creates a new instance with the specified values
    pub fn new(
        sensitive_Area: TPMT_SENSITIVE,
        ) -> Self {
        Self {
            sensitive_Area,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This structure is defined to size the contents of a TPM2B_PRIVATE. This structure is
/// not directly marshaled or unmarshaled.
#[derive(Debug, Clone)]
pub struct _PRIVATE {
    pub integrity_Outer: Vec<u8>,

    /// Could also be a TPM2B_IV
    pub integrity_Inner: Vec<u8>,

    /// The sensitive area
    pub sensitive: TPMT_SENSITIVE,
}

impl Default for _PRIVATE {
    fn default() -> Self {
        Self {
        }
    }
}

impl _PRIVATE {
    /// Creates a new instance with the specified values
    pub fn new(
        integrity_Outer: Vec<u8>,
        integrity_Inner: Vec<u8>,
        sensitive: TPMT_SENSITIVE,
        ) -> Self {
        Self {
            integrity_Outer,
            integrity_Inner,
            sensitive,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// The TPM2B_PRIVATE structure is used as a parameter in multiple commands that create,
/// load, and modify the sensitive area of an object.
#[derive(Debug, Clone)]
pub struct TPM2B_PRIVATE {
    /// An encrypted private area
    pub buffer: Vec<u8>,
}

impl Default for TPM2B_PRIVATE {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPM2B_PRIVATE {
    /// Creates a new instance with the specified values
    pub fn new(
        buffer: Vec<u8>,
        ) -> Self {
        Self {
            buffer,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This structure is used for sizing the TPM2B_ID_OBJECT.
#[derive(Debug, Clone)]
pub struct TPMS_ID_OBJECT {
    /// HMAC using the nameAlg of the storage key on the target TPM
    pub integrity_HMAC: Vec<u8>,

    /// Credential protector information returned if name matches the referenced object
    /// All of the encIdentity is encrypted, including the size field.
    /// NOTE The TPM is not required to check that the size is not larger than the digest of
    /// the nameAlg. However, if the size is larger, the ID object may not be usable on a TPM
    /// that has no digest larger than produced by nameAlg.
    pub enc_Identity: Vec<u8>,
}

impl Default for TPMS_ID_OBJECT {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPMS_ID_OBJECT {
    /// Creates a new instance with the specified values
    pub fn new(
        integrity_HMAC: Vec<u8>,
        enc_Identity: Vec<u8>,
        ) -> Self {
        Self {
            integrity_HMAC,
            enc_Identity,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This structure is an output from TPM2_MakeCredential() and is an input to
/// TPM2_ActivateCredential().
#[derive(Debug, Clone)]
pub struct TPM2B_ID_OBJECT {
    /// An encrypted credential area
    pub credential: TPMS_ID_OBJECT,
}

impl Default for TPM2B_ID_OBJECT {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPM2B_ID_OBJECT {
    /// Creates a new instance with the specified values
    pub fn new(
        credential: TPMS_ID_OBJECT,
        ) -> Self {
        Self {
            credential,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This is the data that can be written to and read from a TPM_NT_PIN_PASS or
/// TPM_NT_PIN_FAIL non-volatile index. pinCount is the most significant octets. pinLimit
/// is the least significant octets.
#[derive(Debug, Clone)]
pub struct TPMS_NV_PIN_COUNTER_PARAMETERS {
    /// This counter shows the current number of successful authValue authorization attempts
    /// to access a TPM_NT_PIN_PASS index or the current number of unsuccessful authValue
    /// authorization attempts to access a TPM_NT_PIN_FAIL index.
    pub pin_Count: u32,

    /// This threshold is the value of pinCount at which the authValue authorization of the
    /// host TPM_NT_PIN_PASS or TPM_NT_PIN_FAIL index is locked out.
    pub pin_Limit: u32,
}

impl Default for TPMS_NV_PIN_COUNTER_PARAMETERS {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPMS_NV_PIN_COUNTER_PARAMETERS {
    /// Creates a new instance with the specified values
    pub fn new(
        pin_Count: u32,
        pin_Limit: u32,
        ) -> Self {
        Self {
            pin_Count,
            pin_Limit,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This structure describes an NV Index.
#[derive(Debug, Clone)]
pub struct TPMS_NV_PUBLIC {
    /// The handle of the data area
    pub nv_Index: TPM_HANDLE,

    /// Hash algorithm used to compute the name of the Index and used for the authPolicy. For
    /// an extend index, the hash algorithm used for the extend.
    pub name_Alg: TPM_ALG_ID,

    /// The Index attributes
    pub attributes: TPMA_NV,

    /// Optional access policy for the Index
    /// The policy is computed using the nameAlg
    /// NOTE Shall be the Empty Policy if no authorization policy is present.
    pub auth_Policy: Vec<u8>,

    /// The size of the data area
    /// The maximum size is implementation-dependent. The minimum maximum size is platform-specific.
    pub data_Size: u16,
}

impl Default for TPMS_NV_PUBLIC {
    fn default() -> Self {
        Self {
            nvIndex: TPM_HANDLE::default(),
            nameAlg: TPM_ALG_ID::NULL,
        }
    }
}

impl TPMS_NV_PUBLIC {
    /// Creates a new instance with the specified values
    pub fn new(
        nv_Index: TPM_HANDLE,
        name_Alg: TPM_ALG_ID,
        attributes: TPMA_NV,
        auth_Policy: Vec<u8>,
        data_Size: u16,
        ) -> Self {
        Self {
            nv_Index,
            name_Alg,
            attributes,
            auth_Policy,
            data_Size,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This structure is used when a TPMS_NV_PUBLIC is sent on the TPM interface.
#[derive(Debug, Clone)]
pub struct TPM2B_NV_PUBLIC {
    /// The public area
    pub nv_Public: TPMS_NV_PUBLIC,
}

impl Default for TPM2B_NV_PUBLIC {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPM2B_NV_PUBLIC {
    /// Creates a new instance with the specified values
    pub fn new(
        nv_Public: TPMS_NV_PUBLIC,
        ) -> Self {
        Self {
            nv_Public,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This structure holds the object or session context data. When saved, the full
/// structure is encrypted.
#[derive(Debug, Clone)]
pub struct TPM2B_CONTEXT_SENSITIVE {
    /// The sensitive data
    pub buffer: Vec<u8>,
}

impl Default for TPM2B_CONTEXT_SENSITIVE {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPM2B_CONTEXT_SENSITIVE {
    /// Creates a new instance with the specified values
    pub fn new(
        buffer: Vec<u8>,
        ) -> Self {
        Self {
            buffer,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This structure holds the integrity value and the encrypted data for a context.
#[derive(Debug, Clone)]
pub struct TPMS_CONTEXT_DATA {
    /// The integrity value
    pub integrity: Vec<u8>,

    /// The sensitive area
    pub encrypted: Vec<u8>,
}

impl Default for TPMS_CONTEXT_DATA {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPMS_CONTEXT_DATA {
    /// Creates a new instance with the specified values
    pub fn new(
        integrity: Vec<u8>,
        encrypted: Vec<u8>,
        ) -> Self {
        Self {
            integrity,
            encrypted,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This structure is used in a TPMS_CONTEXT.
#[derive(Debug, Clone)]
pub struct TPM2B_CONTEXT_DATA {
    pub buffer: TPMS_CONTEXT_DATA,
}

impl Default for TPM2B_CONTEXT_DATA {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPM2B_CONTEXT_DATA {
    /// Creates a new instance with the specified values
    pub fn new(
        buffer: TPMS_CONTEXT_DATA,
        ) -> Self {
        Self {
            buffer,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This structure is used in TPM2_ContextLoad() and TPM2_ContextSave(). If the values of
/// the TPMS_CONTEXT structure in TPM2_ContextLoad() are not the same as the values when
/// the context was saved (TPM2_ContextSave()), then the TPM shall not load the context.
#[derive(Debug, Clone)]
pub struct TPMS_CONTEXT {
    /// The sequence number of the context
    /// NOTE Transient object contexts and session contexts used different counters.
    pub sequence: u64,

    /// A handle indicating if the context is a session, object, or sequence object (see Table
    /// 222 Context Handle Values
    pub saved_Handle: TPM_HANDLE,

    /// The hierarchy of the context
    pub hierarchy: TPM_HANDLE,

    /// The context data and integrity HMAC
    pub context_Blob: TPMS_CONTEXT_DATA,
}

impl Default for TPMS_CONTEXT {
    fn default() -> Self {
        Self {
            savedHandle: TPM_HANDLE::default(),
            hierarchy: TPM_HANDLE::default(),
        }
    }
}

impl TPMS_CONTEXT {
    /// Creates a new instance with the specified values
    pub fn new(
        sequence: u64,
        saved_Handle: TPM_HANDLE,
        hierarchy: TPM_HANDLE,
        context_Blob: TPMS_CONTEXT_DATA,
        ) -> Self {
        Self {
            sequence,
            saved_Handle,
            hierarchy,
            context_Blob,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This structure provides information relating to the creation environment for the
/// object. The creation data includes the parent Name, parent Qualified Name, and the
/// digest of selected PCR. These values represent the environment in which the object was
/// created. Creation data allows a relying party to determine if an object was created
/// when some appropriate protections were present.
#[derive(Debug, Clone)]
pub struct TPMS_CREATION_DATA {
    /// List indicating the PCR included in pcrDigest
    pub pcr_Select: Vec<TPMS_PCR_SELECTION>,

    /// Digest of the selected PCR using nameAlg of the object for which this structure is
    /// being created
    /// pcrDigest.size shall be zero if the pcrSelect list is empty.
    pub pcr_Digest: Vec<u8>,

    /// The locality at which the object was created
    pub locality: TPMA_LOCALITY,

    /// NameAlg of the parent
    pub parent_Name_Alg: TPM_ALG_ID,

    /// Name of the parent at time of creation
    /// The size will match digest size associated with parentNameAlg unless it is
    /// TPM_ALG_NULL, in which case the size will be 4 and parentName will be the hierarchy handle.
    pub parent_Name: Vec<u8>,

    /// Qualified Name of the parent at the time of creation
    /// Size is the same as parentName.
    pub parent_Qualified_Name: Vec<u8>,

    /// Association with additional information added by the key creator
    /// This will be the contents of the outsideInfo parameter in TPM2_Create() or TPM2_CreatePrimary().
    pub outside_Info: Vec<u8>,
}

impl Default for TPMS_CREATION_DATA {
    fn default() -> Self {
        Self {
            parentNameAlg: TPM_ALG_ID::NULL,
        }
    }
}

impl TPMS_CREATION_DATA {
    /// Creates a new instance with the specified values
    pub fn new(
        pcr_Select: Vec<TPMS_PCR_SELECTION>,
        pcr_Digest: Vec<u8>,
        locality: TPMA_LOCALITY,
        parent_Name_Alg: TPM_ALG_ID,
        parent_Name: Vec<u8>,
        parent_Qualified_Name: Vec<u8>,
        outside_Info: Vec<u8>,
        ) -> Self {
        Self {
            pcr_Select,
            pcr_Digest,
            locality,
            parent_Name_Alg,
            parent_Name,
            parent_Qualified_Name,
            outside_Info,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This structure is created by TPM2_Create() and TPM2_CreatePrimary(). It is never
/// entered into the TPM and never has a size of zero.
#[derive(Debug, Clone)]
pub struct TPM2B_CREATION_DATA {
    pub creation_Data: TPMS_CREATION_DATA,
}

impl Default for TPM2B_CREATION_DATA {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPM2B_CREATION_DATA {
    /// Creates a new instance with the specified values
    pub fn new(
        creation_Data: TPMS_CREATION_DATA,
        ) -> Self {
        Self {
            creation_Data,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// TPMS_AC_OUTPUT is used to return information about an AC. The tag structure parameter
/// indicates the type of the data value.
#[derive(Debug, Clone)]
pub struct TPMS_AC_OUTPUT {
    /// Tag indicating the contents of data
    pub tag: TPM_AT,

    /// The data returned from the AC
    pub data: u32,
}

impl Default for TPMS_AC_OUTPUT {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPMS_AC_OUTPUT {
    /// Creates a new instance with the specified values
    pub fn new(
        tag: TPM_AT,
        data: u32,
        ) -> Self {
        Self {
            tag,
            data,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This list is only used in TPM2_AC_GetCapability().
#[derive(Debug, Clone)]
pub struct TPML_AC_CAPABILITIES {
    /// A list of AC values
    pub ac_Capabilities: Vec<TPMS_AC_OUTPUT>,
}

impl Default for TPML_AC_CAPABILITIES {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPML_AC_CAPABILITIES {
    /// Creates a new instance with the specified values
    pub fn new(
        ac_Capabilities: Vec<TPMS_AC_OUTPUT>,
        ) -> Self {
        Self {
            ac_Capabilities,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// TPM2_Startup() is always preceded by _TPM_Init, which is the physical indication that
/// TPM initialization is necessary because of a system-wide reset. TPM2_Startup() is only
/// valid after _TPM_Init. Additional TPM2_Startup() commands are not allowed after it has
/// completed successfully. If a TPM requires TPM2_Startup() and another command is
/// received, or if the TPM receives TPM2_Startup() when it is not required, the TPM shall
/// return TPM_RC_INITIALIZE.
#[derive(Debug, Clone)]
pub struct TPM2_Startup_REQUEST {
    /// TPM_SU_CLEAR or TPM_SU_STATE
    pub startup_Type: TPM_SU,
}

impl Default for TPM2_Startup_REQUEST {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPM2_Startup_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        startup_Type: TPM_SU,
        ) -> Self {
        Self {
            startup_Type,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command is used to prepare the TPM for a power cycle. The shutdownType parameter
/// indicates how the subsequent TPM2_Startup() will be processed.
#[derive(Debug, Clone)]
pub struct TPM2_Shutdown_REQUEST {
    /// TPM_SU_CLEAR or TPM_SU_STATE
    pub shutdown_Type: TPM_SU,
}

impl Default for TPM2_Shutdown_REQUEST {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPM2_Shutdown_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        shutdown_Type: TPM_SU,
        ) -> Self {
        Self {
            shutdown_Type,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command causes the TPM to perform a test of its capabilities. If the fullTest is
/// YES, the TPM will test all functions. If fullTest = NO, the TPM will only test those
/// functions that have not previously been tested.
#[derive(Debug, Clone)]
pub struct TPM2_SelfTest_REQUEST {
    /// YES if full test to be performed
    /// NO if only test of untested functions required
    pub full_Test: u8,
}

impl Default for TPM2_SelfTest_REQUEST {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPM2_SelfTest_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        full_Test: u8,
        ) -> Self {
        Self {
            full_Test,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command causes the TPM to perform a test of the selected algorithms.
#[derive(Debug, Clone)]
pub struct TPM2_IncrementalSelfTest_REQUEST {
    /// List of algorithms that should be tested
    pub to_Test: Vec<TPM_ALG_ID>,
}

impl Default for TPM2_IncrementalSelfTest_REQUEST {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPM2_IncrementalSelfTest_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        to_Test: Vec<TPM_ALG_ID>,
        ) -> Self {
        Self {
            to_Test,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command causes the TPM to perform a test of the selected algorithms.
#[derive(Debug, Clone)]
pub struct IncrementalSelfTestResponse {
    /// List of algorithms that need testing
    pub to_Do_List: Vec<TPM_ALG_ID>,
}

impl Default for IncrementalSelfTestResponse {
    fn default() -> Self {
        Self {
        }
    }
}

impl IncrementalSelfTestResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command returns manufacturer-specific information regarding the results of a
/// self-test and an indication of the test status.
#[derive(Debug, Clone)]
pub struct TPM2_GetTestResult_REQUEST {
}

impl Default for TPM2_GetTestResult_REQUEST {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPM2_GetTestResult_REQUEST {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command returns manufacturer-specific information regarding the results of a
/// self-test and an indication of the test status.
#[derive(Debug, Clone)]
pub struct GetTestResultResponse {
    /// Test result data
    /// contains manufacturer-specific information
    pub out_Data: Vec<u8>,
    pub test_Result: TPM_RC,
}

impl Default for GetTestResultResponse {
    fn default() -> Self {
        Self {
        }
    }
}

impl GetTestResultResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command is used to start an authorization session using alternative methods of
/// establishing the session key (sessionKey). The session key is then used to derive
/// values used for authorization and for encrypting parameters.
#[derive(Debug, Clone)]
pub struct TPM2_StartAuthSession_REQUEST {
    /// Handle of a loaded decrypt key used to encrypt salt
    /// may be TPM_RH_NULL
    /// Auth Index: None
    pub tpm_Key: TPM_HANDLE,

    /// Entity providing the authValue
    /// may be TPM_RH_NULL
    /// Auth Index: None
    pub bind: TPM_HANDLE,

    /// Initial nonceCaller, sets nonceTPM size for the session
    /// shall be at least 16 octets
    pub nonce_Caller: Vec<u8>,

    /// Value encrypted according to the type of tpmKey
    /// If tpmKey is TPM_RH_NULL, this shall be the Empty Buffer.
    pub encrypted_Salt: Vec<u8>,

    /// Indicates the type of the session; simple HMAC or policy (including a trial policy)
    pub session_Type: TPM_SE,

    /// The algorithm and key size for parameter encryption
    /// may select TPM_ALG_NULL
    pub symmetric: TPMT_SYM_DEF,

    /// Hash algorithm to use for the session
    /// Shall be a hash algorithm supported by the TPM and not TPM_ALG_NULL
    pub auth_Hash: TPM_ALG_ID,
}

impl Default for TPM2_StartAuthSession_REQUEST {
    fn default() -> Self {
        Self {
            tpmKey: TPM_HANDLE::default(),
            bind: TPM_HANDLE::default(),
            authHash: TPM_ALG_ID::NULL,
        }
    }
}

impl TPM2_StartAuthSession_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        tpm_Key: TPM_HANDLE,
        bind: TPM_HANDLE,
        nonce_Caller: Vec<u8>,
        encrypted_Salt: Vec<u8>,
        session_Type: TPM_SE,
        symmetric: TPMT_SYM_DEF,
        auth_Hash: TPM_ALG_ID,
        ) -> Self {
        Self {
            tpm_Key,
            bind,
            nonce_Caller,
            encrypted_Salt,
            session_Type,
            symmetric,
            auth_Hash,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command is used to start an authorization session using alternative methods of
/// establishing the session key (sessionKey). The session key is then used to derive
/// values used for authorization and for encrypting parameters.
#[derive(Debug, Clone)]
pub struct StartAuthSessionResponse {
    /// Handle for the newly created session
    pub handle: TPM_HANDLE,

    /// The initial nonce from the TPM, used in the computation of the sessionKey
    pub nonce_TPM: Vec<u8>,
}

impl Default for StartAuthSessionResponse {
    fn default() -> Self {
        Self {
            handle: TPM_HANDLE::default(),
        }
    }
}

impl StartAuthSessionResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command allows a policy authorization session to be returned to its initial
/// state. This command is used after the TPM returns TPM_RC_PCR_CHANGED. That response
/// code indicates that a policy will fail because the PCR have changed after
/// TPM2_PolicyPCR() was executed. Restarting the session allows the authorizations to be
/// replayed because the session restarts with the same nonceTPM. If the PCR are valid for
/// the policy, the policy may then succeed.
#[derive(Debug, Clone)]
pub struct TPM2_PolicyRestart_REQUEST {
    /// The handle for the policy session
    pub session_Handle: TPM_HANDLE,
}

impl Default for TPM2_PolicyRestart_REQUEST {
    fn default() -> Self {
        Self {
            sessionHandle: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_PolicyRestart_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        session_Handle: TPM_HANDLE,
        ) -> Self {
        Self {
            session_Handle,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command is used to create an object that can be loaded into a TPM using
/// TPM2_Load(). If the command completes successfully, the TPM will create the new object
/// and return the objects creation data (creationData), its public area (outPublic), and
/// its encrypted sensitive area (outPrivate). Preservation of the returned data is the
/// responsibility of the caller. The object will need to be loaded (TPM2_Load()) before
/// it may be used. The only difference between the inPublic TPMT_PUBLIC template and the
/// outPublic TPMT_PUBLIC object is in the unique field.
#[derive(Debug, Clone)]
pub struct TPM2_Create_REQUEST {
    /// Handle of parent for new object
    /// Auth Index: 1
    /// Auth Role: USER
    pub parent_Handle: TPM_HANDLE,

    /// The sensitive data
    pub in_Sensitive: TPMS_SENSITIVE_CREATE,

    /// The public template
    pub in_Public: TPMT_PUBLIC,

    /// Data that will be included in the creation data for this object to provide permanent,
    /// verifiable linkage between this object and some object owner data
    pub outside_Info: Vec<u8>,

    /// PCR that will be used in creation data
    pub creation_PCR: Vec<TPMS_PCR_SELECTION>,
}

impl Default for TPM2_Create_REQUEST {
    fn default() -> Self {
        Self {
            parentHandle: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_Create_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        parent_Handle: TPM_HANDLE,
        in_Sensitive: TPMS_SENSITIVE_CREATE,
        in_Public: TPMT_PUBLIC,
        outside_Info: Vec<u8>,
        creation_PCR: Vec<TPMS_PCR_SELECTION>,
        ) -> Self {
        Self {
            parent_Handle,
            in_Sensitive,
            in_Public,
            outside_Info,
            creation_PCR,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command is used to create an object that can be loaded into a TPM using
/// TPM2_Load(). If the command completes successfully, the TPM will create the new object
/// and return the objects creation data (creationData), its public area (outPublic), and
/// its encrypted sensitive area (outPrivate). Preservation of the returned data is the
/// responsibility of the caller. The object will need to be loaded (TPM2_Load()) before
/// it may be used. The only difference between the inPublic TPMT_PUBLIC template and the
/// outPublic TPMT_PUBLIC object is in the unique field.
#[derive(Debug, Clone)]
pub struct CreateResponse {
    /// The private portion of the object
    pub out_Private: TPM2B_PRIVATE,

    /// The public portion of the created object
    pub out_Public: TPMT_PUBLIC,

    /// Contains a TPMS_CREATION_DATA
    pub creation_Data: TPMS_CREATION_DATA,

    /// Digest of creationData using nameAlg of outPublic
    pub creation_Hash: Vec<u8>,

    /// Ticket used by TPM2_CertifyCreation() to validate that the creation data was produced
    /// by the TPM
    pub creation_Ticket: TPMT_TK_CREATION,
}

impl Default for CreateResponse {
    fn default() -> Self {
        Self {
        }
    }
}

impl CreateResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command is used to load objects into the TPM. This command is used when both a
/// TPM2B_PUBLIC and TPM2B_PRIVATE are to be loaded. If only a TPM2B_PUBLIC is to be
/// loaded, the TPM2_LoadExternal command is used.
#[derive(Debug, Clone)]
pub struct TPM2_Load_REQUEST {
    /// TPM handle of parent key; shall not be a reserved handle
    /// Auth Index: 1
    /// Auth Role: USER
    pub parent_Handle: TPM_HANDLE,

    /// The private portion of the object
    pub in_Private: TPM2B_PRIVATE,

    /// The public portion of the object
    pub in_Public: TPMT_PUBLIC,
}

impl Default for TPM2_Load_REQUEST {
    fn default() -> Self {
        Self {
            parentHandle: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_Load_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        parent_Handle: TPM_HANDLE,
        in_Private: TPM2B_PRIVATE,
        in_Public: TPMT_PUBLIC,
        ) -> Self {
        Self {
            parent_Handle,
            in_Private,
            in_Public,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command is used to load objects into the TPM. This command is used when both a
/// TPM2B_PUBLIC and TPM2B_PRIVATE are to be loaded. If only a TPM2B_PUBLIC is to be
/// loaded, the TPM2_LoadExternal command is used.
#[derive(Debug, Clone)]
pub struct LoadResponse {
    /// Handle of type TPM_HT_TRANSIENT for the loaded object
    pub handle: TPM_HANDLE,

    /// Name of the loaded object
    pub name: Vec<u8>,
}

impl Default for LoadResponse {
    fn default() -> Self {
        Self {
            handle: TPM_HANDLE::default(),
        }
    }
}

impl LoadResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command is used to load an object that is not a Protected Object into the TPM.
/// The command allows loading of a public area or both a public and sensitive area.
#[derive(Debug, Clone)]
pub struct TPM2_LoadExternal_REQUEST {
    /// The sensitive portion of the object (optional)
    pub in_Private: TPMT_SENSITIVE,

    /// The public portion of the object
    pub in_Public: TPMT_PUBLIC,

    /// Hierarchy with which the object area is associated
    pub hierarchy: TPM_HANDLE,
}

impl Default for TPM2_LoadExternal_REQUEST {
    fn default() -> Self {
        Self {
            hierarchy: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_LoadExternal_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        in_Private: TPMT_SENSITIVE,
        in_Public: TPMT_PUBLIC,
        hierarchy: TPM_HANDLE,
        ) -> Self {
        Self {
            in_Private,
            in_Public,
            hierarchy,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command is used to load an object that is not a Protected Object into the TPM.
/// The command allows loading of a public area or both a public and sensitive area.
#[derive(Debug, Clone)]
pub struct LoadExternalResponse {
    /// Handle of type TPM_HT_TRANSIENT for the loaded object
    pub handle: TPM_HANDLE,

    /// Name of the loaded object
    pub name: Vec<u8>,
}

impl Default for LoadExternalResponse {
    fn default() -> Self {
        Self {
            handle: TPM_HANDLE::default(),
        }
    }
}

impl LoadExternalResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command allows access to the public area of a loaded object.
#[derive(Debug, Clone)]
pub struct TPM2_ReadPublic_REQUEST {
    /// TPM handle of an object
    /// Auth Index: None
    pub object_Handle: TPM_HANDLE,
}

impl Default for TPM2_ReadPublic_REQUEST {
    fn default() -> Self {
        Self {
            objectHandle: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_ReadPublic_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        object_Handle: TPM_HANDLE,
        ) -> Self {
        Self {
            object_Handle,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command allows access to the public area of a loaded object.
#[derive(Debug, Clone)]
pub struct ReadPublicResponse {
    /// Structure containing the public area of an object
    pub out_Public: TPMT_PUBLIC,

    /// Name of the object
    pub name: Vec<u8>,

    /// The Qualified Name of the object
    pub qualified_Name: Vec<u8>,
}

impl Default for ReadPublicResponse {
    fn default() -> Self {
        Self {
        }
    }
}

impl ReadPublicResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command enables the association of a credential with an object in a way that
/// ensures that the TPM has validated the parameters of the credentialed object.
#[derive(Debug, Clone)]
pub struct TPM2_ActivateCredential_REQUEST {
    /// Handle of the object associated with certificate in credentialBlob
    /// Auth Index: 1
    /// Auth Role: ADMIN
    pub activate_Handle: TPM_HANDLE,

    /// Loaded key used to decrypt the TPMS_SENSITIVE in credentialBlob
    /// Auth Index: 2
    /// Auth Role: USER
    pub key_Handle: TPM_HANDLE,

    /// The credential
    pub credential_Blob: TPMS_ID_OBJECT,

    /// KeyHandle algorithm-dependent encrypted seed that protects credentialBlob
    pub secret: Vec<u8>,
}

impl Default for TPM2_ActivateCredential_REQUEST {
    fn default() -> Self {
        Self {
            activateHandle: TPM_HANDLE::default(),
            keyHandle: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_ActivateCredential_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        activate_Handle: TPM_HANDLE,
        key_Handle: TPM_HANDLE,
        credential_Blob: TPMS_ID_OBJECT,
        secret: Vec<u8>,
        ) -> Self {
        Self {
            activate_Handle,
            key_Handle,
            credential_Blob,
            secret,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command enables the association of a credential with an object in a way that
/// ensures that the TPM has validated the parameters of the credentialed object.
#[derive(Debug, Clone)]
pub struct ActivateCredentialResponse {
    /// The decrypted certificate information
    /// the data should be no larger than the size of the digest of the nameAlg associated
    /// with keyHandle
    pub cert_Info: Vec<u8>,
}

impl Default for ActivateCredentialResponse {
    fn default() -> Self {
        Self {
        }
    }
}

impl ActivateCredentialResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command allows the TPM to perform the actions required of a Certificate Authority
/// (CA) in creating a TPM2B_ID_OBJECT containing an activation credential.
#[derive(Debug, Clone)]
pub struct TPM2_MakeCredential_REQUEST {
    /// Loaded public area, used to encrypt the sensitive area containing the credential key
    /// Auth Index: None
    pub handle: TPM_HANDLE,

    /// The credential information
    pub credential: Vec<u8>,

    /// Name of the object to which the credential applies
    pub object_Name: Vec<u8>,
}

impl Default for TPM2_MakeCredential_REQUEST {
    fn default() -> Self {
        Self {
            handle: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_MakeCredential_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        handle: TPM_HANDLE,
        credential: Vec<u8>,
        object_Name: Vec<u8>,
        ) -> Self {
        Self {
            handle,
            credential,
            object_Name,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command allows the TPM to perform the actions required of a Certificate Authority
/// (CA) in creating a TPM2B_ID_OBJECT containing an activation credential.
#[derive(Debug, Clone)]
pub struct MakeCredentialResponse {
    /// The credential
    pub credential_Blob: TPMS_ID_OBJECT,

    /// Handle algorithm-dependent data that wraps the key that encrypts credentialBlob
    pub secret: Vec<u8>,
}

impl Default for MakeCredentialResponse {
    fn default() -> Self {
        Self {
        }
    }
}

impl MakeCredentialResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command returns the data in a loaded Sealed Data Object.
#[derive(Debug, Clone)]
pub struct TPM2_Unseal_REQUEST {
    /// Handle of a loaded data object
    /// Auth Index: 1
    /// Auth Role: USER
    pub item_Handle: TPM_HANDLE,
}

impl Default for TPM2_Unseal_REQUEST {
    fn default() -> Self {
        Self {
            itemHandle: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_Unseal_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        item_Handle: TPM_HANDLE,
        ) -> Self {
        Self {
            item_Handle,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command returns the data in a loaded Sealed Data Object.
#[derive(Debug, Clone)]
pub struct UnsealResponse {
    /// Unsealed data
    /// Size of outData is limited to be no more than 128 octets.
    pub out_Data: Vec<u8>,
}

impl Default for UnsealResponse {
    fn default() -> Self {
        Self {
        }
    }
}

impl UnsealResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command is used to change the authorization secret for a TPM-resident object.
#[derive(Debug, Clone)]
pub struct TPM2_ObjectChangeAuth_REQUEST {
    /// Handle of the object
    /// Auth Index: 1
    /// Auth Role: ADMIN
    pub object_Handle: TPM_HANDLE,

    /// Handle of the parent
    /// Auth Index: None
    pub parent_Handle: TPM_HANDLE,

    /// New authorization value
    pub new_Auth: Vec<u8>,
}

impl Default for TPM2_ObjectChangeAuth_REQUEST {
    fn default() -> Self {
        Self {
            objectHandle: TPM_HANDLE::default(),
            parentHandle: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_ObjectChangeAuth_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        object_Handle: TPM_HANDLE,
        parent_Handle: TPM_HANDLE,
        new_Auth: Vec<u8>,
        ) -> Self {
        Self {
            object_Handle,
            parent_Handle,
            new_Auth,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command is used to change the authorization secret for a TPM-resident object.
#[derive(Debug, Clone)]
pub struct ObjectChangeAuthResponse {
    /// Private area containing the new authorization value
    pub out_Private: TPM2B_PRIVATE,
}

impl Default for ObjectChangeAuthResponse {
    fn default() -> Self {
        Self {
        }
    }
}

impl ObjectChangeAuthResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command creates an object and loads it in the TPM. This command allows creation
/// of any type of object (Primary, Ordinary, or Derived) depending on the type of
/// parentHandle. If parentHandle references a Primary Seed, then a Primary Object is
/// created; if parentHandle references a Storage Parent, then an Ordinary Object is
/// created; and if parentHandle references a Derivation Parent, then a Derived Object is generated.
#[derive(Debug, Clone)]
pub struct TPM2_CreateLoaded_REQUEST {
    /// Handle of a transient storage key, a persistent storage key, TPM_RH_ENDORSEMENT,
    /// TPM_RH_OWNER, TPM_RH_PLATFORM+{PP}, or TPM_RH_NULL
    /// Auth Index: 1
    /// Auth Role: USER
    pub parent_Handle: TPM_HANDLE,

    /// The sensitive data, see TPM 2.0 Part 1 Sensitive Values
    pub in_Sensitive: TPMS_SENSITIVE_CREATE,

    /// The public template
    pub in_Public: Vec<u8>,
}

impl Default for TPM2_CreateLoaded_REQUEST {
    fn default() -> Self {
        Self {
            parentHandle: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_CreateLoaded_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        parent_Handle: TPM_HANDLE,
        in_Sensitive: TPMS_SENSITIVE_CREATE,
        in_Public: Vec<u8>,
        ) -> Self {
        Self {
            parent_Handle,
            in_Sensitive,
            in_Public,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command creates an object and loads it in the TPM. This command allows creation
/// of any type of object (Primary, Ordinary, or Derived) depending on the type of
/// parentHandle. If parentHandle references a Primary Seed, then a Primary Object is
/// created; if parentHandle references a Storage Parent, then an Ordinary Object is
/// created; and if parentHandle references a Derivation Parent, then a Derived Object is generated.
#[derive(Debug, Clone)]
pub struct CreateLoadedResponse {
    /// Handle of type TPM_HT_TRANSIENT for created object
    pub handle: TPM_HANDLE,

    /// The sensitive area of the object (optional)
    pub out_Private: TPM2B_PRIVATE,

    /// The public portion of the created object
    pub out_Public: TPMT_PUBLIC,

    /// The name of the created object
    pub name: Vec<u8>,
}

impl Default for CreateLoadedResponse {
    fn default() -> Self {
        Self {
            handle: TPM_HANDLE::default(),
        }
    }
}

impl CreateLoadedResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command duplicates a loaded object so that it may be used in a different
/// hierarchy. The new parent key for the duplicate may be on the same or different TPM or
/// TPM_RH_NULL. Only the public area of newParentHandle is required to be loaded.
#[derive(Debug, Clone)]
pub struct TPM2_Duplicate_REQUEST {
    /// Loaded object to duplicate
    /// Auth Index: 1
    /// Auth Role: DUP
    pub object_Handle: TPM_HANDLE,

    /// Shall reference the public area of an asymmetric key
    /// Auth Index: None
    pub new_Parent_Handle: TPM_HANDLE,

    /// Optional symmetric encryption key
    /// The size for this key is set to zero when the TPM is to generate the key. This
    /// parameter may be encrypted.
    pub encryption_Key_In: Vec<u8>,

    /// Definition for the symmetric algorithm to be used for the inner wrapper
    /// may be TPM_ALG_NULL if no inner wrapper is applied
    pub symmetric_Alg: TPMT_SYM_DEF_OBJECT,
}

impl Default for TPM2_Duplicate_REQUEST {
    fn default() -> Self {
        Self {
            objectHandle: TPM_HANDLE::default(),
            newParentHandle: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_Duplicate_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        object_Handle: TPM_HANDLE,
        new_Parent_Handle: TPM_HANDLE,
        encryption_Key_In: Vec<u8>,
        symmetric_Alg: TPMT_SYM_DEF_OBJECT,
        ) -> Self {
        Self {
            object_Handle,
            new_Parent_Handle,
            encryption_Key_In,
            symmetric_Alg,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command duplicates a loaded object so that it may be used in a different
/// hierarchy. The new parent key for the duplicate may be on the same or different TPM or
/// TPM_RH_NULL. Only the public area of newParentHandle is required to be loaded.
#[derive(Debug, Clone)]
pub struct DuplicateResponse {
    /// If the caller provided an encryption key or if symmetricAlg was TPM_ALG_NULL, then
    /// this will be the Empty Buffer; otherwise, it shall contain the TPM-generated,
    /// symmetric encryption key for the inner wrapper.
    pub encryption_Key_Out: Vec<u8>,

    /// Private area that may be encrypted by encryptionKeyIn; and may be doubly encrypted
    pub duplicate: TPM2B_PRIVATE,

    /// Seed protected by the asymmetric algorithms of new parent (NP)
    pub out_Sym_Seed: Vec<u8>,
}

impl Default for DuplicateResponse {
    fn default() -> Self {
        Self {
        }
    }
}

impl DuplicateResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command allows the TPM to serve in the role as a Duplication Authority. If proper
/// authorization for use of the oldParent is provided, then an HMAC key and a symmetric
/// key are recovered from inSymSeed and used to integrity check and decrypt inDuplicate.
/// A new protection seed value is generated according to the methods appropriate for
/// newParent and the blob is re-encrypted and a new integrity value is computed. The
/// re-encrypted blob is returned in outDuplicate and the symmetric key returned in outSymKey.
#[derive(Debug, Clone)]
pub struct TPM2_Rewrap_REQUEST {
    /// Parent of object
    /// Auth Index: 1
    /// Auth Role: User
    pub old_Parent: TPM_HANDLE,

    /// New parent of the object
    /// Auth Index: None
    pub new_Parent: TPM_HANDLE,

    /// An object encrypted using symmetric key derived from inSymSeed
    pub in_Duplicate: TPM2B_PRIVATE,

    /// The Name of the object being rewrapped
    pub name: Vec<u8>,

    /// The seed for the symmetric key and HMAC key
    /// needs oldParent private key to recover the seed and generate the symmetric key
    pub in_Sym_Seed: Vec<u8>,
}

impl Default for TPM2_Rewrap_REQUEST {
    fn default() -> Self {
        Self {
            oldParent: TPM_HANDLE::default(),
            newParent: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_Rewrap_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        old_Parent: TPM_HANDLE,
        new_Parent: TPM_HANDLE,
        in_Duplicate: TPM2B_PRIVATE,
        name: Vec<u8>,
        in_Sym_Seed: Vec<u8>,
        ) -> Self {
        Self {
            old_Parent,
            new_Parent,
            in_Duplicate,
            name,
            in_Sym_Seed,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command allows the TPM to serve in the role as a Duplication Authority. If proper
/// authorization for use of the oldParent is provided, then an HMAC key and a symmetric
/// key are recovered from inSymSeed and used to integrity check and decrypt inDuplicate.
/// A new protection seed value is generated according to the methods appropriate for
/// newParent and the blob is re-encrypted and a new integrity value is computed. The
/// re-encrypted blob is returned in outDuplicate and the symmetric key returned in outSymKey.
#[derive(Debug, Clone)]
pub struct RewrapResponse {
    /// An object encrypted using symmetric key derived from outSymSeed
    pub out_Duplicate: TPM2B_PRIVATE,

    /// Seed for a symmetric key protected by newParent asymmetric key
    pub out_Sym_Seed: Vec<u8>,
}

impl Default for RewrapResponse {
    fn default() -> Self {
        Self {
        }
    }
}

impl RewrapResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command allows an object to be encrypted using the symmetric encryption values of
/// a Storage Key. After encryption, the object may be loaded and used in the new
/// hierarchy. The imported object (duplicate) may be singly encrypted, multiply
/// encrypted, or unencrypted.
#[derive(Debug, Clone)]
pub struct TPM2_Import_REQUEST {
    /// The handle of the new parent for the object
    /// Auth Index: 1
    /// Auth Role: USER
    pub parent_Handle: TPM_HANDLE,

    /// The optional symmetric encryption key used as the inner wrapper for duplicate
    /// If symmetricAlg is TPM_ALG_NULL, then this parameter shall be the Empty Buffer.
    pub encryption_Key: Vec<u8>,

    /// The public area of the object to be imported
    /// This is provided so that the integrity value for duplicate and the object attributes
    /// can be checked.
    /// NOTE Even if the integrity value of the object is not checked on input, the object
    /// Name is required to create the integrity value for the imported object.
    pub object_Public: TPMT_PUBLIC,

    /// The symmetrically encrypted duplicate object that may contain an inner symmetric wrapper
    pub duplicate: TPM2B_PRIVATE,

    /// The seed for the symmetric key and HMAC key
    /// inSymSeed is encrypted/encoded using the algorithms of newParent.
    pub in_Sym_Seed: Vec<u8>,

    /// Definition for the symmetric algorithm to use for the inner wrapper
    /// If this algorithm is TPM_ALG_NULL, no inner wrapper is present and encryptionKey shall
    /// be the Empty Buffer.
    pub symmetric_Alg: TPMT_SYM_DEF_OBJECT,
}

impl Default for TPM2_Import_REQUEST {
    fn default() -> Self {
        Self {
            parentHandle: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_Import_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        parent_Handle: TPM_HANDLE,
        encryption_Key: Vec<u8>,
        object_Public: TPMT_PUBLIC,
        duplicate: TPM2B_PRIVATE,
        in_Sym_Seed: Vec<u8>,
        symmetric_Alg: TPMT_SYM_DEF_OBJECT,
        ) -> Self {
        Self {
            parent_Handle,
            encryption_Key,
            object_Public,
            duplicate,
            in_Sym_Seed,
            symmetric_Alg,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command allows an object to be encrypted using the symmetric encryption values of
/// a Storage Key. After encryption, the object may be loaded and used in the new
/// hierarchy. The imported object (duplicate) may be singly encrypted, multiply
/// encrypted, or unencrypted.
#[derive(Debug, Clone)]
pub struct ImportResponse {
    /// The sensitive area encrypted with the symmetric key of parentHandle
    pub out_Private: TPM2B_PRIVATE,
}

impl Default for ImportResponse {
    fn default() -> Self {
        Self {
        }
    }
}

impl ImportResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command performs RSA encryption using the indicated padding scheme according to
/// IETF RFC 8017. If the scheme of keyHandle is TPM_ALG_NULL, then the caller may use
/// inScheme to specify the padding scheme. If scheme of keyHandle is not TPM_ALG_NULL,
/// then inScheme shall either be TPM_ALG_NULL or be the same as scheme (TPM_RC_SCHEME).
#[derive(Debug, Clone)]
pub struct TPM2_RSA_Encrypt_REQUEST {
    /// Reference to public portion of RSA key to use for encryption
    /// Auth Index: None
    pub key_Handle: TPM_HANDLE,

    /// Message to be encrypted
    /// NOTE 1 The data type was chosen because it limits the overall size of the input to no
    /// greater than the size of the largest RSA public key. This may be larger than allowed
    /// for keyHandle.
    pub message: Vec<u8>,

    /// Scheme selector

    /// The padding scheme to use if scheme associated with keyHandle is TPM_ALG_NULL
    /// One of: TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA,
    /// TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA,
    /// TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES,
    /// TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME.
    pub in_Scheme: TPMU_ASYM_SCHEME,

    /// Optional label L to be associated with the message
    /// Size of the buffer is zero if no label is present
    /// NOTE 2 See description of label above.
    pub label: Vec<u8>,
}

impl Default for TPM2_RSA_Encrypt_REQUEST {
    fn default() -> Self {
        Self {
            keyHandle: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_RSA_Encrypt_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        key_Handle: TPM_HANDLE,
        message: Vec<u8>,
        in_Scheme: TPMU_ASYM_SCHEME,
        label: Vec<u8>,
        ) -> Self {
        Self {
            key_Handle,
            message,
            in_Scheme,
            label,
        }
    }

    /// Get the inSchemeScheme selector value
    pub fn in_Scheme_Scheme(&self) -> TPM_ALG_ID {
        match &self.in_Scheme {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command performs RSA encryption using the indicated padding scheme according to
/// IETF RFC 8017. If the scheme of keyHandle is TPM_ALG_NULL, then the caller may use
/// inScheme to specify the padding scheme. If scheme of keyHandle is not TPM_ALG_NULL,
/// then inScheme shall either be TPM_ALG_NULL or be the same as scheme (TPM_RC_SCHEME).
#[derive(Debug, Clone)]
pub struct RSA_EncryptResponse {
    /// Encrypted output
    pub out_Data: Vec<u8>,
}

impl Default for RSA_EncryptResponse {
    fn default() -> Self {
        Self {
        }
    }
}

impl RSA_EncryptResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command performs RSA decryption using the indicated padding scheme according to
/// IETF RFC 8017 ((PKCS#1).
#[derive(Debug, Clone)]
pub struct TPM2_RSA_Decrypt_REQUEST {
    /// RSA key to use for decryption
    /// Auth Index: 1
    /// Auth Role: USER
    pub key_Handle: TPM_HANDLE,

    /// Cipher text to be decrypted
    /// NOTE An encrypted RSA data block is the size of the public modulus.
    pub cipher_Text: Vec<u8>,

    /// Scheme selector

    /// The padding scheme to use if scheme associated with keyHandle is TPM_ALG_NULL
    /// One of: TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA,
    /// TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA,
    /// TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES,
    /// TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME.
    pub in_Scheme: TPMU_ASYM_SCHEME,

    /// Label whose association with the message is to be verified
    pub label: Vec<u8>,
}

impl Default for TPM2_RSA_Decrypt_REQUEST {
    fn default() -> Self {
        Self {
            keyHandle: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_RSA_Decrypt_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        key_Handle: TPM_HANDLE,
        cipher_Text: Vec<u8>,
        in_Scheme: TPMU_ASYM_SCHEME,
        label: Vec<u8>,
        ) -> Self {
        Self {
            key_Handle,
            cipher_Text,
            in_Scheme,
            label,
        }
    }

    /// Get the inSchemeScheme selector value
    pub fn in_Scheme_Scheme(&self) -> TPM_ALG_ID {
        match &self.in_Scheme {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command performs RSA decryption using the indicated padding scheme according to
/// IETF RFC 8017 ((PKCS#1).
#[derive(Debug, Clone)]
pub struct RSA_DecryptResponse {
    /// Decrypted output
    pub message: Vec<u8>,
}

impl Default for RSA_DecryptResponse {
    fn default() -> Self {
        Self {
        }
    }
}

impl RSA_DecryptResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command uses the TPM to generate an ephemeral key pair (de, Qe where Qe [de]G).
/// It uses the private ephemeral key and a loaded public key (QS) to compute the shared
/// secret value (P [hde]QS).
#[derive(Debug, Clone)]
pub struct TPM2_ECDH_KeyGen_REQUEST {
    /// Handle of a loaded ECC key public area.
    /// Auth Index: None
    pub key_Handle: TPM_HANDLE,
}

impl Default for TPM2_ECDH_KeyGen_REQUEST {
    fn default() -> Self {
        Self {
            keyHandle: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_ECDH_KeyGen_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        key_Handle: TPM_HANDLE,
        ) -> Self {
        Self {
            key_Handle,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command uses the TPM to generate an ephemeral key pair (de, Qe where Qe [de]G).
/// It uses the private ephemeral key and a loaded public key (QS) to compute the shared
/// secret value (P [hde]QS).
#[derive(Debug, Clone)]
pub struct ECDH_KeyGenResponse {
    /// Results of P h[de]Qs
    pub zPoint: TPMS_ECC_POINT,

    /// Generated ephemeral public point (Qe)
    pub pub_Point: TPMS_ECC_POINT,
}

impl Default for ECDH_KeyGenResponse {
    fn default() -> Self {
        Self {
        }
    }
}

impl ECDH_KeyGenResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command uses the TPM to recover the Z value from a public point (QB) and a
/// private key (ds). It will perform the multiplication of the provided inPoint (QB) with
/// the private key (ds) and return the coordinates of the resultant point (Z = (xZ , yZ)
/// [hds]QB; where h is the cofactor of the curve).
#[derive(Debug, Clone)]
pub struct TPM2_ECDH_ZGen_REQUEST {
    /// Handle of a loaded ECC key
    /// Auth Index: 1
    /// Auth Role: USER
    pub key_Handle: TPM_HANDLE,

    /// A public key
    pub in_Point: TPMS_ECC_POINT,
}

impl Default for TPM2_ECDH_ZGen_REQUEST {
    fn default() -> Self {
        Self {
            keyHandle: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_ECDH_ZGen_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        key_Handle: TPM_HANDLE,
        in_Point: TPMS_ECC_POINT,
        ) -> Self {
        Self {
            key_Handle,
            in_Point,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command uses the TPM to recover the Z value from a public point (QB) and a
/// private key (ds). It will perform the multiplication of the provided inPoint (QB) with
/// the private key (ds) and return the coordinates of the resultant point (Z = (xZ , yZ)
/// [hds]QB; where h is the cofactor of the curve).
#[derive(Debug, Clone)]
pub struct ECDH_ZGenResponse {
    /// X and Y coordinates of the product of the multiplication Z = (xZ , yZ) [hdS]QB
    pub out_Point: TPMS_ECC_POINT,
}

impl Default for ECDH_ZGenResponse {
    fn default() -> Self {
        Self {
        }
    }
}

impl ECDH_ZGenResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command returns the parameters of an ECC curve identified by its TCG-assigned curveID.
#[derive(Debug, Clone)]
pub struct TPM2_ECC_Parameters_REQUEST {
    /// Parameter set selector
    pub curve_ID: TPM_ECC_CURVE,
}

impl Default for TPM2_ECC_Parameters_REQUEST {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPM2_ECC_Parameters_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        curve_ID: TPM_ECC_CURVE,
        ) -> Self {
        Self {
            curve_ID,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command returns the parameters of an ECC curve identified by its TCG-assigned curveID.
#[derive(Debug, Clone)]
pub struct ECC_ParametersResponse {
    /// ECC parameters for the selected curve
    pub parameters: TPMS_ALGORITHM_DETAIL_ECC,
}

impl Default for ECC_ParametersResponse {
    fn default() -> Self {
        Self {
        }
    }
}

impl ECC_ParametersResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command supports two-phase key exchange protocols. The command is used in
/// combination with TPM2_EC_Ephemeral(). TPM2_EC_Ephemeral() generates an ephemeral key
/// and returns the public point of that ephemeral key along with a numeric value that
/// allows the TPM to regenerate the associated private key.
#[derive(Debug, Clone)]
pub struct TPM2_ZGen_2Phase_REQUEST {
    /// Handle of an unrestricted decryption key ECC
    /// The private key referenced by this handle is used as dS,A
    /// Auth Index: 1
    /// Auth Role: USER
    pub key_A: TPM_HANDLE,

    /// Other partys static public key (Qs,B = (Xs,B, Ys,B))
    pub in_Qs_B: TPMS_ECC_POINT,

    /// Other party's ephemeral public key (Qe,B = (Xe,B, Ye,B))
    pub in_Qe_B: TPMS_ECC_POINT,

    /// The key exchange scheme
    pub in_Scheme: TPM_ALG_ID,

    /// Value returned by TPM2_EC_Ephemeral()
    pub counter: u16,
}

impl Default for TPM2_ZGen_2Phase_REQUEST {
    fn default() -> Self {
        Self {
            keyA: TPM_HANDLE::default(),
            inScheme: TPM_ALG_ID::NULL,
        }
    }
}

impl TPM2_ZGen_2Phase_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        key_A: TPM_HANDLE,
        in_Qs_B: TPMS_ECC_POINT,
        in_Qe_B: TPMS_ECC_POINT,
        in_Scheme: TPM_ALG_ID,
        counter: u16,
        ) -> Self {
        Self {
            key_A,
            in_Qs_B,
            in_Qe_B,
            in_Scheme,
            counter,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command supports two-phase key exchange protocols. The command is used in
/// combination with TPM2_EC_Ephemeral(). TPM2_EC_Ephemeral() generates an ephemeral key
/// and returns the public point of that ephemeral key along with a numeric value that
/// allows the TPM to regenerate the associated private key.
#[derive(Debug, Clone)]
pub struct ZGen_2PhaseResponse {
    /// X and Y coordinates of the computed value (scheme dependent)
    pub out_Z1: TPMS_ECC_POINT,

    /// X and Y coordinates of the second computed value (scheme dependent)
    pub out_Z2: TPMS_ECC_POINT,
}

impl Default for ZGen_2PhaseResponse {
    fn default() -> Self {
        Self {
        }
    }
}

impl ZGen_2PhaseResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command performs ECC encryption as described in Part 1, Annex D.
#[derive(Debug, Clone)]
pub struct TPM2_ECC_Encrypt_REQUEST {
    /// Reference to public portion of ECC key to use for encryption
    /// Auth Index: None
    pub key_Handle: TPM_HANDLE,

    /// Plaintext to be encrypted
    pub plain_Text: Vec<u8>,

    /// Scheme selector

    /// The KDF to use if scheme associated with keyHandle is TPM_ALG_NULL
    /// One of: TPMS_KDF_SCHEME_MGF1, TPMS_KDF_SCHEME_KDF1_SP800_56A, TPMS_KDF_SCHEME_KDF2,
    /// TPMS_KDF_SCHEME_KDF1_SP800_108, TPMS_SCHEME_HASH, TPMS_NULL_KDF_SCHEME.
    pub in_Scheme: TPMU_KDF_SCHEME,
}

impl Default for TPM2_ECC_Encrypt_REQUEST {
    fn default() -> Self {
        Self {
            keyHandle: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_ECC_Encrypt_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        key_Handle: TPM_HANDLE,
        plain_Text: Vec<u8>,
        in_Scheme: TPMU_KDF_SCHEME,
        ) -> Self {
        Self {
            key_Handle,
            plain_Text,
            in_Scheme,
        }
    }

    /// Get the inSchemeScheme selector value
    pub fn in_Scheme_Scheme(&self) -> TPM_ALG_ID {
        match &self.in_Scheme {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command performs ECC encryption as described in Part 1, Annex D.
#[derive(Debug, Clone)]
pub struct ECC_EncryptResponse {
    /// The public ephemeral key used for ECDH
    pub C1: TPMS_ECC_POINT,

    /// The data block produced by the XOR process
    pub C2: Vec<u8>,

    /// The integrity value
    pub C3: Vec<u8>,
}

impl Default for ECC_EncryptResponse {
    fn default() -> Self {
        Self {
        }
    }
}

impl ECC_EncryptResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command performs ECC decryption.
#[derive(Debug, Clone)]
pub struct TPM2_ECC_Decrypt_REQUEST {
    /// ECC key to use for decryption
    /// Auth Index: 1
    /// Auth Role: USER
    pub key_Handle: TPM_HANDLE,

    /// The public ephemeral key used for ECDH
    pub C1: TPMS_ECC_POINT,

    /// The data block produced by the XOR process
    pub C2: Vec<u8>,

    /// The integrity value
    pub C3: Vec<u8>,

    /// Scheme selector

    /// The KDF to use if scheme associated with keyHandle is TPM_ALG_NULL
    /// One of: TPMS_KDF_SCHEME_MGF1, TPMS_KDF_SCHEME_KDF1_SP800_56A, TPMS_KDF_SCHEME_KDF2,
    /// TPMS_KDF_SCHEME_KDF1_SP800_108, TPMS_SCHEME_HASH, TPMS_NULL_KDF_SCHEME.
    pub in_Scheme: TPMU_KDF_SCHEME,
}

impl Default for TPM2_ECC_Decrypt_REQUEST {
    fn default() -> Self {
        Self {
            keyHandle: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_ECC_Decrypt_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        key_Handle: TPM_HANDLE,
        C1: TPMS_ECC_POINT,
        C2: Vec<u8>,
        C3: Vec<u8>,
        in_Scheme: TPMU_KDF_SCHEME,
        ) -> Self {
        Self {
            key_Handle,
            C1,
            C2,
            C3,
            in_Scheme,
        }
    }

    /// Get the inSchemeScheme selector value
    pub fn in_Scheme_Scheme(&self) -> TPM_ALG_ID {
        match &self.in_Scheme {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command performs ECC decryption.
#[derive(Debug, Clone)]
pub struct ECC_DecryptResponse {
    /// Decrypted output
    pub plain_Text: Vec<u8>,
}

impl Default for ECC_DecryptResponse {
    fn default() -> Self {
        Self {
        }
    }
}

impl ECC_DecryptResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// NOTE 1 This command is deprecated, and TPM2_EncryptDecrypt2() is preferred. This
/// should be reflected in platform-specific specifications.
#[derive(Debug, Clone)]
pub struct TPM2_EncryptDecrypt_REQUEST {
    /// The symmetric key used for the operation
    /// Auth Index: 1
    /// Auth Role: USER
    pub key_Handle: TPM_HANDLE,

    /// If YES, then the operation is decryption; if NO, the operation is encryption
    pub decrypt: u8,

    /// Symmetric encryption/decryption mode
    /// this field shall match the default mode of the key or be TPM_ALG_NULL.
    pub mode: TPM_ALG_ID,

    /// An initial value as required by the algorithm
    pub iv_In: Vec<u8>,

    /// The data to be encrypted/decrypted
    pub in_Data: Vec<u8>,
}

impl Default for TPM2_EncryptDecrypt_REQUEST {
    fn default() -> Self {
        Self {
            keyHandle: TPM_HANDLE::default(),
            mode: TPM_ALG_ID::NULL,
        }
    }
}

impl TPM2_EncryptDecrypt_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        key_Handle: TPM_HANDLE,
        decrypt: u8,
        mode: TPM_ALG_ID,
        iv_In: Vec<u8>,
        in_Data: Vec<u8>,
        ) -> Self {
        Self {
            key_Handle,
            decrypt,
            mode,
            iv_In,
            in_Data,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// NOTE 1 This command is deprecated, and TPM2_EncryptDecrypt2() is preferred. This
/// should be reflected in platform-specific specifications.
#[derive(Debug, Clone)]
pub struct EncryptDecryptResponse {
    /// Encrypted or decrypted output
    pub out_Data: Vec<u8>,

    /// Chaining value to use for IV in next round
    pub iv_Out: Vec<u8>,
}

impl Default for EncryptDecryptResponse {
    fn default() -> Self {
        Self {
        }
    }
}

impl EncryptDecryptResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command is identical to TPM2_EncryptDecrypt(), except that the inData parameter
/// is the first parameter. This permits inData to be parameter encrypted.
#[derive(Debug, Clone)]
pub struct TPM2_EncryptDecrypt2_REQUEST {
    /// The symmetric key used for the operation
    /// Auth Index: 1
    /// Auth Role: USER
    pub key_Handle: TPM_HANDLE,

    /// The data to be encrypted/decrypted
    pub in_Data: Vec<u8>,

    /// If YES, then the operation is decryption; if NO, the operation is encryption
    pub decrypt: u8,

    /// Symmetric mode
    /// this field shall match the default mode of the key or be TPM_ALG_NULL.
    pub mode: TPM_ALG_ID,

    /// An initial value as required by the algorithm
    pub iv_In: Vec<u8>,
}

impl Default for TPM2_EncryptDecrypt2_REQUEST {
    fn default() -> Self {
        Self {
            keyHandle: TPM_HANDLE::default(),
            mode: TPM_ALG_ID::NULL,
        }
    }
}

impl TPM2_EncryptDecrypt2_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        key_Handle: TPM_HANDLE,
        in_Data: Vec<u8>,
        decrypt: u8,
        mode: TPM_ALG_ID,
        iv_In: Vec<u8>,
        ) -> Self {
        Self {
            key_Handle,
            in_Data,
            decrypt,
            mode,
            iv_In,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command is identical to TPM2_EncryptDecrypt(), except that the inData parameter
/// is the first parameter. This permits inData to be parameter encrypted.
#[derive(Debug, Clone)]
pub struct EncryptDecrypt2Response {
    /// Encrypted or decrypted output
    pub out_Data: Vec<u8>,

    /// Chaining value to use for IV in next round
    pub iv_Out: Vec<u8>,
}

impl Default for EncryptDecrypt2Response {
    fn default() -> Self {
        Self {
        }
    }
}

impl EncryptDecrypt2Response {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command performs a hash operation on a data buffer and returns the results.
#[derive(Debug, Clone)]
pub struct TPM2_Hash_REQUEST {
    /// Data to be hashed
    pub data: Vec<u8>,

    /// Algorithm for the hash being computed shall not be TPM_ALG_NULL
    pub hash_Alg: TPM_ALG_ID,

    /// Hierarchy to use for the ticket (TPM_RH_NULL allowed)
    pub hierarchy: TPM_HANDLE,
}

impl Default for TPM2_Hash_REQUEST {
    fn default() -> Self {
        Self {
            hashAlg: TPM_ALG_ID::NULL,
            hierarchy: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_Hash_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        data: Vec<u8>,
        hash_Alg: TPM_ALG_ID,
        hierarchy: TPM_HANDLE,
        ) -> Self {
        Self {
            data,
            hash_Alg,
            hierarchy,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command performs a hash operation on a data buffer and returns the results.
#[derive(Debug, Clone)]
pub struct HashResponse {
    /// Results
    pub out_Hash: Vec<u8>,

    /// Ticket indicating that the sequence of octets used to compute outDigest did not start
    /// with TPM_GENERATED_VALUE
    /// will be a NULL ticket if the digest may not be signed with a restricted key
    pub validation: TPMT_TK_HASHCHECK,
}

impl Default for HashResponse {
    fn default() -> Self {
        Self {
        }
    }
}

impl HashResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command performs an HMAC on the supplied data using the indicated hash algorithm.
#[derive(Debug, Clone)]
pub struct TPM2_HMAC_REQUEST {
    /// Handle for the symmetric signing key providing the HMAC key
    /// Auth Index: 1
    /// Auth Role: USER
    pub handle: TPM_HANDLE,

    /// HMAC data
    pub buffer: Vec<u8>,

    /// Algorithm to use for HMAC
    pub hash_Alg: TPM_ALG_ID,
}

impl Default for TPM2_HMAC_REQUEST {
    fn default() -> Self {
        Self {
            handle: TPM_HANDLE::default(),
            hashAlg: TPM_ALG_ID::NULL,
        }
    }
}

impl TPM2_HMAC_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        handle: TPM_HANDLE,
        buffer: Vec<u8>,
        hash_Alg: TPM_ALG_ID,
        ) -> Self {
        Self {
            handle,
            buffer,
            hash_Alg,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command performs an HMAC on the supplied data using the indicated hash algorithm.
#[derive(Debug, Clone)]
pub struct HMACResponse {
    /// The returned HMAC in a sized buffer
    pub out_HMAC: Vec<u8>,
}

impl Default for HMACResponse {
    fn default() -> Self {
        Self {
        }
    }
}

impl HMACResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command performs an HMAC or a block cipher MAC on the supplied data using the
/// indicated algorithm.
#[derive(Debug, Clone)]
pub struct TPM2_MAC_REQUEST {
    /// Handle for the symmetric signing key providing the MAC key
    /// Auth Index: 1
    /// Auth Role: USER
    pub handle: TPM_HANDLE,

    /// MAC data
    pub buffer: Vec<u8>,

    /// Algorithm to use for MAC
    pub in_Scheme: TPM_ALG_ID,
}

impl Default for TPM2_MAC_REQUEST {
    fn default() -> Self {
        Self {
            handle: TPM_HANDLE::default(),
            inScheme: TPM_ALG_ID::NULL,
        }
    }
}

impl TPM2_MAC_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        handle: TPM_HANDLE,
        buffer: Vec<u8>,
        in_Scheme: TPM_ALG_ID,
        ) -> Self {
        Self {
            handle,
            buffer,
            in_Scheme,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command performs an HMAC or a block cipher MAC on the supplied data using the
/// indicated algorithm.
#[derive(Debug, Clone)]
pub struct MACResponse {
    /// The returned MAC in a sized buffer
    pub out_MAC: Vec<u8>,
}

impl Default for MACResponse {
    fn default() -> Self {
        Self {
        }
    }
}

impl MACResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command returns the next bytesRequested octets from the random number generator (RNG).
#[derive(Debug, Clone)]
pub struct TPM2_GetRandom_REQUEST {
    /// Number of octets to return
    pub bytes_Requested: u16,
}

impl Default for TPM2_GetRandom_REQUEST {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPM2_GetRandom_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        bytes_Requested: u16,
        ) -> Self {
        Self {
            bytes_Requested,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command returns the next bytesRequested octets from the random number generator (RNG).
#[derive(Debug, Clone)]
pub struct GetRandomResponse {
    /// The random octets
    pub random_Bytes: Vec<u8>,
}

impl Default for GetRandomResponse {
    fn default() -> Self {
        Self {
        }
    }
}

impl GetRandomResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command is used to add "additional information" to the RNG state.
#[derive(Debug, Clone)]
pub struct TPM2_StirRandom_REQUEST {
    /// Additional information
    pub in_Data: Vec<u8>,
}

impl Default for TPM2_StirRandom_REQUEST {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPM2_StirRandom_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        in_Data: Vec<u8>,
        ) -> Self {
        Self {
            in_Data,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command starts an HMAC sequence. The TPM will create and initialize an HMAC
/// sequence structure, assign a handle to the sequence, and set the authValue of the
/// sequence object to the value in auth.
#[derive(Debug, Clone)]
pub struct TPM2_HMAC_Start_REQUEST {
    /// Handle of an HMAC key
    /// Auth Index: 1
    /// Auth Role: USER
    pub handle: TPM_HANDLE,

    /// Authorization value for subsequent use of the sequence
    pub auth: Vec<u8>,

    /// The hash algorithm to use for the HMAC
    pub hash_Alg: TPM_ALG_ID,
}

impl Default for TPM2_HMAC_Start_REQUEST {
    fn default() -> Self {
        Self {
            handle: TPM_HANDLE::default(),
            hashAlg: TPM_ALG_ID::NULL,
        }
    }
}

impl TPM2_HMAC_Start_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        handle: TPM_HANDLE,
        auth: Vec<u8>,
        hash_Alg: TPM_ALG_ID,
        ) -> Self {
        Self {
            handle,
            auth,
            hash_Alg,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command starts an HMAC sequence. The TPM will create and initialize an HMAC
/// sequence structure, assign a handle to the sequence, and set the authValue of the
/// sequence object to the value in auth.
#[derive(Debug, Clone)]
pub struct HMAC_StartResponse {
    /// A handle to reference the sequence
    pub handle: TPM_HANDLE,
}

impl Default for HMAC_StartResponse {
    fn default() -> Self {
        Self {
            handle: TPM_HANDLE::default(),
        }
    }
}

impl HMAC_StartResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command starts a MAC sequence. The TPM will create and initialize a MAC sequence
/// structure, assign a handle to the sequence, and set the authValue of the sequence
/// object to the value in auth.
#[derive(Debug, Clone)]
pub struct TPM2_MAC_Start_REQUEST {
    /// Handle of a MAC key
    /// Auth Index: 1
    /// Auth Role: USER
    pub handle: TPM_HANDLE,

    /// Authorization value for subsequent use of the sequence
    pub auth: Vec<u8>,

    /// The algorithm to use for the MAC
    pub in_Scheme: TPM_ALG_ID,
}

impl Default for TPM2_MAC_Start_REQUEST {
    fn default() -> Self {
        Self {
            handle: TPM_HANDLE::default(),
            inScheme: TPM_ALG_ID::NULL,
        }
    }
}

impl TPM2_MAC_Start_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        handle: TPM_HANDLE,
        auth: Vec<u8>,
        in_Scheme: TPM_ALG_ID,
        ) -> Self {
        Self {
            handle,
            auth,
            in_Scheme,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command starts a MAC sequence. The TPM will create and initialize a MAC sequence
/// structure, assign a handle to the sequence, and set the authValue of the sequence
/// object to the value in auth.
#[derive(Debug, Clone)]
pub struct MAC_StartResponse {
    /// A handle to reference the sequence
    pub handle: TPM_HANDLE,
}

impl Default for MAC_StartResponse {
    fn default() -> Self {
        Self {
            handle: TPM_HANDLE::default(),
        }
    }
}

impl MAC_StartResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command starts a hash or an Event Sequence. If hashAlg is an implemented hash,
/// then a hash sequence is started. If hashAlg is TPM_ALG_NULL, then an Event Sequence is
/// started. If hashAlg is neither an implemented algorithm nor TPM_ALG_NULL, then the TPM
/// shall return TPM_RC_HASH.
#[derive(Debug, Clone)]
pub struct TPM2_HashSequenceStart_REQUEST {
    /// Authorization value for subsequent use of the sequence
    pub auth: Vec<u8>,

    /// The hash algorithm to use for the hash sequence
    /// An Event Sequence starts if this is TPM_ALG_NULL.
    pub hash_Alg: TPM_ALG_ID,
}

impl Default for TPM2_HashSequenceStart_REQUEST {
    fn default() -> Self {
        Self {
            hashAlg: TPM_ALG_ID::NULL,
        }
    }
}

impl TPM2_HashSequenceStart_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        auth: Vec<u8>,
        hash_Alg: TPM_ALG_ID,
        ) -> Self {
        Self {
            auth,
            hash_Alg,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command starts a hash or an Event Sequence. If hashAlg is an implemented hash,
/// then a hash sequence is started. If hashAlg is TPM_ALG_NULL, then an Event Sequence is
/// started. If hashAlg is neither an implemented algorithm nor TPM_ALG_NULL, then the TPM
/// shall return TPM_RC_HASH.
#[derive(Debug, Clone)]
pub struct HashSequenceStartResponse {
    /// A handle to reference the sequence
    pub handle: TPM_HANDLE,
}

impl Default for HashSequenceStartResponse {
    fn default() -> Self {
        Self {
            handle: TPM_HANDLE::default(),
        }
    }
}

impl HashSequenceStartResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command is used to add data to a hash or HMAC sequence. The amount of data in
/// buffer may be any size up to the limits of the TPM.
#[derive(Debug, Clone)]
pub struct TPM2_SequenceUpdate_REQUEST {
    /// Handle for the sequence object
    /// Auth Index: 1
    /// Auth Role: USER
    pub sequence_Handle: TPM_HANDLE,

    /// Data to be added to hash
    pub buffer: Vec<u8>,
}

impl Default for TPM2_SequenceUpdate_REQUEST {
    fn default() -> Self {
        Self {
            sequenceHandle: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_SequenceUpdate_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        sequence_Handle: TPM_HANDLE,
        buffer: Vec<u8>,
        ) -> Self {
        Self {
            sequence_Handle,
            buffer,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command adds the last part of data, if any, to a hash/HMAC sequence and returns
/// the result.
#[derive(Debug, Clone)]
pub struct TPM2_SequenceComplete_REQUEST {
    /// Authorization for the sequence
    /// Auth Index: 1
    /// Auth Role: USER
    pub sequence_Handle: TPM_HANDLE,

    /// Data to be added to the hash/HMAC
    pub buffer: Vec<u8>,

    /// Hierarchy of the ticket for a hash
    pub hierarchy: TPM_HANDLE,
}

impl Default for TPM2_SequenceComplete_REQUEST {
    fn default() -> Self {
        Self {
            sequenceHandle: TPM_HANDLE::default(),
            hierarchy: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_SequenceComplete_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        sequence_Handle: TPM_HANDLE,
        buffer: Vec<u8>,
        hierarchy: TPM_HANDLE,
        ) -> Self {
        Self {
            sequence_Handle,
            buffer,
            hierarchy,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command adds the last part of data, if any, to a hash/HMAC sequence and returns
/// the result.
#[derive(Debug, Clone)]
pub struct SequenceCompleteResponse {
    /// The returned HMAC or digest in a sized buffer
    pub result: Vec<u8>,

    /// Ticket indicating that the sequence of octets used to compute outDigest did not start
    /// with TPM_GENERATED_VALUE
    /// This is a NULL Ticket when the sequence is HMAC.
    pub validation: TPMT_TK_HASHCHECK,
}

impl Default for SequenceCompleteResponse {
    fn default() -> Self {
        Self {
        }
    }
}

impl SequenceCompleteResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command adds the last part of data, if any, to an Event Sequence and returns the
/// result in a digest list. If pcrHandle references a PCR and not TPM_RH_NULL, then the
/// returned digest list is processed in the same manner as the digest list input
/// parameter to TPM2_PCR_Extend(). That is, if a bank contains a PCR associated with
/// pcrHandle, it is extended with the associated digest value from the list.
#[derive(Debug, Clone)]
pub struct TPM2_EventSequenceComplete_REQUEST {
    /// PCR to be extended with the Event data
    /// Auth Index: 1
    /// Auth Role: USER
    pub pcr_Handle: TPM_HANDLE,

    /// Authorization for the sequence
    /// Auth Index: 2
    /// Auth Role: USER
    pub sequence_Handle: TPM_HANDLE,

    /// Data to be added to the Event
    pub buffer: Vec<u8>,
}

impl Default for TPM2_EventSequenceComplete_REQUEST {
    fn default() -> Self {
        Self {
            pcrHandle: TPM_HANDLE::default(),
            sequenceHandle: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_EventSequenceComplete_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        pcr_Handle: TPM_HANDLE,
        sequence_Handle: TPM_HANDLE,
        buffer: Vec<u8>,
        ) -> Self {
        Self {
            pcr_Handle,
            sequence_Handle,
            buffer,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command adds the last part of data, if any, to an Event Sequence and returns the
/// result in a digest list. If pcrHandle references a PCR and not TPM_RH_NULL, then the
/// returned digest list is processed in the same manner as the digest list input
/// parameter to TPM2_PCR_Extend(). That is, if a bank contains a PCR associated with
/// pcrHandle, it is extended with the associated digest value from the list.
#[derive(Debug, Clone)]
pub struct EventSequenceCompleteResponse {
    /// List of digests computed for the PCR
    pub results: Vec<TPMT_HA>,
}

impl Default for EventSequenceCompleteResponse {
    fn default() -> Self {
        Self {
        }
    }
}

impl EventSequenceCompleteResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// The purpose of this command is to prove that an object with a specific Name is loaded
/// in the TPM. By certifying that the object is loaded, the TPM warrants that a public
/// area with a given Name is self-consistent and associated with a valid sensitive area.
/// If a relying party has a public area that has the same Name as a Name certified with
/// this command, then the values in that public area are correct.
#[derive(Debug, Clone)]
pub struct TPM2_Certify_REQUEST {
    /// Handle of the object to be certified
    /// Auth Index: 1
    /// Auth Role: ADMIN
    pub object_Handle: TPM_HANDLE,

    /// Handle of the key used to sign the attestation structure
    /// Auth Index: 2
    /// Auth Role: USER
    pub sign_Handle: TPM_HANDLE,

    /// User provided qualifying data
    pub qualifying_Data: Vec<u8>,

    /// Scheme selector

    /// Signing scheme to use if the scheme for signHandle is TPM_ALG_NULL
    /// One of: TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA,
    /// TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR,
    /// TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME.
    pub in_Scheme: TPMU_SIG_SCHEME,
}

impl Default for TPM2_Certify_REQUEST {
    fn default() -> Self {
        Self {
            objectHandle: TPM_HANDLE::default(),
            signHandle: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_Certify_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        object_Handle: TPM_HANDLE,
        sign_Handle: TPM_HANDLE,
        qualifying_Data: Vec<u8>,
        in_Scheme: TPMU_SIG_SCHEME,
        ) -> Self {
        Self {
            object_Handle,
            sign_Handle,
            qualifying_Data,
            in_Scheme,
        }
    }

    /// Get the inSchemeScheme selector value
    pub fn in_Scheme_Scheme(&self) -> TPM_ALG_ID {
        match &self.in_Scheme {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// The purpose of this command is to prove that an object with a specific Name is loaded
/// in the TPM. By certifying that the object is loaded, the TPM warrants that a public
/// area with a given Name is self-consistent and associated with a valid sensitive area.
/// If a relying party has a public area that has the same Name as a Name certified with
/// this command, then the values in that public area are correct.
#[derive(Debug, Clone)]
pub struct CertifyResponse {
    /// The structure that was signed
    pub certify_Info: TPMS_ATTEST,

    /// Selector of the algorithm used to construct the signature

    /// The asymmetric signature over certifyInfo using the key referenced by signHandle
    /// One of: TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA,
    /// TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TPMT_HA,
    /// TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE.
    pub signature: TPMU_SIGNATURE,
}

impl Default for CertifyResponse {
    fn default() -> Self {
        Self {
        }
    }
}

impl CertifyResponse {
    /// Get the signatureSigAlg selector value
    pub fn signature_Sig_Alg(&self) -> TPM_ALG_ID {
        match &self.signature {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command is used to prove the association between an object and its creation data.
/// The TPM will validate that the ticket was produced by the TPM and that the ticket
/// validates the association between a loaded public area and the provided hash of the
/// creation data (creationHash).
#[derive(Debug, Clone)]
pub struct TPM2_CertifyCreation_REQUEST {
    /// Handle of the key that will sign the attestation block
    /// Auth Index: 1
    /// Auth Role: USER
    pub sign_Handle: TPM_HANDLE,

    /// The object associated with the creation data
    /// Auth Index: None
    pub object_Handle: TPM_HANDLE,

    /// User-provided qualifying data
    pub qualifying_Data: Vec<u8>,

    /// Hash of the creation data produced by TPM2_Create() or TPM2_CreatePrimary()
    pub creation_Hash: Vec<u8>,

    /// Scheme selector

    /// Signing scheme to use if the scheme for signHandle is TPM_ALG_NULL
    /// One of: TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA,
    /// TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR,
    /// TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME.
    pub in_Scheme: TPMU_SIG_SCHEME,

    /// Ticket produced by TPM2_Create() or TPM2_CreatePrimary()
    pub creation_Ticket: TPMT_TK_CREATION,
}

impl Default for TPM2_CertifyCreation_REQUEST {
    fn default() -> Self {
        Self {
            signHandle: TPM_HANDLE::default(),
            objectHandle: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_CertifyCreation_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        sign_Handle: TPM_HANDLE,
        object_Handle: TPM_HANDLE,
        qualifying_Data: Vec<u8>,
        creation_Hash: Vec<u8>,
        in_Scheme: TPMU_SIG_SCHEME,
        creation_Ticket: TPMT_TK_CREATION,
        ) -> Self {
        Self {
            sign_Handle,
            object_Handle,
            qualifying_Data,
            creation_Hash,
            in_Scheme,
            creation_Ticket,
        }
    }

    /// Get the inSchemeScheme selector value
    pub fn in_Scheme_Scheme(&self) -> TPM_ALG_ID {
        match &self.in_Scheme {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command is used to prove the association between an object and its creation data.
/// The TPM will validate that the ticket was produced by the TPM and that the ticket
/// validates the association between a loaded public area and the provided hash of the
/// creation data (creationHash).
#[derive(Debug, Clone)]
pub struct CertifyCreationResponse {
    /// The structure that was signed
    pub certify_Info: TPMS_ATTEST,

    /// Selector of the algorithm used to construct the signature

    /// The signature over certifyInfo
    /// One of: TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA,
    /// TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TPMT_HA,
    /// TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE.
    pub signature: TPMU_SIGNATURE,
}

impl Default for CertifyCreationResponse {
    fn default() -> Self {
        Self {
        }
    }
}

impl CertifyCreationResponse {
    /// Get the signatureSigAlg selector value
    pub fn signature_Sig_Alg(&self) -> TPM_ALG_ID {
        match &self.signature {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command is used to quote PCR values.
#[derive(Debug, Clone)]
pub struct TPM2_Quote_REQUEST {
    /// Handle of key that will perform signature
    /// Auth Index: 1
    /// Auth Role: USER
    pub sign_Handle: TPM_HANDLE,

    /// Data supplied by the caller
    pub qualifying_Data: Vec<u8>,

    /// Scheme selector

    /// Signing scheme to use if the scheme for signHandle is TPM_ALG_NULL
    /// One of: TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA,
    /// TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR,
    /// TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME.
    pub in_Scheme: TPMU_SIG_SCHEME,

    /// PCR set to quote
    pub PCRselect: Vec<TPMS_PCR_SELECTION>,
}

impl Default for TPM2_Quote_REQUEST {
    fn default() -> Self {
        Self {
            signHandle: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_Quote_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        sign_Handle: TPM_HANDLE,
        qualifying_Data: Vec<u8>,
        in_Scheme: TPMU_SIG_SCHEME,
        PCRselect: Vec<TPMS_PCR_SELECTION>,
        ) -> Self {
        Self {
            sign_Handle,
            qualifying_Data,
            in_Scheme,
            PCRselect,
        }
    }

    /// Get the inSchemeScheme selector value
    pub fn in_Scheme_Scheme(&self) -> TPM_ALG_ID {
        match &self.in_Scheme {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command is used to quote PCR values.
#[derive(Debug, Clone)]
pub struct QuoteResponse {
    /// The quoted information
    pub quoted: TPMS_ATTEST,

    /// Selector of the algorithm used to construct the signature

    /// The signature over quoted
    /// One of: TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA,
    /// TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TPMT_HA,
    /// TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE.
    pub signature: TPMU_SIGNATURE,
}

impl Default for QuoteResponse {
    fn default() -> Self {
        Self {
        }
    }
}

impl QuoteResponse {
    /// Get the signatureSigAlg selector value
    pub fn signature_Sig_Alg(&self) -> TPM_ALG_ID {
        match &self.signature {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command returns a digital signature of the audit session digest.
#[derive(Debug, Clone)]
pub struct TPM2_GetSessionAuditDigest_REQUEST {
    /// Handle of the privacy administrator (TPM_RH_ENDORSEMENT)
    /// Auth Index: 1
    /// Auth Role: USER
    pub privacy_Admin_Handle: TPM_HANDLE,

    /// Handle of the signing key
    /// Auth Index: 2
    /// Auth Role: USER
    pub sign_Handle: TPM_HANDLE,

    /// Handle of the audit session
    /// Auth Index: None
    pub session_Handle: TPM_HANDLE,

    /// User-provided qualifying data may be zero-length
    pub qualifying_Data: Vec<u8>,

    /// Scheme selector

    /// Signing scheme to use if the scheme for signHandle is TPM_ALG_NULL
    /// One of: TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA,
    /// TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR,
    /// TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME.
    pub in_Scheme: TPMU_SIG_SCHEME,
}

impl Default for TPM2_GetSessionAuditDigest_REQUEST {
    fn default() -> Self {
        Self {
            privacyAdminHandle: TPM_HANDLE::default(),
            signHandle: TPM_HANDLE::default(),
            sessionHandle: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_GetSessionAuditDigest_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        privacy_Admin_Handle: TPM_HANDLE,
        sign_Handle: TPM_HANDLE,
        session_Handle: TPM_HANDLE,
        qualifying_Data: Vec<u8>,
        in_Scheme: TPMU_SIG_SCHEME,
        ) -> Self {
        Self {
            privacy_Admin_Handle,
            sign_Handle,
            session_Handle,
            qualifying_Data,
            in_Scheme,
        }
    }

    /// Get the inSchemeScheme selector value
    pub fn in_Scheme_Scheme(&self) -> TPM_ALG_ID {
        match &self.in_Scheme {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command returns a digital signature of the audit session digest.
#[derive(Debug, Clone)]
pub struct GetSessionAuditDigestResponse {
    /// The audit information that was signed
    pub audit_Info: TPMS_ATTEST,

    /// Selector of the algorithm used to construct the signature

    /// The signature over auditInfo
    /// One of: TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA,
    /// TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TPMT_HA,
    /// TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE.
    pub signature: TPMU_SIGNATURE,
}

impl Default for GetSessionAuditDigestResponse {
    fn default() -> Self {
        Self {
        }
    }
}

impl GetSessionAuditDigestResponse {
    /// Get the signatureSigAlg selector value
    pub fn signature_Sig_Alg(&self) -> TPM_ALG_ID {
        match &self.signature {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command returns the current value of the command audit digest, a digest of the
/// commands being audited, and the audit hash algorithm. These values are placed in an
/// attestation structure and signed with the key referenced by signHandle.
#[derive(Debug, Clone)]
pub struct TPM2_GetCommandAuditDigest_REQUEST {
    /// Handle of the privacy administrator (TPM_RH_ENDORSEMENT)
    /// Auth Index: 1
    /// Auth Role: USER
    pub privacy_Handle: TPM_HANDLE,

    /// The handle of the signing key
    /// Auth Index: 2
    /// Auth Role: USER
    pub sign_Handle: TPM_HANDLE,

    /// Other data to associate with this audit digest
    pub qualifying_Data: Vec<u8>,

    /// Scheme selector

    /// Signing scheme to use if the scheme for signHandle is TPM_ALG_NULL
    /// One of: TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA,
    /// TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR,
    /// TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME.
    pub in_Scheme: TPMU_SIG_SCHEME,
}

impl Default for TPM2_GetCommandAuditDigest_REQUEST {
    fn default() -> Self {
        Self {
            privacyHandle: TPM_HANDLE::default(),
            signHandle: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_GetCommandAuditDigest_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        privacy_Handle: TPM_HANDLE,
        sign_Handle: TPM_HANDLE,
        qualifying_Data: Vec<u8>,
        in_Scheme: TPMU_SIG_SCHEME,
        ) -> Self {
        Self {
            privacy_Handle,
            sign_Handle,
            qualifying_Data,
            in_Scheme,
        }
    }

    /// Get the inSchemeScheme selector value
    pub fn in_Scheme_Scheme(&self) -> TPM_ALG_ID {
        match &self.in_Scheme {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command returns the current value of the command audit digest, a digest of the
/// commands being audited, and the audit hash algorithm. These values are placed in an
/// attestation structure and signed with the key referenced by signHandle.
#[derive(Debug, Clone)]
pub struct GetCommandAuditDigestResponse {
    /// The auditInfo that was signed
    pub audit_Info: TPMS_ATTEST,

    /// Selector of the algorithm used to construct the signature

    /// The signature over auditInfo
    /// One of: TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA,
    /// TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TPMT_HA,
    /// TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE.
    pub signature: TPMU_SIGNATURE,
}

impl Default for GetCommandAuditDigestResponse {
    fn default() -> Self {
        Self {
        }
    }
}

impl GetCommandAuditDigestResponse {
    /// Get the signatureSigAlg selector value
    pub fn signature_Sig_Alg(&self) -> TPM_ALG_ID {
        match &self.signature {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command returns the current values of Time and Clock.
#[derive(Debug, Clone)]
pub struct TPM2_GetTime_REQUEST {
    /// Handle of the privacy administrator (TPM_RH_ENDORSEMENT)
    /// Auth Index: 1
    /// Auth Role: USER
    pub privacy_Admin_Handle: TPM_HANDLE,

    /// The keyHandle identifier of a loaded key that can perform digital signatures
    /// Auth Index: 2
    /// Auth Role: USER
    pub sign_Handle: TPM_HANDLE,

    /// Data to tick stamp
    pub qualifying_Data: Vec<u8>,

    /// Scheme selector

    /// Signing scheme to use if the scheme for signHandle is TPM_ALG_NULL
    /// One of: TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA,
    /// TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR,
    /// TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME.
    pub in_Scheme: TPMU_SIG_SCHEME,
}

impl Default for TPM2_GetTime_REQUEST {
    fn default() -> Self {
        Self {
            privacyAdminHandle: TPM_HANDLE::default(),
            signHandle: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_GetTime_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        privacy_Admin_Handle: TPM_HANDLE,
        sign_Handle: TPM_HANDLE,
        qualifying_Data: Vec<u8>,
        in_Scheme: TPMU_SIG_SCHEME,
        ) -> Self {
        Self {
            privacy_Admin_Handle,
            sign_Handle,
            qualifying_Data,
            in_Scheme,
        }
    }

    /// Get the inSchemeScheme selector value
    pub fn in_Scheme_Scheme(&self) -> TPM_ALG_ID {
        match &self.in_Scheme {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command returns the current values of Time and Clock.
#[derive(Debug, Clone)]
pub struct GetTimeResponse {
    /// Standard TPM-generated attestation block
    pub time_Info: TPMS_ATTEST,

    /// Selector of the algorithm used to construct the signature

    /// The signature over timeInfo
    /// One of: TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA,
    /// TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TPMT_HA,
    /// TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE.
    pub signature: TPMU_SIGNATURE,
}

impl Default for GetTimeResponse {
    fn default() -> Self {
        Self {
        }
    }
}

impl GetTimeResponse {
    /// Get the signatureSigAlg selector value
    pub fn signature_Sig_Alg(&self) -> TPM_ALG_ID {
        match &self.signature {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// The purpose of this command is to generate an X.509 certificate that proves an object
/// with a specific public key and attributes is loaded in the TPM. In contrast to
/// TPM2_Certify, which uses a TCG-defined data structure to convey attestation
/// information, TPM2_CertifyX509 encodes the attestation information in a DER-encoded
/// X.509 certificate that is compliant with RFC5280 Internet X.509 Public Key
/// Infrastructure Certificate and Certificate Revocation List (CRL) Profile.
#[derive(Debug, Clone)]
pub struct TPM2_CertifyX509_REQUEST {
    /// Handle of the object to be certified
    /// Auth Index: 1
    /// Auth Role: ADMIN
    pub object_Handle: TPM_HANDLE,

    /// Handle of the key used to sign the attestation structure
    /// Auth Index: 2
    /// Auth Role: USER
    pub sign_Handle: TPM_HANDLE,

    /// Shall be an Empty Buffer
    pub reserved: Vec<u8>,

    /// Scheme selector

    /// Signing scheme to use if the scheme for signHandle is TPM_ALG_NULL
    /// One of: TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA,
    /// TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR,
    /// TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME.
    pub in_Scheme: TPMU_SIG_SCHEME,

    /// A DER encoded partial certificate
    pub partial_Certificate: Vec<u8>,
}

impl Default for TPM2_CertifyX509_REQUEST {
    fn default() -> Self {
        Self {
            objectHandle: TPM_HANDLE::default(),
            signHandle: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_CertifyX509_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        object_Handle: TPM_HANDLE,
        sign_Handle: TPM_HANDLE,
        reserved: Vec<u8>,
        in_Scheme: TPMU_SIG_SCHEME,
        partial_Certificate: Vec<u8>,
        ) -> Self {
        Self {
            object_Handle,
            sign_Handle,
            reserved,
            in_Scheme,
            partial_Certificate,
        }
    }

    /// Get the inSchemeScheme selector value
    pub fn in_Scheme_Scheme(&self) -> TPM_ALG_ID {
        match &self.in_Scheme {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// The purpose of this command is to generate an X.509 certificate that proves an object
/// with a specific public key and attributes is loaded in the TPM. In contrast to
/// TPM2_Certify, which uses a TCG-defined data structure to convey attestation
/// information, TPM2_CertifyX509 encodes the attestation information in a DER-encoded
/// X.509 certificate that is compliant with RFC5280 Internet X.509 Public Key
/// Infrastructure Certificate and Certificate Revocation List (CRL) Profile.
#[derive(Debug, Clone)]
pub struct CertifyX509Response {
    /// A DER encoded SEQUENCE containing the DER encoded fields added to partialCertificate
    /// to make it a complete RFC5280 TBSCertificate.
    pub added_To_Certificate: Vec<u8>,

    /// The digest that was signed
    pub tbs_Digest: Vec<u8>,

    /// Selector of the algorithm used to construct the signature

    /// The signature over tbsDigest
    /// One of: TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA,
    /// TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TPMT_HA,
    /// TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE.
    pub signature: TPMU_SIGNATURE,
}

impl Default for CertifyX509Response {
    fn default() -> Self {
        Self {
        }
    }
}

impl CertifyX509Response {
    /// Get the signatureSigAlg selector value
    pub fn signature_Sig_Alg(&self) -> TPM_ALG_ID {
        match &self.signature {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// TPM2_Commit() performs the first part of an ECC anonymous signing operation. The TPM
/// will perform the point multiplications on the provided points and return intermediate
/// signing values. The signHandle parameter shall refer to an ECC key and the signing
/// scheme must be anonymous (TPM_RC_SCHEME).
#[derive(Debug, Clone)]
pub struct TPM2_Commit_REQUEST {
    /// Handle of the key that will be used in the signing operation
    /// Auth Index: 1
    /// Auth Role: USER
    pub sign_Handle: TPM_HANDLE,

    /// A point (M) on the curve used by signHandle
    pub P1: TPMS_ECC_POINT,

    /// Octet array used to derive x-coordinate of a base point
    pub s2: Vec<u8>,

    /// Y coordinate of the point associated with s2
    pub y2: Vec<u8>,
}

impl Default for TPM2_Commit_REQUEST {
    fn default() -> Self {
        Self {
            signHandle: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_Commit_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        sign_Handle: TPM_HANDLE,
        P1: TPMS_ECC_POINT,
        s2: Vec<u8>,
        y2: Vec<u8>,
        ) -> Self {
        Self {
            sign_Handle,
            P1,
            s2,
            y2,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// TPM2_Commit() performs the first part of an ECC anonymous signing operation. The TPM
/// will perform the point multiplications on the provided points and return intermediate
/// signing values. The signHandle parameter shall refer to an ECC key and the signing
/// scheme must be anonymous (TPM_RC_SCHEME).
#[derive(Debug, Clone)]
pub struct CommitResponse {
    /// ECC point K [ds](x2, y2)
    pub K: TPMS_ECC_POINT,

    /// ECC point L [r](x2, y2)
    pub L: TPMS_ECC_POINT,

    /// ECC point E [r]P1
    pub E: TPMS_ECC_POINT,

    /// Least-significant 16 bits of commitCount
    pub counter: u16,
}

impl Default for CommitResponse {
    fn default() -> Self {
        Self {
        }
    }
}

impl CommitResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// TPM2_EC_Ephemeral() creates an ephemeral key for use in a two-phase key exchange protocol.
#[derive(Debug, Clone)]
pub struct TPM2_EC_Ephemeral_REQUEST {
    /// The curve for the computed ephemeral point
    pub curve_ID: TPM_ECC_CURVE,
}

impl Default for TPM2_EC_Ephemeral_REQUEST {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPM2_EC_Ephemeral_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        curve_ID: TPM_ECC_CURVE,
        ) -> Self {
        Self {
            curve_ID,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// TPM2_EC_Ephemeral() creates an ephemeral key for use in a two-phase key exchange protocol.
#[derive(Debug, Clone)]
pub struct EC_EphemeralResponse {
    /// Ephemeral public key Q [r]G
    pub Q: TPMS_ECC_POINT,

    /// Least-significant 16 bits of commitCount
    pub counter: u16,
}

impl Default for EC_EphemeralResponse {
    fn default() -> Self {
        Self {
        }
    }
}

impl EC_EphemeralResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command uses loaded keys to validate a signature on a message with the message
/// digest passed to the TPM.
#[derive(Debug, Clone)]
pub struct TPM2_VerifySignature_REQUEST {
    /// Handle of public key that will be used in the validation
    /// Auth Index: None
    pub key_Handle: TPM_HANDLE,

    /// Digest of the signed message
    pub digest: Vec<u8>,

    /// Selector of the algorithm used to construct the signature

    /// Signature to be tested
    /// One of: TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA,
    /// TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TPMT_HA,
    /// TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE.
    pub signature: TPMU_SIGNATURE,
}

impl Default for TPM2_VerifySignature_REQUEST {
    fn default() -> Self {
        Self {
            keyHandle: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_VerifySignature_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        key_Handle: TPM_HANDLE,
        digest: Vec<u8>,
        signature: TPMU_SIGNATURE,
        ) -> Self {
        Self {
            key_Handle,
            digest,
            signature,
        }
    }

    /// Get the signatureSigAlg selector value
    pub fn signature_Sig_Alg(&self) -> TPM_ALG_ID {
        match &self.signature {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command uses loaded keys to validate a signature on a message with the message
/// digest passed to the TPM.
#[derive(Debug, Clone)]
pub struct VerifySignatureResponse {
    pub validation: TPMT_TK_VERIFIED,
}

impl Default for VerifySignatureResponse {
    fn default() -> Self {
        Self {
        }
    }
}

impl VerifySignatureResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command causes the TPM to sign an externally provided hash with the specified
/// symmetric or asymmetric signing key.
#[derive(Debug, Clone)]
pub struct TPM2_Sign_REQUEST {
    /// Handle of key that will perform signing
    /// Auth Index: 1
    /// Auth Role: USER
    pub key_Handle: TPM_HANDLE,

    /// Digest to be signed
    pub digest: Vec<u8>,

    /// Scheme selector

    /// Signing scheme to use if the scheme for keyHandle is TPM_ALG_NULL
    /// One of: TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA,
    /// TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR,
    /// TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME.
    pub in_Scheme: TPMU_SIG_SCHEME,

    /// Proof that digest was created by the TPM
    /// If keyHandle is not a restricted signing key, then this may be a NULL Ticket with tag
    /// = TPM_ST_CHECKHASH.
    pub validation: TPMT_TK_HASHCHECK,
}

impl Default for TPM2_Sign_REQUEST {
    fn default() -> Self {
        Self {
            keyHandle: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_Sign_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        key_Handle: TPM_HANDLE,
        digest: Vec<u8>,
        in_Scheme: TPMU_SIG_SCHEME,
        validation: TPMT_TK_HASHCHECK,
        ) -> Self {
        Self {
            key_Handle,
            digest,
            in_Scheme,
            validation,
        }
    }

    /// Get the inSchemeScheme selector value
    pub fn in_Scheme_Scheme(&self) -> TPM_ALG_ID {
        match &self.in_Scheme {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command causes the TPM to sign an externally provided hash with the specified
/// symmetric or asymmetric signing key.
#[derive(Debug, Clone)]
pub struct SignResponse {
    /// Selector of the algorithm used to construct the signature

    /// The signature
    /// One of: TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA,
    /// TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TPMT_HA,
    /// TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE.
    pub signature: TPMU_SIGNATURE,
}

impl Default for SignResponse {
    fn default() -> Self {
        Self {
        }
    }
}

impl SignResponse {
    /// Get the signatureSigAlg selector value
    pub fn signature_Sig_Alg(&self) -> TPM_ALG_ID {
        match &self.signature {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command may be used by the Privacy Administrator or platform to change the audit
/// status of a command or to set the hash algorithm used for the audit digest, but not
/// both at the same time.
#[derive(Debug, Clone)]
pub struct TPM2_SetCommandCodeAuditStatus_REQUEST {
    /// TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
    /// Auth Index: 1
    /// Auth Role: USER
    pub auth: TPM_HANDLE,

    /// Hash algorithm for the audit digest; if TPM_ALG_NULL, then the hash is not changed
    pub audit_Alg: TPM_ALG_ID,

    /// List of commands that will be added to those that will be audited
    pub set_List: Vec<TPM_CC>,

    /// List of commands that will no longer be audited
    pub clear_List: Vec<TPM_CC>,
}

impl Default for TPM2_SetCommandCodeAuditStatus_REQUEST {
    fn default() -> Self {
        Self {
            auth: TPM_HANDLE::default(),
            auditAlg: TPM_ALG_ID::NULL,
        }
    }
}

impl TPM2_SetCommandCodeAuditStatus_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        auth: TPM_HANDLE,
        audit_Alg: TPM_ALG_ID,
        set_List: Vec<TPM_CC>,
        clear_List: Vec<TPM_CC>,
        ) -> Self {
        Self {
            auth,
            audit_Alg,
            set_List,
            clear_List,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command is used to cause an update to the indicated PCR. The digests parameter
/// contains one or more tagged digest values identified by an algorithm ID. For each
/// digest, the PCR associated with pcrHandle is Extended into the bank identified by the
/// tag (hashAlg).
#[derive(Debug, Clone)]
pub struct TPM2_PCR_Extend_REQUEST {
    /// Handle of the PCR
    /// Auth Handle: 1
    /// Auth Role: USER
    pub pcr_Handle: TPM_HANDLE,

    /// List of tagged digest values to be extended
    pub digests: Vec<TPMT_HA>,
}

impl Default for TPM2_PCR_Extend_REQUEST {
    fn default() -> Self {
        Self {
            pcrHandle: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_PCR_Extend_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        pcr_Handle: TPM_HANDLE,
        digests: Vec<TPMT_HA>,
        ) -> Self {
        Self {
            pcr_Handle,
            digests,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command is used to cause an update to the indicated PCR.
#[derive(Debug, Clone)]
pub struct TPM2_PCR_Event_REQUEST {
    /// Handle of the PCR
    /// Auth Handle: 1
    /// Auth Role: USER
    pub pcr_Handle: TPM_HANDLE,

    /// Event data in sized buffer
    pub event_Data: Vec<u8>,
}

impl Default for TPM2_PCR_Event_REQUEST {
    fn default() -> Self {
        Self {
            pcrHandle: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_PCR_Event_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        pcr_Handle: TPM_HANDLE,
        event_Data: Vec<u8>,
        ) -> Self {
        Self {
            pcr_Handle,
            event_Data,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command is used to cause an update to the indicated PCR.
#[derive(Debug, Clone)]
pub struct PCR_EventResponse {
    pub digests: Vec<TPMT_HA>,
}

impl Default for PCR_EventResponse {
    fn default() -> Self {
        Self {
        }
    }
}

impl PCR_EventResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command returns the values of all PCR specified in pcrSelectionIn.
#[derive(Debug, Clone)]
pub struct TPM2_PCR_Read_REQUEST {
    /// The selection of PCR to read
    pub pcr_Selection_In: Vec<TPMS_PCR_SELECTION>,
}

impl Default for TPM2_PCR_Read_REQUEST {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPM2_PCR_Read_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        pcr_Selection_In: Vec<TPMS_PCR_SELECTION>,
        ) -> Self {
        Self {
            pcr_Selection_In,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command returns the values of all PCR specified in pcrSelectionIn.
#[derive(Debug, Clone)]
pub struct PCR_ReadResponse {
    /// The current value of the PCR update counter
    pub pcr_Update_Counter: u32,

    /// The PCR in the returned list
    pub pcr_Selection_Out: Vec<TPMS_PCR_SELECTION>,

    /// The contents of the PCR indicated in pcrSelectOut-˃ pcrSelection[] as tagged digests
    pub pcr_Values: Vec<TPM2B_DIGEST>,
}

impl Default for PCR_ReadResponse {
    fn default() -> Self {
        Self {
        }
    }
}

impl PCR_ReadResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command is used to set the desired PCR allocation of PCR and algorithms. This
/// command requires Platform Authorization.
#[derive(Debug, Clone)]
pub struct TPM2_PCR_Allocate_REQUEST {
    /// TPM_RH_PLATFORM+{PP}
    /// Auth Index: 1
    /// Auth Role: USER
    pub auth_Handle: TPM_HANDLE,

    /// The requested allocation
    pub pcr_Allocation: Vec<TPMS_PCR_SELECTION>,
}

impl Default for TPM2_PCR_Allocate_REQUEST {
    fn default() -> Self {
        Self {
            authHandle: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_PCR_Allocate_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        auth_Handle: TPM_HANDLE,
        pcr_Allocation: Vec<TPMS_PCR_SELECTION>,
        ) -> Self {
        Self {
            auth_Handle,
            pcr_Allocation,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command is used to set the desired PCR allocation of PCR and algorithms. This
/// command requires Platform Authorization.
#[derive(Debug, Clone)]
pub struct PCR_AllocateResponse {
    /// YES if the allocation succeeded
    pub allocation_Success: u8,

    /// Maximum number of PCR that may be in a bank
    pub max_PCR: u32,

    /// Number of octets required to satisfy the request
    pub size_Needed: u32,

    /// Number of octets available. Computed before the allocation.
    pub size_Available: u32,
}

impl Default for PCR_AllocateResponse {
    fn default() -> Self {
        Self {
        }
    }
}

impl PCR_AllocateResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command is used to associate a policy with a PCR or group of PCR. The policy
/// determines the conditions under which a PCR may be extended or reset.
#[derive(Debug, Clone)]
pub struct TPM2_PCR_SetAuthPolicy_REQUEST {
    /// TPM_RH_PLATFORM+{PP}
    /// Auth Index: 1
    /// Auth Role: USER
    pub auth_Handle: TPM_HANDLE,

    /// The desired authPolicy
    pub auth_Policy: Vec<u8>,

    /// The hash algorithm of the policy
    pub hash_Alg: TPM_ALG_ID,

    /// The PCR for which the policy is to be set
    pub pcr_Num: TPM_HANDLE,
}

impl Default for TPM2_PCR_SetAuthPolicy_REQUEST {
    fn default() -> Self {
        Self {
            authHandle: TPM_HANDLE::default(),
            hashAlg: TPM_ALG_ID::NULL,
            pcrNum: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_PCR_SetAuthPolicy_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        auth_Handle: TPM_HANDLE,
        auth_Policy: Vec<u8>,
        hash_Alg: TPM_ALG_ID,
        pcr_Num: TPM_HANDLE,
        ) -> Self {
        Self {
            auth_Handle,
            auth_Policy,
            hash_Alg,
            pcr_Num,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command changes the authValue of a PCR or group of PCR.
#[derive(Debug, Clone)]
pub struct TPM2_PCR_SetAuthValue_REQUEST {
    /// Handle for a PCR that may have an authorization value set
    /// Auth Index: 1
    /// Auth Role: USER
    pub pcr_Handle: TPM_HANDLE,

    /// The desired authorization value
    pub auth: Vec<u8>,
}

impl Default for TPM2_PCR_SetAuthValue_REQUEST {
    fn default() -> Self {
        Self {
            pcrHandle: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_PCR_SetAuthValue_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        pcr_Handle: TPM_HANDLE,
        auth: Vec<u8>,
        ) -> Self {
        Self {
            pcr_Handle,
            auth,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// If the attribute of a PCR allows the PCR to be reset and proper authorization is
/// provided, then this command may be used to set the PCR in all banks to zero. The
/// attributes of the PCR may restrict the locality that can perform the reset operation.
#[derive(Debug, Clone)]
pub struct TPM2_PCR_Reset_REQUEST {
    /// The PCR to reset
    /// Auth Index: 1
    /// Auth Role: USER
    pub pcr_Handle: TPM_HANDLE,
}

impl Default for TPM2_PCR_Reset_REQUEST {
    fn default() -> Self {
        Self {
            pcrHandle: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_PCR_Reset_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        pcr_Handle: TPM_HANDLE,
        ) -> Self {
        Self {
            pcr_Handle,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command includes a signed authorization in a policy. The command ties the policy
/// to a signing key by including the Name of the signing key in the policyDigest
#[derive(Debug, Clone)]
pub struct TPM2_PolicySigned_REQUEST {
    /// Handle for a key that will validate the signature
    /// Auth Index: None
    pub auth_Object: TPM_HANDLE,

    /// Handle for the policy session being extended
    /// Auth Index: None
    pub policy_Session: TPM_HANDLE,

    /// The policy nonce for the session
    /// This can be the Empty Buffer.
    pub nonce_TPM: Vec<u8>,

    /// Digest of the command parameters to which this authorization is limited
    /// This is not the cpHash for this command but the cpHash for the command to which this
    /// policy session will be applied. If it is not limited, the parameter will be the Empty Buffer.
    pub cp_Hash_A: Vec<u8>,

    /// A reference to a policy relating to the authorization may be the Empty Buffer
    /// Size is limited to be no larger than the nonce size supported on the TPM.
    pub policy_Ref: Vec<u8>,

    /// Time when authorization will expire, measured in seconds from the time that nonceTPM
    /// was generated
    /// If expiration is non-negative, a NULL Ticket is returned. See 23.2.5.
    pub expiration: i32,

    /// Selector of the algorithm used to construct the signature

    /// Signed authorization (not optional)
    /// One of: TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA,
    /// TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TPMT_HA,
    /// TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE.
    pub auth: TPMU_SIGNATURE,
}

impl Default for TPM2_PolicySigned_REQUEST {
    fn default() -> Self {
        Self {
            authObject: TPM_HANDLE::default(),
            policySession: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_PolicySigned_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        auth_Object: TPM_HANDLE,
        policy_Session: TPM_HANDLE,
        nonce_TPM: Vec<u8>,
        cp_Hash_A: Vec<u8>,
        policy_Ref: Vec<u8>,
        expiration: i32,
        auth: TPMU_SIGNATURE,
        ) -> Self {
        Self {
            auth_Object,
            policy_Session,
            nonce_TPM,
            cp_Hash_A,
            policy_Ref,
            expiration,
            auth,
        }
    }

    /// Get the authSigAlg selector value
    pub fn auth_Sig_Alg(&self) -> TPM_ALG_ID {
        match &self.auth {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command includes a signed authorization in a policy. The command ties the policy
/// to a signing key by including the Name of the signing key in the policyDigest
#[derive(Debug, Clone)]
pub struct PolicySignedResponse {
    /// Implementation-specific time value, used to indicate to the TPM when the ticket expires
    /// NOTE If policyTicket is a NULL Ticket, then this shall be the Empty Buffer.
    pub timeout: Vec<u8>,

    /// Produced if the command succeeds and expiration in the command was non-zero; this
    /// ticket will use the TPMT_ST_AUTH_SIGNED structure tag. See 23.2.5
    pub policy_Ticket: TPMT_TK_AUTH,
}

impl Default for PolicySignedResponse {
    fn default() -> Self {
        Self {
        }
    }
}

impl PolicySignedResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command includes a secret-based authorization to a policy. The caller proves
/// knowledge of the secret value using an authorization session using the authValue
/// associated with authHandle. A password session, an HMAC session, or a policy session
/// containing TPM2_PolicyAuthValue() or TPM2_PolicyPassword() will satisfy this requirement.
#[derive(Debug, Clone)]
pub struct TPM2_PolicySecret_REQUEST {
    /// Handle for an entity providing the authorization
    /// Auth Index: 1
    /// Auth Role: USER
    pub auth_Handle: TPM_HANDLE,

    /// Handle for the policy session being extended
    /// Auth Index: None
    pub policy_Session: TPM_HANDLE,

    /// The policy nonce for the session
    /// This can be the Empty Buffer.
    pub nonce_TPM: Vec<u8>,

    /// Digest of the command parameters to which this authorization is limited
    /// This not the cpHash for this command but the cpHash for the command to which this
    /// policy session will be applied. If it is not limited, the parameter will be the Empty Buffer.
    pub cp_Hash_A: Vec<u8>,

    /// A reference to a policy relating to the authorization may be the Empty Buffer
    /// Size is limited to be no larger than the nonce size supported on the TPM.
    pub policy_Ref: Vec<u8>,

    /// Time when authorization will expire, measured in seconds from the time that nonceTPM
    /// was generated
    /// If expiration is non-negative, a NULL Ticket is returned. See 23.2.5.
    pub expiration: i32,
}

impl Default for TPM2_PolicySecret_REQUEST {
    fn default() -> Self {
        Self {
            authHandle: TPM_HANDLE::default(),
            policySession: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_PolicySecret_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        auth_Handle: TPM_HANDLE,
        policy_Session: TPM_HANDLE,
        nonce_TPM: Vec<u8>,
        cp_Hash_A: Vec<u8>,
        policy_Ref: Vec<u8>,
        expiration: i32,
        ) -> Self {
        Self {
            auth_Handle,
            policy_Session,
            nonce_TPM,
            cp_Hash_A,
            policy_Ref,
            expiration,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command includes a secret-based authorization to a policy. The caller proves
/// knowledge of the secret value using an authorization session using the authValue
/// associated with authHandle. A password session, an HMAC session, or a policy session
/// containing TPM2_PolicyAuthValue() or TPM2_PolicyPassword() will satisfy this requirement.
#[derive(Debug, Clone)]
pub struct PolicySecretResponse {
    /// Implementation-specific time value used to indicate to the TPM when the ticket expires
    pub timeout: Vec<u8>,

    /// Produced if the command succeeds and expiration in the command was non-zero ( See
    /// 23.2.5). This ticket will use the TPMT_ST_AUTH_SECRET structure tag
    pub policy_Ticket: TPMT_TK_AUTH,
}

impl Default for PolicySecretResponse {
    fn default() -> Self {
        Self {
        }
    }
}

impl PolicySecretResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command is similar to TPM2_PolicySigned() except that it takes a ticket instead
/// of a signed authorization. The ticket represents a validated authorization that had an
/// expiration time associated with it.
#[derive(Debug, Clone)]
pub struct TPM2_PolicyTicket_REQUEST {
    /// Handle for the policy session being extended
    /// Auth Index: None
    pub policy_Session: TPM_HANDLE,

    /// Time when authorization will expire
    /// The contents are TPM specific. This shall be the value returned when ticket was produced.
    pub timeout: Vec<u8>,

    /// Digest of the command parameters to which this authorization is limited
    /// If it is not limited, the parameter will be the Empty Buffer.
    pub cp_Hash_A: Vec<u8>,

    /// Reference to a qualifier for the policy may be the Empty Buffer
    pub policy_Ref: Vec<u8>,

    /// Name of the object that provided the authorization
    pub auth_Name: Vec<u8>,

    /// An authorization ticket returned by the TPM in response to a TPM2_PolicySigned() or
    /// TPM2_PolicySecret()
    pub ticket: TPMT_TK_AUTH,
}

impl Default for TPM2_PolicyTicket_REQUEST {
    fn default() -> Self {
        Self {
            policySession: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_PolicyTicket_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        policy_Session: TPM_HANDLE,
        timeout: Vec<u8>,
        cp_Hash_A: Vec<u8>,
        policy_Ref: Vec<u8>,
        auth_Name: Vec<u8>,
        ticket: TPMT_TK_AUTH,
        ) -> Self {
        Self {
            policy_Session,
            timeout,
            cp_Hash_A,
            policy_Ref,
            auth_Name,
            ticket,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command allows options in authorizations without requiring that the TPM evaluate
/// all of the options. If a policy may be satisfied by different sets of conditions, the
/// TPM need only evaluate one set that satisfies the policy. This command will indicate
/// that one of the required sets of conditions has been satisfied.
#[derive(Debug, Clone)]
pub struct TPM2_PolicyOR_REQUEST {
    /// Handle for the policy session being extended
    /// Auth Index: None
    pub policy_Session: TPM_HANDLE,

    /// The list of hashes to check for a match
    pub pHashList: Vec<TPM2B_DIGEST>,
}

impl Default for TPM2_PolicyOR_REQUEST {
    fn default() -> Self {
        Self {
            policySession: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_PolicyOR_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        policy_Session: TPM_HANDLE,
        pHashList: Vec<TPM2B_DIGEST>,
        ) -> Self {
        Self {
            policy_Session,
            pHashList,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command is used to cause conditional gating of a policy based on PCR. This
/// command together with TPM2_PolicyOR() allows one group of authorizations to occur when
/// PCR are in one state and a different set of authorizations when the PCR are in a
/// different state.
#[derive(Debug, Clone)]
pub struct TPM2_PolicyPCR_REQUEST {
    /// Handle for the policy session being extended
    /// Auth Index: None
    pub policy_Session: TPM_HANDLE,

    /// Expected digest value of the selected PCR using the hash algorithm of the session; may
    /// be zero length
    pub pcr_Digest: Vec<u8>,

    /// The PCR to include in the check digest
    pub pcrs: Vec<TPMS_PCR_SELECTION>,
}

impl Default for TPM2_PolicyPCR_REQUEST {
    fn default() -> Self {
        Self {
            policySession: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_PolicyPCR_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        policy_Session: TPM_HANDLE,
        pcr_Digest: Vec<u8>,
        pcrs: Vec<TPMS_PCR_SELECTION>,
        ) -> Self {
        Self {
            policy_Session,
            pcr_Digest,
            pcrs,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command indicates that the authorization will be limited to a specific locality.
#[derive(Debug, Clone)]
pub struct TPM2_PolicyLocality_REQUEST {
    /// Handle for the policy session being extended
    /// Auth Index: None
    pub policy_Session: TPM_HANDLE,

    /// The allowed localities for the policy
    pub locality: TPMA_LOCALITY,
}

impl Default for TPM2_PolicyLocality_REQUEST {
    fn default() -> Self {
        Self {
            policySession: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_PolicyLocality_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        policy_Session: TPM_HANDLE,
        locality: TPMA_LOCALITY,
        ) -> Self {
        Self {
            policy_Session,
            locality,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command is used to cause conditional gating of a policy based on the contents of
/// an NV Index. It is an immediate assertion. The NV index is validated during the
/// TPM2_PolicyNV() command, not when the session is used for authorization.
#[derive(Debug, Clone)]
pub struct TPM2_PolicyNV_REQUEST {
    /// Handle indicating the source of the authorization value
    /// Auth Index: 1
    /// Auth Role: USER
    pub auth_Handle: TPM_HANDLE,

    /// The NV Index of the area to read
    /// Auth Index: None
    pub nv_Index: TPM_HANDLE,

    /// Handle for the policy session being extended
    /// Auth Index: None
    pub policy_Session: TPM_HANDLE,

    /// The second operand
    pub operand_B: Vec<u8>,

    /// The octet offset in the NV Index for the start of operand A
    pub offset: u16,

    /// The comparison to make
    pub operation: TPM_EO,
}

impl Default for TPM2_PolicyNV_REQUEST {
    fn default() -> Self {
        Self {
            authHandle: TPM_HANDLE::default(),
            nvIndex: TPM_HANDLE::default(),
            policySession: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_PolicyNV_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        auth_Handle: TPM_HANDLE,
        nv_Index: TPM_HANDLE,
        policy_Session: TPM_HANDLE,
        operand_B: Vec<u8>,
        offset: u16,
        operation: TPM_EO,
        ) -> Self {
        Self {
            auth_Handle,
            nv_Index,
            policy_Session,
            operand_B,
            offset,
            operation,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command is used to cause conditional gating of a policy based on the contents of
/// the TPMS_TIME_INFO structure.
#[derive(Debug, Clone)]
pub struct TPM2_PolicyCounterTimer_REQUEST {
    /// Handle for the policy session being extended
    /// Auth Index: None
    pub policy_Session: TPM_HANDLE,

    /// The second operand
    pub operand_B: Vec<u8>,

    /// The octet offset in the TPMS_TIME_INFO structure for the start of operand A
    pub offset: u16,

    /// The comparison to make
    pub operation: TPM_EO,
}

impl Default for TPM2_PolicyCounterTimer_REQUEST {
    fn default() -> Self {
        Self {
            policySession: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_PolicyCounterTimer_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        policy_Session: TPM_HANDLE,
        operand_B: Vec<u8>,
        offset: u16,
        operation: TPM_EO,
        ) -> Self {
        Self {
            policy_Session,
            operand_B,
            offset,
            operation,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command indicates that the authorization will be limited to a specific command code.
#[derive(Debug, Clone)]
pub struct TPM2_PolicyCommandCode_REQUEST {
    /// Handle for the policy session being extended
    /// Auth Index: None
    pub policy_Session: TPM_HANDLE,

    /// The allowed commandCode
    pub code: TPM_CC,
}

impl Default for TPM2_PolicyCommandCode_REQUEST {
    fn default() -> Self {
        Self {
            policySession: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_PolicyCommandCode_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        policy_Session: TPM_HANDLE,
        code: TPM_CC,
        ) -> Self {
        Self {
            policy_Session,
            code,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command indicates that physical presence will need to be asserted at the time the
/// authorization is performed.
#[derive(Debug, Clone)]
pub struct TPM2_PolicyPhysicalPresence_REQUEST {
    /// Handle for the policy session being extended
    /// Auth Index: None
    pub policy_Session: TPM_HANDLE,
}

impl Default for TPM2_PolicyPhysicalPresence_REQUEST {
    fn default() -> Self {
        Self {
            policySession: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_PolicyPhysicalPresence_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        policy_Session: TPM_HANDLE,
        ) -> Self {
        Self {
            policy_Session,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command is used to allow a policy to be bound to a specific command and command parameters.
#[derive(Debug, Clone)]
pub struct TPM2_PolicyCpHash_REQUEST {
    /// Handle for the policy session being extended
    /// Auth Index: None
    pub policy_Session: TPM_HANDLE,

    /// The cpHash added to the policy
    pub cp_Hash_A: Vec<u8>,
}

impl Default for TPM2_PolicyCpHash_REQUEST {
    fn default() -> Self {
        Self {
            policySession: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_PolicyCpHash_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        policy_Session: TPM_HANDLE,
        cp_Hash_A: Vec<u8>,
        ) -> Self {
        Self {
            policy_Session,
            cp_Hash_A,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command allows a policy to be bound to a specific set of TPM entities without
/// being bound to the parameters of the command. This is most useful for commands such as
/// TPM2_Duplicate() and for TPM2_PCR_Event() when the referenced PCR requires a policy.
#[derive(Debug, Clone)]
pub struct TPM2_PolicyNameHash_REQUEST {
    /// Handle for the policy session being extended
    /// Auth Index: None
    pub policy_Session: TPM_HANDLE,

    /// The digest to be added to the policy
    pub name_Hash: Vec<u8>,
}

impl Default for TPM2_PolicyNameHash_REQUEST {
    fn default() -> Self {
        Self {
            policySession: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_PolicyNameHash_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        policy_Session: TPM_HANDLE,
        name_Hash: Vec<u8>,
        ) -> Self {
        Self {
            policy_Session,
            name_Hash,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command allows qualification of duplication to allow duplication to a selected
/// new parent.
#[derive(Debug, Clone)]
pub struct TPM2_PolicyDuplicationSelect_REQUEST {
    /// Handle for the policy session being extended
    /// Auth Index: None
    pub policy_Session: TPM_HANDLE,

    /// The Name of the object to be duplicated
    pub object_Name: Vec<u8>,

    /// The Name of the new parent
    pub new_Parent_Name: Vec<u8>,

    /// If YES, the objectName will be included in the value in policySessionpolicyDigest
    pub include_Object: u8,
}

impl Default for TPM2_PolicyDuplicationSelect_REQUEST {
    fn default() -> Self {
        Self {
            policySession: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_PolicyDuplicationSelect_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        policy_Session: TPM_HANDLE,
        object_Name: Vec<u8>,
        new_Parent_Name: Vec<u8>,
        include_Object: u8,
        ) -> Self {
        Self {
            policy_Session,
            object_Name,
            new_Parent_Name,
            include_Object,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command allows policies to change. If a policy were static, then it would be
/// difficult to add users to a policy. This command lets a policy authority sign a new
/// policy so that it may be used in an existing policy.
#[derive(Debug, Clone)]
pub struct TPM2_PolicyAuthorize_REQUEST {
    /// Handle for the policy session being extended
    /// Auth Index: None
    pub policy_Session: TPM_HANDLE,

    /// Digest of the policy being approved
    pub approved_Policy: Vec<u8>,

    /// A policy qualifier
    pub policy_Ref: Vec<u8>,

    /// Name of a key that can sign a policy addition
    pub key_Sign: Vec<u8>,

    /// Ticket validating that approvedPolicy and policyRef were signed by keySign
    pub check_Ticket: TPMT_TK_VERIFIED,
}

impl Default for TPM2_PolicyAuthorize_REQUEST {
    fn default() -> Self {
        Self {
            policySession: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_PolicyAuthorize_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        policy_Session: TPM_HANDLE,
        approved_Policy: Vec<u8>,
        policy_Ref: Vec<u8>,
        key_Sign: Vec<u8>,
        check_Ticket: TPMT_TK_VERIFIED,
        ) -> Self {
        Self {
            policy_Session,
            approved_Policy,
            policy_Ref,
            key_Sign,
            check_Ticket,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command allows a policy to be bound to the authorization value of the authorized entity.
#[derive(Debug, Clone)]
pub struct TPM2_PolicyAuthValue_REQUEST {
    /// Handle for the policy session being extended
    /// Auth Index: None
    pub policy_Session: TPM_HANDLE,
}

impl Default for TPM2_PolicyAuthValue_REQUEST {
    fn default() -> Self {
        Self {
            policySession: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_PolicyAuthValue_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        policy_Session: TPM_HANDLE,
        ) -> Self {
        Self {
            policy_Session,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command allows a policy to be bound to the authorization value of the authorized object.
#[derive(Debug, Clone)]
pub struct TPM2_PolicyPassword_REQUEST {
    /// Handle for the policy session being extended
    /// Auth Index: None
    pub policy_Session: TPM_HANDLE,
}

impl Default for TPM2_PolicyPassword_REQUEST {
    fn default() -> Self {
        Self {
            policySession: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_PolicyPassword_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        policy_Session: TPM_HANDLE,
        ) -> Self {
        Self {
            policy_Session,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command returns the current policyDigest of the session. This command allows the
/// TPM to be used to perform the actions required to pre-compute the authPolicy for an object.
#[derive(Debug, Clone)]
pub struct TPM2_PolicyGetDigest_REQUEST {
    /// Handle for the policy session
    /// Auth Index: None
    pub policy_Session: TPM_HANDLE,
}

impl Default for TPM2_PolicyGetDigest_REQUEST {
    fn default() -> Self {
        Self {
            policySession: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_PolicyGetDigest_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        policy_Session: TPM_HANDLE,
        ) -> Self {
        Self {
            policy_Session,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command returns the current policyDigest of the session. This command allows the
/// TPM to be used to perform the actions required to pre-compute the authPolicy for an object.
#[derive(Debug, Clone)]
pub struct PolicyGetDigestResponse {
    /// The current value of the policySessionpolicyDigest
    pub policy_Digest: Vec<u8>,
}

impl Default for PolicyGetDigestResponse {
    fn default() -> Self {
        Self {
        }
    }
}

impl PolicyGetDigestResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command allows a policy to be bound to the TPMA_NV_WRITTEN attributes. This is a
/// deferred assertion. Values are stored in the policy session context and checked when
/// the policy is used for authorization.
#[derive(Debug, Clone)]
pub struct TPM2_PolicyNvWritten_REQUEST {
    /// Handle for the policy session being extended
    /// Auth Index: None
    pub policy_Session: TPM_HANDLE,

    /// YES if NV Index is required to have been written
    /// NO if NV Index is required not to have been written
    pub written_Set: u8,
}

impl Default for TPM2_PolicyNvWritten_REQUEST {
    fn default() -> Self {
        Self {
            policySession: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_PolicyNvWritten_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        policy_Session: TPM_HANDLE,
        written_Set: u8,
        ) -> Self {
        Self {
            policy_Session,
            written_Set,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command allows a policy to be bound to a specific creation template. This is most
/// useful for an object creation command such as TPM2_Create(), TPM2_CreatePrimary(), or
/// TPM2_CreateLoaded().
#[derive(Debug, Clone)]
pub struct TPM2_PolicyTemplate_REQUEST {
    /// Handle for the policy session being extended
    /// Auth Index: None
    pub policy_Session: TPM_HANDLE,

    /// The digest to be added to the policy
    pub template_Hash: Vec<u8>,
}

impl Default for TPM2_PolicyTemplate_REQUEST {
    fn default() -> Self {
        Self {
            policySession: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_PolicyTemplate_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        policy_Session: TPM_HANDLE,
        template_Hash: Vec<u8>,
        ) -> Self {
        Self {
            policy_Session,
            template_Hash,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command provides a capability that is the equivalent of a revocable policy. With
/// TPM2_PolicyAuthorize(), the authorization ticket never expires, so the authorization
/// may not be withdrawn. With this command, the approved policy is kept in an NV Index
/// location so that the policy may be changed as needed to render the old policy unusable.
#[derive(Debug, Clone)]
pub struct TPM2_PolicyAuthorizeNV_REQUEST {
    /// Handle indicating the source of the authorization value
    /// Auth Index: 1
    /// Auth Role: USER
    pub auth_Handle: TPM_HANDLE,

    /// The NV Index of the area to read
    /// Auth Index: None
    pub nv_Index: TPM_HANDLE,

    /// Handle for the policy session being extended
    /// Auth Index: None
    pub policy_Session: TPM_HANDLE,
}

impl Default for TPM2_PolicyAuthorizeNV_REQUEST {
    fn default() -> Self {
        Self {
            authHandle: TPM_HANDLE::default(),
            nvIndex: TPM_HANDLE::default(),
            policySession: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_PolicyAuthorizeNV_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        auth_Handle: TPM_HANDLE,
        nv_Index: TPM_HANDLE,
        policy_Session: TPM_HANDLE,
        ) -> Self {
        Self {
            auth_Handle,
            nv_Index,
            policy_Session,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command is used to create a Primary Object under one of the Primary Seeds or a
/// Temporary Object under TPM_RH_NULL. The command uses a TPM2B_PUBLIC as a template for
/// the object to be created. The size of the unique field shall not be checked for
/// consistency with the other object parameters. The command will create and load a
/// Primary Object. The sensitive area is not returned.
#[derive(Debug, Clone)]
pub struct TPM2_CreatePrimary_REQUEST {
    /// TPM_RH_ENDORSEMENT, TPM_RH_OWNER, TPM_RH_PLATFORM+{PP}, or TPM_RH_NULL
    /// Auth Index: 1
    /// Auth Role: USER
    pub primary_Handle: TPM_HANDLE,

    /// The sensitive data, see TPM 2.0 Part 1 Sensitive Values
    pub in_Sensitive: TPMS_SENSITIVE_CREATE,

    /// The public template
    pub in_Public: TPMT_PUBLIC,

    /// Data that will be included in the creation data for this object to provide permanent,
    /// verifiable linkage between this object and some object owner data
    pub outside_Info: Vec<u8>,

    /// PCR that will be used in creation data
    pub creation_PCR: Vec<TPMS_PCR_SELECTION>,
}

impl Default for TPM2_CreatePrimary_REQUEST {
    fn default() -> Self {
        Self {
            primaryHandle: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_CreatePrimary_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        primary_Handle: TPM_HANDLE,
        in_Sensitive: TPMS_SENSITIVE_CREATE,
        in_Public: TPMT_PUBLIC,
        outside_Info: Vec<u8>,
        creation_PCR: Vec<TPMS_PCR_SELECTION>,
        ) -> Self {
        Self {
            primary_Handle,
            in_Sensitive,
            in_Public,
            outside_Info,
            creation_PCR,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command is used to create a Primary Object under one of the Primary Seeds or a
/// Temporary Object under TPM_RH_NULL. The command uses a TPM2B_PUBLIC as a template for
/// the object to be created. The size of the unique field shall not be checked for
/// consistency with the other object parameters. The command will create and load a
/// Primary Object. The sensitive area is not returned.
#[derive(Debug, Clone)]
pub struct CreatePrimaryResponse {
    /// Handle of type TPM_HT_TRANSIENT for created Primary Object
    pub handle: TPM_HANDLE,

    /// The public portion of the created object
    pub out_Public: TPMT_PUBLIC,

    /// Contains a TPMT_CREATION_DATA
    pub creation_Data: TPMS_CREATION_DATA,

    /// Digest of creationData using nameAlg of outPublic
    pub creation_Hash: Vec<u8>,

    /// Ticket used by TPM2_CertifyCreation() to validate that the creation data was produced
    /// by the TPM
    pub creation_Ticket: TPMT_TK_CREATION,

    /// The name of the created object
    pub name: Vec<u8>,
}

impl Default for CreatePrimaryResponse {
    fn default() -> Self {
        Self {
            handle: TPM_HANDLE::default(),
        }
    }
}

impl CreatePrimaryResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command enables and disables use of a hierarchy and its associated NV storage.
/// The command allows phEnable, phEnableNV, shEnable, and ehEnable to be changed when the
/// proper authorization is provided.
#[derive(Debug, Clone)]
pub struct TPM2_HierarchyControl_REQUEST {
    /// TPM_RH_ENDORSEMENT, TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
    /// Auth Index: 1
    /// Auth Role: USER
    pub auth_Handle: TPM_HANDLE,

    /// The enable being modified
    /// TPM_RH_ENDORSEMENT, TPM_RH_OWNER, TPM_RH_PLATFORM, or TPM_RH_PLATFORM_NV
    pub enable: TPM_HANDLE,

    /// YES if the enable should be SET, NO if the enable should be CLEAR
    pub state: u8,
}

impl Default for TPM2_HierarchyControl_REQUEST {
    fn default() -> Self {
        Self {
            authHandle: TPM_HANDLE::default(),
            enable: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_HierarchyControl_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        auth_Handle: TPM_HANDLE,
        enable: TPM_HANDLE,
        state: u8,
        ) -> Self {
        Self {
            auth_Handle,
            enable,
            state,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command allows setting of the authorization policy for the lockout
/// (lockoutPolicy), the platform hierarchy (platformPolicy), the storage hierarchy
/// (ownerPolicy), and the endorsement hierarchy (endorsementPolicy). On TPMs implementing
/// Authenticated Countdown Timers (ACT), this command may also be used to set the
/// authorization policy for an ACT.
#[derive(Debug, Clone)]
pub struct TPM2_SetPrimaryPolicy_REQUEST {
    /// TPM_RH_LOCKOUT, TPM_RH_ENDORSEMENT, TPM_RH_OWNER, TPMI_RH_ACT or TPM_RH_PLATFORM+{PP}
    /// Auth Index: 1
    /// Auth Role: USER
    pub auth_Handle: TPM_HANDLE,

    /// An authorization policy digest; may be the Empty Buffer
    /// If hashAlg is TPM_ALG_NULL, then this shall be an Empty Buffer.
    pub auth_Policy: Vec<u8>,

    /// The hash algorithm to use for the policy
    /// If the authPolicy is an Empty Buffer, then this field shall be TPM_ALG_NULL.
    pub hash_Alg: TPM_ALG_ID,
}

impl Default for TPM2_SetPrimaryPolicy_REQUEST {
    fn default() -> Self {
        Self {
            authHandle: TPM_HANDLE::default(),
            hashAlg: TPM_ALG_ID::NULL,
        }
    }
}

impl TPM2_SetPrimaryPolicy_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        auth_Handle: TPM_HANDLE,
        auth_Policy: Vec<u8>,
        hash_Alg: TPM_ALG_ID,
        ) -> Self {
        Self {
            auth_Handle,
            auth_Policy,
            hash_Alg,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This replaces the current platform primary seed (PPS) with a value from the RNG and
/// sets platformPolicy to the default initialization value (the Empty Buffer).
#[derive(Debug, Clone)]
pub struct TPM2_ChangePPS_REQUEST {
    /// TPM_RH_PLATFORM+{PP}
    /// Auth Index: 1
    /// Auth Role: USER
    pub auth_Handle: TPM_HANDLE,
}

impl Default for TPM2_ChangePPS_REQUEST {
    fn default() -> Self {
        Self {
            authHandle: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_ChangePPS_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        auth_Handle: TPM_HANDLE,
        ) -> Self {
        Self {
            auth_Handle,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This replaces the current endorsement primary seed (EPS) with a value from the RNG and
/// sets the Endorsement hierarchy controls to their default initialization values:
/// ehEnable is SET, endorsementAuth and endorsementPolicy are both set to the Empty
/// Buffer. It will flush any resident objects (transient or persistent) in the
/// Endorsement hierarchy and not allow objects in the hierarchy associated with the
/// previous EPS to be loaded.
#[derive(Debug, Clone)]
pub struct TPM2_ChangeEPS_REQUEST {
    /// TPM_RH_PLATFORM+{PP}
    /// Auth Handle: 1
    /// Auth Role: USER
    pub auth_Handle: TPM_HANDLE,
}

impl Default for TPM2_ChangeEPS_REQUEST {
    fn default() -> Self {
        Self {
            authHandle: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_ChangeEPS_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        auth_Handle: TPM_HANDLE,
        ) -> Self {
        Self {
            auth_Handle,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command removes all TPM context associated with a specific Owner.
#[derive(Debug, Clone)]
pub struct TPM2_Clear_REQUEST {
    /// TPM_RH_LOCKOUT or TPM_RH_PLATFORM+{PP}
    /// Auth Handle: 1
    /// Auth Role: USER
    pub auth_Handle: TPM_HANDLE,
}

impl Default for TPM2_Clear_REQUEST {
    fn default() -> Self {
        Self {
            authHandle: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_Clear_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        auth_Handle: TPM_HANDLE,
        ) -> Self {
        Self {
            auth_Handle,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// TPM2_ClearControl() disables and enables the execution of TPM2_Clear().
#[derive(Debug, Clone)]
pub struct TPM2_ClearControl_REQUEST {
    /// TPM_RH_LOCKOUT or TPM_RH_PLATFORM+{PP}
    /// Auth Handle: 1
    /// Auth Role: USER
    pub auth: TPM_HANDLE,

    /// YES if the disableOwnerClear flag is to be SET, NO if the flag is to be CLEAR.
    pub disable: u8,
}

impl Default for TPM2_ClearControl_REQUEST {
    fn default() -> Self {
        Self {
            auth: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_ClearControl_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        auth: TPM_HANDLE,
        disable: u8,
        ) -> Self {
        Self {
            auth,
            disable,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command allows the authorization secret for a hierarchy or lockout to be changed
/// using the current authorization value as the command authorization.
#[derive(Debug, Clone)]
pub struct TPM2_HierarchyChangeAuth_REQUEST {
    /// TPM_RH_LOCKOUT, TPM_RH_ENDORSEMENT, TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
    /// Auth Index: 1
    /// Auth Role: USER
    pub auth_Handle: TPM_HANDLE,

    /// New authorization value
    pub new_Auth: Vec<u8>,
}

impl Default for TPM2_HierarchyChangeAuth_REQUEST {
    fn default() -> Self {
        Self {
            authHandle: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_HierarchyChangeAuth_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        auth_Handle: TPM_HANDLE,
        new_Auth: Vec<u8>,
        ) -> Self {
        Self {
            auth_Handle,
            new_Auth,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command cancels the effect of a TPM lockout due to a number of successive
/// authorization failures. If this command is properly authorized, the lockout counter is
/// set to zero.
#[derive(Debug, Clone)]
pub struct TPM2_DictionaryAttackLockReset_REQUEST {
    /// TPM_RH_LOCKOUT
    /// Auth Index: 1
    /// Auth Role: USER
    pub lock_Handle: TPM_HANDLE,
}

impl Default for TPM2_DictionaryAttackLockReset_REQUEST {
    fn default() -> Self {
        Self {
            lockHandle: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_DictionaryAttackLockReset_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        lock_Handle: TPM_HANDLE,
        ) -> Self {
        Self {
            lock_Handle,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command changes the lockout parameters.
#[derive(Debug, Clone)]
pub struct TPM2_DictionaryAttackParameters_REQUEST {
    /// TPM_RH_LOCKOUT
    /// Auth Index: 1
    /// Auth Role: USER
    pub lock_Handle: TPM_HANDLE,

    /// Count of authorization failures before the lockout is imposed
    pub new_Max_Tries: u32,

    /// Time in seconds before the authorization failure count is automatically decremented
    /// A value of zero indicates that DA protection is disabled.
    pub new_Recovery_Time: u32,

    /// Time in seconds after a lockoutAuth failure before use of lockoutAuth is allowed
    /// A value of zero indicates that a reboot is required.
    pub lockout_Recovery: u32,
}

impl Default for TPM2_DictionaryAttackParameters_REQUEST {
    fn default() -> Self {
        Self {
            lockHandle: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_DictionaryAttackParameters_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        lock_Handle: TPM_HANDLE,
        new_Max_Tries: u32,
        new_Recovery_Time: u32,
        lockout_Recovery: u32,
        ) -> Self {
        Self {
            lock_Handle,
            new_Max_Tries,
            new_Recovery_Time,
            lockout_Recovery,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command is used to determine which commands require assertion of Physical
/// Presence (PP) in addition to platformAuth/platformPolicy.
#[derive(Debug, Clone)]
pub struct TPM2_PP_Commands_REQUEST {
    /// TPM_RH_PLATFORM+PP
    /// Auth Index: 1
    /// Auth Role: USER + Physical Presence
    pub auth: TPM_HANDLE,

    /// List of commands to be added to those that will require that Physical Presence be asserted
    pub set_List: Vec<TPM_CC>,

    /// List of commands that will no longer require that Physical Presence be asserted
    pub clear_List: Vec<TPM_CC>,
}

impl Default for TPM2_PP_Commands_REQUEST {
    fn default() -> Self {
        Self {
            auth: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_PP_Commands_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        auth: TPM_HANDLE,
        set_List: Vec<TPM_CC>,
        clear_List: Vec<TPM_CC>,
        ) -> Self {
        Self {
            auth,
            set_List,
            clear_List,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command allows the platform to change the set of algorithms that are used by the
/// TPM. The algorithmSet setting is a vendor-dependent value.
#[derive(Debug, Clone)]
pub struct TPM2_SetAlgorithmSet_REQUEST {
    /// TPM_RH_PLATFORM
    /// Auth Index: 1
    /// Auth Role: USER
    pub auth_Handle: TPM_HANDLE,

    /// A TPM vendor-dependent value indicating the algorithm set selection
    pub algorithm_Set: u32,
}

impl Default for TPM2_SetAlgorithmSet_REQUEST {
    fn default() -> Self {
        Self {
            authHandle: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_SetAlgorithmSet_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        auth_Handle: TPM_HANDLE,
        algorithm_Set: u32,
        ) -> Self {
        Self {
            auth_Handle,
            algorithm_Set,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command uses platformPolicy and a TPM Vendor Authorization Key to authorize a
/// Field Upgrade Manifest.
#[derive(Debug, Clone)]
pub struct TPM2_FieldUpgradeStart_REQUEST {
    /// TPM_RH_PLATFORM+{PP}
    /// Auth Index:1
    /// Auth Role: ADMIN
    pub authorization: TPM_HANDLE,

    /// Handle of a public area that contains the TPM Vendor Authorization Key that will be
    /// used to validate manifestSignature
    /// Auth Index: None
    pub key_Handle: TPM_HANDLE,

    /// Digest of the first block in the field upgrade sequence
    pub fu_Digest: Vec<u8>,

    /// Selector of the algorithm used to construct the signature

    /// Signature over fuDigest using the key associated with keyHandle (not optional)
    /// One of: TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA,
    /// TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TPMT_HA,
    /// TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE.
    pub manifest_Signature: TPMU_SIGNATURE,
}

impl Default for TPM2_FieldUpgradeStart_REQUEST {
    fn default() -> Self {
        Self {
            authorization: TPM_HANDLE::default(),
            keyHandle: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_FieldUpgradeStart_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        authorization: TPM_HANDLE,
        key_Handle: TPM_HANDLE,
        fu_Digest: Vec<u8>,
        manifest_Signature: TPMU_SIGNATURE,
        ) -> Self {
        Self {
            authorization,
            key_Handle,
            fu_Digest,
            manifest_Signature,
        }
    }

    /// Get the manifestSignatureSigAlg selector value
    pub fn manifest_Signature_Sig_Alg(&self) -> TPM_ALG_ID {
        match &self.manifest_Signature {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command will take the actual field upgrade image to be installed on the TPM. The
/// exact format of fuData is vendor-specific. This command is only possible following a
/// successful TPM2_FieldUpgradeStart(). If the TPM has not received a properly authorized
/// TPM2_FieldUpgradeStart(), then the TPM shall return TPM_RC_FIELDUPGRADE.
#[derive(Debug, Clone)]
pub struct TPM2_FieldUpgradeData_REQUEST {
    /// Field upgrade image data
    pub fu_Data: Vec<u8>,
}

impl Default for TPM2_FieldUpgradeData_REQUEST {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPM2_FieldUpgradeData_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        fu_Data: Vec<u8>,
        ) -> Self {
        Self {
            fu_Data,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command will take the actual field upgrade image to be installed on the TPM. The
/// exact format of fuData is vendor-specific. This command is only possible following a
/// successful TPM2_FieldUpgradeStart(). If the TPM has not received a properly authorized
/// TPM2_FieldUpgradeStart(), then the TPM shall return TPM_RC_FIELDUPGRADE.
#[derive(Debug, Clone)]
pub struct FieldUpgradeDataResponse {
    /// Tagged digest of the next block
    /// TPM_ALG_NULL if field update is complete
    pub next_Digest: TPMT_HA,

    /// Tagged digest of the first block of the sequence
    pub first_Digest: TPMT_HA,
}

impl Default for FieldUpgradeDataResponse {
    fn default() -> Self {
        Self {
        }
    }
}

impl FieldUpgradeDataResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command is used to read a copy of the current firmware installed in the TPM.
#[derive(Debug, Clone)]
pub struct TPM2_FirmwareRead_REQUEST {
    /// The number of previous calls to this command in this sequence
    /// set to 0 on the first call
    pub sequence_Number: u32,
}

impl Default for TPM2_FirmwareRead_REQUEST {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPM2_FirmwareRead_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        sequence_Number: u32,
        ) -> Self {
        Self {
            sequence_Number,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command is used to read a copy of the current firmware installed in the TPM.
#[derive(Debug, Clone)]
pub struct FirmwareReadResponse {
    /// Field upgrade image data
    pub fu_Data: Vec<u8>,
}

impl Default for FirmwareReadResponse {
    fn default() -> Self {
        Self {
        }
    }
}

impl FirmwareReadResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command saves a session context, object context, or sequence object context
/// outside the TPM.
#[derive(Debug, Clone)]
pub struct TPM2_ContextSave_REQUEST {
    /// Handle of the resource to save
    /// Auth Index: None
    pub save_Handle: TPM_HANDLE,
}

impl Default for TPM2_ContextSave_REQUEST {
    fn default() -> Self {
        Self {
            saveHandle: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_ContextSave_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        save_Handle: TPM_HANDLE,
        ) -> Self {
        Self {
            save_Handle,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command saves a session context, object context, or sequence object context
/// outside the TPM.
#[derive(Debug, Clone)]
pub struct ContextSaveResponse {
    pub context: TPMS_CONTEXT,
}

impl Default for ContextSaveResponse {
    fn default() -> Self {
        Self {
        }
    }
}

impl ContextSaveResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command is used to reload a context that has been saved by TPM2_ContextSave().
#[derive(Debug, Clone)]
pub struct TPM2_ContextLoad_REQUEST {
    /// The context blob
    pub context: TPMS_CONTEXT,
}

impl Default for TPM2_ContextLoad_REQUEST {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPM2_ContextLoad_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        context: TPMS_CONTEXT,
        ) -> Self {
        Self {
            context,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command is used to reload a context that has been saved by TPM2_ContextSave().
#[derive(Debug, Clone)]
pub struct ContextLoadResponse {
    /// The handle assigned to the resource after it has been successfully loaded
    pub handle: TPM_HANDLE,
}

impl Default for ContextLoadResponse {
    fn default() -> Self {
        Self {
            handle: TPM_HANDLE::default(),
        }
    }
}

impl ContextLoadResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command causes all context associated with a loaded object, sequence object, or
/// session to be removed from TPM memory.
#[derive(Debug, Clone)]
pub struct TPM2_FlushContext_REQUEST {
    /// The handle of the item to flush
    /// NOTE This is a use of a handle as a parameter.
    pub flush_Handle: TPM_HANDLE,
}

impl Default for TPM2_FlushContext_REQUEST {
    fn default() -> Self {
        Self {
            flushHandle: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_FlushContext_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        flush_Handle: TPM_HANDLE,
        ) -> Self {
        Self {
            flush_Handle,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command allows certain Transient Objects to be made persistent or a persistent
/// object to be evicted.
#[derive(Debug, Clone)]
pub struct TPM2_EvictControl_REQUEST {
    /// TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
    /// Auth Handle: 1
    /// Auth Role: USER
    pub auth: TPM_HANDLE,

    /// The handle of a loaded object
    /// Auth Index: None
    pub object_Handle: TPM_HANDLE,

    /// If objectHandle is a transient object handle, then this is the persistent handle for
    /// the object
    /// if objectHandle is a persistent object handle, then it shall be the same value as
    /// persistentHandle
    pub persistent_Handle: TPM_HANDLE,
}

impl Default for TPM2_EvictControl_REQUEST {
    fn default() -> Self {
        Self {
            auth: TPM_HANDLE::default(),
            objectHandle: TPM_HANDLE::default(),
            persistentHandle: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_EvictControl_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        auth: TPM_HANDLE,
        object_Handle: TPM_HANDLE,
        persistent_Handle: TPM_HANDLE,
        ) -> Self {
        Self {
            auth,
            object_Handle,
            persistent_Handle,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command reads the current TPMS_TIME_INFO structure that contains the current
/// setting of Time, Clock, resetCount, and restartCount.
#[derive(Debug, Clone)]
pub struct TPM2_ReadClock_REQUEST {
}

impl Default for TPM2_ReadClock_REQUEST {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPM2_ReadClock_REQUEST {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command reads the current TPMS_TIME_INFO structure that contains the current
/// setting of Time, Clock, resetCount, and restartCount.
#[derive(Debug, Clone)]
pub struct ReadClockResponse {
    pub current_Time: TPMS_TIME_INFO,
}

impl Default for ReadClockResponse {
    fn default() -> Self {
        Self {
        }
    }
}

impl ReadClockResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command is used to advance the value of the TPMs Clock. The command will fail if
/// newTime is less than the current value of Clock or if the new time is greater than
/// FFFF00000000000016. If both of these checks succeed, Clock is set to newTime. If
/// either of these checks fails, the TPM shall return TPM_RC_VALUE and make no change to Clock.
#[derive(Debug, Clone)]
pub struct TPM2_ClockSet_REQUEST {
    /// TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
    /// Auth Handle: 1
    /// Auth Role: USER
    pub auth: TPM_HANDLE,

    /// New Clock setting in milliseconds
    pub new_Time: u64,
}

impl Default for TPM2_ClockSet_REQUEST {
    fn default() -> Self {
        Self {
            auth: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_ClockSet_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        auth: TPM_HANDLE,
        new_Time: u64,
        ) -> Self {
        Self {
            auth,
            new_Time,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command adjusts the rate of advance of Clock and Time to provide a better
/// approximation to real time.
#[derive(Debug, Clone)]
pub struct TPM2_ClockRateAdjust_REQUEST {
    /// TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
    /// Auth Handle: 1
    /// Auth Role: USER
    pub auth: TPM_HANDLE,

    /// Adjustment to current Clock update rate
    pub rate_Adjust: TPM_CLOCK_ADJUST,
}

impl Default for TPM2_ClockRateAdjust_REQUEST {
    fn default() -> Self {
        Self {
            auth: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_ClockRateAdjust_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        auth: TPM_HANDLE,
        rate_Adjust: TPM_CLOCK_ADJUST,
        ) -> Self {
        Self {
            auth,
            rate_Adjust,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command returns various information regarding the TPM and its current state.
#[derive(Debug, Clone)]
pub struct TPM2_GetCapability_REQUEST {
    /// Group selection; determines the format of the response
    pub capability: TPM_CAP,

    /// Further definition of information
    pub property: u32,

    /// Number of properties of the indicated type to return
    pub property_Count: u32,
}

impl Default for TPM2_GetCapability_REQUEST {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPM2_GetCapability_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        capability: TPM_CAP,
        property: u32,
        property_Count: u32,
        ) -> Self {
        Self {
            capability,
            property,
            property_Count,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command returns various information regarding the TPM and its current state.
#[derive(Debug, Clone)]
pub struct GetCapabilityResponse {
    /// Flag to indicate if there are more values of this type
    pub more_Data: u8,

    /// The capability

    /// The capability data
    /// One of: TPML_ALG_PROPERTY, TPML_HANDLE, TPML_CCA, TPML_CC, TPML_PCR_SELECTION,
    /// TPML_TAGGED_TPM_PROPERTY, TPML_TAGGED_PCR_PROPERTY, TPML_ECC_CURVE,
    /// TPML_TAGGED_POLICY, TPML_ACT_DATA.
    pub capability_Data: TPMU_CAPABILITIES,
}

impl Default for GetCapabilityResponse {
    fn default() -> Self {
        Self {
        }
    }
}

impl GetCapabilityResponse {
    /// Get the capabilityDataCapability selector value
    pub fn capability_Data_Capability(&self) -> TPM_CAP {
        match &self.capability_Data {
        Some(u) => u.get_union_selector() as _,
            None => 0 as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command is used to check to see if specific combinations of algorithm parameters
/// are supported.
#[derive(Debug, Clone)]
pub struct TPM2_TestParms_REQUEST {
    /// The algorithm to be tested

    /// Algorithm parameters to be validated
    /// One of: TPMS_KEYEDHASH_PARMS, TPMS_SYMCIPHER_PARMS, TPMS_RSA_PARMS, TPMS_ECC_PARMS,
    /// TPMS_ASYM_PARMS.
    pub parameters: TPMU_PUBLIC_PARMS,
}

impl Default for TPM2_TestParms_REQUEST {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPM2_TestParms_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        parameters: TPMU_PUBLIC_PARMS,
        ) -> Self {
        Self {
            parameters,
        }
    }

    /// Get the parametersType selector value
    pub fn parameters_Type(&self) -> TPM_ALG_ID {
        match &self.parameters {
        Some(u) => u.get_union_selector() as _,
            None => 0 as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command defines the attributes of an NV Index and causes the TPM to reserve space
/// to hold the data associated with the NV Index. If a definition already exists at the
/// NV Index, the TPM will return TPM_RC_NV_DEFINED.
#[derive(Debug, Clone)]
pub struct TPM2_NV_DefineSpace_REQUEST {
    /// TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
    /// Auth Index: 1
    /// Auth Role: USER
    pub auth_Handle: TPM_HANDLE,

    /// The authorization value
    pub auth: Vec<u8>,

    /// The public parameters of the NV area
    pub public_Info: TPMS_NV_PUBLIC,
}

impl Default for TPM2_NV_DefineSpace_REQUEST {
    fn default() -> Self {
        Self {
            authHandle: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_NV_DefineSpace_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        auth_Handle: TPM_HANDLE,
        auth: Vec<u8>,
        public_Info: TPMS_NV_PUBLIC,
        ) -> Self {
        Self {
            auth_Handle,
            auth,
            public_Info,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command removes an Index from the TPM.
#[derive(Debug, Clone)]
pub struct TPM2_NV_UndefineSpace_REQUEST {
    /// TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
    /// Auth Index: 1
    /// Auth Role: USER
    pub auth_Handle: TPM_HANDLE,

    /// The NV Index to remove from NV space
    /// Auth Index: None
    pub nv_Index: TPM_HANDLE,
}

impl Default for TPM2_NV_UndefineSpace_REQUEST {
    fn default() -> Self {
        Self {
            authHandle: TPM_HANDLE::default(),
            nvIndex: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_NV_UndefineSpace_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        auth_Handle: TPM_HANDLE,
        nv_Index: TPM_HANDLE,
        ) -> Self {
        Self {
            auth_Handle,
            nv_Index,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command allows removal of a platform-created NV Index that has
/// TPMA_NV_POLICY_DELETE SET.
#[derive(Debug, Clone)]
pub struct TPM2_NV_UndefineSpaceSpecial_REQUEST {
    /// Index to be deleted
    /// Auth Index: 1
    /// Auth Role: ADMIN
    pub nv_Index: TPM_HANDLE,

    /// TPM_RH_PLATFORM + {PP}
    /// Auth Index: 2
    /// Auth Role: USER
    pub platform: TPM_HANDLE,
}

impl Default for TPM2_NV_UndefineSpaceSpecial_REQUEST {
    fn default() -> Self {
        Self {
            nvIndex: TPM_HANDLE::default(),
            platform: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_NV_UndefineSpaceSpecial_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        nv_Index: TPM_HANDLE,
        platform: TPM_HANDLE,
        ) -> Self {
        Self {
            nv_Index,
            platform,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command is used to read the public area and Name of an NV Index. The public area
/// of an Index is not privacy-sensitive and no authorization is required to read this data.
#[derive(Debug, Clone)]
pub struct TPM2_NV_ReadPublic_REQUEST {
    /// The NV Index
    /// Auth Index: None
    pub nv_Index: TPM_HANDLE,
}

impl Default for TPM2_NV_ReadPublic_REQUEST {
    fn default() -> Self {
        Self {
            nvIndex: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_NV_ReadPublic_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        nv_Index: TPM_HANDLE,
        ) -> Self {
        Self {
            nv_Index,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command is used to read the public area and Name of an NV Index. The public area
/// of an Index is not privacy-sensitive and no authorization is required to read this data.
#[derive(Debug, Clone)]
pub struct NV_ReadPublicResponse {
    /// The public area of the NV Index
    pub nv_Public: TPMS_NV_PUBLIC,

    /// The Name of the nvIndex
    pub nv_Name: Vec<u8>,
}

impl Default for NV_ReadPublicResponse {
    fn default() -> Self {
        Self {
        }
    }
}

impl NV_ReadPublicResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command writes a value to an area in NV memory that was previously defined by
/// TPM2_NV_DefineSpace().
#[derive(Debug, Clone)]
pub struct TPM2_NV_Write_REQUEST {
    /// Handle indicating the source of the authorization value
    /// Auth Index: 1
    /// Auth Role: USER
    pub auth_Handle: TPM_HANDLE,

    /// The NV Index of the area to write
    /// Auth Index: None
    pub nv_Index: TPM_HANDLE,

    /// The data to write
    pub data: Vec<u8>,

    /// The octet offset into the NV Area
    pub offset: u16,
}

impl Default for TPM2_NV_Write_REQUEST {
    fn default() -> Self {
        Self {
            authHandle: TPM_HANDLE::default(),
            nvIndex: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_NV_Write_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        auth_Handle: TPM_HANDLE,
        nv_Index: TPM_HANDLE,
        data: Vec<u8>,
        offset: u16,
        ) -> Self {
        Self {
            auth_Handle,
            nv_Index,
            data,
            offset,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command is used to increment the value in an NV Index that has the TPM_NT_COUNTER
/// attribute. The data value of the NV Index is incremented by one.
#[derive(Debug, Clone)]
pub struct TPM2_NV_Increment_REQUEST {
    /// Handle indicating the source of the authorization value
    /// Auth Index: 1
    /// Auth Role: USER
    pub auth_Handle: TPM_HANDLE,

    /// The NV Index to increment
    /// Auth Index: None
    pub nv_Index: TPM_HANDLE,
}

impl Default for TPM2_NV_Increment_REQUEST {
    fn default() -> Self {
        Self {
            authHandle: TPM_HANDLE::default(),
            nvIndex: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_NV_Increment_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        auth_Handle: TPM_HANDLE,
        nv_Index: TPM_HANDLE,
        ) -> Self {
        Self {
            auth_Handle,
            nv_Index,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command extends a value to an area in NV memory that was previously defined by
/// TPM2_NV_DefineSpace.
#[derive(Debug, Clone)]
pub struct TPM2_NV_Extend_REQUEST {
    /// Handle indicating the source of the authorization value
    /// Auth Index: 1
    /// Auth Role: USER
    pub auth_Handle: TPM_HANDLE,

    /// The NV Index to extend
    /// Auth Index: None
    pub nv_Index: TPM_HANDLE,

    /// The data to extend
    pub data: Vec<u8>,
}

impl Default for TPM2_NV_Extend_REQUEST {
    fn default() -> Self {
        Self {
            authHandle: TPM_HANDLE::default(),
            nvIndex: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_NV_Extend_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        auth_Handle: TPM_HANDLE,
        nv_Index: TPM_HANDLE,
        data: Vec<u8>,
        ) -> Self {
        Self {
            auth_Handle,
            nv_Index,
            data,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command is used to SET bits in an NV Index that was created as a bit field. Any
/// number of bits from 0 to 64 may be SET. The contents of bits are ORed with the current
/// contents of the NV Index.
#[derive(Debug, Clone)]
pub struct TPM2_NV_SetBits_REQUEST {
    /// Handle indicating the source of the authorization value
    /// Auth Index: 1
    /// Auth Role: USER
    pub auth_Handle: TPM_HANDLE,

    /// NV Index of the area in which the bit is to be set
    /// Auth Index: None
    pub nv_Index: TPM_HANDLE,

    /// The data to OR with the current contents
    pub bits: u64,
}

impl Default for TPM2_NV_SetBits_REQUEST {
    fn default() -> Self {
        Self {
            authHandle: TPM_HANDLE::default(),
            nvIndex: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_NV_SetBits_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        auth_Handle: TPM_HANDLE,
        nv_Index: TPM_HANDLE,
        bits: u64,
        ) -> Self {
        Self {
            auth_Handle,
            nv_Index,
            bits,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// If the TPMA_NV_WRITEDEFINE or TPMA_NV_WRITE_STCLEAR attributes of an NV location are
/// SET, then this command may be used to inhibit further writes of the NV Index.
#[derive(Debug, Clone)]
pub struct TPM2_NV_WriteLock_REQUEST {
    /// Handle indicating the source of the authorization value
    /// Auth Index: 1
    /// Auth Role: USER
    pub auth_Handle: TPM_HANDLE,

    /// The NV Index of the area to lock
    /// Auth Index: None
    pub nv_Index: TPM_HANDLE,
}

impl Default for TPM2_NV_WriteLock_REQUEST {
    fn default() -> Self {
        Self {
            authHandle: TPM_HANDLE::default(),
            nvIndex: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_NV_WriteLock_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        auth_Handle: TPM_HANDLE,
        nv_Index: TPM_HANDLE,
        ) -> Self {
        Self {
            auth_Handle,
            nv_Index,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// The command will SET TPMA_NV_WRITELOCKED for all indexes that have their
/// TPMA_NV_GLOBALLOCK attribute SET.
#[derive(Debug, Clone)]
pub struct TPM2_NV_GlobalWriteLock_REQUEST {
    /// TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
    /// Auth Index: 1
    /// Auth Role: USER
    pub auth_Handle: TPM_HANDLE,
}

impl Default for TPM2_NV_GlobalWriteLock_REQUEST {
    fn default() -> Self {
        Self {
            authHandle: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_NV_GlobalWriteLock_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        auth_Handle: TPM_HANDLE,
        ) -> Self {
        Self {
            auth_Handle,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command reads a value from an area in NV memory previously defined by TPM2_NV_DefineSpace().
#[derive(Debug, Clone)]
pub struct TPM2_NV_Read_REQUEST {
    /// The handle indicating the source of the authorization value
    /// Auth Index: 1
    /// Auth Role: USER
    pub auth_Handle: TPM_HANDLE,

    /// The NV Index to be read
    /// Auth Index: None
    pub nv_Index: TPM_HANDLE,

    /// Number of octets to read
    pub size: u16,

    /// Octet offset into the NV area
    /// This value shall be less than or equal to the size of the nvIndex data.
    pub offset: u16,
}

impl Default for TPM2_NV_Read_REQUEST {
    fn default() -> Self {
        Self {
            authHandle: TPM_HANDLE::default(),
            nvIndex: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_NV_Read_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        auth_Handle: TPM_HANDLE,
        nv_Index: TPM_HANDLE,
        size: u16,
        offset: u16,
        ) -> Self {
        Self {
            auth_Handle,
            nv_Index,
            size,
            offset,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command reads a value from an area in NV memory previously defined by TPM2_NV_DefineSpace().
#[derive(Debug, Clone)]
pub struct NV_ReadResponse {
    /// The data read
    pub data: Vec<u8>,
}

impl Default for NV_ReadResponse {
    fn default() -> Self {
        Self {
        }
    }
}

impl NV_ReadResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// If TPMA_NV_READ_STCLEAR is SET in an Index, then this command may be used to prevent
/// further reads of the NV Index until the next TPM2_Startup (TPM_SU_CLEAR).
#[derive(Debug, Clone)]
pub struct TPM2_NV_ReadLock_REQUEST {
    /// The handle indicating the source of the authorization value
    /// Auth Index: 1
    /// Auth Role: USER
    pub auth_Handle: TPM_HANDLE,

    /// The NV Index to be locked
    /// Auth Index: None
    pub nv_Index: TPM_HANDLE,
}

impl Default for TPM2_NV_ReadLock_REQUEST {
    fn default() -> Self {
        Self {
            authHandle: TPM_HANDLE::default(),
            nvIndex: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_NV_ReadLock_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        auth_Handle: TPM_HANDLE,
        nv_Index: TPM_HANDLE,
        ) -> Self {
        Self {
            auth_Handle,
            nv_Index,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command allows the authorization secret for an NV Index to be changed.
#[derive(Debug, Clone)]
pub struct TPM2_NV_ChangeAuth_REQUEST {
    /// Handle of the entity
    /// Auth Index: 1
    /// Auth Role: ADMIN
    pub nv_Index: TPM_HANDLE,

    /// New authorization value
    pub new_Auth: Vec<u8>,
}

impl Default for TPM2_NV_ChangeAuth_REQUEST {
    fn default() -> Self {
        Self {
            nvIndex: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_NV_ChangeAuth_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        nv_Index: TPM_HANDLE,
        new_Auth: Vec<u8>,
        ) -> Self {
        Self {
            nv_Index,
            new_Auth,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// The purpose of this command is to certify the contents of an NV Index or portion of an
/// NV Index.
#[derive(Debug, Clone)]
pub struct TPM2_NV_Certify_REQUEST {
    /// Handle of the key used to sign the attestation structure
    /// Auth Index: 1
    /// Auth Role: USER
    pub sign_Handle: TPM_HANDLE,

    /// Handle indicating the source of the authorization value for the NV Index
    /// Auth Index: 2
    /// Auth Role: USER
    pub auth_Handle: TPM_HANDLE,

    /// Index for the area to be certified
    /// Auth Index: None
    pub nv_Index: TPM_HANDLE,

    /// User-provided qualifying data
    pub qualifying_Data: Vec<u8>,

    /// Scheme selector

    /// Signing scheme to use if the scheme for signHandle is TPM_ALG_NULL
    /// One of: TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA,
    /// TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR,
    /// TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME.
    pub in_Scheme: TPMU_SIG_SCHEME,

    /// Number of octets to certify
    pub size: u16,

    /// Octet offset into the NV area
    /// This value shall be less than or equal to the size of the nvIndex data.
    pub offset: u16,
}

impl Default for TPM2_NV_Certify_REQUEST {
    fn default() -> Self {
        Self {
            signHandle: TPM_HANDLE::default(),
            authHandle: TPM_HANDLE::default(),
            nvIndex: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_NV_Certify_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        sign_Handle: TPM_HANDLE,
        auth_Handle: TPM_HANDLE,
        nv_Index: TPM_HANDLE,
        qualifying_Data: Vec<u8>,
        in_Scheme: TPMU_SIG_SCHEME,
        size: u16,
        offset: u16,
        ) -> Self {
        Self {
            sign_Handle,
            auth_Handle,
            nv_Index,
            qualifying_Data,
            in_Scheme,
            size,
            offset,
        }
    }

    /// Get the inSchemeScheme selector value
    pub fn in_Scheme_Scheme(&self) -> TPM_ALG_ID {
        match &self.in_Scheme {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// The purpose of this command is to certify the contents of an NV Index or portion of an
/// NV Index.
#[derive(Debug, Clone)]
pub struct NV_CertifyResponse {
    /// The structure that was signed
    pub certify_Info: TPMS_ATTEST,

    /// Selector of the algorithm used to construct the signature

    /// The asymmetric signature over certifyInfo using the key referenced by signHandle
    /// One of: TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA,
    /// TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TPMT_HA,
    /// TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE.
    pub signature: TPMU_SIGNATURE,
}

impl Default for NV_CertifyResponse {
    fn default() -> Self {
        Self {
        }
    }
}

impl NV_CertifyResponse {
    /// Get the signatureSigAlg selector value
    pub fn signature_Sig_Alg(&self) -> TPM_ALG_ID {
        match &self.signature {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// The purpose of this command is to obtain information about an Attached Component
/// referenced by an AC handle.
#[derive(Debug, Clone)]
pub struct TPM2_AC_GetCapability_REQUEST {
    /// Handle indicating the Attached Component
    /// Auth Index: None
    pub ac: TPM_HANDLE,

    /// Starting info type
    pub capability: TPM_AT,

    /// Maximum number of values to return
    pub count: u32,
}

impl Default for TPM2_AC_GetCapability_REQUEST {
    fn default() -> Self {
        Self {
            ac: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_AC_GetCapability_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        ac: TPM_HANDLE,
        capability: TPM_AT,
        count: u32,
        ) -> Self {
        Self {
            ac,
            capability,
            count,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// The purpose of this command is to obtain information about an Attached Component
/// referenced by an AC handle.
#[derive(Debug, Clone)]
pub struct AC_GetCapabilityResponse {
    /// Flag to indicate whether there are more values
    pub more_Data: u8,

    /// List of capabilities
    pub capabilities_Data: Vec<TPMS_AC_OUTPUT>,
}

impl Default for AC_GetCapabilityResponse {
    fn default() -> Self {
        Self {
        }
    }
}

impl AC_GetCapabilityResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// The purpose of this command is to send (copy) a loaded object from the TPM to an
/// Attached Component.
#[derive(Debug, Clone)]
pub struct TPM2_AC_Send_REQUEST {
    /// Handle of the object being sent to ac
    /// Auth Index: 1
    /// Auth Role: DUP
    pub send_Object: TPM_HANDLE,

    /// The handle indicating the source of the authorization value
    /// Auth Index: 2
    /// Auth Role: USER
    pub auth_Handle: TPM_HANDLE,

    /// Handle indicating the Attached Component to which the object will be sent
    /// Auth Index: None
    pub ac: TPM_HANDLE,

    /// Optional non sensitive information related to the object
    pub ac_Data_In: Vec<u8>,
}

impl Default for TPM2_AC_Send_REQUEST {
    fn default() -> Self {
        Self {
            sendObject: TPM_HANDLE::default(),
            authHandle: TPM_HANDLE::default(),
            ac: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_AC_Send_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        send_Object: TPM_HANDLE,
        auth_Handle: TPM_HANDLE,
        ac: TPM_HANDLE,
        ac_Data_In: Vec<u8>,
        ) -> Self {
        Self {
            send_Object,
            auth_Handle,
            ac,
            ac_Data_In,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// The purpose of this command is to send (copy) a loaded object from the TPM to an
/// Attached Component.
#[derive(Debug, Clone)]
pub struct AC_SendResponse {
    /// May include AC specific data or information about an error.
    pub ac_Data_Out: TPMS_AC_OUTPUT,
}

impl Default for AC_SendResponse {
    fn default() -> Self {
        Self {
        }
    }
}

impl AC_SendResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command allows qualification of the sending (copying) of an Object to an Attached
/// Component (AC). Qualification includes selection of the receiving AC and the method of
/// authentication for the AC, and, in certain circumstances, the Object to be sent may be
/// specified.
#[derive(Debug, Clone)]
pub struct TPM2_Policy_AC_SendSelect_REQUEST {
    /// Handle for the policy session being extended
    /// Auth Index: None
    pub policy_Session: TPM_HANDLE,

    /// The Name of the Object to be sent
    pub object_Name: Vec<u8>,

    /// The Name associated with authHandle used in the TPM2_AC_Send() command
    pub auth_Handle_Name: Vec<u8>,

    /// The Name of the Attached Component to which the Object will be sent
    pub ac_Name: Vec<u8>,

    /// If SET, objectName will be included in the value in policySessionpolicyDigest
    pub include_Object: u8,
}

impl Default for TPM2_Policy_AC_SendSelect_REQUEST {
    fn default() -> Self {
        Self {
            policySession: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_Policy_AC_SendSelect_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        policy_Session: TPM_HANDLE,
        object_Name: Vec<u8>,
        auth_Handle_Name: Vec<u8>,
        ac_Name: Vec<u8>,
        include_Object: u8,
        ) -> Self {
        Self {
            policy_Session,
            object_Name,
            auth_Handle_Name,
            ac_Name,
            include_Object,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This command is used to set the time remaining before an Authenticated Countdown Timer
/// (ACT) expires.
#[derive(Debug, Clone)]
pub struct TPM2_ACT_SetTimeout_REQUEST {
    /// Handle of the selected ACT
    /// Auth Index: 1
    /// Auth Role: USER
    pub act_Handle: TPM_HANDLE,

    /// The start timeout value for the ACT in seconds
    pub start_Timeout: u32,
}

impl Default for TPM2_ACT_SetTimeout_REQUEST {
    fn default() -> Self {
        Self {
            actHandle: TPM_HANDLE::default(),
        }
    }
}

impl TPM2_ACT_SetTimeout_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        act_Handle: TPM_HANDLE,
        start_Timeout: u32,
        ) -> Self {
        Self {
            act_Handle,
            start_Timeout,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This is a placeholder to allow testing of the dispatch code.
#[derive(Debug, Clone)]
pub struct TPM2_Vendor_TCG_Test_REQUEST {
    /// Dummy data
    pub input_Data: Vec<u8>,
}

impl Default for TPM2_Vendor_TCG_Test_REQUEST {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPM2_Vendor_TCG_Test_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        input_Data: Vec<u8>,
        ) -> Self {
        Self {
            input_Data,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// This is a placeholder to allow testing of the dispatch code.
#[derive(Debug, Clone)]
pub struct Vendor_TCG_TestResponse {
    /// Dummy data
    pub output_Data: Vec<u8>,
}

impl Default for Vendor_TCG_TestResponse {
    fn default() -> Self {
        Self {
        }
    }
}

impl Vendor_TCG_TestResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// These are the RSA schemes that only need a hash algorithm as a scheme parameter.
pub type TPMS_SCHEME_RSASSA = TPMS_SIG_SCHEME_RSASSA;

/// These are the RSA schemes that only need a hash algorithm as a scheme parameter.
pub type TPMS_SCHEME_RSAPSS = TPMS_SIG_SCHEME_RSAPSS;

/// Most of the ECC signature schemes only require a hash algorithm to complete the
/// definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a
/// count value so they are typed to be TPMS_SCHEME_ECDAA.
pub type TPMS_SCHEME_ECDSA = TPMS_SIG_SCHEME_ECDSA;

/// Most of the ECC signature schemes only require a hash algorithm to complete the
/// definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a
/// count value so they are typed to be TPMS_SCHEME_ECDAA.
pub type TPMS_SCHEME_SM2 = TPMS_SIG_SCHEME_SM2;

/// Most of the ECC signature schemes only require a hash algorithm to complete the
/// definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a
/// count value so they are typed to be TPMS_SCHEME_ECDAA.
pub type TPMS_SCHEME_ECSCHNORR = TPMS_SIG_SCHEME_ECSCHNORR;

/// These are the RSA encryption schemes that only need a hash algorithm as a controlling parameter.
pub type TPMS_SCHEME_OAEP = TPMS_ENC_SCHEME_OAEP;

/// These are the RSA encryption schemes that only need a hash algorithm as a controlling parameter.
pub type TPMS_SCHEME_RSAES = TPMS_ENC_SCHEME_RSAES;

/// These are the ECC schemes that only need a hash algorithm as a controlling parameter.
pub type TPMS_SCHEME_ECDH = TPMS_KEY_SCHEME_ECDH;

/// These are the ECC schemes that only need a hash algorithm as a controlling parameter.
pub type TPMS_SCHEME_ECMQV = TPMS_KEY_SCHEME_ECMQV;

/// These structures are used to define the key derivation for symmetric secret sharing
/// using asymmetric methods. A secret sharing scheme is required in any asymmetric key
/// with the decrypt attribute SET.
pub type TPMS_SCHEME_MGF1 = TPMS_KDF_SCHEME_MGF1;

/// These structures are used to define the key derivation for symmetric secret sharing
/// using asymmetric methods. A secret sharing scheme is required in any asymmetric key
/// with the decrypt attribute SET.
pub type TPMS_SCHEME_KDF1_SP800_56A = TPMS_KDF_SCHEME_KDF1_SP800_56A;

/// These structures are used to define the key derivation for symmetric secret sharing
/// using asymmetric methods. A secret sharing scheme is required in any asymmetric key
/// with the decrypt attribute SET.
pub type TPMS_SCHEME_KDF2 = TPMS_KDF_SCHEME_KDF2;

/// These structures are used to define the key derivation for symmetric secret sharing
/// using asymmetric methods. A secret sharing scheme is required in any asymmetric key
/// with the decrypt attribute SET.
pub type TPMS_SCHEME_KDF1_SP800_108 = TPMS_KDF_SCHEME_KDF1_SP800_108;

/// Contains the public and the plaintext-sensitive and/or encrypted private part of a TPM
/// key (or other object)
#[derive(Debug, Clone)]
pub struct TssObject {
    /// Public part of key
    pub Public: TPMT_PUBLIC,

    /// Sensitive part of key
    pub Sensitive: TPMT_SENSITIVE,

    /// Private part is the encrypted sensitive part of key
    pub Private: TPM2B_PRIVATE,
}

impl Default for TssObject {
    fn default() -> Self {
        Self {
        }
    }
}

impl TssObject {
    /// Creates a new instance with the specified values
    pub fn new(
        Public: TPMT_PUBLIC,
        Sensitive: TPMT_SENSITIVE,
        Private: TPM2B_PRIVATE,
        ) -> Self {
        Self {
            Public,
            Sensitive,
            Private,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// Contains a PCR index and associated hash(pcr-value) [TSS]
#[derive(Debug, Clone)]
pub struct PcrValue {
    /// PCR Index
    pub index: u32,

    /// PCR Value
    pub value: TPMT_HA,
}

impl Default for PcrValue {
    fn default() -> Self {
        Self {
        }
    }
}

impl PcrValue {
    /// Creates a new instance with the specified values
    pub fn new(
        index: u32,
        value: TPMT_HA,
        ) -> Self {
        Self {
            index,
            value,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// Structure representing a session block in a command buffer [TSS]
#[derive(Debug, Clone)]
pub struct SessionIn {
    /// Session handle
    pub handle: TPM_HANDLE,

    /// Caller nonce
    pub nonce_Caller: Vec<u8>,

    /// Session attributes
    pub attributes: TPMA_SESSION,

    /// AuthValue (or HMAC)
    pub auth: Vec<u8>,
}

impl Default for SessionIn {
    fn default() -> Self {
        Self {
            handle: TPM_HANDLE::default(),
        }
    }
}

impl SessionIn {
    /// Creates a new instance with the specified values
    pub fn new(
        handle: TPM_HANDLE,
        nonce_Caller: Vec<u8>,
        attributes: TPMA_SESSION,
        auth: Vec<u8>,
        ) -> Self {
        Self {
            handle,
            nonce_Caller,
            attributes,
            auth,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// Structure representing a session block in a response buffer [TSS]
#[derive(Debug, Clone)]
pub struct SessionOut {
    /// TPM nonce
    pub nonce_Tpm: Vec<u8>,

    /// Session attributes
    pub attributes: TPMA_SESSION,

    /// HMAC value
    pub auth: Vec<u8>,
}

impl Default for SessionOut {
    fn default() -> Self {
        Self {
        }
    }
}

impl SessionOut {
    /// Creates a new instance with the specified values
    pub fn new(
        nonce_Tpm: Vec<u8>,
        attributes: TPMA_SESSION,
        auth: Vec<u8>,
        ) -> Self {
        Self {
            nonce_Tpm,
            attributes,
            auth,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// Command header [TSS]
#[derive(Debug, Clone)]
pub struct CommandHeader {
    /// Command tag (sessions, or no sessions)
    pub Tag: TPM_ST,

    /// Total command buffer length
    pub Command_Size: u32,

    /// Command code
    pub Command_Code: TPM_CC,
}

impl Default for CommandHeader {
    fn default() -> Self {
        Self {
        }
    }
}

impl CommandHeader {
    /// Creates a new instance with the specified values
    pub fn new(
        Tag: TPM_ST,
        Command_Size: u32,
        Command_Code: TPM_CC,
        ) -> Self {
        Self {
            Tag,
            Command_Size,
            Command_Code,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// Contains the public and private part of a TPM key
#[derive(Debug, Clone)]
pub struct TSS_KEY {
    /// Public part of key
    pub public_Part: TPMT_PUBLIC,

    /// Private part is the encrypted sensitive part of key
    pub private_Part: Vec<u8>,
}

impl Default for TSS_KEY {
    fn default() -> Self {
        Self {
        }
    }
}

impl TSS_KEY {
    /// Creates a new instance with the specified values
    pub fn new(
        public_Part: TPMT_PUBLIC,
        private_Part: Vec<u8>,
        ) -> Self {
        Self {
            public_Part,
            private_Part,
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// Auto-derived from TPM2B_DIGEST to provide unique GetUnionSelector() implementation
#[derive(Debug, Clone)]
pub struct TPM2B_DIGEST_SYMCIPHER {
}

impl Default for TPM2B_DIGEST_SYMCIPHER {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPM2B_DIGEST_SYMCIPHER {
    // Union trait implementations
    impl TpmUnion for TPM2B_DIGEST_SYMCIPHER {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
            TPMU_PUBLIC_ID::SYMCIPHER as u32
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

/// Auto-derived from TPM2B_DIGEST
#[derive(Debug, Clone)]
pub struct TPM2B_DIGEST_KEYEDHASH {
}

impl Default for TPM2B_DIGEST_KEYEDHASH {
    fn default() -> Self {
        Self {
        }
    }
}

impl TPM2B_DIGEST_KEYEDHASH {
    // Union trait implementations
    impl TpmUnion for TPM2B_DIGEST_KEYEDHASH {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
            TPMU_PUBLIC_ID::KEYEDHASH as u32
        }
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
        // Implement deserialization
        Ok(Self::default())
    }
}

