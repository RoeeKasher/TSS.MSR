/*
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See the LICENSE file in the project root for full license information.
 */

/*
 * NOTE: this file is partially auto generated!
 *
 * All code after the point marked with the '// <<AUTOGEN_BEGIN>>' comment
 * is autogenerated from the TPM 2.0 Specification docs.
 *
 * DO NOT EDIT AUTOGENERATED PART - all manual changes will be lost!
 */

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        // <<AUTOGEN_BEGIN>>
// ------------------------------------------------------------------------------------------------
// DO NOT REMOVE the <<AUTOGEN_BEGIN>> comment!
// DO NOT MODIFY any code below this point - all manual changes will be lost!
// ------------------------------------------------------------------------------------------------

//! TPM type definitions

use crate::error::TpmError;
use crate::tpm_buffer::TpmBuffer;
use std::convert::{TryFrom, TryInto};
use std::fmt;

/// Table 2 is the list of algorithms to which the TCG has assigned an algorithm
/// identifier along with its numeric identifier.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u16)]
pub enum TPM_ALG_ID {
    /// Should not occur
    ERROR = 0x0000,

    /// An object type that contains an RSA key
    FIRST = 0x0001,

    /// An object type that contains an RSA key
    RSA = 0x0001,

    /// Block cipher with various key sizes (Triple Data Encryption Algorithm, commonly called
    /// Triple Data Encryption Standard)
    TDES = 0x0003,

    /// Hash algorithm producing a 160-bit digest
    SHA = 0x0004,

    /// Redefinition for documentation consistency
    SHA1 = 0x0004,

    /// Hash Message Authentication Code (HMAC) algorithm
    HMAC = 0x0005,

    /// Block cipher with various key sizes
    AES = 0x0006,

    /// Hash-based mask-generation function
    MGF1 = 0x0007,

    /// An object type that may use XOR for encryption or an HMAC for signing and may also
    /// refer to a data object that is neither signing nor encrypting
    KEYEDHASH = 0x0008,

    /// Hash-based stream cipher
    XOR = 0x000A,

    /// Hash algorithm producing a 256-bit digest
    SHA256 = 0x000B,

    /// Hash algorithm producing a 384-bit digest
    SHA384 = 0x000C,

    /// Hash algorithm producing a 512-bit digest
    SHA512 = 0x000D,

    /// Indication that no algorithm is selected
    NULL = 0x0010,

    /// Hash algorithm producing a 256-bit digest
    Sm3256 = 0x0012,

    /// Symmetric block cipher with 128 bit key
    SM4 = 0x0013,

    /// A signature algorithm defined in section 8.2 (RSASSA-PKCS1-v1_5)
    RSASSA = 0x0014,

    /// A padding algorithm defined in section 7.2 (RSAES-PKCS1-v1_5)
    RSAES = 0x0015,

    /// A signature algorithm defined in section 8.1 (RSASSA-PSS)
    RSAPSS = 0x0016,

    /// A padding algorithm defined in Section 7.1 (RSAES_OAEP)
    OAEP = 0x0017,

    /// Signature algorithm using elliptic curve cryptography (ECC)
    ECDSA = 0x0018,

    /// Secret sharing using ECC Based on context, this can be either One-Pass Diffie-Hellman,
    /// C(1, 1, ECC CDH) defined in 6.2.2.2 or Full Unified Model C(2, 2, ECC CDH) defined in 6.1.1.2
    ECDH = 0x0019,

    /// Elliptic-curve based, anonymous signing scheme
    ECDAA = 0x001A,

    /// Depending on context, either an elliptic-curve-based signature algorithm, encryption
    /// algorithm, or key exchange protocol
    SM2 = 0x001B,

    /// Elliptic-curve based Schnorr signature
    ECSCHNORR = 0x001C,

    /// Two-phase elliptic-curve key exchange C(2, 2, ECC MQV) Section 6.1.1.4
    ECMQV = 0x001D,

    /// Concatenation key derivation function (approved alternative 1) Section 5.8.1
    Kdf1Sp80056a = 0x0020,

    /// Key derivation function KDF2 Section 13.2
    KDF2 = 0x0021,

    /// A key derivation method SP800-108, Section 5.1 KDF in Counter Mode
    Kdf1Sp800108 = 0x0022,

    /// Prime field ECC
    ECC = 0x0023,

    /// The object type for a symmetric block cipher key
    SYMCIPHER = 0x0025,

    /// Symmetric block cipher with various key sizes
    CAMELLIA = 0x0026,

    /// Hash algorithm producing a 256-bit digest
    Sha3256 = 0x0027,

    /// Hash algorithm producing a 384-bit digest
    Sha3384 = 0x0028,

    /// Hash algorithm producing a 512-bit digest
    Sha3512 = 0x0029,
    CMAC = 0x003F,

    /// Counter mode if implemented, all symmetric block ciphers (S type) implemented shall be
    /// capable of using this mode.
    CTR = 0x0040,

    /// Output Feedback mode if implemented, all symmetric block ciphers (S type) implemented
    /// shall be capable of using this mode.
    OFB = 0x0041,

    /// Cipher Block Chaining mode if implemented, all symmetric block ciphers (S type)
    /// implemented shall be capable of using this mode.
    CBC = 0x0042,

    /// Cipher Feedback mode if implemented, all symmetric block ciphers (S type) implemented
    /// shall be capable of using this mode.
    CFB = 0x0043,

    /// Electronic Codebook mode if implemented, all implemented symmetric block ciphers (S
    /// type) shall be capable of using this mode.
    /// NOTE This mode is not recommended for uses unless the key is frequently rotated such
    /// as in video codecs
    ECB = 0x0044,
    LAST = 0x0044,

    /// Phony alg ID to be used for the first union member with no selector
    ANY = 0x7FFF,

    /// Phony alg ID to be used for the second union member with no selector
    ANY2 = 0x7FFE
}

impl TryFrom<u16> for TPM_ALG_ID {
    type Error = TpmError;

    fn try_from(value: u16) -> Result<Self, Self::Error> {
        match value {
            0x0000 => Ok(Self::ERROR),
            0x0001 => Ok(Self::FIRST),
            0x0001 => Ok(Self::RSA),
            0x0003 => Ok(Self::TDES),
            0x0004 => Ok(Self::SHA),
            0x0004 => Ok(Self::SHA1),
            0x0005 => Ok(Self::HMAC),
            0x0006 => Ok(Self::AES),
            0x0007 => Ok(Self::MGF1),
            0x0008 => Ok(Self::KEYEDHASH),
            0x000A => Ok(Self::XOR),
            0x000B => Ok(Self::SHA256),
            0x000C => Ok(Self::SHA384),
            0x000D => Ok(Self::SHA512),
            0x0010 => Ok(Self::NULL),
            0x0012 => Ok(Self::Sm3256),
            0x0013 => Ok(Self::SM4),
            0x0014 => Ok(Self::RSASSA),
            0x0015 => Ok(Self::RSAES),
            0x0016 => Ok(Self::RSAPSS),
            0x0017 => Ok(Self::OAEP),
            0x0018 => Ok(Self::ECDSA),
            0x0019 => Ok(Self::ECDH),
            0x001A => Ok(Self::ECDAA),
            0x001B => Ok(Self::SM2),
            0x001C => Ok(Self::ECSCHNORR),
            0x001D => Ok(Self::ECMQV),
            0x0020 => Ok(Self::Kdf1Sp80056a),
            0x0021 => Ok(Self::KDF2),
            0x0022 => Ok(Self::Kdf1Sp800108),
            0x0023 => Ok(Self::ECC),
            0x0025 => Ok(Self::SYMCIPHER),
            0x0026 => Ok(Self::CAMELLIA),
            0x0027 => Ok(Self::Sha3256),
            0x0028 => Ok(Self::Sha3384),
            0x0029 => Ok(Self::Sha3512),
            0x003F => Ok(Self::CMAC),
            0x0040 => Ok(Self::CTR),
            0x0041 => Ok(Self::OFB),
            0x0042 => Ok(Self::CBC),
            0x0043 => Ok(Self::CFB),
            0x0044 => Ok(Self::ECB),
            0x0044 => Ok(Self::LAST),
            0x7FFF => Ok(Self::ANY),
            0x7FFE => Ok(Self::ANY2),
            _ => Err(TpmError::InvalidEnumValue),
        }

    }

}

impl fmt::Display for TPM_ALG_ID {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::ERROR => write!(f, "ERROR"),
            Self::FIRST => write!(f, "FIRST"),
            Self::RSA => write!(f, "RSA"),
            Self::TDES => write!(f, "TDES"),
            Self::SHA => write!(f, "SHA"),
            Self::SHA1 => write!(f, "SHA1"),
            Self::HMAC => write!(f, "HMAC"),
            Self::AES => write!(f, "AES"),
            Self::MGF1 => write!(f, "MGF1"),
            Self::KEYEDHASH => write!(f, "KEYEDHASH"),
            Self::XOR => write!(f, "XOR"),
            Self::SHA256 => write!(f, "SHA256"),
            Self::SHA384 => write!(f, "SHA384"),
            Self::SHA512 => write!(f, "SHA512"),
            Self::NULL => write!(f, "NULL"),
            Self::Sm3256 => write!(f, "Sm3256"),
            Self::SM4 => write!(f, "SM4"),
            Self::RSASSA => write!(f, "RSASSA"),
            Self::RSAES => write!(f, "RSAES"),
            Self::RSAPSS => write!(f, "RSAPSS"),
            Self::OAEP => write!(f, "OAEP"),
            Self::ECDSA => write!(f, "ECDSA"),
            Self::ECDH => write!(f, "ECDH"),
            Self::ECDAA => write!(f, "ECDAA"),
            Self::SM2 => write!(f, "SM2"),
            Self::ECSCHNORR => write!(f, "ECSCHNORR"),
            Self::ECMQV => write!(f, "ECMQV"),
            Self::Kdf1Sp80056a => write!(f, "Kdf1Sp80056a"),
            Self::KDF2 => write!(f, "KDF2"),
            Self::Kdf1Sp800108 => write!(f, "Kdf1Sp800108"),
            Self::ECC => write!(f, "ECC"),
            Self::SYMCIPHER => write!(f, "SYMCIPHER"),
            Self::CAMELLIA => write!(f, "CAMELLIA"),
            Self::Sha3256 => write!(f, "Sha3256"),
            Self::Sha3384 => write!(f, "Sha3384"),
            Self::Sha3512 => write!(f, "Sha3512"),
            Self::CMAC => write!(f, "CMAC"),
            Self::CTR => write!(f, "CTR"),
            Self::OFB => write!(f, "OFB"),
            Self::CBC => write!(f, "CBC"),
            Self::CFB => write!(f, "CFB"),
            Self::ECB => write!(f, "ECB"),
            Self::LAST => write!(f, "LAST"),
            Self::ANY => write!(f, "ANY"),
            Self::ANY2 => write!(f, "ANY2"),
        }

    }

}

/// Table 4 is the list of identifiers for TCG-registered curve ID values for elliptic
/// curve cryptography.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u16)]
pub enum TPM_ECC_CURVE {
    NONE = 0x0000,
    NistP192 = 0x0001,
    NistP224 = 0x0002,
    NistP256 = 0x0003,
    NistP384 = 0x0004,
    NistP521 = 0x0005,

    /// Curve to support ECDAA
    BnP256 = 0x0010,

    /// Curve to support ECDAA
    BnP638 = 0x0011,
    Sm2P256 = 0x0020,
    TestP192 = 0x0021
}

impl TryFrom<u16> for TPM_ECC_CURVE {
    type Error = TpmError;

    fn try_from(value: u16) -> Result<Self, Self::Error> {
        match value {
            0x0000 => Ok(Self::NONE),
            0x0001 => Ok(Self::NistP192),
            0x0002 => Ok(Self::NistP224),
            0x0003 => Ok(Self::NistP256),
            0x0004 => Ok(Self::NistP384),
            0x0005 => Ok(Self::NistP521),
            0x0010 => Ok(Self::BnP256),
            0x0011 => Ok(Self::BnP638),
            0x0020 => Ok(Self::Sm2P256),
            0x0021 => Ok(Self::TestP192),
            _ => Err(TpmError::InvalidEnumValue),
        }

    }

}

impl fmt::Display for TPM_ECC_CURVE {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::NONE => write!(f, "NONE"),
            Self::NistP192 => write!(f, "NistP192"),
            Self::NistP224 => write!(f, "NistP224"),
            Self::NistP256 => write!(f, "NistP256"),
            Self::NistP384 => write!(f, "NistP384"),
            Self::NistP521 => write!(f, "NistP521"),
            Self::BnP256 => write!(f, "BnP256"),
            Self::BnP638 => write!(f, "BnP638"),
            Self::Sm2P256 => write!(f, "Sm2P256"),
            Self::TestP192 => write!(f, "TestP192"),
        }

    }

}

/// Table 13 Defines for SHA1 Hash Values
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u32)]
pub enum SHA1 {
    /// Size of digest in octets
    DigestSize = 20,

    /// Size of hash block in octets
    BlockSize = 64
}

impl TryFrom<u32> for SHA1 {
    type Error = TpmError;

    fn try_from(value: u32) -> Result<Self, Self::Error> {
        match value {
            20 => Ok(Self::DigestSize),
            64 => Ok(Self::BlockSize),
            _ => Err(TpmError::InvalidEnumValue),
        }

    }

}

impl fmt::Display for SHA1 {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::DigestSize => write!(f, "DigestSize"),
            Self::BlockSize => write!(f, "BlockSize"),
        }

    }

}

/// Table 14 Defines for SHA256 Hash Values
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u32)]
pub enum SHA256 {
    /// Size of digest
    DigestSize = 32,

    /// Size of hash block
    BlockSize = 64
}

impl TryFrom<u32> for SHA256 {
    type Error = TpmError;

    fn try_from(value: u32) -> Result<Self, Self::Error> {
        match value {
            32 => Ok(Self::DigestSize),
            64 => Ok(Self::BlockSize),
            _ => Err(TpmError::InvalidEnumValue),
        }

    }

}

impl fmt::Display for SHA256 {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::DigestSize => write!(f, "DigestSize"),
            Self::BlockSize => write!(f, "BlockSize"),
        }

    }

}

/// Table 15 Defines for SHA384 Hash Values
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u32)]
pub enum SHA384 {
    /// Size of digest in octets
    DigestSize = 48,

    /// Size of hash block in octets
    BlockSize = 128
}

impl TryFrom<u32> for SHA384 {
    type Error = TpmError;

    fn try_from(value: u32) -> Result<Self, Self::Error> {
        match value {
            48 => Ok(Self::DigestSize),
            128 => Ok(Self::BlockSize),
            _ => Err(TpmError::InvalidEnumValue),
        }

    }

}

impl fmt::Display for SHA384 {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::DigestSize => write!(f, "DigestSize"),
            Self::BlockSize => write!(f, "BlockSize"),
        }

    }

}

/// Table 16 Defines for SHA512 Hash Values
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u32)]
pub enum SHA512 {
    /// Size of digest in octets
    DigestSize = 64,

    /// Size of hash block in octets
    BlockSize = 128
}

impl TryFrom<u32> for SHA512 {
    type Error = TpmError;

    fn try_from(value: u32) -> Result<Self, Self::Error> {
        match value {
            64 => Ok(Self::DigestSize),
            128 => Ok(Self::BlockSize),
            _ => Err(TpmError::InvalidEnumValue),
        }

    }

}

impl fmt::Display for SHA512 {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::DigestSize => write!(f, "DigestSize"),
            Self::BlockSize => write!(f, "BlockSize"),
        }

    }

}

/// Table 17 Defines for SM3_256 Hash Values
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u32)]
pub enum SM3_256 {
    /// Size of digest in octets
    DigestSize = 32,

    /// Size of hash block in octets
    BlockSize = 64
}

impl TryFrom<u32> for SM3_256 {
    type Error = TpmError;

    fn try_from(value: u32) -> Result<Self, Self::Error> {
        match value {
            32 => Ok(Self::DigestSize),
            64 => Ok(Self::BlockSize),
            _ => Err(TpmError::InvalidEnumValue),
        }

    }

}

impl fmt::Display for SM3_256 {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::DigestSize => write!(f, "DigestSize"),
            Self::BlockSize => write!(f, "BlockSize"),
        }

    }

}

/// Table 18 Defines for SHA3_256 Hash Values
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u32)]
pub enum SHA3_256 {
    /// Size of digest in octets
    DigestSize = 32,

    /// Size of hash block in octets
    BlockSize = 136
}

impl TryFrom<u32> for SHA3_256 {
    type Error = TpmError;

    fn try_from(value: u32) -> Result<Self, Self::Error> {
        match value {
            32 => Ok(Self::DigestSize),
            136 => Ok(Self::BlockSize),
            _ => Err(TpmError::InvalidEnumValue),
        }

    }

}

impl fmt::Display for SHA3_256 {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::DigestSize => write!(f, "DigestSize"),
            Self::BlockSize => write!(f, "BlockSize"),
        }

    }

}

/// Table 19 Defines for SHA3_384 Hash Values
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u32)]
pub enum SHA3_384 {
    /// Size of digest in octets
    DigestSize = 48,

    /// Size of hash block in octets
    BlockSize = 104
}

impl TryFrom<u32> for SHA3_384 {
    type Error = TpmError;

    fn try_from(value: u32) -> Result<Self, Self::Error> {
        match value {
            48 => Ok(Self::DigestSize),
            104 => Ok(Self::BlockSize),
            _ => Err(TpmError::InvalidEnumValue),
        }

    }

}

impl fmt::Display for SHA3_384 {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::DigestSize => write!(f, "DigestSize"),
            Self::BlockSize => write!(f, "BlockSize"),
        }

    }

}

/// Table 20 Defines for SHA3_512 Hash Values
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u32)]
pub enum SHA3_512 {
    /// Size of digest in octets
    DigestSize = 64,

    /// Size of hash block in octets
    BlockSize = 72
}

impl TryFrom<u32> for SHA3_512 {
    type Error = TpmError;

    fn try_from(value: u32) -> Result<Self, Self::Error> {
        match value {
            64 => Ok(Self::DigestSize),
            72 => Ok(Self::BlockSize),
            _ => Err(TpmError::InvalidEnumValue),
        }

    }

}

impl fmt::Display for SHA3_512 {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::DigestSize => write!(f, "DigestSize"),
            Self::BlockSize => write!(f, "BlockSize"),
        }

    }

}

/// Table 4 Defines for Logic Values
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum Logic {
    TRUE = 1,
    FALSE = 0,
    YES = 1,
    NO = 0,
    SET = 1,
    CLEAR = 0
}

impl TryFrom<u8> for Logic {
    type Error = TpmError;

    fn try_from(value: u8) -> Result<Self, Self::Error> {
        match value {
            1 => Ok(Self::TRUE),
            0 => Ok(Self::FALSE),
            1 => Ok(Self::YES),
            0 => Ok(Self::NO),
            1 => Ok(Self::SET),
            0 => Ok(Self::CLEAR),
            _ => Err(TpmError::InvalidEnumValue),
        }

    }

}

impl fmt::Display for Logic {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::TRUE => write!(f, "TRUE"),
            Self::FALSE => write!(f, "FALSE"),
            Self::YES => write!(f, "YES"),
            Self::NO => write!(f, "NO"),
            Self::SET => write!(f, "SET"),
            Self::CLEAR => write!(f, "CLEAR"),
        }

    }

}

/// These values are readable with TPM2_GetCapability() (see 6.13 for the format).
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u32)]
pub enum TPM_SPEC {
    /// ASCII 2.0 with null terminator
    FAMILY = 0x322E3000,

    /// The level number for the specification
    LEVEL = 0,

    /// The version number of the spec (001.62 * 100)
    VERSION = 162,

    /// The year of the version
    YEAR = 2019,

    /// The day of the year (December 26)
    DayOfYear = 360
}

impl TryFrom<u32> for TPM_SPEC {
    type Error = TpmError;

    fn try_from(value: u32) -> Result<Self, Self::Error> {
        match value {
            0x322E3000 => Ok(Self::FAMILY),
            0 => Ok(Self::LEVEL),
            162 => Ok(Self::VERSION),
            2019 => Ok(Self::YEAR),
            360 => Ok(Self::DayOfYear),
            _ => Err(TpmError::InvalidEnumValue),
        }

    }

}

impl fmt::Display for TPM_SPEC {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::FAMILY => write!(f, "FAMILY"),
            Self::LEVEL => write!(f, "LEVEL"),
            Self::VERSION => write!(f, "VERSION"),
            Self::YEAR => write!(f, "YEAR"),
            Self::DayOfYear => write!(f, "DayOfYear"),
        }

    }

}

/// This constant value differentiates TPM-generated structures from non-TPM structures.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u32)]
pub enum TPM_GENERATED {
    /// 0xFF TCG (FF 54 43 4716)
    VALUE = 0xff544347
}

impl TryFrom<u32> for TPM_GENERATED {
    type Error = TpmError;

    fn try_from(value: u32) -> Result<Self, Self::Error> {
        match value {
            0xff544347 => Ok(Self::VALUE),
            _ => Err(TpmError::InvalidEnumValue),
        }

    }

}

impl fmt::Display for TPM_GENERATED {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::VALUE => write!(f, "VALUE"),
        }

    }

}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u32)]
pub enum TPM_CC {
    /// Compile variable. May decrease based on implementation.
    FIRST = 0x0000011F,
    NvUndefinespacespecial = 0x0000011F,
    EvictControl = 0x00000120,
    HierarchyControl = 0x00000121,
    NvUndefinespace = 0x00000122,
    ChangeEPS = 0x00000124,
    ChangePPS = 0x00000125,
    Clear = 0x00000126,
    ClearControl = 0x00000127,
    ClockSet = 0x00000128,
    HierarchyChangeAuth = 0x00000129,
    NvDefinespace = 0x0000012A,
    PcrAllocate = 0x0000012B,
    PcrSetauthpolicy = 0x0000012C,
    PpCommands = 0x0000012D,
    SetPrimaryPolicy = 0x0000012E,
    FieldUpgradeStart = 0x0000012F,
    ClockRateAdjust = 0x00000130,
    CreatePrimary = 0x00000131,
    NvGlobalwritelock = 0x00000132,
    GetCommandAuditDigest = 0x00000133,
    NvIncrement = 0x00000134,
    NvSetbits = 0x00000135,
    NvExtend = 0x00000136,
    NvWrite = 0x00000137,
    NvWritelock = 0x00000138,
    DictionaryAttackLockReset = 0x00000139,
    DictionaryAttackParameters = 0x0000013A,
    NvChangeauth = 0x0000013B,

    /// PCR
    PcrEvent = 0x0000013C,

    /// PCR
    PcrReset = 0x0000013D,
    SequenceComplete = 0x0000013E,
    SetAlgorithmSet = 0x0000013F,
    SetCommandCodeAuditStatus = 0x00000140,
    FieldUpgradeData = 0x00000141,
    IncrementalSelfTest = 0x00000142,
    SelfTest = 0x00000143,
    Startup = 0x00000144,
    Shutdown = 0x00000145,
    StirRandom = 0x00000146,
    ActivateCredential = 0x00000147,
    Certify = 0x00000148,

    /// Policy
    PolicyNV = 0x00000149,
    CertifyCreation = 0x0000014A,
    Duplicate = 0x0000014B,
    GetTime = 0x0000014C,
    GetSessionAuditDigest = 0x0000014D,
    NvRead = 0x0000014E,
    NvReadlock = 0x0000014F,
    ObjectChangeAuth = 0x00000150,

    /// Policy
    PolicySecret = 0x00000151,
    Rewrap = 0x00000152,
    Create = 0x00000153,
    EcdhZgen = 0x00000154,

    /// See NOTE 1
    HMAC = 0x00000155,

    /// See NOTE 1
    MAC = 0x00000155,
    Import = 0x00000156,
    Load = 0x00000157,
    Quote = 0x00000158,
    RsaDecrypt = 0x00000159,

    /// See NOTE 1
    HmacStart = 0x0000015B,

    /// See NOTE 1
    MacStart = 0x0000015B,
    SequenceUpdate = 0x0000015C,
    Sign = 0x0000015D,
    Unseal = 0x0000015E,

    /// Policy
    PolicySigned = 0x00000160,

    /// Context
    ContextLoad = 0x00000161,

    /// Context
    ContextSave = 0x00000162,
    EcdhKeygen = 0x00000163,
    EncryptDecrypt = 0x00000164,

    /// Context
    FlushContext = 0x00000165,
    LoadExternal = 0x00000167,
    MakeCredential = 0x00000168,

    /// NV
    NvReadpublic = 0x00000169,

    /// Policy
    PolicyAuthorize = 0x0000016A,

    /// Policy
    PolicyAuthValue = 0x0000016B,

    /// Policy
    PolicyCommandCode = 0x0000016C,

    /// Policy
    PolicyCounterTimer = 0x0000016D,

    /// Policy
    PolicyCpHash = 0x0000016E,

    /// Policy
    PolicyLocality = 0x0000016F,

    /// Policy
    PolicyNameHash = 0x00000170,

    /// Policy
    PolicyOR = 0x00000171,

    /// Policy
    PolicyTicket = 0x00000172,
    ReadPublic = 0x00000173,
    RsaEncrypt = 0x00000174,
    StartAuthSession = 0x00000176,
    VerifySignature = 0x00000177,
    EccParameters = 0x00000178,
    FirmwareRead = 0x00000179,
    GetCapability = 0x0000017A,
    GetRandom = 0x0000017B,
    GetTestResult = 0x0000017C,
    Hash = 0x0000017D,

    /// PCR
    PcrRead = 0x0000017E,

    /// Policy
    PolicyPCR = 0x0000017F,
    PolicyRestart = 0x00000180,
    ReadClock = 0x00000181,
    PcrExtend = 0x00000182,
    PcrSetauthvalue = 0x00000183,
    NvCertify = 0x00000184,
    EventSequenceComplete = 0x00000185,
    HashSequenceStart = 0x00000186,

    /// Policy
    PolicyPhysicalPresence = 0x00000187,

    /// Policy
    PolicyDuplicationSelect = 0x00000188,

    /// Policy
    PolicyGetDigest = 0x00000189,
    TestParms = 0x0000018A,
    Commit = 0x0000018B,

    /// Policy
    PolicyPassword = 0x0000018C,
    Zgen2phase = 0x0000018D,
    EcEphemeral = 0x0000018E,

    /// Policy
    PolicyNvWritten = 0x0000018F,

    /// Policy
    PolicyTemplate = 0x00000190,
    CreateLoaded = 0x00000191,

    /// Policy
    PolicyAuthorizeNV = 0x00000192,
    EncryptDecrypt2 = 0x00000193,
    AcGetcapability = 0x00000194,
    AcSend = 0x00000195,

    /// Policy
    PolicyAcSendselect = 0x00000196,
    CertifyX509 = 0x00000197,
    ActSettimeout = 0x00000198,
    EccEncrypt = 0x00000199,
    EccDecrypt = 0x0000019A,

    /// Compile variable. May increase based on implementation.
    LAST = 0x0000019A,
    CcVend = 0x20000000,

    /// Used for testing of command dispatch
    VendorTcgTest = CC_VEND+0x0000
}

impl TryFrom<u32> for TPM_CC {
    type Error = TpmError;

    fn try_from(value: u32) -> Result<Self, Self::Error> {
        match value {
            0x0000011F => Ok(Self::FIRST),
            0x0000011F => Ok(Self::NvUndefinespacespecial),
            0x00000120 => Ok(Self::EvictControl),
            0x00000121 => Ok(Self::HierarchyControl),
            0x00000122 => Ok(Self::NvUndefinespace),
            0x00000124 => Ok(Self::ChangeEPS),
            0x00000125 => Ok(Self::ChangePPS),
            0x00000126 => Ok(Self::Clear),
            0x00000127 => Ok(Self::ClearControl),
            0x00000128 => Ok(Self::ClockSet),
            0x00000129 => Ok(Self::HierarchyChangeAuth),
            0x0000012A => Ok(Self::NvDefinespace),
            0x0000012B => Ok(Self::PcrAllocate),
            0x0000012C => Ok(Self::PcrSetauthpolicy),
            0x0000012D => Ok(Self::PpCommands),
            0x0000012E => Ok(Self::SetPrimaryPolicy),
            0x0000012F => Ok(Self::FieldUpgradeStart),
            0x00000130 => Ok(Self::ClockRateAdjust),
            0x00000131 => Ok(Self::CreatePrimary),
            0x00000132 => Ok(Self::NvGlobalwritelock),
            0x00000133 => Ok(Self::GetCommandAuditDigest),
            0x00000134 => Ok(Self::NvIncrement),
            0x00000135 => Ok(Self::NvSetbits),
            0x00000136 => Ok(Self::NvExtend),
            0x00000137 => Ok(Self::NvWrite),
            0x00000138 => Ok(Self::NvWritelock),
            0x00000139 => Ok(Self::DictionaryAttackLockReset),
            0x0000013A => Ok(Self::DictionaryAttackParameters),
            0x0000013B => Ok(Self::NvChangeauth),
            0x0000013C => Ok(Self::PcrEvent),
            0x0000013D => Ok(Self::PcrReset),
            0x0000013E => Ok(Self::SequenceComplete),
            0x0000013F => Ok(Self::SetAlgorithmSet),
            0x00000140 => Ok(Self::SetCommandCodeAuditStatus),
            0x00000141 => Ok(Self::FieldUpgradeData),
            0x00000142 => Ok(Self::IncrementalSelfTest),
            0x00000143 => Ok(Self::SelfTest),
            0x00000144 => Ok(Self::Startup),
            0x00000145 => Ok(Self::Shutdown),
            0x00000146 => Ok(Self::StirRandom),
            0x00000147 => Ok(Self::ActivateCredential),
            0x00000148 => Ok(Self::Certify),
            0x00000149 => Ok(Self::PolicyNV),
            0x0000014A => Ok(Self::CertifyCreation),
            0x0000014B => Ok(Self::Duplicate),
            0x0000014C => Ok(Self::GetTime),
            0x0000014D => Ok(Self::GetSessionAuditDigest),
            0x0000014E => Ok(Self::NvRead),
            0x0000014F => Ok(Self::NvReadlock),
            0x00000150 => Ok(Self::ObjectChangeAuth),
            0x00000151 => Ok(Self::PolicySecret),
            0x00000152 => Ok(Self::Rewrap),
            0x00000153 => Ok(Self::Create),
            0x00000154 => Ok(Self::EcdhZgen),
            0x00000155 => Ok(Self::HMAC),
            0x00000155 => Ok(Self::MAC),
            0x00000156 => Ok(Self::Import),
            0x00000157 => Ok(Self::Load),
            0x00000158 => Ok(Self::Quote),
            0x00000159 => Ok(Self::RsaDecrypt),
            0x0000015B => Ok(Self::HmacStart),
            0x0000015B => Ok(Self::MacStart),
            0x0000015C => Ok(Self::SequenceUpdate),
            0x0000015D => Ok(Self::Sign),
            0x0000015E => Ok(Self::Unseal),
            0x00000160 => Ok(Self::PolicySigned),
            0x00000161 => Ok(Self::ContextLoad),
            0x00000162 => Ok(Self::ContextSave),
            0x00000163 => Ok(Self::EcdhKeygen),
            0x00000164 => Ok(Self::EncryptDecrypt),
            0x00000165 => Ok(Self::FlushContext),
            0x00000167 => Ok(Self::LoadExternal),
            0x00000168 => Ok(Self::MakeCredential),
            0x00000169 => Ok(Self::NvReadpublic),
            0x0000016A => Ok(Self::PolicyAuthorize),
            0x0000016B => Ok(Self::PolicyAuthValue),
            0x0000016C => Ok(Self::PolicyCommandCode),
            0x0000016D => Ok(Self::PolicyCounterTimer),
            0x0000016E => Ok(Self::PolicyCpHash),
            0x0000016F => Ok(Self::PolicyLocality),
            0x00000170 => Ok(Self::PolicyNameHash),
            0x00000171 => Ok(Self::PolicyOR),
            0x00000172 => Ok(Self::PolicyTicket),
            0x00000173 => Ok(Self::ReadPublic),
            0x00000174 => Ok(Self::RsaEncrypt),
            0x00000176 => Ok(Self::StartAuthSession),
            0x00000177 => Ok(Self::VerifySignature),
            0x00000178 => Ok(Self::EccParameters),
            0x00000179 => Ok(Self::FirmwareRead),
            0x0000017A => Ok(Self::GetCapability),
            0x0000017B => Ok(Self::GetRandom),
            0x0000017C => Ok(Self::GetTestResult),
            0x0000017D => Ok(Self::Hash),
            0x0000017E => Ok(Self::PcrRead),
            0x0000017F => Ok(Self::PolicyPCR),
            0x00000180 => Ok(Self::PolicyRestart),
            0x00000181 => Ok(Self::ReadClock),
            0x00000182 => Ok(Self::PcrExtend),
            0x00000183 => Ok(Self::PcrSetauthvalue),
            0x00000184 => Ok(Self::NvCertify),
            0x00000185 => Ok(Self::EventSequenceComplete),
            0x00000186 => Ok(Self::HashSequenceStart),
            0x00000187 => Ok(Self::PolicyPhysicalPresence),
            0x00000188 => Ok(Self::PolicyDuplicationSelect),
            0x00000189 => Ok(Self::PolicyGetDigest),
            0x0000018A => Ok(Self::TestParms),
            0x0000018B => Ok(Self::Commit),
            0x0000018C => Ok(Self::PolicyPassword),
            0x0000018D => Ok(Self::Zgen2phase),
            0x0000018E => Ok(Self::EcEphemeral),
            0x0000018F => Ok(Self::PolicyNvWritten),
            0x00000190 => Ok(Self::PolicyTemplate),
            0x00000191 => Ok(Self::CreateLoaded),
            0x00000192 => Ok(Self::PolicyAuthorizeNV),
            0x00000193 => Ok(Self::EncryptDecrypt2),
            0x00000194 => Ok(Self::AcGetcapability),
            0x00000195 => Ok(Self::AcSend),
            0x00000196 => Ok(Self::PolicyAcSendselect),
            0x00000197 => Ok(Self::CertifyX509),
            0x00000198 => Ok(Self::ActSettimeout),
            0x00000199 => Ok(Self::EccEncrypt),
            0x0000019A => Ok(Self::EccDecrypt),
            0x0000019A => Ok(Self::LAST),
            0x20000000 => Ok(Self::CcVend),
            CC_VEND+0x0000 => Ok(Self::VendorTcgTest),
            _ => Err(TpmError::InvalidEnumValue),
        }

    }

}

impl fmt::Display for TPM_CC {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::FIRST => write!(f, "FIRST"),
            Self::NvUndefinespacespecial => write!(f, "NvUndefinespacespecial"),
            Self::EvictControl => write!(f, "EvictControl"),
            Self::HierarchyControl => write!(f, "HierarchyControl"),
            Self::NvUndefinespace => write!(f, "NvUndefinespace"),
            Self::ChangeEPS => write!(f, "ChangeEPS"),
            Self::ChangePPS => write!(f, "ChangePPS"),
            Self::Clear => write!(f, "Clear"),
            Self::ClearControl => write!(f, "ClearControl"),
            Self::ClockSet => write!(f, "ClockSet"),
            Self::HierarchyChangeAuth => write!(f, "HierarchyChangeAuth"),
            Self::NvDefinespace => write!(f, "NvDefinespace"),
            Self::PcrAllocate => write!(f, "PcrAllocate"),
            Self::PcrSetauthpolicy => write!(f, "PcrSetauthpolicy"),
            Self::PpCommands => write!(f, "PpCommands"),
            Self::SetPrimaryPolicy => write!(f, "SetPrimaryPolicy"),
            Self::FieldUpgradeStart => write!(f, "FieldUpgradeStart"),
            Self::ClockRateAdjust => write!(f, "ClockRateAdjust"),
            Self::CreatePrimary => write!(f, "CreatePrimary"),
            Self::NvGlobalwritelock => write!(f, "NvGlobalwritelock"),
            Self::GetCommandAuditDigest => write!(f, "GetCommandAuditDigest"),
            Self::NvIncrement => write!(f, "NvIncrement"),
            Self::NvSetbits => write!(f, "NvSetbits"),
            Self::NvExtend => write!(f, "NvExtend"),
            Self::NvWrite => write!(f, "NvWrite"),
            Self::NvWritelock => write!(f, "NvWritelock"),
            Self::DictionaryAttackLockReset => write!(f, "DictionaryAttackLockReset"),
            Self::DictionaryAttackParameters => write!(f, "DictionaryAttackParameters"),
            Self::NvChangeauth => write!(f, "NvChangeauth"),
            Self::PcrEvent => write!(f, "PcrEvent"),
            Self::PcrReset => write!(f, "PcrReset"),
            Self::SequenceComplete => write!(f, "SequenceComplete"),
            Self::SetAlgorithmSet => write!(f, "SetAlgorithmSet"),
            Self::SetCommandCodeAuditStatus => write!(f, "SetCommandCodeAuditStatus"),
            Self::FieldUpgradeData => write!(f, "FieldUpgradeData"),
            Self::IncrementalSelfTest => write!(f, "IncrementalSelfTest"),
            Self::SelfTest => write!(f, "SelfTest"),
            Self::Startup => write!(f, "Startup"),
            Self::Shutdown => write!(f, "Shutdown"),
            Self::StirRandom => write!(f, "StirRandom"),
            Self::ActivateCredential => write!(f, "ActivateCredential"),
            Self::Certify => write!(f, "Certify"),
            Self::PolicyNV => write!(f, "PolicyNV"),
            Self::CertifyCreation => write!(f, "CertifyCreation"),
            Self::Duplicate => write!(f, "Duplicate"),
            Self::GetTime => write!(f, "GetTime"),
            Self::GetSessionAuditDigest => write!(f, "GetSessionAuditDigest"),
            Self::NvRead => write!(f, "NvRead"),
            Self::NvReadlock => write!(f, "NvReadlock"),
            Self::ObjectChangeAuth => write!(f, "ObjectChangeAuth"),
            Self::PolicySecret => write!(f, "PolicySecret"),
            Self::Rewrap => write!(f, "Rewrap"),
            Self::Create => write!(f, "Create"),
            Self::EcdhZgen => write!(f, "EcdhZgen"),
            Self::HMAC => write!(f, "HMAC"),
            Self::MAC => write!(f, "MAC"),
            Self::Import => write!(f, "Import"),
            Self::Load => write!(f, "Load"),
            Self::Quote => write!(f, "Quote"),
            Self::RsaDecrypt => write!(f, "RsaDecrypt"),
            Self::HmacStart => write!(f, "HmacStart"),
            Self::MacStart => write!(f, "MacStart"),
            Self::SequenceUpdate => write!(f, "SequenceUpdate"),
            Self::Sign => write!(f, "Sign"),
            Self::Unseal => write!(f, "Unseal"),
            Self::PolicySigned => write!(f, "PolicySigned"),
            Self::ContextLoad => write!(f, "ContextLoad"),
            Self::ContextSave => write!(f, "ContextSave"),
            Self::EcdhKeygen => write!(f, "EcdhKeygen"),
            Self::EncryptDecrypt => write!(f, "EncryptDecrypt"),
            Self::FlushContext => write!(f, "FlushContext"),
            Self::LoadExternal => write!(f, "LoadExternal"),
            Self::MakeCredential => write!(f, "MakeCredential"),
            Self::NvReadpublic => write!(f, "NvReadpublic"),
            Self::PolicyAuthorize => write!(f, "PolicyAuthorize"),
            Self::PolicyAuthValue => write!(f, "PolicyAuthValue"),
            Self::PolicyCommandCode => write!(f, "PolicyCommandCode"),
            Self::PolicyCounterTimer => write!(f, "PolicyCounterTimer"),
            Self::PolicyCpHash => write!(f, "PolicyCpHash"),
            Self::PolicyLocality => write!(f, "PolicyLocality"),
            Self::PolicyNameHash => write!(f, "PolicyNameHash"),
            Self::PolicyOR => write!(f, "PolicyOR"),
            Self::PolicyTicket => write!(f, "PolicyTicket"),
            Self::ReadPublic => write!(f, "ReadPublic"),
            Self::RsaEncrypt => write!(f, "RsaEncrypt"),
            Self::StartAuthSession => write!(f, "StartAuthSession"),
            Self::VerifySignature => write!(f, "VerifySignature"),
            Self::EccParameters => write!(f, "EccParameters"),
            Self::FirmwareRead => write!(f, "FirmwareRead"),
            Self::GetCapability => write!(f, "GetCapability"),
            Self::GetRandom => write!(f, "GetRandom"),
            Self::GetTestResult => write!(f, "GetTestResult"),
            Self::Hash => write!(f, "Hash"),
            Self::PcrRead => write!(f, "PcrRead"),
            Self::PolicyPCR => write!(f, "PolicyPCR"),
            Self::PolicyRestart => write!(f, "PolicyRestart"),
            Self::ReadClock => write!(f, "ReadClock"),
            Self::PcrExtend => write!(f, "PcrExtend"),
            Self::PcrSetauthvalue => write!(f, "PcrSetauthvalue"),
            Self::NvCertify => write!(f, "NvCertify"),
            Self::EventSequenceComplete => write!(f, "EventSequenceComplete"),
            Self::HashSequenceStart => write!(f, "HashSequenceStart"),
            Self::PolicyPhysicalPresence => write!(f, "PolicyPhysicalPresence"),
            Self::PolicyDuplicationSelect => write!(f, "PolicyDuplicationSelect"),
            Self::PolicyGetDigest => write!(f, "PolicyGetDigest"),
            Self::TestParms => write!(f, "TestParms"),
            Self::Commit => write!(f, "Commit"),
            Self::PolicyPassword => write!(f, "PolicyPassword"),
            Self::Zgen2phase => write!(f, "Zgen2phase"),
            Self::EcEphemeral => write!(f, "EcEphemeral"),
            Self::PolicyNvWritten => write!(f, "PolicyNvWritten"),
            Self::PolicyTemplate => write!(f, "PolicyTemplate"),
            Self::CreateLoaded => write!(f, "CreateLoaded"),
            Self::PolicyAuthorizeNV => write!(f, "PolicyAuthorizeNV"),
            Self::EncryptDecrypt2 => write!(f, "EncryptDecrypt2"),
            Self::AcGetcapability => write!(f, "AcGetcapability"),
            Self::AcSend => write!(f, "AcSend"),
            Self::PolicyAcSendselect => write!(f, "PolicyAcSendselect"),
            Self::CertifyX509 => write!(f, "CertifyX509"),
            Self::ActSettimeout => write!(f, "ActSettimeout"),
            Self::EccEncrypt => write!(f, "EccEncrypt"),
            Self::EccDecrypt => write!(f, "EccDecrypt"),
            Self::LAST => write!(f, "LAST"),
            Self::CcVend => write!(f, "CcVend"),
            Self::VendorTcgTest => write!(f, "VendorTcgTest"),
        }

    }

}

/// Architecturally defined constants
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u32)]
pub enum ImplementationConstants {
    Ossl = 1,
    Ltc = 2,
    Msbn = 3,
    Symcrypt = 4,
    HashCount = 3,
    MaxSymKeyBits = 256,
    MaxSymKeyBytes = ((MAX_SYM_KEY_BITS + 7) / 8),
    MaxSymBlockSize = 16,
    MaxCapCc = TPM_CC:LAST,
    MaxRsaKeyBytes = 256,
    MaxAesKeyBytes = 32,
    MaxEccKeyBytes = 48,
    LabelMaxBuffer = 32,
    TpmCapSize = 0x4 /* sizeof(UINT32) */,
    MaxCapData = (Implementation:MAX_CAP_BUFFER-_TPM_CAP_SIZE-0x4) /* (MAX_CAP_BUFFER-_TPM_CAP_SIZE-sizeof(UINT32)) */,
    MaxCapAlgs = (MAX_CAP_DATA / 0x6) /* (MAX_CAP_DATA / sizeof(TPMS_ALG_PROPERTY)) */,
    MaxCapHandles = (MAX_CAP_DATA / 0x4) /* (MAX_CAP_DATA / sizeof(TPM_HANDLE)) */,
    MaxTpmProperties = (MAX_CAP_DATA / 0x8) /* (MAX_CAP_DATA / sizeof(TPMS_TAGGED_PROPERTY)) */,
    MaxPcrProperties = (MAX_CAP_DATA / 0x5) /* (MAX_CAP_DATA / sizeof(TPMS_TAGGED_PCR_SELECT)) */,
    MaxEccCurves = (MAX_CAP_DATA / 0x2) /* (MAX_CAP_DATA / sizeof(TPM_ECC_CURVE)) */,
    MaxTaggedPolicies = (MAX_CAP_DATA / 0x46) /* (MAX_CAP_DATA / sizeof(TPMS_TAGGED_POLICY)) */,
    MaxAcCapabilities = (MAX_CAP_DATA / 0x8) /* (MAX_CAP_DATA / sizeof(TPMS_AC_OUTPUT)) */,
    MaxActData = MAX_CAP_DATA / 0xC /* MAX_CAP_DATA / sizeof(TPMS_ACT_DATA) */
}

impl TryFrom<u32> for ImplementationConstants {
    type Error = TpmError;

    fn try_from(value: u32) -> Result<Self, Self::Error> {
        match value {
            1 => Ok(Self::Ossl),
            2 => Ok(Self::Ltc),
            3 => Ok(Self::Msbn),
            4 => Ok(Self::Symcrypt),
            3 => Ok(Self::HashCount),
            256 => Ok(Self::MaxSymKeyBits),
            ((MAX_SYM_KEY_BITS + 7) / 8) => Ok(Self::MaxSymKeyBytes),
            16 => Ok(Self::MaxSymBlockSize),
            TPM_CC:LAST => Ok(Self::MaxCapCc),
            256 => Ok(Self::MaxRsaKeyBytes),
            32 => Ok(Self::MaxAesKeyBytes),
            48 => Ok(Self::MaxEccKeyBytes),
            32 => Ok(Self::LabelMaxBuffer),
            0x4 /* sizeof(UINT32) */ => Ok(Self::TpmCapSize),
            (Implementation:MAX_CAP_BUFFER-_TPM_CAP_SIZE-0x4) /* (MAX_CAP_BUFFER-_TPM_CAP_SIZE-sizeof(UINT32)) */ => Ok(Self::MaxCapData),
            (MAX_CAP_DATA / 0x6) /* (MAX_CAP_DATA / sizeof(TPMS_ALG_PROPERTY)) */ => Ok(Self::MaxCapAlgs),
            (MAX_CAP_DATA / 0x4) /* (MAX_CAP_DATA / sizeof(TPM_HANDLE)) */ => Ok(Self::MaxCapHandles),
            (MAX_CAP_DATA / 0x8) /* (MAX_CAP_DATA / sizeof(TPMS_TAGGED_PROPERTY)) */ => Ok(Self::MaxTpmProperties),
            (MAX_CAP_DATA / 0x5) /* (MAX_CAP_DATA / sizeof(TPMS_TAGGED_PCR_SELECT)) */ => Ok(Self::MaxPcrProperties),
            (MAX_CAP_DATA / 0x2) /* (MAX_CAP_DATA / sizeof(TPM_ECC_CURVE)) */ => Ok(Self::MaxEccCurves),
            (MAX_CAP_DATA / 0x46) /* (MAX_CAP_DATA / sizeof(TPMS_TAGGED_POLICY)) */ => Ok(Self::MaxTaggedPolicies),
            (MAX_CAP_DATA / 0x8) /* (MAX_CAP_DATA / sizeof(TPMS_AC_OUTPUT)) */ => Ok(Self::MaxAcCapabilities),
            MAX_CAP_DATA / 0xC /* MAX_CAP_DATA / sizeof(TPMS_ACT_DATA) */ => Ok(Self::MaxActData),
            _ => Err(TpmError::InvalidEnumValue),
        }

    }

}

impl fmt::Display for ImplementationConstants {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::Ossl => write!(f, "Ossl"),
            Self::Ltc => write!(f, "Ltc"),
            Self::Msbn => write!(f, "Msbn"),
            Self::Symcrypt => write!(f, "Symcrypt"),
            Self::HashCount => write!(f, "HashCount"),
            Self::MaxSymKeyBits => write!(f, "MaxSymKeyBits"),
            Self::MaxSymKeyBytes => write!(f, "MaxSymKeyBytes"),
            Self::MaxSymBlockSize => write!(f, "MaxSymBlockSize"),
            Self::MaxCapCc => write!(f, "MaxCapCc"),
            Self::MaxRsaKeyBytes => write!(f, "MaxRsaKeyBytes"),
            Self::MaxAesKeyBytes => write!(f, "MaxAesKeyBytes"),
            Self::MaxEccKeyBytes => write!(f, "MaxEccKeyBytes"),
            Self::LabelMaxBuffer => write!(f, "LabelMaxBuffer"),
            Self::TpmCapSize => write!(f, "TpmCapSize"),
            Self::MaxCapData => write!(f, "MaxCapData"),
            Self::MaxCapAlgs => write!(f, "MaxCapAlgs"),
            Self::MaxCapHandles => write!(f, "MaxCapHandles"),
            Self::MaxTpmProperties => write!(f, "MaxTpmProperties"),
            Self::MaxPcrProperties => write!(f, "MaxPcrProperties"),
            Self::MaxEccCurves => write!(f, "MaxEccCurves"),
            Self::MaxTaggedPolicies => write!(f, "MaxTaggedPolicies"),
            Self::MaxAcCapabilities => write!(f, "MaxAcCapabilities"),
            Self::MaxActData => write!(f, "MaxActData"),
        }

    }

}

/// In general, response codes defined in TPM 2.0 Part 2 will be unmarshaling errors and
/// will have the F (format) bit SET. Codes that are unique to TPM 2.0 Part 3 will have
/// the F bit CLEAR but the V (version) attribute will be SET to indicate that it is a TPM
/// 2.0 response code. See Response Code Details in TPM 2.0 Part 1.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u32)]
pub enum TPM_RC {
    SUCCESS = 0x000,

    /// Defined for compatibility with TPM 1.2
    BadTag = 0x01E,

    /// Set for all format 0 response codes
    RcVer1 = 0x100,

    /// TPM not initialized by TPM2_Startup or already initialized
    INITIALIZE = RC_VER1 + 0x000,

    /// Commands not being accepted because of a TPM failure
    /// NOTE This may be returned by TPM2_GetTestResult() as the testResult parameter.
    FAILURE = RC_VER1 + 0x001,

    /// Improper use of a sequence handle
    SEQUENCE = RC_VER1 + 0x003,

    /// Not currently used
    PRIVATE = RC_VER1 + 0x00B,

    /// Not currently used
    HMAC = RC_VER1 + 0x019,

    /// The command is disabled
    DISABLED = RC_VER1 + 0x020,

    /// Command failed because audit sequence required exclusivity
    EXCLUSIVE = RC_VER1 + 0x021,

    /// Authorization handle is not correct for command
    AuthType = RC_VER1 + 0x024,

    /// Command requires an authorization session for handle and it is not present.
    AuthMissing = RC_VER1 + 0x025,

    /// Policy failure in math operation or an invalid authPolicy value
    POLICY = RC_VER1 + 0x026,

    /// PCR check fail
    PCR = RC_VER1 + 0x027,

    /// PCR have changed since checked.
    PcrChanged = RC_VER1 + 0x028,

    /// For all commands other than TPM2_FieldUpgradeData(), this code indicates that the TPM
    /// is in field upgrade mode; for TPM2_FieldUpgradeData(), this code indicates that the
    /// TPM is not in field upgrade mode
    UPGRADE = RC_VER1 + 0x02D,

    /// Context ID counter is at maximum.
    TooManyContexts = RC_VER1 + 0x02E,

    /// AuthValue or authPolicy is not available for selected entity.
    AuthUnavailable = RC_VER1 + 0x02F,

    /// A _TPM_Init and Startup(CLEAR) is required before the TPM can resume operation.
    REBOOT = RC_VER1 + 0x030,

    /// The protection algorithms (hash and symmetric) are not reasonably balanced. The digest
    /// size of the hash must be larger than the key size of the symmetric algorithm.
    UNBALANCED = RC_VER1 + 0x031,

    /// Command commandSize value is inconsistent with contents of the command buffer; either
    /// the size is not the same as the octets loaded by the hardware interface layer or the
    /// value is not large enough to hold a command header
    CommandSize = RC_VER1 + 0x042,

    /// Command code not supported
    CommandCode = RC_VER1 + 0x043,

    /// The value of authorizationSize is out of range or the number of octets in the
    /// Authorization Area is greater than required
    AUTHSIZE = RC_VER1 + 0x044,

    /// Use of an authorization session with a context command or another command that cannot
    /// have an authorization session.
    AuthContext = RC_VER1 + 0x045,

    /// NV offset+size is out of range.
    NvRange = RC_VER1 + 0x046,

    /// Requested allocation size is larger than allowed.
    NvSize = RC_VER1 + 0x047,

    /// NV access locked.
    NvLocked = RC_VER1 + 0x048,

    /// NV access authorization fails in command actions (this failure does not affect lockout.action)
    NvAuthorization = RC_VER1 + 0x049,

    /// An NV Index is used before being initialized or the state saved by
    /// TPM2_Shutdown(STATE) could not be restored
    NvUninitialized = RC_VER1 + 0x04A,

    /// Insufficient space for NV allocation
    NvSpace = RC_VER1 + 0x04B,

    /// NV Index or persistent object already defined
    NvDefined = RC_VER1 + 0x04C,

    /// Context in TPM2_ContextLoad() is not valid
    BadContext = RC_VER1 + 0x050,

    /// CpHash value already set or not correct for use
    CPHASH = RC_VER1 + 0x051,

    /// Handle for parent is not a valid parent
    PARENT = RC_VER1 + 0x052,

    /// Some function needs testing.
    NeedsTest = RC_VER1 + 0x053,

    /// Returned when an internal function cannot process a request due to an unspecified
    /// problem. This code is usually related to invalid parameters that are not properly
    /// filtered by the input unmarshaling code.
    NoResult = RC_VER1 + 0x054,

    /// The sensitive area did not unmarshal correctly after decryption this code is used in
    /// lieu of the other unmarshaling errors so that an attacker cannot determine where the
    /// unmarshaling error occurred
    SENSITIVE = RC_VER1 + 0x055,

    /// Largest version 1 code that is not a warning
    RcMaxFm0 = RC_VER1 + 0x07F,

    /// This bit is SET in all format 1 response codes
    /// The codes in this group may have a value added to them to indicate the handle,
    /// session, or parameter to which they apply.
    RcFmt1 = 0x080,

    /// Asymmetric algorithm not supported or not correct
    ASYMMETRIC = RC_FMT1 + 0x001,

    /// Inconsistent attributes
    ATTRIBUTES = RC_FMT1 + 0x002,

    /// Hash algorithm not supported or not appropriate
    HASH = RC_FMT1 + 0x003,

    /// Value is out of range or is not correct for the context
    VALUE = RC_FMT1 + 0x004,

    /// Hierarchy is not enabled or is not correct for the use
    HIERARCHY = RC_FMT1 + 0x005,

    /// Key size is not supported
    KeySize = RC_FMT1 + 0x007,

    /// Mask generation function not supported
    MGF = RC_FMT1 + 0x008,

    /// Mode of operation not supported
    MODE = RC_FMT1 + 0x009,

    /// The type of the value is not appropriate for the use
    TYPE = RC_FMT1 + 0x00A,

    /// The handle is not correct for the use
    HANDLE = RC_FMT1 + 0x00B,

    /// Unsupported key derivation function or function not appropriate for use
    KDF = RC_FMT1 + 0x00C,

    /// Value was out of allowed range.
    RANGE = RC_FMT1 + 0x00D,

    /// The authorization HMAC check failed and DA counter incremented
    AuthFail = RC_FMT1 + 0x00E,

    /// Invalid nonce size or nonce value mismatch
    NONCE = RC_FMT1 + 0x00F,

    /// Authorization requires assertion of PP
    PP = RC_FMT1 + 0x010,

    /// Unsupported or incompatible scheme
    SCHEME = RC_FMT1 + 0x012,

    /// Structure is the wrong size
    SIZE = RC_FMT1 + 0x015,

    /// Unsupported symmetric algorithm or key size, or not appropriate for instance
    SYMMETRIC = RC_FMT1 + 0x016,

    /// Incorrect structure tag
    TAG = RC_FMT1 + 0x017,

    /// Union selector is incorrect
    SELECTOR = RC_FMT1 + 0x018,

    /// The TPM was unable to unmarshal a value because there were not enough octets in the
    /// input buffer
    INSUFFICIENT = RC_FMT1 + 0x01A,

    /// The signature is not valid
    SIGNATURE = RC_FMT1 + 0x01B,

    /// Key fields are not compatible with the selected use
    KEY = RC_FMT1 + 0x01C,

    /// A policy check failed
    PolicyFail = RC_FMT1 + 0x01D,

    /// Integrity check failed
    INTEGRITY = RC_FMT1 + 0x01F,

    /// Invalid ticket
    TICKET = RC_FMT1 + 0x020,

    /// Reserved bits not set to zero as required
    ReservedBits = RC_FMT1 + 0x021,

    /// Authorization failure without DA implications
    BadAuth = RC_FMT1 + 0x022,

    /// The policy has expired
    EXPIRED = RC_FMT1 + 0x023,

    /// The commandCode in the policy is not the commandCode of the command or the command
    /// code in a policy command references a command that is not implemented
    PolicyCc = RC_FMT1 + 0x024,

    /// Public and sensitive portions of an object are not cryptographically bound
    BINDING = RC_FMT1 + 0x025,

    /// Curve not supported
    CURVE = RC_FMT1 + 0x026,

    /// Point is not on the required curve.
    EccPoint = RC_FMT1 + 0x027,

    /// Set for warning response codes
    RcWarn = 0x900,

    /// Gap for context ID is too large
    ContextGap = RC_WARN + 0x001,

    /// Out of memory for object contexts
    ObjectMemory = RC_WARN + 0x002,

    /// Out of memory for session contexts
    SessionMemory = RC_WARN + 0x003,

    /// Out of shared object/session memory or need space for internal operations
    MEMORY = RC_WARN + 0x004,

    /// Out of session handles a session must be flushed before a new session may be created
    SessionHandles = RC_WARN + 0x005,

    /// Out of object handles the handle space for objects is depleted and a reboot is required
    /// NOTE 1 This cannot occur on the reference implementation.
    /// NOTE 2 There is no reason why an implementation would implement a design that would
    /// deplete handle space. Platform specifications are encouraged to forbid it.
    ObjectHandles = RC_WARN + 0x006,

    /// Bad locality
    LOCALITY = RC_WARN + 0x007,

    /// The TPM has suspended operation on the command; forward progress was made and the
    /// command may be retried
    /// See TPM 2.0 Part 1, Multi-tasking.
    /// NOTE This cannot occur on the reference implementation.
    YIELDED = RC_WARN + 0x008,

    /// The command was canceled
    CANCELED = RC_WARN + 0x009,

    /// TPM is performing self-tests
    TESTING = RC_WARN + 0x00A,

    /// The 1st handle in the handle area references a transient object or session that is not
    /// loaded
    ReferenceH0 = RC_WARN + 0x010,

    /// The 2nd handle in the handle area references a transient object or session that is not
    /// loaded
    ReferenceH1 = RC_WARN + 0x011,

    /// The 3rd handle in the handle area references a transient object or session that is not
    /// loaded
    ReferenceH2 = RC_WARN + 0x012,

    /// The 4th handle in the handle area references a transient object or session that is not
    /// loaded
    ReferenceH3 = RC_WARN + 0x013,

    /// The 5th handle in the handle area references a transient object or session that is not
    /// loaded
    ReferenceH4 = RC_WARN + 0x014,

    /// The 6th handle in the handle area references a transient object or session that is not
    /// loaded
    ReferenceH5 = RC_WARN + 0x015,

    /// The 7th handle in the handle area references a transient object or session that is not
    /// loaded
    ReferenceH6 = RC_WARN + 0x016,

    /// The 1st authorization session handle references a session that is not loaded
    ReferenceS0 = RC_WARN + 0x018,

    /// The 2nd authorization session handle references a session that is not loaded
    ReferenceS1 = RC_WARN + 0x019,

    /// The 3rd authorization session handle references a session that is not loaded
    ReferenceS2 = RC_WARN + 0x01A,

    /// The 4th authorization session handle references a session that is not loaded
    ReferenceS3 = RC_WARN + 0x01B,

    /// The 5th session handle references a session that is not loaded
    ReferenceS4 = RC_WARN + 0x01C,

    /// The 6th session handle references a session that is not loaded
    ReferenceS5 = RC_WARN + 0x01D,

    /// The 7th authorization session handle references a session that is not loaded
    ReferenceS6 = RC_WARN + 0x01E,

    /// The TPM is rate-limiting accesses to prevent wearout of NV
    NvRate = RC_WARN + 0x020,

    /// Authorizations for objects subject to DA protection are not allowed at this time
    /// because the TPM is in DA lockout mode
    LOCKOUT = RC_WARN + 0x021,

    /// The TPM was not able to start the command
    RETRY = RC_WARN + 0x022,

    /// The command may require writing of NV and NV is not current accessible
    NvUnavailable = RC_WARN + 0x023,

    /// This value is reserved and shall not be returned by the TPM
    NotUsed = RC_WARN + 0x7F,

    /// Add to a handle-related error
    H = 0x000,

    /// Add to a parameter-related error
    P = 0x040,

    /// Add to a session-related error
    S = 0x800,

    /// Add to a parameter-, handle-, or session-related error
    1 = 0x100,

    /// Add to a parameter-, handle-, or session-related error
    2 = 0x200,

    /// Add to a parameter-, handle-, or session-related error
    3 = 0x300,

    /// Add to a parameter-, handle-, or session-related error
    4 = 0x400,

    /// Add to a parameter-, handle-, or session-related error
    5 = 0x500,

    /// Add to a parameter-, handle-, or session-related error
    6 = 0x600,

    /// Add to a parameter-, handle-, or session-related error
    7 = 0x700,

    /// Add to a parameter-related error
    8 = 0x800,

    /// Add to a parameter-related error
    9 = 0x900,

    /// Add to a parameter-related error
    A = 0xA00,

    /// Add to a parameter-related error
    B = 0xB00,

    /// Add to a parameter-related error
    C = 0xC00,

    /// Add to a parameter-related error
    D = 0xD00,

    /// Add to a parameter-related error
    E = 0xE00,

    /// Add to a parameter-related error
    F = 0xF00,

    /// Number mask
    NMask = 0xF00,

    /// Response buffer returned by the TPM is too short
    TssTcpBadHandshakeResp = 0x40280001,

    /// Too old TCP server version
    TssTcpServerTooOld = 0x40280002,

    /// Bad ack from the TCP end point
    TssTcpBadAck = 0x40280003,

    /// Wrong length of the response buffer returned by the TPM
    TssTcpBadRespLen = 0x40280004,

    /// TPM2_Startup returned unexpected response code
    TssTcpUnexpectedStartupResp = 0x40280005,

    /// Invalid size tag in the TPM response TCP packet
    TssTcpInvalidSizeTag = 0x40280006,

    /// TPM over TCP device is not connected
    TssTcpDisconnected = 0x40280007,

    /// General TPM command dispatch failure
    TssDispatchFailed = 0x40280010,

    /// Sending data to TPM failed
    TssSendOpFailed = 0x40280011,

    /// Response buffer returned by the TPM is too short
    TssRespBufTooShort = 0x40280021,

    /// Invalid tag in the response buffer returned by the TPM
    TssRespBufInvalidSessionTag = 0x40280022,

    /// Inconsistent TPM response parameters size
    TssRespBufInvalidSize = 0x40280023,

    /// Windows TBS error TPM_E_COMMAND_BLOCKED
    TbsCommandBlocked = 0x80280400,

    /// Windows TBS error TPM_E_INVALID_HANDLE
    TbsInvalidHandle = 0x80280401,

    /// Windows TBS error TPM_E_DUPLICATE_VHANDLE
    TbsDuplicateVHandle = 0x80280402,

    /// Windows TBS error TPM_E_EMBEDDED_COMMAND_BLOCKED
    TbsEmbeddedCommandBlocked = 0x80280403,

    /// Windows TBS error TPM_E_EMBEDDED_COMMAND_UNSUPPORTED
    TbsEmbeddedCommandUnsupported = 0x80280404,

    /// Windows TBS returned success but empty response buffer
    TbsUnknownError = 0x80284000,

    /// Windows TBS error TBS_E_INTERNAL_ERROR
    TbsInternalError = 0x80284001,

    /// Windows TBS error TBS_E_BAD_PARAMETER
    TbsBadParameter = 0x80284002,

    /// Windows TBS error TBS_E_INVALID_OUTPUT_POINTER
    TbsInvalidOutputPointer = 0x80284003,

    /// Windows TBS error TBS_E_INVALID_CONTEXT
    TbsInvalidContext = 0x80284004,

    /// Windows TBS error TBS_E_INSUFFICIENT_BUFFER
    TbsInsufficientBuffer = 0x80284005,

    /// Windows TBS error TBS_E_IOERROR
    TbsIoError = 0x80284006,

    /// Windows TBS error TBS_E_INVALID_CONTEXT_PARAM
    TbsInvalidContextParam = 0x80284007,

    /// Windows TBS error TBS_E_SERVICE_NOT_RUNNING
    TbsServiceNotRunning = 0x80284008,

    /// Windows TBS error TBS_E_TOO_MANY_TBS_CONTEXTS
    TbsTooManyContexts = 0x80284009,

    /// Windows TBS error TBS_E_TOO_MANY_TBS_RESOURCES
    TbsTooManyResources = 0x8028400A,

    /// Windows TBS error TBS_E_SERVICE_START_PENDING
    TbsServiceStartPending = 0x8028400B,

    /// Windows TBS error TBS_E_PPI_NOT_SUPPORTED
    TbsPpiNotSupported = 0x8028400C,

    /// Windows TBS error TBS_E_COMMAND_CANCELED
    TbsCommandCanceled = 0x8028400D,

    /// Windows TBS error TBS_E_BUFFER_TOO_LARGE
    TbsBufferTooLarge = 0x8028400E,

    /// Windows TBS error TBS_E_TPM_NOT_FOUND
    TbsTpmNotFound = 0x8028400F,

    /// Windows TBS error TBS_E_SERVICE_DISABLED
    TbsServiceDisabled = 0x80284010,

    /// Windows TBS error TBS_E_ACCESS_DENIED
    TbsAccessDenied = 0x80284012,

    /// Windows TBS error TBS_E_PPI_FUNCTION_UNSUPPORTED
    TbsPpiFunctionNotSupported = 0x80284014,

    /// Windows TBS error TBS_E_OWNERAUTH_NOT_FOUND
    TbsOwnerAuthNotFound = 0x80284015
}

impl TryFrom<u32> for TPM_RC {
    type Error = TpmError;

    fn try_from(value: u32) -> Result<Self, Self::Error> {
        match value {
            0x000 => Ok(Self::SUCCESS),
            0x01E => Ok(Self::BadTag),
            0x100 => Ok(Self::RcVer1),
            RC_VER1 + 0x000 => Ok(Self::INITIALIZE),
            RC_VER1 + 0x001 => Ok(Self::FAILURE),
            RC_VER1 + 0x003 => Ok(Self::SEQUENCE),
            RC_VER1 + 0x00B => Ok(Self::PRIVATE),
            RC_VER1 + 0x019 => Ok(Self::HMAC),
            RC_VER1 + 0x020 => Ok(Self::DISABLED),
            RC_VER1 + 0x021 => Ok(Self::EXCLUSIVE),
            RC_VER1 + 0x024 => Ok(Self::AuthType),
            RC_VER1 + 0x025 => Ok(Self::AuthMissing),
            RC_VER1 + 0x026 => Ok(Self::POLICY),
            RC_VER1 + 0x027 => Ok(Self::PCR),
            RC_VER1 + 0x028 => Ok(Self::PcrChanged),
            RC_VER1 + 0x02D => Ok(Self::UPGRADE),
            RC_VER1 + 0x02E => Ok(Self::TooManyContexts),
            RC_VER1 + 0x02F => Ok(Self::AuthUnavailable),
            RC_VER1 + 0x030 => Ok(Self::REBOOT),
            RC_VER1 + 0x031 => Ok(Self::UNBALANCED),
            RC_VER1 + 0x042 => Ok(Self::CommandSize),
            RC_VER1 + 0x043 => Ok(Self::CommandCode),
            RC_VER1 + 0x044 => Ok(Self::AUTHSIZE),
            RC_VER1 + 0x045 => Ok(Self::AuthContext),
            RC_VER1 + 0x046 => Ok(Self::NvRange),
            RC_VER1 + 0x047 => Ok(Self::NvSize),
            RC_VER1 + 0x048 => Ok(Self::NvLocked),
            RC_VER1 + 0x049 => Ok(Self::NvAuthorization),
            RC_VER1 + 0x04A => Ok(Self::NvUninitialized),
            RC_VER1 + 0x04B => Ok(Self::NvSpace),
            RC_VER1 + 0x04C => Ok(Self::NvDefined),
            RC_VER1 + 0x050 => Ok(Self::BadContext),
            RC_VER1 + 0x051 => Ok(Self::CPHASH),
            RC_VER1 + 0x052 => Ok(Self::PARENT),
            RC_VER1 + 0x053 => Ok(Self::NeedsTest),
            RC_VER1 + 0x054 => Ok(Self::NoResult),
            RC_VER1 + 0x055 => Ok(Self::SENSITIVE),
            RC_VER1 + 0x07F => Ok(Self::RcMaxFm0),
            0x080 => Ok(Self::RcFmt1),
            RC_FMT1 + 0x001 => Ok(Self::ASYMMETRIC),
            RC_FMT1 + 0x002 => Ok(Self::ATTRIBUTES),
            RC_FMT1 + 0x003 => Ok(Self::HASH),
            RC_FMT1 + 0x004 => Ok(Self::VALUE),
            RC_FMT1 + 0x005 => Ok(Self::HIERARCHY),
            RC_FMT1 + 0x007 => Ok(Self::KeySize),
            RC_FMT1 + 0x008 => Ok(Self::MGF),
            RC_FMT1 + 0x009 => Ok(Self::MODE),
            RC_FMT1 + 0x00A => Ok(Self::TYPE),
            RC_FMT1 + 0x00B => Ok(Self::HANDLE),
            RC_FMT1 + 0x00C => Ok(Self::KDF),
            RC_FMT1 + 0x00D => Ok(Self::RANGE),
            RC_FMT1 + 0x00E => Ok(Self::AuthFail),
            RC_FMT1 + 0x00F => Ok(Self::NONCE),
            RC_FMT1 + 0x010 => Ok(Self::PP),
            RC_FMT1 + 0x012 => Ok(Self::SCHEME),
            RC_FMT1 + 0x015 => Ok(Self::SIZE),
            RC_FMT1 + 0x016 => Ok(Self::SYMMETRIC),
            RC_FMT1 + 0x017 => Ok(Self::TAG),
            RC_FMT1 + 0x018 => Ok(Self::SELECTOR),
            RC_FMT1 + 0x01A => Ok(Self::INSUFFICIENT),
            RC_FMT1 + 0x01B => Ok(Self::SIGNATURE),
            RC_FMT1 + 0x01C => Ok(Self::KEY),
            RC_FMT1 + 0x01D => Ok(Self::PolicyFail),
            RC_FMT1 + 0x01F => Ok(Self::INTEGRITY),
            RC_FMT1 + 0x020 => Ok(Self::TICKET),
            RC_FMT1 + 0x021 => Ok(Self::ReservedBits),
            RC_FMT1 + 0x022 => Ok(Self::BadAuth),
            RC_FMT1 + 0x023 => Ok(Self::EXPIRED),
            RC_FMT1 + 0x024 => Ok(Self::PolicyCc),
            RC_FMT1 + 0x025 => Ok(Self::BINDING),
            RC_FMT1 + 0x026 => Ok(Self::CURVE),
            RC_FMT1 + 0x027 => Ok(Self::EccPoint),
            0x900 => Ok(Self::RcWarn),
            RC_WARN + 0x001 => Ok(Self::ContextGap),
            RC_WARN + 0x002 => Ok(Self::ObjectMemory),
            RC_WARN + 0x003 => Ok(Self::SessionMemory),
            RC_WARN + 0x004 => Ok(Self::MEMORY),
            RC_WARN + 0x005 => Ok(Self::SessionHandles),
            RC_WARN + 0x006 => Ok(Self::ObjectHandles),
            RC_WARN + 0x007 => Ok(Self::LOCALITY),
            RC_WARN + 0x008 => Ok(Self::YIELDED),
            RC_WARN + 0x009 => Ok(Self::CANCELED),
            RC_WARN + 0x00A => Ok(Self::TESTING),
            RC_WARN + 0x010 => Ok(Self::ReferenceH0),
            RC_WARN + 0x011 => Ok(Self::ReferenceH1),
            RC_WARN + 0x012 => Ok(Self::ReferenceH2),
            RC_WARN + 0x013 => Ok(Self::ReferenceH3),
            RC_WARN + 0x014 => Ok(Self::ReferenceH4),
            RC_WARN + 0x015 => Ok(Self::ReferenceH5),
            RC_WARN + 0x016 => Ok(Self::ReferenceH6),
            RC_WARN + 0x018 => Ok(Self::ReferenceS0),
            RC_WARN + 0x019 => Ok(Self::ReferenceS1),
            RC_WARN + 0x01A => Ok(Self::ReferenceS2),
            RC_WARN + 0x01B => Ok(Self::ReferenceS3),
            RC_WARN + 0x01C => Ok(Self::ReferenceS4),
            RC_WARN + 0x01D => Ok(Self::ReferenceS5),
            RC_WARN + 0x01E => Ok(Self::ReferenceS6),
            RC_WARN + 0x020 => Ok(Self::NvRate),
            RC_WARN + 0x021 => Ok(Self::LOCKOUT),
            RC_WARN + 0x022 => Ok(Self::RETRY),
            RC_WARN + 0x023 => Ok(Self::NvUnavailable),
            RC_WARN + 0x7F => Ok(Self::NotUsed),
            0x000 => Ok(Self::H),
            0x040 => Ok(Self::P),
            0x800 => Ok(Self::S),
            0x100 => Ok(Self::1),
            0x200 => Ok(Self::2),
            0x300 => Ok(Self::3),
            0x400 => Ok(Self::4),
            0x500 => Ok(Self::5),
            0x600 => Ok(Self::6),
            0x700 => Ok(Self::7),
            0x800 => Ok(Self::8),
            0x900 => Ok(Self::9),
            0xA00 => Ok(Self::A),
            0xB00 => Ok(Self::B),
            0xC00 => Ok(Self::C),
            0xD00 => Ok(Self::D),
            0xE00 => Ok(Self::E),
            0xF00 => Ok(Self::F),
            0xF00 => Ok(Self::NMask),
            0x40280001 => Ok(Self::TssTcpBadHandshakeResp),
            0x40280002 => Ok(Self::TssTcpServerTooOld),
            0x40280003 => Ok(Self::TssTcpBadAck),
            0x40280004 => Ok(Self::TssTcpBadRespLen),
            0x40280005 => Ok(Self::TssTcpUnexpectedStartupResp),
            0x40280006 => Ok(Self::TssTcpInvalidSizeTag),
            0x40280007 => Ok(Self::TssTcpDisconnected),
            0x40280010 => Ok(Self::TssDispatchFailed),
            0x40280011 => Ok(Self::TssSendOpFailed),
            0x40280021 => Ok(Self::TssRespBufTooShort),
            0x40280022 => Ok(Self::TssRespBufInvalidSessionTag),
            0x40280023 => Ok(Self::TssRespBufInvalidSize),
            0x80280400 => Ok(Self::TbsCommandBlocked),
            0x80280401 => Ok(Self::TbsInvalidHandle),
            0x80280402 => Ok(Self::TbsDuplicateVHandle),
            0x80280403 => Ok(Self::TbsEmbeddedCommandBlocked),
            0x80280404 => Ok(Self::TbsEmbeddedCommandUnsupported),
            0x80284000 => Ok(Self::TbsUnknownError),
            0x80284001 => Ok(Self::TbsInternalError),
            0x80284002 => Ok(Self::TbsBadParameter),
            0x80284003 => Ok(Self::TbsInvalidOutputPointer),
            0x80284004 => Ok(Self::TbsInvalidContext),
            0x80284005 => Ok(Self::TbsInsufficientBuffer),
            0x80284006 => Ok(Self::TbsIoError),
            0x80284007 => Ok(Self::TbsInvalidContextParam),
            0x80284008 => Ok(Self::TbsServiceNotRunning),
            0x80284009 => Ok(Self::TbsTooManyContexts),
            0x8028400A => Ok(Self::TbsTooManyResources),
            0x8028400B => Ok(Self::TbsServiceStartPending),
            0x8028400C => Ok(Self::TbsPpiNotSupported),
            0x8028400D => Ok(Self::TbsCommandCanceled),
            0x8028400E => Ok(Self::TbsBufferTooLarge),
            0x8028400F => Ok(Self::TbsTpmNotFound),
            0x80284010 => Ok(Self::TbsServiceDisabled),
            0x80284012 => Ok(Self::TbsAccessDenied),
            0x80284014 => Ok(Self::TbsPpiFunctionNotSupported),
            0x80284015 => Ok(Self::TbsOwnerAuthNotFound),
            _ => Err(TpmError::InvalidEnumValue),
        }

    }

}

impl fmt::Display for TPM_RC {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::SUCCESS => write!(f, "SUCCESS"),
            Self::BadTag => write!(f, "BadTag"),
            Self::RcVer1 => write!(f, "RcVer1"),
            Self::INITIALIZE => write!(f, "INITIALIZE"),
            Self::FAILURE => write!(f, "FAILURE"),
            Self::SEQUENCE => write!(f, "SEQUENCE"),
            Self::PRIVATE => write!(f, "PRIVATE"),
            Self::HMAC => write!(f, "HMAC"),
            Self::DISABLED => write!(f, "DISABLED"),
            Self::EXCLUSIVE => write!(f, "EXCLUSIVE"),
            Self::AuthType => write!(f, "AuthType"),
            Self::AuthMissing => write!(f, "AuthMissing"),
            Self::POLICY => write!(f, "POLICY"),
            Self::PCR => write!(f, "PCR"),
            Self::PcrChanged => write!(f, "PcrChanged"),
            Self::UPGRADE => write!(f, "UPGRADE"),
            Self::TooManyContexts => write!(f, "TooManyContexts"),
            Self::AuthUnavailable => write!(f, "AuthUnavailable"),
            Self::REBOOT => write!(f, "REBOOT"),
            Self::UNBALANCED => write!(f, "UNBALANCED"),
            Self::CommandSize => write!(f, "CommandSize"),
            Self::CommandCode => write!(f, "CommandCode"),
            Self::AUTHSIZE => write!(f, "AUTHSIZE"),
            Self::AuthContext => write!(f, "AuthContext"),
            Self::NvRange => write!(f, "NvRange"),
            Self::NvSize => write!(f, "NvSize"),
            Self::NvLocked => write!(f, "NvLocked"),
            Self::NvAuthorization => write!(f, "NvAuthorization"),
            Self::NvUninitialized => write!(f, "NvUninitialized"),
            Self::NvSpace => write!(f, "NvSpace"),
            Self::NvDefined => write!(f, "NvDefined"),
            Self::BadContext => write!(f, "BadContext"),
            Self::CPHASH => write!(f, "CPHASH"),
            Self::PARENT => write!(f, "PARENT"),
            Self::NeedsTest => write!(f, "NeedsTest"),
            Self::NoResult => write!(f, "NoResult"),
            Self::SENSITIVE => write!(f, "SENSITIVE"),
            Self::RcMaxFm0 => write!(f, "RcMaxFm0"),
            Self::RcFmt1 => write!(f, "RcFmt1"),
            Self::ASYMMETRIC => write!(f, "ASYMMETRIC"),
            Self::ATTRIBUTES => write!(f, "ATTRIBUTES"),
            Self::HASH => write!(f, "HASH"),
            Self::VALUE => write!(f, "VALUE"),
            Self::HIERARCHY => write!(f, "HIERARCHY"),
            Self::KeySize => write!(f, "KeySize"),
            Self::MGF => write!(f, "MGF"),
            Self::MODE => write!(f, "MODE"),
            Self::TYPE => write!(f, "TYPE"),
            Self::HANDLE => write!(f, "HANDLE"),
            Self::KDF => write!(f, "KDF"),
            Self::RANGE => write!(f, "RANGE"),
            Self::AuthFail => write!(f, "AuthFail"),
            Self::NONCE => write!(f, "NONCE"),
            Self::PP => write!(f, "PP"),
            Self::SCHEME => write!(f, "SCHEME"),
            Self::SIZE => write!(f, "SIZE"),
            Self::SYMMETRIC => write!(f, "SYMMETRIC"),
            Self::TAG => write!(f, "TAG"),
            Self::SELECTOR => write!(f, "SELECTOR"),
            Self::INSUFFICIENT => write!(f, "INSUFFICIENT"),
            Self::SIGNATURE => write!(f, "SIGNATURE"),
            Self::KEY => write!(f, "KEY"),
            Self::PolicyFail => write!(f, "PolicyFail"),
            Self::INTEGRITY => write!(f, "INTEGRITY"),
            Self::TICKET => write!(f, "TICKET"),
            Self::ReservedBits => write!(f, "ReservedBits"),
            Self::BadAuth => write!(f, "BadAuth"),
            Self::EXPIRED => write!(f, "EXPIRED"),
            Self::PolicyCc => write!(f, "PolicyCc"),
            Self::BINDING => write!(f, "BINDING"),
            Self::CURVE => write!(f, "CURVE"),
            Self::EccPoint => write!(f, "EccPoint"),
            Self::RcWarn => write!(f, "RcWarn"),
            Self::ContextGap => write!(f, "ContextGap"),
            Self::ObjectMemory => write!(f, "ObjectMemory"),
            Self::SessionMemory => write!(f, "SessionMemory"),
            Self::MEMORY => write!(f, "MEMORY"),
            Self::SessionHandles => write!(f, "SessionHandles"),
            Self::ObjectHandles => write!(f, "ObjectHandles"),
            Self::LOCALITY => write!(f, "LOCALITY"),
            Self::YIELDED => write!(f, "YIELDED"),
            Self::CANCELED => write!(f, "CANCELED"),
            Self::TESTING => write!(f, "TESTING"),
            Self::ReferenceH0 => write!(f, "ReferenceH0"),
            Self::ReferenceH1 => write!(f, "ReferenceH1"),
            Self::ReferenceH2 => write!(f, "ReferenceH2"),
            Self::ReferenceH3 => write!(f, "ReferenceH3"),
            Self::ReferenceH4 => write!(f, "ReferenceH4"),
            Self::ReferenceH5 => write!(f, "ReferenceH5"),
            Self::ReferenceH6 => write!(f, "ReferenceH6"),
            Self::ReferenceS0 => write!(f, "ReferenceS0"),
            Self::ReferenceS1 => write!(f, "ReferenceS1"),
            Self::ReferenceS2 => write!(f, "ReferenceS2"),
            Self::ReferenceS3 => write!(f, "ReferenceS3"),
            Self::ReferenceS4 => write!(f, "ReferenceS4"),
            Self::ReferenceS5 => write!(f, "ReferenceS5"),
            Self::ReferenceS6 => write!(f, "ReferenceS6"),
            Self::NvRate => write!(f, "NvRate"),
            Self::LOCKOUT => write!(f, "LOCKOUT"),
            Self::RETRY => write!(f, "RETRY"),
            Self::NvUnavailable => write!(f, "NvUnavailable"),
            Self::NotUsed => write!(f, "NotUsed"),
            Self::H => write!(f, "H"),
            Self::P => write!(f, "P"),
            Self::S => write!(f, "S"),
            Self::1 => write!(f, "1"),
            Self::2 => write!(f, "2"),
            Self::3 => write!(f, "3"),
            Self::4 => write!(f, "4"),
            Self::5 => write!(f, "5"),
            Self::6 => write!(f, "6"),
            Self::7 => write!(f, "7"),
            Self::8 => write!(f, "8"),
            Self::9 => write!(f, "9"),
            Self::A => write!(f, "A"),
            Self::B => write!(f, "B"),
            Self::C => write!(f, "C"),
            Self::D => write!(f, "D"),
            Self::E => write!(f, "E"),
            Self::F => write!(f, "F"),
            Self::NMask => write!(f, "NMask"),
            Self::TssTcpBadHandshakeResp => write!(f, "TssTcpBadHandshakeResp"),
            Self::TssTcpServerTooOld => write!(f, "TssTcpServerTooOld"),
            Self::TssTcpBadAck => write!(f, "TssTcpBadAck"),
            Self::TssTcpBadRespLen => write!(f, "TssTcpBadRespLen"),
            Self::TssTcpUnexpectedStartupResp => write!(f, "TssTcpUnexpectedStartupResp"),
            Self::TssTcpInvalidSizeTag => write!(f, "TssTcpInvalidSizeTag"),
            Self::TssTcpDisconnected => write!(f, "TssTcpDisconnected"),
            Self::TssDispatchFailed => write!(f, "TssDispatchFailed"),
            Self::TssSendOpFailed => write!(f, "TssSendOpFailed"),
            Self::TssRespBufTooShort => write!(f, "TssRespBufTooShort"),
            Self::TssRespBufInvalidSessionTag => write!(f, "TssRespBufInvalidSessionTag"),
            Self::TssRespBufInvalidSize => write!(f, "TssRespBufInvalidSize"),
            Self::TbsCommandBlocked => write!(f, "TbsCommandBlocked"),
            Self::TbsInvalidHandle => write!(f, "TbsInvalidHandle"),
            Self::TbsDuplicateVHandle => write!(f, "TbsDuplicateVHandle"),
            Self::TbsEmbeddedCommandBlocked => write!(f, "TbsEmbeddedCommandBlocked"),
            Self::TbsEmbeddedCommandUnsupported => write!(f, "TbsEmbeddedCommandUnsupported"),
            Self::TbsUnknownError => write!(f, "TbsUnknownError"),
            Self::TbsInternalError => write!(f, "TbsInternalError"),
            Self::TbsBadParameter => write!(f, "TbsBadParameter"),
            Self::TbsInvalidOutputPointer => write!(f, "TbsInvalidOutputPointer"),
            Self::TbsInvalidContext => write!(f, "TbsInvalidContext"),
            Self::TbsInsufficientBuffer => write!(f, "TbsInsufficientBuffer"),
            Self::TbsIoError => write!(f, "TbsIoError"),
            Self::TbsInvalidContextParam => write!(f, "TbsInvalidContextParam"),
            Self::TbsServiceNotRunning => write!(f, "TbsServiceNotRunning"),
            Self::TbsTooManyContexts => write!(f, "TbsTooManyContexts"),
            Self::TbsTooManyResources => write!(f, "TbsTooManyResources"),
            Self::TbsServiceStartPending => write!(f, "TbsServiceStartPending"),
            Self::TbsPpiNotSupported => write!(f, "TbsPpiNotSupported"),
            Self::TbsCommandCanceled => write!(f, "TbsCommandCanceled"),
            Self::TbsBufferTooLarge => write!(f, "TbsBufferTooLarge"),
            Self::TbsTpmNotFound => write!(f, "TbsTpmNotFound"),
            Self::TbsServiceDisabled => write!(f, "TbsServiceDisabled"),
            Self::TbsAccessDenied => write!(f, "TbsAccessDenied"),
            Self::TbsPpiFunctionNotSupported => write!(f, "TbsPpiFunctionNotSupported"),
            Self::TbsOwnerAuthNotFound => write!(f, "TbsOwnerAuthNotFound"),
        }

    }

}

/// A TPM_CLOCK_ADJUST value is used to change the rate at which the TPM internal
/// oscillator is divided. A change to the divider will change the rate at which Clock and
/// Time change.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum TPM_CLOCK_ADJUST {
    /// Slow the Clock update rate by one coarse adjustment step.
    CoarseSlower = -3,

    /// Slow the Clock update rate by one medium adjustment step.
    MediumSlower = -2,

    /// Slow the Clock update rate by one fine adjustment step.
    FineSlower = -1,

    /// No change to the Clock update rate.
    NoChange = 0,

    /// Speed the Clock update rate by one fine adjustment step.
    FineFaster = 1,

    /// Speed the Clock update rate by one medium adjustment step.
    MediumFaster = 2,

    /// Speed the Clock update rate by one coarse adjustment step.
    CoarseFaster = 3
}

impl TryFrom<u8> for TPM_CLOCK_ADJUST {
    type Error = TpmError;

    fn try_from(value: u8) -> Result<Self, Self::Error> {
        match value {
            -3 => Ok(Self::CoarseSlower),
            -2 => Ok(Self::MediumSlower),
            -1 => Ok(Self::FineSlower),
            0 => Ok(Self::NoChange),
            1 => Ok(Self::FineFaster),
            2 => Ok(Self::MediumFaster),
            3 => Ok(Self::CoarseFaster),
            _ => Err(TpmError::InvalidEnumValue),
        }

    }

}

impl fmt::Display for TPM_CLOCK_ADJUST {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::CoarseSlower => write!(f, "CoarseSlower"),
            Self::MediumSlower => write!(f, "MediumSlower"),
            Self::FineSlower => write!(f, "FineSlower"),
            Self::NoChange => write!(f, "NoChange"),
            Self::FineFaster => write!(f, "FineFaster"),
            Self::MediumFaster => write!(f, "MediumFaster"),
            Self::CoarseFaster => write!(f, "CoarseFaster"),
        }

    }

}

/// Table 18 Definition of (UINT16) TPM_EO Constants [IN/OUT]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u16)]
pub enum TPM_EO {
    /// A = B
    EQ = 0x0000,

    /// A B
    NEQ = 0x0001,

    /// A  B signed
    SignedGt = 0x0002,

    /// A  B unsigned
    UnsignedGt = 0x0003,

    /// A  B signed
    SignedLt = 0x0004,

    /// A  B unsigned
    UnsignedLt = 0x0005,

    /// A B signed
    SignedGe = 0x0006,

    /// A B unsigned
    UnsignedGe = 0x0007,

    /// A B signed
    SignedLe = 0x0008,

    /// A B unsigned
    UnsignedLe = 0x0009,

    /// All bits SET in B are SET in A. ((AB)=B)
    BITSET = 0x000A,

    /// All bits SET in B are CLEAR in A. ((AB)=0)
    BITCLEAR = 0x000B
}

impl TryFrom<u16> for TPM_EO {
    type Error = TpmError;

    fn try_from(value: u16) -> Result<Self, Self::Error> {
        match value {
            0x0000 => Ok(Self::EQ),
            0x0001 => Ok(Self::NEQ),
            0x0002 => Ok(Self::SignedGt),
            0x0003 => Ok(Self::UnsignedGt),
            0x0004 => Ok(Self::SignedLt),
            0x0005 => Ok(Self::UnsignedLt),
            0x0006 => Ok(Self::SignedGe),
            0x0007 => Ok(Self::UnsignedGe),
            0x0008 => Ok(Self::SignedLe),
            0x0009 => Ok(Self::UnsignedLe),
            0x000A => Ok(Self::BITSET),
            0x000B => Ok(Self::BITCLEAR),
            _ => Err(TpmError::InvalidEnumValue),
        }

    }

}

impl fmt::Display for TPM_EO {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::EQ => write!(f, "EQ"),
            Self::NEQ => write!(f, "NEQ"),
            Self::SignedGt => write!(f, "SignedGt"),
            Self::UnsignedGt => write!(f, "UnsignedGt"),
            Self::SignedLt => write!(f, "SignedLt"),
            Self::UnsignedLt => write!(f, "UnsignedLt"),
            Self::SignedGe => write!(f, "SignedGe"),
            Self::UnsignedGe => write!(f, "UnsignedGe"),
            Self::SignedLe => write!(f, "SignedLe"),
            Self::UnsignedLe => write!(f, "UnsignedLe"),
            Self::BITSET => write!(f, "BITSET"),
            Self::BITCLEAR => write!(f, "BITCLEAR"),
        }

    }

}

/// Structure tags are used to disambiguate structures. They are 16-bit values with the
/// most significant bit SET so that they do not overlap TPM_ALG_ID values. A single
/// exception is made for the value associated with TPM_ST_RSP_COMMAND (0x00C4), which has
/// the same value as the TPM_TAG_RSP_COMMAND tag from earlier versions of this
/// specification. This value is used when the TPM is compatible with a previous TPM
/// specification and the TPM cannot determine which family of response code to return
/// because the command tag is not valid.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u16)]
pub enum TPM_ST {
    /// Tag value for a response; used when there is an error in the tag. This is also the
    /// value returned from a TPM 1.2 when an error occurs. This value is used in this
    /// specification because an error in the command tag may prevent determination of the
    /// family. When this tag is used in the response, the response code will be
    /// TPM_RC_BAD_TAG (0 1E16), which has the same numeric value as the TPM 1.2 response code
    /// for TPM_BADTAG.
    /// NOTE In a previously published version of this specification, TPM_RC_BAD_TAG was
    /// incorrectly assigned a value of 0x030 instead of 30 (0x01e). Some implementations my
    /// return the old value instead of the new value.
    RspCommand = 0x00C4,

    /// No structure type specified
    NULL = 0X8000,

    /// Tag value for a command/response for a command defined in this specification;
    /// indicating that the command/response has no attached sessions and no
    /// authorizationSize/parameterSize value is present
    /// If the responseCode from the TPM is not TPM_RC_SUCCESS, then the response tag shall
    /// have this value.
    NoSessions = 0x8001,

    /// Tag value for a command/response for a command defined in this specification;
    /// indicating that the command/response has one or more attached sessions and the
    /// authorizationSize/parameterSize field is present
    SESSIONS = 0x8002,

    /// Tag for an attestation structure
    AttestNv = 0x8014,

    /// Tag for an attestation structure
    AttestCommandAudit = 0x8015,

    /// Tag for an attestation structure
    AttestSessionAudit = 0x8016,

    /// Tag for an attestation structure
    AttestCertify = 0x8017,

    /// Tag for an attestation structure
    AttestQuote = 0x8018,

    /// Tag for an attestation structure
    AttestTime = 0x8019,

    /// Tag for an attestation structure
    AttestCreation = 0x801A,

    /// Tag for an attestation structure
    AttestNvDigest = 0x801C,

    /// Tag for a ticket type
    CREATION = 0x8021,

    /// Tag for a ticket type
    VERIFIED = 0x8022,

    /// Tag for a ticket type
    AuthSecret = 0x8023,

    /// Tag for a ticket type
    HASHCHECK = 0x8024,

    /// Tag for a ticket type
    AuthSigned = 0x8025,

    /// Tag for a structure describing a Field Upgrade Policy
    FuManifest = 0x8029
}

impl TryFrom<u16> for TPM_ST {
    type Error = TpmError;

    fn try_from(value: u16) -> Result<Self, Self::Error> {
        match value {
            0x00C4 => Ok(Self::RspCommand),
            0X8000 => Ok(Self::NULL),
            0x8001 => Ok(Self::NoSessions),
            0x8002 => Ok(Self::SESSIONS),
            0x8014 => Ok(Self::AttestNv),
            0x8015 => Ok(Self::AttestCommandAudit),
            0x8016 => Ok(Self::AttestSessionAudit),
            0x8017 => Ok(Self::AttestCertify),
            0x8018 => Ok(Self::AttestQuote),
            0x8019 => Ok(Self::AttestTime),
            0x801A => Ok(Self::AttestCreation),
            0x801C => Ok(Self::AttestNvDigest),
            0x8021 => Ok(Self::CREATION),
            0x8022 => Ok(Self::VERIFIED),
            0x8023 => Ok(Self::AuthSecret),
            0x8024 => Ok(Self::HASHCHECK),
            0x8025 => Ok(Self::AuthSigned),
            0x8029 => Ok(Self::FuManifest),
            _ => Err(TpmError::InvalidEnumValue),
        }

    }

}

impl fmt::Display for TPM_ST {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::RspCommand => write!(f, "RspCommand"),
            Self::NULL => write!(f, "NULL"),
            Self::NoSessions => write!(f, "NoSessions"),
            Self::SESSIONS => write!(f, "SESSIONS"),
            Self::AttestNv => write!(f, "AttestNv"),
            Self::AttestCommandAudit => write!(f, "AttestCommandAudit"),
            Self::AttestSessionAudit => write!(f, "AttestSessionAudit"),
            Self::AttestCertify => write!(f, "AttestCertify"),
            Self::AttestQuote => write!(f, "AttestQuote"),
            Self::AttestTime => write!(f, "AttestTime"),
            Self::AttestCreation => write!(f, "AttestCreation"),
            Self::AttestNvDigest => write!(f, "AttestNvDigest"),
            Self::CREATION => write!(f, "CREATION"),
            Self::VERIFIED => write!(f, "VERIFIED"),
            Self::AuthSecret => write!(f, "AuthSecret"),
            Self::HASHCHECK => write!(f, "HASHCHECK"),
            Self::AuthSigned => write!(f, "AuthSigned"),
            Self::FuManifest => write!(f, "FuManifest"),
        }

    }

}

/// These values are used in TPM2_Startup() to indicate the shutdown and startup mode. The
/// defined startup sequences are:
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u16)]
pub enum TPM_SU {
    /// On TPM2_Shutdown(), indicates that the TPM should prepare for loss of power and save
    /// state required for an orderly startup (TPM Reset).
    /// on TPM2_Startup(), indicates that the TPM should perform TPM Reset or TPM Restart
    CLEAR = 0x0000,

    /// On TPM2_Shutdown(), indicates that the TPM should prepare for loss of power and save
    /// state required for an orderly startup (TPM Restart or TPM Resume)
    /// on TPM2_Startup(), indicates that the TPM should restore the state saved by
    /// TPM2_Shutdown(TPM_SU_STATE)
    STATE = 0x0001
}

impl TryFrom<u16> for TPM_SU {
    type Error = TpmError;

    fn try_from(value: u16) -> Result<Self, Self::Error> {
        match value {
            0x0000 => Ok(Self::CLEAR),
            0x0001 => Ok(Self::STATE),
            _ => Err(TpmError::InvalidEnumValue),
        }

    }

}

impl fmt::Display for TPM_SU {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::CLEAR => write!(f, "CLEAR"),
            Self::STATE => write!(f, "STATE"),
        }

    }

}

/// This type is used in TPM2_StartAuthSession() to indicate the type of the session to be
/// created.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum TPM_SE {
    HMAC = 0x00,
    POLICY = 0x01,

    /// The policy session is being used to compute the policyHash and not for command authorization.
    /// This setting modifies some policy commands and prevents session from being used to
    /// authorize a command.
    TRIAL = 0x03
}

impl TryFrom<u8> for TPM_SE {
    type Error = TpmError;

    fn try_from(value: u8) -> Result<Self, Self::Error> {
        match value {
            0x00 => Ok(Self::HMAC),
            0x01 => Ok(Self::POLICY),
            0x03 => Ok(Self::TRIAL),
            _ => Err(TpmError::InvalidEnumValue),
        }

    }

}

impl fmt::Display for TPM_SE {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::HMAC => write!(f, "HMAC"),
            Self::POLICY => write!(f, "POLICY"),
            Self::TRIAL => write!(f, "TRIAL"),
        }

    }

}

/// The TPM_CAP values are used in TPM2_GetCapability() to select the type of the value to
/// be returned. The format of the response varies according to the type of the value.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u32)]
pub enum TPM_CAP {
    FIRST = 0x00000000,

    /// TPML_ALG_PROPERTY
    ALGS = 0x00000000,

    /// TPML_HANDLE
    HANDLES = 0x00000001,

    /// TPML_CCA
    COMMANDS = 0x00000002,

    /// TPML_CC
    PpCommands = 0x00000003,

    /// TPML_CC
    AuditCommands = 0x00000004,

    /// TPML_PCR_SELECTION
    PCRS = 0x00000005,

    /// TPML_TAGGED_TPM_PROPERTY
    TpmProperties = 0x00000006,

    /// TPML_TAGGED_PCR_PROPERTY
    PcrProperties = 0x00000007,

    /// TPML_ECC_CURVE
    EccCurves = 0x00000008,

    /// TPML_TAGGED_POLICY
    AuthPolicies = 0x00000009,

    /// TPML_ACT_DATA
    ACT = 0x0000000A,
    LAST = 0x0000000A,

    /// Manufacturer-specific values
    VendorProperty = 0x00000100
}

impl TryFrom<u32> for TPM_CAP {
    type Error = TpmError;

    fn try_from(value: u32) -> Result<Self, Self::Error> {
        match value {
            0x00000000 => Ok(Self::FIRST),
            0x00000000 => Ok(Self::ALGS),
            0x00000001 => Ok(Self::HANDLES),
            0x00000002 => Ok(Self::COMMANDS),
            0x00000003 => Ok(Self::PpCommands),
            0x00000004 => Ok(Self::AuditCommands),
            0x00000005 => Ok(Self::PCRS),
            0x00000006 => Ok(Self::TpmProperties),
            0x00000007 => Ok(Self::PcrProperties),
            0x00000008 => Ok(Self::EccCurves),
            0x00000009 => Ok(Self::AuthPolicies),
            0x0000000A => Ok(Self::ACT),
            0x0000000A => Ok(Self::LAST),
            0x00000100 => Ok(Self::VendorProperty),
            _ => Err(TpmError::InvalidEnumValue),
        }

    }

}

impl fmt::Display for TPM_CAP {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::FIRST => write!(f, "FIRST"),
            Self::ALGS => write!(f, "ALGS"),
            Self::HANDLES => write!(f, "HANDLES"),
            Self::COMMANDS => write!(f, "COMMANDS"),
            Self::PpCommands => write!(f, "PpCommands"),
            Self::AuditCommands => write!(f, "AuditCommands"),
            Self::PCRS => write!(f, "PCRS"),
            Self::TpmProperties => write!(f, "TpmProperties"),
            Self::PcrProperties => write!(f, "PcrProperties"),
            Self::EccCurves => write!(f, "EccCurves"),
            Self::AuthPolicies => write!(f, "AuthPolicies"),
            Self::ACT => write!(f, "ACT"),
            Self::LAST => write!(f, "LAST"),
            Self::VendorProperty => write!(f, "VendorProperty"),
        }

    }

}

/// The TPM_PT constants are used in TPM2_GetCapability(capability =
/// TPM_CAP_TPM_PROPERTIES) to indicate the property being selected or returned.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u32)]
pub enum TPM_PT {
    /// Indicates no property type
    NONE = 0x00000000,

    /// The number of properties in each group.
    /// NOTE The first group with any properties is group 1 (PT_GROUP * 1). Group 0 is reserved.
    PtGroup = 0x00000100,

    /// The group of fixed properties returned as TPMS_TAGGED_PROPERTY
    /// The values in this group are only changed due to a firmware change in the TPM.
    PtFixed = PT_GROUP * 1,

    /// A 4-octet character string containing the TPM Family value (TPM_SPEC_FAMILY)
    FamilyIndicator = PT_FIXED + 0,

    /// The level of the specification
    /// NOTE 1 For this specification, the level is zero.
    /// NOTE 2 The level is on the title page of the specification.
    LEVEL = PT_FIXED + 1,

    /// The specification Revision times 100
    /// EXAMPLE Revision 01.01 would have a value of 101.
    /// NOTE The Revision value is on the title page of the specification.
    REVISION = PT_FIXED + 2,

    /// The specification day of year using TCG calendar
    /// EXAMPLE November 15, 2010, has a day of year value of 319 (0000013F16).
    /// NOTE The specification date is on the title page of the specification or errata (see 6.1).
    DayOfYear = PT_FIXED + 3,

    /// The specification year using the CE
    /// EXAMPLE The year 2010 has a value of 000007DA16.
    /// NOTE The specification date is on the title page of the specification or errata (see 6.1).
    YEAR = PT_FIXED + 4,

    /// The vendor ID unique to each TPM manufacturer
    MANUFACTURER = PT_FIXED + 5,

    /// The first four characters of the vendor ID string
    /// NOTE When the vendor string is fewer than 16 octets, the additional property values do
    /// not have to be present. A vendor string of 4 octets can be represented in one 32-bit
    /// value and no null terminating character is required.
    VendorString1 = PT_FIXED + 6,

    /// The second four characters of the vendor ID string
    VendorString2 = PT_FIXED + 7,

    /// The third four characters of the vendor ID string
    VendorString3 = PT_FIXED + 8,

    /// The fourth four characters of the vendor ID sting
    VendorString4 = PT_FIXED + 9,

    /// Vendor-defined value indicating the TPM model
    VendorTpmType = PT_FIXED + 10,

    /// The most-significant 32 bits of a TPM vendor-specific value indicating the version
    /// number of the firmware. See 10.12.2 and 10.12.12.
    FirmwareVersion1 = PT_FIXED + 11,

    /// The least-significant 32 bits of a TPM vendor-specific value indicating the version
    /// number of the firmware. See 10.12.2 and 10.12.12.
    FirmwareVersion2 = PT_FIXED + 12,

    /// The maximum size of a parameter (typically, a TPM2B_MAX_BUFFER)
    InputBuffer = PT_FIXED + 13,

    /// The minimum number of transient objects that can be held in TPM RAM
    /// NOTE This minimum shall be no less than the minimum value required by the
    /// platform-specific specification to which the TPM is built.
    HrTransientMin = PT_FIXED + 14,

    /// The minimum number of persistent objects that can be held in TPM NV memory
    /// NOTE This minimum shall be no less than the minimum value required by the
    /// platform-specific specification to which the TPM is built.
    HrPersistentMin = PT_FIXED + 15,

    /// The minimum number of authorization sessions that can be held in TPM RAM
    /// NOTE This minimum shall be no less than the minimum value required by the
    /// platform-specific specification to which the TPM is built.
    HrLoadedMin = PT_FIXED + 16,

    /// The number of authorization sessions that may be active at a time
    /// A session is active when it has a context associated with its handle. The context may
    /// either be in TPM RAM or be context saved.
    /// NOTE This value shall be no less than the minimum value required by the
    /// platform-specific specification to which the TPM is built.
    ActiveSessionsMax = PT_FIXED + 17,

    /// The number of PCR implemented
    /// NOTE This number is determined by the defined attributes, not the number of PCR that
    /// are populated.
    PcrCount = PT_FIXED + 18,

    /// The minimum number of octets in a TPMS_PCR_SELECT.sizeOfSelect
    /// NOTE This value is not determined by the number of PCR implemented but by the number
    /// of PCR required by the platform-specific specification with which the TPM is compliant
    /// or by the implementer if not adhering to a platform-specific specification.
    PcrSelectMin = PT_FIXED + 19,

    /// The maximum allowed difference (unsigned) between the contextID values of two saved
    /// session contexts
    /// This value shall be 2n-1, where n is at least 16.
    ContextGapMax = PT_FIXED + 20,

    /// The maximum number of NV Indexes that are allowed to have the TPM_NT_COUNTER attribute
    /// NOTE 1 It is allowed for this value to be larger than the number of NV Indexes that
    /// can be defined. This would be indicative of a TPM implementation that did not use
    /// different implementation technology for different NV Index types.
    /// NOTE 2 The value zero indicates that there is no fixed maximum. The number of counter
    /// indexes is determined by the available NV memory pool.
    NvCountersMax = PT_FIXED + 22,

    /// The maximum size of an NV Index data area
    NvIndexMax = PT_FIXED + 23,

    /// A TPMA_MEMORY indicating the memory management method for the TPM
    MEMORY = PT_FIXED + 24,

    /// Interval, in milliseconds, between updates to the copy of TPMS_CLOCK_INFO.clock in NV
    ClockUpdate = PT_FIXED + 25,

    /// The algorithm used for the integrity HMAC on saved contexts and for hashing the fuData
    /// of TPM2_FirmwareRead()
    ContextHash = PT_FIXED + 26,

    /// TPM_ALG_ID, the algorithm used for encryption of saved contexts
    ContextSym = PT_FIXED + 27,

    /// TPM_KEY_BITS, the size of the key used for encryption of saved contexts
    ContextSymSize = PT_FIXED + 28,

    /// The modulus - 1 of the count for NV update of an orderly counter
    /// The returned value is MAX_ORDERLY_COUNT.
    /// This will have a value of 2N 1 where 1 N 32
    /// NOTE 1 An orderly counter is an NV Index with an TPM_NT of TPM_NV_COUNTER and
    /// TPMA_NV_ORDERLY SET.
    /// NOTE 2 When the low-order bits of a counter equal this value, an NV write occurs on
    /// the next increment.
    OrderlyCount = PT_FIXED + 29,

    /// The maximum value for commandSize in a command
    MaxCommandSize = PT_FIXED + 30,

    /// The maximum value for responseSize in a response
    MaxResponseSize = PT_FIXED + 31,

    /// The maximum size of a digest that can be produced by the TPM
    MaxDigest = PT_FIXED + 32,

    /// The maximum size of an object context that will be returned by TPM2_ContextSave
    MaxObjectContext = PT_FIXED + 33,

    /// The maximum size of a session context that will be returned by TPM2_ContextSave
    MaxSessionContext = PT_FIXED + 34,

    /// Platform-specific family (a TPM_PS value)(see Table 25)
    /// NOTE The platform-specific values for the TPM_PT_PS parameters are in the relevant
    /// platform-specific specification. In the reference implementation, all of these values
    /// are 0.
    PsFamilyIndicator = PT_FIXED + 35,

    /// The level of the platform-specific specification
    PsLevel = PT_FIXED + 36,

    /// A platform specific value
    PsRevision = PT_FIXED + 37,

    /// The platform-specific TPM specification day of year using TCG calendar
    /// EXAMPLE November 15, 2010, has a day of year value of 319 (0000013F16).
    PsDayOfYear = PT_FIXED + 38,

    /// The platform-specific TPM specification year using the CE
    /// EXAMPLE The year 2010 has a value of 000007DA16.
    PsYear = PT_FIXED + 39,

    /// The number of split signing operations supported by the TPM
    SplitMax = PT_FIXED + 40,

    /// Total number of commands implemented in the TPM
    TotalCommands = PT_FIXED + 41,

    /// Number of commands from the TPM library that are implemented
    LibraryCommands = PT_FIXED + 42,

    /// Number of vendor commands that are implemented
    VendorCommands = PT_FIXED + 43,

    /// The maximum data size in one NV write, NV read, NV extend, or NV certify command
    NvBufferMax = PT_FIXED + 44,

    /// A TPMA_MODES value, indicating that the TPM is designed for these modes.
    MODES = PT_FIXED + 45,

    /// The maximum size of a TPMS_CAPABILITY_DATA structure returned in TPM2_GetCapability().
    MaxCapBuffer = PT_FIXED + 46,

    /// The group of variable properties returned as TPMS_TAGGED_PROPERTY
    /// The properties in this group change because of a Protected Capability other than a
    /// firmware update. The values are not necessarily persistent across all power transitions.
    PtVar = PT_GROUP * 2,

    /// TPMA_PERMANENT
    PERMANENT = PT_VAR + 0,

    /// TPMA_STARTUP_CLEAR
    StartupClear = PT_VAR + 1,

    /// The number of NV Indexes currently defined
    HrNvIndex = PT_VAR + 2,

    /// The number of authorization sessions currently loaded into TPM RAM
    HrLoaded = PT_VAR + 3,

    /// The number of additional authorization sessions, of any type, that could be loaded
    /// into TPM RAM
    /// This value is an estimate. If this value is at least 1, then at least one
    /// authorization session of any type may be loaded. Any command that changes the RAM
    /// memory allocation can make this estimate invalid.
    /// NOTE A valid implementation may return 1 even if more than one authorization session
    /// would fit into RAM.
    HrLoadedAvail = PT_VAR + 4,

    /// The number of active authorization sessions currently being tracked by the TPM
    /// This is the sum of the loaded and saved sessions.
    HrActive = PT_VAR + 5,

    /// The number of additional authorization sessions, of any type, that could be created
    /// This value is an estimate. If this value is at least 1, then at least one
    /// authorization session of any type may be created. Any command that changes the RAM
    /// memory allocation can make this estimate invalid.
    /// NOTE A valid implementation may return 1 even if more than one authorization session
    /// could be created.
    HrActiveAvail = PT_VAR + 6,

    /// Estimate of the number of additional transient objects that could be loaded into TPM RAM
    /// This value is an estimate. If this value is at least 1, then at least one object of
    /// any type may be loaded. Any command that changes the memory allocation can make this
    /// estimate invalid.
    /// NOTE A valid implementation may return 1 even if more than one transient object would
    /// fit into RAM.
    HrTransientAvail = PT_VAR + 7,

    /// The number of persistent objects currently loaded into TPM NV memory
    HrPersistent = PT_VAR + 8,

    /// The number of additional persistent objects that could be loaded into NV memory
    /// This value is an estimate. If this value is at least 1, then at least one object of
    /// any type may be made persistent. Any command that changes the NV memory allocation can
    /// make this estimate invalid.
    /// NOTE A valid implementation may return 1 even if more than one persistent object would
    /// fit into NV memory.
    HrPersistentAvail = PT_VAR + 9,

    /// The number of defined NV Indexes that have NV the TPM_NT_COUNTER attribute
    NvCounters = PT_VAR + 10,

    /// The number of additional NV Indexes that can be defined with their TPM_NT of
    /// TPM_NV_COUNTER and the TPMA_NV_ORDERLY attribute SET
    /// This value is an estimate. If this value is at least 1, then at least one NV Index may
    /// be created with a TPM_NT of TPM_NV_COUNTER and the TPMA_NV_ORDERLY attributes. Any
    /// command that changes the NV memory allocation can make this estimate invalid.
    /// NOTE A valid implementation may return 1 even if more than one NV counter could be defined.
    NvCountersAvail = PT_VAR + 11,

    /// Code that limits the algorithms that may be used with the TPM
    AlgorithmSet = PT_VAR + 12,

    /// The number of loaded ECC curves
    LoadedCurves = PT_VAR + 13,

    /// The current value of the lockout counter (failedTries)
    LockoutCounter = PT_VAR + 14,

    /// The number of authorization failures before DA lockout is invoked
    MaxAuthFail = PT_VAR + 15,

    /// The number of seconds before the value reported by TPM_PT_LOCKOUT_COUNTER is decremented
    LockoutInterval = PT_VAR + 16,

    /// The number of seconds after a lockoutAuth failure before use of lockoutAuth may be
    /// attempted again
    LockoutRecovery = PT_VAR + 17,

    /// Number of milliseconds before the TPM will accept another command that will modify NV
    /// This value is an approximation and may go up or down over time.
    NvWriteRecovery = PT_VAR + 18,

    /// The high-order 32 bits of the command audit counter
    AuditCounter0 = PT_VAR + 19,

    /// The low-order 32 bits of the command audit counter
    AuditCounter1 = PT_VAR + 20
}

impl TryFrom<u32> for TPM_PT {
    type Error = TpmError;

    fn try_from(value: u32) -> Result<Self, Self::Error> {
        match value {
            0x00000000 => Ok(Self::NONE),
            0x00000100 => Ok(Self::PtGroup),
            PT_GROUP * 1 => Ok(Self::PtFixed),
            PT_FIXED + 0 => Ok(Self::FamilyIndicator),
            PT_FIXED + 1 => Ok(Self::LEVEL),
            PT_FIXED + 2 => Ok(Self::REVISION),
            PT_FIXED + 3 => Ok(Self::DayOfYear),
            PT_FIXED + 4 => Ok(Self::YEAR),
            PT_FIXED + 5 => Ok(Self::MANUFACTURER),
            PT_FIXED + 6 => Ok(Self::VendorString1),
            PT_FIXED + 7 => Ok(Self::VendorString2),
            PT_FIXED + 8 => Ok(Self::VendorString3),
            PT_FIXED + 9 => Ok(Self::VendorString4),
            PT_FIXED + 10 => Ok(Self::VendorTpmType),
            PT_FIXED + 11 => Ok(Self::FirmwareVersion1),
            PT_FIXED + 12 => Ok(Self::FirmwareVersion2),
            PT_FIXED + 13 => Ok(Self::InputBuffer),
            PT_FIXED + 14 => Ok(Self::HrTransientMin),
            PT_FIXED + 15 => Ok(Self::HrPersistentMin),
            PT_FIXED + 16 => Ok(Self::HrLoadedMin),
            PT_FIXED + 17 => Ok(Self::ActiveSessionsMax),
            PT_FIXED + 18 => Ok(Self::PcrCount),
            PT_FIXED + 19 => Ok(Self::PcrSelectMin),
            PT_FIXED + 20 => Ok(Self::ContextGapMax),
            PT_FIXED + 22 => Ok(Self::NvCountersMax),
            PT_FIXED + 23 => Ok(Self::NvIndexMax),
            PT_FIXED + 24 => Ok(Self::MEMORY),
            PT_FIXED + 25 => Ok(Self::ClockUpdate),
            PT_FIXED + 26 => Ok(Self::ContextHash),
            PT_FIXED + 27 => Ok(Self::ContextSym),
            PT_FIXED + 28 => Ok(Self::ContextSymSize),
            PT_FIXED + 29 => Ok(Self::OrderlyCount),
            PT_FIXED + 30 => Ok(Self::MaxCommandSize),
            PT_FIXED + 31 => Ok(Self::MaxResponseSize),
            PT_FIXED + 32 => Ok(Self::MaxDigest),
            PT_FIXED + 33 => Ok(Self::MaxObjectContext),
            PT_FIXED + 34 => Ok(Self::MaxSessionContext),
            PT_FIXED + 35 => Ok(Self::PsFamilyIndicator),
            PT_FIXED + 36 => Ok(Self::PsLevel),
            PT_FIXED + 37 => Ok(Self::PsRevision),
            PT_FIXED + 38 => Ok(Self::PsDayOfYear),
            PT_FIXED + 39 => Ok(Self::PsYear),
            PT_FIXED + 40 => Ok(Self::SplitMax),
            PT_FIXED + 41 => Ok(Self::TotalCommands),
            PT_FIXED + 42 => Ok(Self::LibraryCommands),
            PT_FIXED + 43 => Ok(Self::VendorCommands),
            PT_FIXED + 44 => Ok(Self::NvBufferMax),
            PT_FIXED + 45 => Ok(Self::MODES),
            PT_FIXED + 46 => Ok(Self::MaxCapBuffer),
            PT_GROUP * 2 => Ok(Self::PtVar),
            PT_VAR + 0 => Ok(Self::PERMANENT),
            PT_VAR + 1 => Ok(Self::StartupClear),
            PT_VAR + 2 => Ok(Self::HrNvIndex),
            PT_VAR + 3 => Ok(Self::HrLoaded),
            PT_VAR + 4 => Ok(Self::HrLoadedAvail),
            PT_VAR + 5 => Ok(Self::HrActive),
            PT_VAR + 6 => Ok(Self::HrActiveAvail),
            PT_VAR + 7 => Ok(Self::HrTransientAvail),
            PT_VAR + 8 => Ok(Self::HrPersistent),
            PT_VAR + 9 => Ok(Self::HrPersistentAvail),
            PT_VAR + 10 => Ok(Self::NvCounters),
            PT_VAR + 11 => Ok(Self::NvCountersAvail),
            PT_VAR + 12 => Ok(Self::AlgorithmSet),
            PT_VAR + 13 => Ok(Self::LoadedCurves),
            PT_VAR + 14 => Ok(Self::LockoutCounter),
            PT_VAR + 15 => Ok(Self::MaxAuthFail),
            PT_VAR + 16 => Ok(Self::LockoutInterval),
            PT_VAR + 17 => Ok(Self::LockoutRecovery),
            PT_VAR + 18 => Ok(Self::NvWriteRecovery),
            PT_VAR + 19 => Ok(Self::AuditCounter0),
            PT_VAR + 20 => Ok(Self::AuditCounter1),
            _ => Err(TpmError::InvalidEnumValue),
        }

    }

}

impl fmt::Display for TPM_PT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::NONE => write!(f, "NONE"),
            Self::PtGroup => write!(f, "PtGroup"),
            Self::PtFixed => write!(f, "PtFixed"),
            Self::FamilyIndicator => write!(f, "FamilyIndicator"),
            Self::LEVEL => write!(f, "LEVEL"),
            Self::REVISION => write!(f, "REVISION"),
            Self::DayOfYear => write!(f, "DayOfYear"),
            Self::YEAR => write!(f, "YEAR"),
            Self::MANUFACTURER => write!(f, "MANUFACTURER"),
            Self::VendorString1 => write!(f, "VendorString1"),
            Self::VendorString2 => write!(f, "VendorString2"),
            Self::VendorString3 => write!(f, "VendorString3"),
            Self::VendorString4 => write!(f, "VendorString4"),
            Self::VendorTpmType => write!(f, "VendorTpmType"),
            Self::FirmwareVersion1 => write!(f, "FirmwareVersion1"),
            Self::FirmwareVersion2 => write!(f, "FirmwareVersion2"),
            Self::InputBuffer => write!(f, "InputBuffer"),
            Self::HrTransientMin => write!(f, "HrTransientMin"),
            Self::HrPersistentMin => write!(f, "HrPersistentMin"),
            Self::HrLoadedMin => write!(f, "HrLoadedMin"),
            Self::ActiveSessionsMax => write!(f, "ActiveSessionsMax"),
            Self::PcrCount => write!(f, "PcrCount"),
            Self::PcrSelectMin => write!(f, "PcrSelectMin"),
            Self::ContextGapMax => write!(f, "ContextGapMax"),
            Self::NvCountersMax => write!(f, "NvCountersMax"),
            Self::NvIndexMax => write!(f, "NvIndexMax"),
            Self::MEMORY => write!(f, "MEMORY"),
            Self::ClockUpdate => write!(f, "ClockUpdate"),
            Self::ContextHash => write!(f, "ContextHash"),
            Self::ContextSym => write!(f, "ContextSym"),
            Self::ContextSymSize => write!(f, "ContextSymSize"),
            Self::OrderlyCount => write!(f, "OrderlyCount"),
            Self::MaxCommandSize => write!(f, "MaxCommandSize"),
            Self::MaxResponseSize => write!(f, "MaxResponseSize"),
            Self::MaxDigest => write!(f, "MaxDigest"),
            Self::MaxObjectContext => write!(f, "MaxObjectContext"),
            Self::MaxSessionContext => write!(f, "MaxSessionContext"),
            Self::PsFamilyIndicator => write!(f, "PsFamilyIndicator"),
            Self::PsLevel => write!(f, "PsLevel"),
            Self::PsRevision => write!(f, "PsRevision"),
            Self::PsDayOfYear => write!(f, "PsDayOfYear"),
            Self::PsYear => write!(f, "PsYear"),
            Self::SplitMax => write!(f, "SplitMax"),
            Self::TotalCommands => write!(f, "TotalCommands"),
            Self::LibraryCommands => write!(f, "LibraryCommands"),
            Self::VendorCommands => write!(f, "VendorCommands"),
            Self::NvBufferMax => write!(f, "NvBufferMax"),
            Self::MODES => write!(f, "MODES"),
            Self::MaxCapBuffer => write!(f, "MaxCapBuffer"),
            Self::PtVar => write!(f, "PtVar"),
            Self::PERMANENT => write!(f, "PERMANENT"),
            Self::StartupClear => write!(f, "StartupClear"),
            Self::HrNvIndex => write!(f, "HrNvIndex"),
            Self::HrLoaded => write!(f, "HrLoaded"),
            Self::HrLoadedAvail => write!(f, "HrLoadedAvail"),
            Self::HrActive => write!(f, "HrActive"),
            Self::HrActiveAvail => write!(f, "HrActiveAvail"),
            Self::HrTransientAvail => write!(f, "HrTransientAvail"),
            Self::HrPersistent => write!(f, "HrPersistent"),
            Self::HrPersistentAvail => write!(f, "HrPersistentAvail"),
            Self::NvCounters => write!(f, "NvCounters"),
            Self::NvCountersAvail => write!(f, "NvCountersAvail"),
            Self::AlgorithmSet => write!(f, "AlgorithmSet"),
            Self::LoadedCurves => write!(f, "LoadedCurves"),
            Self::LockoutCounter => write!(f, "LockoutCounter"),
            Self::MaxAuthFail => write!(f, "MaxAuthFail"),
            Self::LockoutInterval => write!(f, "LockoutInterval"),
            Self::LockoutRecovery => write!(f, "LockoutRecovery"),
            Self::NvWriteRecovery => write!(f, "NvWriteRecovery"),
            Self::AuditCounter0 => write!(f, "AuditCounter0"),
            Self::AuditCounter1 => write!(f, "AuditCounter1"),
        }

    }

}

/// The TPM_PT_PCR constants are used in TPM2_GetCapability() to indicate the property
/// being selected or returned. The PCR properties can be read when capability ==
/// TPM_CAP_PCR_PROPERTIES. If there is no property that corresponds to the value of
/// property, the next higher value is returned, if it exists.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u32)]
pub enum TPM_PT_PCR {
    /// Bottom of the range of TPM_PT_PCR properties
    FIRST = 0x00000000,

    /// A SET bit in the TPMS_PCR_SELECT indicates that the PCR is saved and restored by TPM_SU_STATE
    SAVE = 0x00000000,

    /// A SET bit in the TPMS_PCR_SELECT indicates that the PCR may be extended from locality 0
    /// This property is only present if a locality other than 0 is implemented.
    ExtendL0 = 0x00000001,

    /// A SET bit in the TPMS_PCR_SELECT indicates that the PCR may be reset by
    /// TPM2_PCR_Reset() from locality 0
    ResetL0 = 0x00000002,

    /// A SET bit in the TPMS_PCR_SELECT indicates that the PCR may be extended from locality 1
    /// This property is only present if locality 1 is implemented.
    ExtendL1 = 0x00000003,

    /// A SET bit in the TPMS_PCR_SELECT indicates that the PCR may be reset by
    /// TPM2_PCR_Reset() from locality 1
    /// This property is only present if locality 1 is implemented.
    ResetL1 = 0x00000004,

    /// A SET bit in the TPMS_PCR_SELECT indicates that the PCR may be extended from locality 2
    /// This property is only present if localities 1 and 2 are implemented.
    ExtendL2 = 0x00000005,

    /// A SET bit in the TPMS_PCR_SELECT indicates that the PCR may be reset by
    /// TPM2_PCR_Reset() from locality 2
    /// This property is only present if localities 1 and 2 are implemented.
    ResetL2 = 0x00000006,

    /// A SET bit in the TPMS_PCR_SELECT indicates that the PCR may be extended from locality 3
    /// This property is only present if localities 1, 2, and 3 are implemented.
    ExtendL3 = 0x00000007,

    /// A SET bit in the TPMS_PCR_SELECT indicates that the PCR may be reset by
    /// TPM2_PCR_Reset() from locality 3
    /// This property is only present if localities 1, 2, and 3 are implemented.
    ResetL3 = 0x00000008,

    /// A SET bit in the TPMS_PCR_SELECT indicates that the PCR may be extended from locality 4
    /// This property is only present if localities 1, 2, 3, and 4 are implemented.
    ExtendL4 = 0x00000009,

    /// A SET bit in the TPMS_PCR_SELECT indicates that the PCR may be reset by
    /// TPM2_PCR_Reset() from locality 4
    /// This property is only present if localities 1, 2, 3, and 4 are implemented.
    ResetL4 = 0x0000000A,

    /// A SET bit in the TPMS_PCR_SELECT indicates that modifications to this PCR (reset or
    /// Extend) will not increment the pcrUpdateCounter
    NoIncrement = 0x00000011,

    /// A SET bit in the TPMS_PCR_SELECT indicates that the PCR is reset by a D-RTM event
    /// These PCR are reset to -1 on TPM2_Startup() and reset to 0 on a _TPM_Hash_End event
    /// following a _TPM_Hash_Start event.
    DrtmReset = 0x00000012,

    /// A SET bit in the TPMS_PCR_SELECT indicates that the PCR is controlled by policy
    /// This property is only present if the TPM supports policy control of a PCR.
    POLICY = 0x00000013,

    /// A SET bit in the TPMS_PCR_SELECT indicates that the PCR is controlled by an
    /// authorization value
    /// This property is only present if the TPM supports authorization control of a PCR.
    AUTH = 0x00000014,

    /// Top of the range of TPM_PT_PCR properties of the implementation
    /// If the TPM receives a request for a PCR property with a value larger than this, the
    /// TPM will return a zero length list and set the moreData parameter to NO.
    /// NOTE This is an implementation-specific value. The value shown reflects the reference
    /// code implementation.
    LAST = 0x00000014
}

impl TryFrom<u32> for TPM_PT_PCR {
    type Error = TpmError;

    fn try_from(value: u32) -> Result<Self, Self::Error> {
        match value {
            0x00000000 => Ok(Self::FIRST),
            0x00000000 => Ok(Self::SAVE),
            0x00000001 => Ok(Self::ExtendL0),
            0x00000002 => Ok(Self::ResetL0),
            0x00000003 => Ok(Self::ExtendL1),
            0x00000004 => Ok(Self::ResetL1),
            0x00000005 => Ok(Self::ExtendL2),
            0x00000006 => Ok(Self::ResetL2),
            0x00000007 => Ok(Self::ExtendL3),
            0x00000008 => Ok(Self::ResetL3),
            0x00000009 => Ok(Self::ExtendL4),
            0x0000000A => Ok(Self::ResetL4),
            0x00000011 => Ok(Self::NoIncrement),
            0x00000012 => Ok(Self::DrtmReset),
            0x00000013 => Ok(Self::POLICY),
            0x00000014 => Ok(Self::AUTH),
            0x00000014 => Ok(Self::LAST),
            _ => Err(TpmError::InvalidEnumValue),
        }

    }

}

impl fmt::Display for TPM_PT_PCR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::FIRST => write!(f, "FIRST"),
            Self::SAVE => write!(f, "SAVE"),
            Self::ExtendL0 => write!(f, "ExtendL0"),
            Self::ResetL0 => write!(f, "ResetL0"),
            Self::ExtendL1 => write!(f, "ExtendL1"),
            Self::ResetL1 => write!(f, "ResetL1"),
            Self::ExtendL2 => write!(f, "ExtendL2"),
            Self::ResetL2 => write!(f, "ResetL2"),
            Self::ExtendL3 => write!(f, "ExtendL3"),
            Self::ResetL3 => write!(f, "ResetL3"),
            Self::ExtendL4 => write!(f, "ExtendL4"),
            Self::ResetL4 => write!(f, "ResetL4"),
            Self::NoIncrement => write!(f, "NoIncrement"),
            Self::DrtmReset => write!(f, "DrtmReset"),
            Self::POLICY => write!(f, "POLICY"),
            Self::AUTH => write!(f, "AUTH"),
            Self::LAST => write!(f, "LAST"),
        }

    }

}

/// The platform values in Table 25 are used for the TPM_PT_PS_FAMILY_INDICATOR.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u32)]
pub enum TPM_PS {
    /// Not platform specific
    MAIN = 0x00000000,

    /// PC Client
    PC = 0x00000001,

    /// PDA (includes all mobile devices that are not specifically cell phones)
    PDA = 0x00000002,

    /// Cell Phone
    CellPhone = 0x00000003,

    /// Server WG
    SERVER = 0x00000004,

    /// Peripheral WG
    PERIPHERAL = 0x00000005,

    /// TSS WG (deprecated)
    TSS = 0x00000006,

    /// Storage WG
    STORAGE = 0x00000007,

    /// Authentication WG
    AUTHENTICATION = 0x00000008,

    /// Embedded WG
    EMBEDDED = 0x00000009,

    /// Hardcopy WG
    HARDCOPY = 0x0000000A,

    /// Infrastructure WG (deprecated)
    INFRASTRUCTURE = 0x0000000B,

    /// Virtualization WG
    VIRTUALIZATION = 0x0000000C,

    /// Trusted Network Connect WG (deprecated)
    TNC = 0x0000000D,

    /// Multi-tenant WG (deprecated)
    MultiTenant = 0x0000000E,

    /// Technical Committee (deprecated)
    TC = 0x0000000F
}

impl TryFrom<u32> for TPM_PS {
    type Error = TpmError;

    fn try_from(value: u32) -> Result<Self, Self::Error> {
        match value {
            0x00000000 => Ok(Self::MAIN),
            0x00000001 => Ok(Self::PC),
            0x00000002 => Ok(Self::PDA),
            0x00000003 => Ok(Self::CellPhone),
            0x00000004 => Ok(Self::SERVER),
            0x00000005 => Ok(Self::PERIPHERAL),
            0x00000006 => Ok(Self::TSS),
            0x00000007 => Ok(Self::STORAGE),
            0x00000008 => Ok(Self::AUTHENTICATION),
            0x00000009 => Ok(Self::EMBEDDED),
            0x0000000A => Ok(Self::HARDCOPY),
            0x0000000B => Ok(Self::INFRASTRUCTURE),
            0x0000000C => Ok(Self::VIRTUALIZATION),
            0x0000000D => Ok(Self::TNC),
            0x0000000E => Ok(Self::MultiTenant),
            0x0000000F => Ok(Self::TC),
            _ => Err(TpmError::InvalidEnumValue),
        }

    }

}

impl fmt::Display for TPM_PS {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::MAIN => write!(f, "MAIN"),
            Self::PC => write!(f, "PC"),
            Self::PDA => write!(f, "PDA"),
            Self::CellPhone => write!(f, "CellPhone"),
            Self::SERVER => write!(f, "SERVER"),
            Self::PERIPHERAL => write!(f, "PERIPHERAL"),
            Self::TSS => write!(f, "TSS"),
            Self::STORAGE => write!(f, "STORAGE"),
            Self::AUTHENTICATION => write!(f, "AUTHENTICATION"),
            Self::EMBEDDED => write!(f, "EMBEDDED"),
            Self::HARDCOPY => write!(f, "HARDCOPY"),
            Self::INFRASTRUCTURE => write!(f, "INFRASTRUCTURE"),
            Self::VIRTUALIZATION => write!(f, "VIRTUALIZATION"),
            Self::TNC => write!(f, "TNC"),
            Self::MultiTenant => write!(f, "MultiTenant"),
            Self::TC => write!(f, "TC"),
        }

    }

}

/// The 32-bit handle space is divided into 256 regions of equal size with 224 values in
/// each. Each of these ranges represents a handle type.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum TPM_HT {
    /// PCR consecutive numbers, starting at 0, that reference the PCR registers
    /// A platform-specific specification will set the minimum number of PCR and an
    /// implementation may have more.
    PCR = 0x00,

    /// NV Index assigned by the caller
    NvIndex = 0x01,

    /// HMAC Authorization Session assigned by the TPM when the session is created
    HmacSession = 0x02,

    /// Loaded Authorization Session used only in the context of TPM2_GetCapability
    /// This type references both loaded HMAC and loaded policy authorization sessions.
    LoadedSession = 0x02,

    /// Policy Authorization Session assigned by the TPM when the session is created
    PolicySession = 0x03,

    /// Saved Authorization Session used only in the context of TPM2_GetCapability
    /// This type references saved authorization session contexts for which the TPM is
    /// maintaining tracking information.
    SavedSession = 0x03,

    /// Permanent Values assigned by this specification in Table 28
    PERMANENT = 0x40,

    /// Transient Objects assigned by the TPM when an object is loaded into transient-object
    /// memory or when a persistent object is converted to a transient object
    TRANSIENT = 0x80,

    /// Persistent Objects assigned by the TPM when a loaded transient object is made persistent
    PERSISTENT = 0x81,

    /// Attached Component handle for an Attached Component.
    AC = 0x90
}

impl TryFrom<u8> for TPM_HT {
    type Error = TpmError;

    fn try_from(value: u8) -> Result<Self, Self::Error> {
        match value {
            0x00 => Ok(Self::PCR),
            0x01 => Ok(Self::NvIndex),
            0x02 => Ok(Self::HmacSession),
            0x02 => Ok(Self::LoadedSession),
            0x03 => Ok(Self::PolicySession),
            0x03 => Ok(Self::SavedSession),
            0x40 => Ok(Self::PERMANENT),
            0x80 => Ok(Self::TRANSIENT),
            0x81 => Ok(Self::PERSISTENT),
            0x90 => Ok(Self::AC),
            _ => Err(TpmError::InvalidEnumValue),
        }

    }

}

impl fmt::Display for TPM_HT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::PCR => write!(f, "PCR"),
            Self::NvIndex => write!(f, "NvIndex"),
            Self::HmacSession => write!(f, "HmacSession"),
            Self::LoadedSession => write!(f, "LoadedSession"),
            Self::PolicySession => write!(f, "PolicySession"),
            Self::SavedSession => write!(f, "SavedSession"),
            Self::PERMANENT => write!(f, "PERMANENT"),
            Self::TRANSIENT => write!(f, "TRANSIENT"),
            Self::PERSISTENT => write!(f, "PERSISTENT"),
            Self::AC => write!(f, "AC"),
        }

    }

}

/// Table 28 lists the architecturally defined handles that cannot be changed. The handles
/// include authorization handles, and special handles.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u32)]
pub enum TPM_RH {
    FIRST = 0x40000000,

    /// Not used1
    SRK = 0x40000000,

    /// Handle references the Storage Primary Seed (SPS), the ownerAuth, and the ownerPolicy
    OWNER = 0x40000001,

    /// Not used1
    REVOKE = 0x40000002,

    /// Not used1
    TRANSPORT = 0x40000003,

    /// Not used1
    OPERATOR = 0x40000004,

    /// Not used1
    ADMIN = 0x40000005,

    /// Not used1
    EK = 0x40000006,

    /// A handle associated with the null hierarchy, an EmptyAuth authValue, and an Empty
    /// Policy authPolicy.
    NULL = 0x40000007,

    /// Value reserved to the TPM to indicate a handle location that has not been initialized
    /// or assigned
    UNASSIGNED = 0x40000008,

    /// Authorization value used to indicate a password authorization session
    PW = 0x40000009,

    /// References the authorization associated with the dictionary attack lockout reset
    LOCKOUT = 0x4000000A,

    /// References the Endorsement Primary Seed (EPS), endorsementAuth, and endorsementPolicy
    ENDORSEMENT = 0x4000000B,

    /// References the Platform Primary Seed (PPS), platformAuth, and platformPolicy
    PLATFORM = 0x4000000C,

    /// For phEnableNV
    PlatformNv = 0x4000000D,

    /// Start of a range of authorization values that are vendor-specific. A TPM may support
    /// any of the values in this range as are needed for vendor-specific purposes.
    /// Disabled if ehEnable is CLEAR.
    /// NOTE Any includes none.
    Auth00 = 0x40000010,

    /// End of the range of vendor-specific authorization values.
    AuthFf = 0x4000010F,

    /// Start of the range of authenticated timers
    Act0 = 0x40000110,

    /// End of the range of authenticated timers
    ActF = 0x4000011F,

    /// The top of the reserved handle area
    /// This is set to allow TPM2_GetCapability() to know where to stop. It may vary as
    /// implementations add to the permanent handle area.
    LAST = 0x4000011F
}

impl TryFrom<u32> for TPM_RH {
    type Error = TpmError;

    fn try_from(value: u32) -> Result<Self, Self::Error> {
        match value {
            0x40000000 => Ok(Self::FIRST),
            0x40000000 => Ok(Self::SRK),
            0x40000001 => Ok(Self::OWNER),
            0x40000002 => Ok(Self::REVOKE),
            0x40000003 => Ok(Self::TRANSPORT),
            0x40000004 => Ok(Self::OPERATOR),
            0x40000005 => Ok(Self::ADMIN),
            0x40000006 => Ok(Self::EK),
            0x40000007 => Ok(Self::NULL),
            0x40000008 => Ok(Self::UNASSIGNED),
            0x40000009 => Ok(Self::PW),
            0x4000000A => Ok(Self::LOCKOUT),
            0x4000000B => Ok(Self::ENDORSEMENT),
            0x4000000C => Ok(Self::PLATFORM),
            0x4000000D => Ok(Self::PlatformNv),
            0x40000010 => Ok(Self::Auth00),
            0x4000010F => Ok(Self::AuthFf),
            0x40000110 => Ok(Self::Act0),
            0x4000011F => Ok(Self::ActF),
            0x4000011F => Ok(Self::LAST),
            _ => Err(TpmError::InvalidEnumValue),
        }

    }

}

impl fmt::Display for TPM_RH {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::FIRST => write!(f, "FIRST"),
            Self::SRK => write!(f, "SRK"),
            Self::OWNER => write!(f, "OWNER"),
            Self::REVOKE => write!(f, "REVOKE"),
            Self::TRANSPORT => write!(f, "TRANSPORT"),
            Self::OPERATOR => write!(f, "OPERATOR"),
            Self::ADMIN => write!(f, "ADMIN"),
            Self::EK => write!(f, "EK"),
            Self::NULL => write!(f, "NULL"),
            Self::UNASSIGNED => write!(f, "UNASSIGNED"),
            Self::PW => write!(f, "PW"),
            Self::LOCKOUT => write!(f, "LOCKOUT"),
            Self::ENDORSEMENT => write!(f, "ENDORSEMENT"),
            Self::PLATFORM => write!(f, "PLATFORM"),
            Self::PlatformNv => write!(f, "PlatformNv"),
            Self::Auth00 => write!(f, "Auth00"),
            Self::AuthFf => write!(f, "AuthFf"),
            Self::Act0 => write!(f, "Act0"),
            Self::ActF => write!(f, "ActF"),
            Self::LAST => write!(f, "LAST"),
        }

    }

}

/// This table lists the values of the TPM_NT field of a TPMA_NV. See Table 215 for usage.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u32)]
pub enum TPM_NT {
    /// Ordinary contains data that is opaque to the TPM that can only be modified using TPM2_NV_Write().
    ORDINARY = 0x0,

    /// Counter contains an 8-octet value that is to be used as a counter and can only be
    /// modified with TPM2_NV_Increment()
    COUNTER = 0x1,

    /// Bit Field contains an 8-octet value to be used as a bit field and can only be modified
    /// with TPM2_NV_SetBits().
    BITS = 0x2,

    /// Extend contains a digest-sized value used like a PCR. The Index can only be modified
    /// using TPM2_NV_Extend(). The extend will use the nameAlg of the Index.
    EXTEND = 0x4,

    /// PIN Fail - contains pinCount that increments on a PIN authorization failure and a pinLimit
    PinFail = 0x8,

    /// PIN Pass - contains pinCount that increments on a PIN authorization success and a pinLimit
    PinPass = 0x9
}

impl TryFrom<u32> for TPM_NT {
    type Error = TpmError;

    fn try_from(value: u32) -> Result<Self, Self::Error> {
        match value {
            0x0 => Ok(Self::ORDINARY),
            0x1 => Ok(Self::COUNTER),
            0x2 => Ok(Self::BITS),
            0x4 => Ok(Self::EXTEND),
            0x8 => Ok(Self::PinFail),
            0x9 => Ok(Self::PinPass),
            _ => Err(TpmError::InvalidEnumValue),
        }

    }

}

impl fmt::Display for TPM_NT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::ORDINARY => write!(f, "ORDINARY"),
            Self::COUNTER => write!(f, "COUNTER"),
            Self::BITS => write!(f, "BITS"),
            Self::EXTEND => write!(f, "EXTEND"),
            Self::PinFail => write!(f, "PinFail"),
            Self::PinPass => write!(f, "PinPass"),
        }

    }

}

/// These constants are used in TPM2_AC_GetCapability() to indicate the first tagged value
/// returned from an attached component.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u32)]
pub enum TPM_AT {
    /// In a command, a non-specific request for AC information; in a response, indicates that
    /// outputData is not meaningful
    ANY = 0x00000000,

    /// Indicates a TCG defined, device-specific error
    ERROR = 0x00000001,

    /// Indicates the most significant 32 bits of a pairing value for the AC
    PV1 = 0x00000002,

    /// Value added to a TPM_AT to indicate a vendor-specific tag value
    VEND = 0x80000000
}

impl TryFrom<u32> for TPM_AT {
    type Error = TpmError;

    fn try_from(value: u32) -> Result<Self, Self::Error> {
        match value {
            0x00000000 => Ok(Self::ANY),
            0x00000001 => Ok(Self::ERROR),
            0x00000002 => Ok(Self::PV1),
            0x80000000 => Ok(Self::VEND),
            _ => Err(TpmError::InvalidEnumValue),
        }

    }

}

impl fmt::Display for TPM_AT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::ANY => write!(f, "ANY"),
            Self::ERROR => write!(f, "ERROR"),
            Self::PV1 => write!(f, "PV1"),
            Self::VEND => write!(f, "VEND"),
        }

    }

}

/// These constants are the TCG-defined error values returned by an AC.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u32)]
pub enum TPM_AE {
    /// In a command, a non-specific request for AC information; in a response, indicates that
    /// outputData is not meaningful
    NONE = 0x00000000
}

impl TryFrom<u32> for TPM_AE {
    type Error = TpmError;

    fn try_from(value: u32) -> Result<Self, Self::Error> {
        match value {
            0x00000000 => Ok(Self::NONE),
            _ => Err(TpmError::InvalidEnumValue),
        }

    }

}

impl fmt::Display for TPM_AE {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::NONE => write!(f, "NONE"),
        }

    }

}

/// These values are readable with TPM2_GetCapability(). They are the TPM_PT_PS_xxx values.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u32)]
pub enum PLATFORM {
    FAMILY = TPM_SPEC:FAMILY,
    LEVEL = TPM_SPEC:LEVEL,
    VERSION = TPM_SPEC:VERSION,
    YEAR = TPM_SPEC:YEAR,
    DayOfYear = TPM_SPEC:DAY_OF_YEAR
}

impl TryFrom<u32> for PLATFORM {
    type Error = TpmError;

    fn try_from(value: u32) -> Result<Self, Self::Error> {
        match value {
            TPM_SPEC:FAMILY => Ok(Self::FAMILY),
            TPM_SPEC:LEVEL => Ok(Self::LEVEL),
            TPM_SPEC:VERSION => Ok(Self::VERSION),
            TPM_SPEC:YEAR => Ok(Self::YEAR),
            TPM_SPEC:DAY_OF_YEAR => Ok(Self::DayOfYear),
            _ => Err(TpmError::InvalidEnumValue),
        }

    }

}

impl fmt::Display for PLATFORM {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::FAMILY => write!(f, "FAMILY"),
            Self::LEVEL => write!(f, "LEVEL"),
            Self::VERSION => write!(f, "VERSION"),
            Self::YEAR => write!(f, "YEAR"),
            Self::DayOfYear => write!(f, "DayOfYear"),
        }

    }

}

/// This table contains a collection of values used in various parts of the reference
/// code. The values shown are illustrative.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u32)]
pub enum Implementation {
    /// Temporary define
    FieldUpgradeImplemented = Logic:NO,

    /// Selection of the library that provides the basic hashing functions.
    HashLib = ImplementationConstants:Ossl,

    /// Selection of the library that provides the low-level symmetric cryptography. Choices
    /// are determined by the vendor (See LibSupport.h for implications).
    SymLib = ImplementationConstants:Ossl,

    /// Selection of the library that provides the big number math including ECC. Choices are
    /// determined by the vendor (See LibSupport.h for implications).
    MathLib = ImplementationConstants:Ossl,

    /// The number of PCR in the TPM
    ImplementationPcr = 24,
    PcrSelectMax = ((IMPLEMENTATION_PCR+7)/8),

    /// The number of PCR required by the relevant platform specification
    PlatformPcr = 24,
    PcrSelectMin = ((PLATFORM_PCR + 7) / 8),

    /// The D-RTM PCR
    /// NOTE This value is not defined when the TPM does not implement D-RTM
    DrtmPcr = 17,

    /// The PCR that will receive the H-CRTM value at TPM2_Startup. This value should not be changed.
    HcrtmPcr = 0,

    /// The number of localities supported by the TPM
    /// This is expected to be either 5 for a PC, or 1 for just about everything else.
    NumLocalities = 5,

    /// The maximum number of handles in the handle area
    /// This should be produced by the Part 3 parser but is here for now.
    MaxHandleNum = 3,

    /// The number of simultaneously active sessions that are supported by the TPM implementation
    MaxActiveSessions = 64,

    /// The number of sessions that the TPM may have in memory
    MaxLoadedSessions = 3,

    /// This is the current maximum value
    MaxSessionNum = 3,

    /// The number of simultaneously loaded objects that are supported by the TPM; this number
    /// does not include the objects that may be placed in NV memory by TPM2_EvictControl().
    MaxLoadedObjects = 3,

    /// The minimum number of evict objects supported by the TPM
    MinEvictObjects = 2,

    /// Number of PCR groups that have individual policies
    NumPolicyPcrGroup = 1,

    /// Number of PCR groups that have individual authorization values
    NumAuthvaluePcrGroup = 1,
    MaxContextSize = 1264,
    MaxDigestBuffer = 1024,

    /// Maximum data size allowed in an NV Index
    MaxNvIndexSize = 2048,

    /// Maximum data size in one NV read or write command
    MaxNvBufferSize = 1024,

    /// Maximum size of a capability buffer
    MaxCapBuffer = 1024,

    /// Size of NV memory in octets
    NvMemorySize = 16384,

    /// The TPM will not allocate a non-counter index if it would prevent allocation of this
    /// number of indices.
    MinCounterIndices = 8,
    NumStaticPcr = 16,

    /// Number of algorithms that can be in a list
    MaxAlgListSize = 64,

    /// Size of the Primary Seed in octets
    PrimarySeedSize = 32,

    /// Context encryption algorithm
    /// Just use the root so that the macros in GpMacros.h will work correctly.
    ContextEncryptAlgorithm = TPM_ALG_ID:AES,

    /// The update interval expressed as a power of 2 seconds
    /// A value of 12 is 4,096 seconds (~68 minutes).
    NvClockUpdateInterval = 12,

    /// Number of PCR groups that allow policy/auth
    NumPolicyPcr = 1,

    /// Maximum size of a command
    MaxCommandSize = 4096,

    /// Maximum size of a response
    MaxResponseSize = 4096,

    /// Number between 1 and 32 inclusive
    OrderlyBits = 8,

    /// The maximum number of octets that may be in a sealed blob; 128 is the minimum allowed value
    MaxSymData = 128,
    MaxRngEntropySize = 64,

    /// Number of bytes used for the RAM index space. If this is not large enough, it might
    /// not be possible to allocate orderly indices.
    RamIndexSpace = 512,

    /// 216 + 1
    RsaDefaultPublicExponent = 0x00010001,

    /// Indicates if the TPM_PT_PCR_NO_INCREMENT group is implemented
    EnablePcrNoIncrement = Logic:YES,
    CrtFormatRsa = Logic:YES,
    VendorCommandCount = 0,

    /// Maximum size of the vendor-specific buffer
    MaxVendorBufferSize = 1024,

    /// L value for a derivation. This is the
    /// maximum number of bits allowed from an instantiation of a KDF-DRBG. This is size is OK
    /// because RSA keys are never derived keys
    MaxDerivationBits = 8192,
    RsaMaxPrime = (ImplementationConstants:MAX_RSA_KEY_BYTES/2),
    RsaPrivateSize = (RSA_MAX_PRIME * 5),
    SizeOfX509SerialNumber = 20,

    /// This is a vendor-specific value so it is in this vendor-speific table. When this is
    /// used, RSA_PRIVATE_SIZE will have been defined
    PrivateVendorSpecificBytes = RSA_PRIVATE_SIZE
}

impl TryFrom<u32> for Implementation {
    type Error = TpmError;

    fn try_from(value: u32) -> Result<Self, Self::Error> {
        match value {
            Logic:NO => Ok(Self::FieldUpgradeImplemented),
            ImplementationConstants:Ossl => Ok(Self::HashLib),
            ImplementationConstants:Ossl => Ok(Self::SymLib),
            ImplementationConstants:Ossl => Ok(Self::MathLib),
            24 => Ok(Self::ImplementationPcr),
            ((IMPLEMENTATION_PCR+7)/8) => Ok(Self::PcrSelectMax),
            24 => Ok(Self::PlatformPcr),
            ((PLATFORM_PCR + 7) / 8) => Ok(Self::PcrSelectMin),
            17 => Ok(Self::DrtmPcr),
            0 => Ok(Self::HcrtmPcr),
            5 => Ok(Self::NumLocalities),
            3 => Ok(Self::MaxHandleNum),
            64 => Ok(Self::MaxActiveSessions),
            3 => Ok(Self::MaxLoadedSessions),
            3 => Ok(Self::MaxSessionNum),
            3 => Ok(Self::MaxLoadedObjects),
            2 => Ok(Self::MinEvictObjects),
            1 => Ok(Self::NumPolicyPcrGroup),
            1 => Ok(Self::NumAuthvaluePcrGroup),
            1264 => Ok(Self::MaxContextSize),
            1024 => Ok(Self::MaxDigestBuffer),
            2048 => Ok(Self::MaxNvIndexSize),
            1024 => Ok(Self::MaxNvBufferSize),
            1024 => Ok(Self::MaxCapBuffer),
            16384 => Ok(Self::NvMemorySize),
            8 => Ok(Self::MinCounterIndices),
            16 => Ok(Self::NumStaticPcr),
            64 => Ok(Self::MaxAlgListSize),
            32 => Ok(Self::PrimarySeedSize),
            TPM_ALG_ID:AES => Ok(Self::ContextEncryptAlgorithm),
            12 => Ok(Self::NvClockUpdateInterval),
            1 => Ok(Self::NumPolicyPcr),
            4096 => Ok(Self::MaxCommandSize),
            4096 => Ok(Self::MaxResponseSize),
            8 => Ok(Self::OrderlyBits),
            128 => Ok(Self::MaxSymData),
            64 => Ok(Self::MaxRngEntropySize),
            512 => Ok(Self::RamIndexSpace),
            0x00010001 => Ok(Self::RsaDefaultPublicExponent),
            Logic:YES => Ok(Self::EnablePcrNoIncrement),
            Logic:YES => Ok(Self::CrtFormatRsa),
            0 => Ok(Self::VendorCommandCount),
            1024 => Ok(Self::MaxVendorBufferSize),
            8192 => Ok(Self::MaxDerivationBits),
            (ImplementationConstants:MAX_RSA_KEY_BYTES/2) => Ok(Self::RsaMaxPrime),
            (RSA_MAX_PRIME * 5) => Ok(Self::RsaPrivateSize),
            20 => Ok(Self::SizeOfX509SerialNumber),
            RSA_PRIVATE_SIZE => Ok(Self::PrivateVendorSpecificBytes),
            _ => Err(TpmError::InvalidEnumValue),
        }

    }

}

impl fmt::Display for Implementation {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::FieldUpgradeImplemented => write!(f, "FieldUpgradeImplemented"),
            Self::HashLib => write!(f, "HashLib"),
            Self::SymLib => write!(f, "SymLib"),
            Self::MathLib => write!(f, "MathLib"),
            Self::ImplementationPcr => write!(f, "ImplementationPcr"),
            Self::PcrSelectMax => write!(f, "PcrSelectMax"),
            Self::PlatformPcr => write!(f, "PlatformPcr"),
            Self::PcrSelectMin => write!(f, "PcrSelectMin"),
            Self::DrtmPcr => write!(f, "DrtmPcr"),
            Self::HcrtmPcr => write!(f, "HcrtmPcr"),
            Self::NumLocalities => write!(f, "NumLocalities"),
            Self::MaxHandleNum => write!(f, "MaxHandleNum"),
            Self::MaxActiveSessions => write!(f, "MaxActiveSessions"),
            Self::MaxLoadedSessions => write!(f, "MaxLoadedSessions"),
            Self::MaxSessionNum => write!(f, "MaxSessionNum"),
            Self::MaxLoadedObjects => write!(f, "MaxLoadedObjects"),
            Self::MinEvictObjects => write!(f, "MinEvictObjects"),
            Self::NumPolicyPcrGroup => write!(f, "NumPolicyPcrGroup"),
            Self::NumAuthvaluePcrGroup => write!(f, "NumAuthvaluePcrGroup"),
            Self::MaxContextSize => write!(f, "MaxContextSize"),
            Self::MaxDigestBuffer => write!(f, "MaxDigestBuffer"),
            Self::MaxNvIndexSize => write!(f, "MaxNvIndexSize"),
            Self::MaxNvBufferSize => write!(f, "MaxNvBufferSize"),
            Self::MaxCapBuffer => write!(f, "MaxCapBuffer"),
            Self::NvMemorySize => write!(f, "NvMemorySize"),
            Self::MinCounterIndices => write!(f, "MinCounterIndices"),
            Self::NumStaticPcr => write!(f, "NumStaticPcr"),
            Self::MaxAlgListSize => write!(f, "MaxAlgListSize"),
            Self::PrimarySeedSize => write!(f, "PrimarySeedSize"),
            Self::ContextEncryptAlgorithm => write!(f, "ContextEncryptAlgorithm"),
            Self::NvClockUpdateInterval => write!(f, "NvClockUpdateInterval"),
            Self::NumPolicyPcr => write!(f, "NumPolicyPcr"),
            Self::MaxCommandSize => write!(f, "MaxCommandSize"),
            Self::MaxResponseSize => write!(f, "MaxResponseSize"),
            Self::OrderlyBits => write!(f, "OrderlyBits"),
            Self::MaxSymData => write!(f, "MaxSymData"),
            Self::MaxRngEntropySize => write!(f, "MaxRngEntropySize"),
            Self::RamIndexSpace => write!(f, "RamIndexSpace"),
            Self::RsaDefaultPublicExponent => write!(f, "RsaDefaultPublicExponent"),
            Self::EnablePcrNoIncrement => write!(f, "EnablePcrNoIncrement"),
            Self::CrtFormatRsa => write!(f, "CrtFormatRsa"),
            Self::VendorCommandCount => write!(f, "VendorCommandCount"),
            Self::MaxVendorBufferSize => write!(f, "MaxVendorBufferSize"),
            Self::MaxDerivationBits => write!(f, "MaxDerivationBits"),
            Self::RsaMaxPrime => write!(f, "RsaMaxPrime"),
            Self::RsaPrivateSize => write!(f, "RsaPrivateSize"),
            Self::SizeOfX509SerialNumber => write!(f, "SizeOfX509SerialNumber"),
            Self::PrivateVendorSpecificBytes => write!(f, "PrivateVendorSpecificBytes"),
        }

    }

}

/// The definitions in Table 29 are used to define many of the interface data types.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u32)]
pub enum TPM_HC {
    /// To mask off the HR
    HrHandleMask = 0x00FFFFFF,

    /// To mask off the variable part
    HrRangeMask = 0xFF000000,
    HrShift = 24,
    HrPcr = (TPM_HT:PCR  <<  HR_SHIFT),
    HrHmacSession = (TPM_HT:HMAC_SESSION  <<  HR_SHIFT),
    HrPolicySession = (TPM_HT:POLICY_SESSION  <<  HR_SHIFT),
    HrTransient = (TPM_HT:TRANSIENT  <<  HR_SHIFT),
    HrPersistent = (TPM_HT:PERSISTENT  <<  HR_SHIFT),
    HrNvIndex = (TPM_HT:NV_INDEX  <<  HR_SHIFT),
    HrPermanent = (TPM_HT:PERMANENT  <<  HR_SHIFT),

    /// First PCR
    PcrFirst = (HR_PCR + 0),

    /// Last PCR
    PcrLast = (PCR_FIRST + Implementation:IMPLEMENTATION_PCR-1),

    /// First HMAC session
    HmacSessionFirst = (HR_HMAC_SESSION + 0),

    /// Last HMAC session
    HmacSessionLast = (HMAC_SESSION_FIRST+Implementation:MAX_ACTIVE_SESSIONS-1),

    /// Used in GetCapability
    LoadedSessionFirst = HMAC_SESSION_FIRST,

    /// Used in GetCapability
    LoadedSessionLast = HMAC_SESSION_LAST,

    /// First policy session
    PolicySessionFirst = (HR_POLICY_SESSION + 0),

    /// Last policy session
    PolicySessionLast = (POLICY_SESSION_FIRST + Implementation:MAX_ACTIVE_SESSIONS-1),

    /// First transient object
    TransientFirst = (HR_TRANSIENT + 0),

    /// Used in GetCapability
    ActiveSessionFirst = POLICY_SESSION_FIRST,

    /// Used in GetCapability
    ActiveSessionLast = POLICY_SESSION_LAST,

    /// Last transient object
    TransientLast = (TRANSIENT_FIRST+Implementation:MAX_LOADED_OBJECTS-1),

    /// First persistent object
    PersistentFirst = (HR_PERSISTENT + 0),

    /// Last persistent object
    PersistentLast = (PERSISTENT_FIRST + 0x00FFFFFF),

    /// First platform persistent object
    PlatformPersistent = (PERSISTENT_FIRST + 0x00800000),

    /// First allowed NV Index
    NvIndexFirst = (HR_NV_INDEX + 0),

    /// Last allowed NV Index
    NvIndexLast = (NV_INDEX_FIRST + 0x00FFFFFF),
    PermanentFirst = TPM_RH:FIRST,
    PermanentLast = TPM_RH:LAST,

    /// AC aliased NV Index
    HrNvAc = ((TPM_HT:NV_INDEX  <<  HR_SHIFT) + 0xD00000),

    /// First NV Index aliased to Attached Component
    NvAcFirst = (HR_NV_AC + 0),

    /// Last NV Index aliased to Attached Component
    NvAcLast = (HR_NV_AC + 0x0000FFFF),

    /// AC Handle
    HrAc = (TPM_HT:AC  <<  HR_SHIFT),

    /// First Attached Component
    AcFirst = (HR_AC + 0),

    /// Last Attached Component
    AcLast = (HR_AC + 0x0000FFFF)
}

impl TryFrom<u32> for TPM_HC {
    type Error = TpmError;

    fn try_from(value: u32) -> Result<Self, Self::Error> {
        match value {
            0x00FFFFFF => Ok(Self::HrHandleMask),
            0xFF000000 => Ok(Self::HrRangeMask),
            24 => Ok(Self::HrShift),
            (TPM_HT:PCR  <<  HR_SHIFT) => Ok(Self::HrPcr),
            (TPM_HT:HMAC_SESSION  <<  HR_SHIFT) => Ok(Self::HrHmacSession),
            (TPM_HT:POLICY_SESSION  <<  HR_SHIFT) => Ok(Self::HrPolicySession),
            (TPM_HT:TRANSIENT  <<  HR_SHIFT) => Ok(Self::HrTransient),
            (TPM_HT:PERSISTENT  <<  HR_SHIFT) => Ok(Self::HrPersistent),
            (TPM_HT:NV_INDEX  <<  HR_SHIFT) => Ok(Self::HrNvIndex),
            (TPM_HT:PERMANENT  <<  HR_SHIFT) => Ok(Self::HrPermanent),
            (HR_PCR + 0) => Ok(Self::PcrFirst),
            (PCR_FIRST + Implementation:IMPLEMENTATION_PCR-1) => Ok(Self::PcrLast),
            (HR_HMAC_SESSION + 0) => Ok(Self::HmacSessionFirst),
            (HMAC_SESSION_FIRST+Implementation:MAX_ACTIVE_SESSIONS-1) => Ok(Self::HmacSessionLast),
            HMAC_SESSION_FIRST => Ok(Self::LoadedSessionFirst),
            HMAC_SESSION_LAST => Ok(Self::LoadedSessionLast),
            (HR_POLICY_SESSION + 0) => Ok(Self::PolicySessionFirst),
            (POLICY_SESSION_FIRST + Implementation:MAX_ACTIVE_SESSIONS-1) => Ok(Self::PolicySessionLast),
            (HR_TRANSIENT + 0) => Ok(Self::TransientFirst),
            POLICY_SESSION_FIRST => Ok(Self::ActiveSessionFirst),
            POLICY_SESSION_LAST => Ok(Self::ActiveSessionLast),
            (TRANSIENT_FIRST+Implementation:MAX_LOADED_OBJECTS-1) => Ok(Self::TransientLast),
            (HR_PERSISTENT + 0) => Ok(Self::PersistentFirst),
            (PERSISTENT_FIRST + 0x00FFFFFF) => Ok(Self::PersistentLast),
            (PERSISTENT_FIRST + 0x00800000) => Ok(Self::PlatformPersistent),
            (HR_NV_INDEX + 0) => Ok(Self::NvIndexFirst),
            (NV_INDEX_FIRST + 0x00FFFFFF) => Ok(Self::NvIndexLast),
            TPM_RH:FIRST => Ok(Self::PermanentFirst),
            TPM_RH:LAST => Ok(Self::PermanentLast),
            ((TPM_HT:NV_INDEX  <<  HR_SHIFT) + 0xD00000) => Ok(Self::HrNvAc),
            (HR_NV_AC + 0) => Ok(Self::NvAcFirst),
            (HR_NV_AC + 0x0000FFFF) => Ok(Self::NvAcLast),
            (TPM_HT:AC  <<  HR_SHIFT) => Ok(Self::HrAc),
            (HR_AC + 0) => Ok(Self::AcFirst),
            (HR_AC + 0x0000FFFF) => Ok(Self::AcLast),
            _ => Err(TpmError::InvalidEnumValue),
        }

    }

}

impl fmt::Display for TPM_HC {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::HrHandleMask => write!(f, "HrHandleMask"),
            Self::HrRangeMask => write!(f, "HrRangeMask"),
            Self::HrShift => write!(f, "HrShift"),
            Self::HrPcr => write!(f, "HrPcr"),
            Self::HrHmacSession => write!(f, "HrHmacSession"),
            Self::HrPolicySession => write!(f, "HrPolicySession"),
            Self::HrTransient => write!(f, "HrTransient"),
            Self::HrPersistent => write!(f, "HrPersistent"),
            Self::HrNvIndex => write!(f, "HrNvIndex"),
            Self::HrPermanent => write!(f, "HrPermanent"),
            Self::PcrFirst => write!(f, "PcrFirst"),
            Self::PcrLast => write!(f, "PcrLast"),
            Self::HmacSessionFirst => write!(f, "HmacSessionFirst"),
            Self::HmacSessionLast => write!(f, "HmacSessionLast"),
            Self::LoadedSessionFirst => write!(f, "LoadedSessionFirst"),
            Self::LoadedSessionLast => write!(f, "LoadedSessionLast"),
            Self::PolicySessionFirst => write!(f, "PolicySessionFirst"),
            Self::PolicySessionLast => write!(f, "PolicySessionLast"),
            Self::TransientFirst => write!(f, "TransientFirst"),
            Self::ActiveSessionFirst => write!(f, "ActiveSessionFirst"),
            Self::ActiveSessionLast => write!(f, "ActiveSessionLast"),
            Self::TransientLast => write!(f, "TransientLast"),
            Self::PersistentFirst => write!(f, "PersistentFirst"),
            Self::PersistentLast => write!(f, "PersistentLast"),
            Self::PlatformPersistent => write!(f, "PlatformPersistent"),
            Self::NvIndexFirst => write!(f, "NvIndexFirst"),
            Self::NvIndexLast => write!(f, "NvIndexLast"),
            Self::PermanentFirst => write!(f, "PermanentFirst"),
            Self::PermanentLast => write!(f, "PermanentLast"),
            Self::HrNvAc => write!(f, "HrNvAc"),
            Self::NvAcFirst => write!(f, "NvAcFirst"),
            Self::NvAcLast => write!(f, "NvAcLast"),
            Self::HrAc => write!(f, "HrAc"),
            Self::AcFirst => write!(f, "AcFirst"),
            Self::AcLast => write!(f, "AcLast"),
        }

    }

}

/// This structure defines the attributes of an algorithm.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u32)]
pub enum TPMA_ALGORITHM {
    /// SET (1): an asymmetric algorithm with public and private portions
    /// CLEAR (0): not an asymmetric algorithm
    Asymmetric = 0x1,

    /// SET (1): a symmetric block cipher
    /// CLEAR (0): not a symmetric block cipher
    Symmetric = 0x2,

    /// SET (1): a hash algorithm
    /// CLEAR (0): not a hash algorithm
    Hash = 0x4,

    /// SET (1): an algorithm that may be used as an object type
    /// CLEAR (0): an algorithm that is not used as an object type
    Object = 0x8,

    /// SET (1): a signing algorithm. The setting of asymmetric, symmetric, and hash will
    /// indicate the type of signing algorithm.
    /// CLEAR (0): not a signing algorithm
    Signing = 0x100,

    /// SET (1): an encryption/decryption algorithm. The setting of asymmetric, symmetric, and
    /// hash will indicate the type of encryption/decryption algorithm.
    /// CLEAR (0): not an encryption/decryption algorithm
    Encrypting = 0x200,

    /// SET (1): a method such as a key derivative function (KDF)
    /// CLEAR (0): not a method
    Method = 0x400
}

impl TryFrom<u32> for TPMA_ALGORITHM {
    type Error = TpmError;

    fn try_from(value: u32) -> Result<Self, Self::Error> {
        match value {
            0x1 => Ok(Self::Asymmetric),
            0x2 => Ok(Self::Symmetric),
            0x4 => Ok(Self::Hash),
            0x8 => Ok(Self::Object),
            0x100 => Ok(Self::Signing),
            0x200 => Ok(Self::Encrypting),
            0x400 => Ok(Self::Method),
            _ => Err(TpmError::InvalidEnumValue),
        }

    }

}

impl fmt::Display for TPMA_ALGORITHM {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::Asymmetric => write!(f, "Asymmetric"),
            Self::Symmetric => write!(f, "Symmetric"),
            Self::Hash => write!(f, "Hash"),
            Self::Object => write!(f, "Object"),
            Self::Signing => write!(f, "Signing"),
            Self::Encrypting => write!(f, "Encrypting"),
            Self::Method => write!(f, "Method"),
        }

    }

}

impl std::ops::BitOr for TPMA_ALGORITHM {
type Output = Self;
    fn bitor(self, rhs: Self) -> Self::Output {
    unsafe { std::mem::transmute(self as u32 | rhs as u32) }
    }

}

impl From<u32> for TPMA_ALGORITHM {
fn from(value: u32) -> Self {
    unsafe { std::mem::transmute(value) }
    }

}

/// This attribute structure indicates an objects use, its authorization types, and its
/// relationship to other objects.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u32)]
pub enum TPMA_OBJECT {
    /// SET (1): The hierarchy of the object, as indicated by its Qualified Name, may not change.
    /// CLEAR (0): The hierarchy of the object may change as a result of this object or an
    /// ancestor key being duplicated for use in another hierarchy.
    /// NOTE fixedTPM does not indicate that key material resides on a single TPM (see
    /// sensitiveDataOrigin).
    FixedTPM = 0x2,

    /// SET (1): Previously saved contexts of this object may not be loaded after Startup(CLEAR).
    /// CLEAR (0): Saved contexts of this object may be used after a Shutdown(STATE) and
    /// subsequent Startup().
    StClear = 0x4,

    /// SET (1): The parent of the object may not change.
    /// CLEAR (0): The parent of the object may change as the result of a TPM2_Duplicate() of
    /// the object.
    FixedParent = 0x10,

    /// SET (1): Indicates that, when the object was created with TPM2_Create() or
    /// TPM2_CreatePrimary(), the TPM generated all of the sensitive data other than the authValue.
    /// CLEAR (0): A portion of the sensitive data, other than the authValue, was provided by
    /// the caller.
    SensitiveDataOrigin = 0x20,

    /// SET (1): Approval of USER role actions with this object may be with an HMAC session or
    /// with a password using the authValue of the object or a policy session.
    /// CLEAR (0): Approval of USER role actions with this object may only be done with a
    /// policy session.
    UserWithAuth = 0x40,

    /// SET (1): Approval of ADMIN role actions with this object may only be done with a
    /// policy session.
    /// CLEAR (0): Approval of ADMIN role actions with this object may be with an HMAC session
    /// or with a password using the authValue of the object or a policy session.
    AdminWithPolicy = 0x80,

    /// SET (1): The object is not subject to dictionary attack protections.
    /// CLEAR (0): The object is subject to dictionary attack protections.
    NoDA = 0x400,

    /// SET (1): If the object is duplicated, then symmetricAlg shall not be TPM_ALG_NULL and
    /// newParentHandle shall not be TPM_RH_NULL.
    /// CLEAR (0): The object may be duplicated without an inner wrapper on the private
    /// portion of the object and the new parent may be TPM_RH_NULL.
    EncryptedDuplication = 0x800,

    /// SET (1): Key usage is restricted to manipulate structures of known format; the parent
    /// of this key shall have restricted SET.
    /// CLEAR (0): Key usage is not restricted to use on special formats.
    Restricted = 0x10000,

    /// SET (1): The private portion of the key may be used to decrypt.
    /// CLEAR (0): The private portion of the key may not be used to decrypt.
    Decrypt = 0x20000,

    /// SET (1): For a symmetric cipher object, the private portion of the key may be used to
    /// encrypt. For other objects, the private portion of the key may be used to sign.
    /// CLEAR (0): The private portion of the key may not be used to sign or encrypt.
    Sign = 0x40000,

    /// Alias to the sign value.
    Encrypt = 0x40000,

    /// SET (1): An asymmetric key that may not be used to sign with TPM2_Sign()
    /// CLEAR (0): A key that may be used with TPM2_Sign() if sign is SET
    /// NOTE: This attribute only has significance if sign is SET.
    X509sign = 0x80000
}

impl TryFrom<u32> for TPMA_OBJECT {
    type Error = TpmError;

    fn try_from(value: u32) -> Result<Self, Self::Error> {
        match value {
            0x2 => Ok(Self::FixedTPM),
            0x4 => Ok(Self::StClear),
            0x10 => Ok(Self::FixedParent),
            0x20 => Ok(Self::SensitiveDataOrigin),
            0x40 => Ok(Self::UserWithAuth),
            0x80 => Ok(Self::AdminWithPolicy),
            0x400 => Ok(Self::NoDA),
            0x800 => Ok(Self::EncryptedDuplication),
            0x10000 => Ok(Self::Restricted),
            0x20000 => Ok(Self::Decrypt),
            0x40000 => Ok(Self::Sign),
            0x40000 => Ok(Self::Encrypt),
            0x80000 => Ok(Self::X509sign),
            _ => Err(TpmError::InvalidEnumValue),
        }

    }

}

impl fmt::Display for TPMA_OBJECT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::FixedTPM => write!(f, "FixedTPM"),
            Self::StClear => write!(f, "StClear"),
            Self::FixedParent => write!(f, "FixedParent"),
            Self::SensitiveDataOrigin => write!(f, "SensitiveDataOrigin"),
            Self::UserWithAuth => write!(f, "UserWithAuth"),
            Self::AdminWithPolicy => write!(f, "AdminWithPolicy"),
            Self::NoDA => write!(f, "NoDA"),
            Self::EncryptedDuplication => write!(f, "EncryptedDuplication"),
            Self::Restricted => write!(f, "Restricted"),
            Self::Decrypt => write!(f, "Decrypt"),
            Self::Sign => write!(f, "Sign"),
            Self::Encrypt => write!(f, "Encrypt"),
            Self::X509sign => write!(f, "X509sign"),
        }

    }

}

impl std::ops::BitOr for TPMA_OBJECT {
type Output = Self;
    fn bitor(self, rhs: Self) -> Self::Output {
    unsafe { std::mem::transmute(self as u32 | rhs as u32) }
    }

}

impl From<u32> for TPMA_OBJECT {
fn from(value: u32) -> Self {
    unsafe { std::mem::transmute(value) }
    }

}

/// This octet in each session is used to identify the session type, indicate its
/// relationship to any handles in the command, and indicate its use in parameter encryption.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum TPMA_SESSION {
    /// SET (1): In a command, this setting indicates that the session is to remain active
    /// after successful completion of the command. In a response, it indicates that the
    /// session is still active. If SET in the command, this attribute shall be SET in the response.
    /// CLEAR (0): In a command, this setting indicates that the TPM should close the session
    /// and flush any related context when the command completes successfully. In a response,
    /// it indicates that the session is closed and the context is no longer active.
    /// This attribute has no meaning for a password authorization and the TPM will allow any
    /// setting of the attribute in the command and SET the attribute in the response.
    /// This attribute will only be CLEAR in one response for a logical session. If the
    /// attribute is CLEAR, the context associated with the session is no longer in use and
    /// the space is available. A session created after another session is ended may have the
    /// same handle but logically is not the same session.
    /// This attribute has no effect if the command does not complete successfully.
    ContinueSession = 0x1,

    /// SET (1): In a command, this setting indicates that the command should only be executed
    /// if the session is exclusive at the start of the command. In a response, it indicates
    /// that the session is exclusive. This setting is only allowed if the audit attribute is
    /// SET (TPM_RC_ATTRIBUTES).
    /// CLEAR (0): In a command, indicates that the session need not be exclusive at the start
    /// of the command. In a response, indicates that the session is not exclusive.
    AuditExclusive = 0x2,

    /// SET (1): In a command, this setting indicates that the audit digest of the session
    /// should be initialized and the exclusive status of the session SET. This setting is
    /// only allowed if the audit attribute is SET (TPM_RC_ATTRIBUTES).
    /// CLEAR (0): In a command, indicates that the audit digest should not be initialized.
    /// This bit is always CLEAR in a response.
    AuditReset = 0x4,

    /// SET (1): In a command, this setting indicates that the first parameter in the command
    /// is symmetrically encrypted using the parameter encryption scheme described in TPM 2.0
    /// Part 1. The TPM will decrypt the parameter after performing any HMAC computations and
    /// before unmarshaling the parameter. In a response, the attribute is copied from the
    /// request but has no effect on the response.
    /// CLEAR (0): Session not used for encryption.
    /// For a password authorization, this attribute will be CLEAR in both the command and response.
    /// This attribute may be SET in a session that is not associated with a command handle.
    /// Such a session is provided for purposes of encrypting a parameter and not for authorization.
    /// This attribute may be SET in combination with any other session attributes.
    Decrypt = 0x20,

    /// SET (1): In a command, this setting indicates that the TPM should use this session to
    /// encrypt the first parameter in the response. In a response, it indicates that the
    /// attribute was set in the command and that the TPM used the session to encrypt the
    /// first parameter in the response using the parameter encryption scheme described in TPM
    /// 2.0 Part 1.
    /// CLEAR (0): Session not used for encryption.
    /// For a password authorization, this attribute will be CLEAR in both the command and response.
    /// This attribute may be SET in a session that is not associated with a command handle.
    /// Such a session is provided for purposes of encrypting a parameter and not for authorization.
    Encrypt = 0x40,

    /// SET (1): In a command or response, this setting indicates that the session is for
    /// audit and that auditExclusive and auditReset have meaning. This session may also be
    /// used for authorization, encryption, or decryption. The encrypted and encrypt fields
    /// may be SET or CLEAR.
    /// CLEAR (0): Session is not used for audit.
    /// If SET in the command, then this attribute will be SET in the response.
    Audit = 0x80
}

impl TryFrom<u8> for TPMA_SESSION {
    type Error = TpmError;

    fn try_from(value: u8) -> Result<Self, Self::Error> {
        match value {
            0x1 => Ok(Self::ContinueSession),
            0x2 => Ok(Self::AuditExclusive),
            0x4 => Ok(Self::AuditReset),
            0x20 => Ok(Self::Decrypt),
            0x40 => Ok(Self::Encrypt),
            0x80 => Ok(Self::Audit),
            _ => Err(TpmError::InvalidEnumValue),
        }

    }

}

impl fmt::Display for TPMA_SESSION {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::ContinueSession => write!(f, "ContinueSession"),
            Self::AuditExclusive => write!(f, "AuditExclusive"),
            Self::AuditReset => write!(f, "AuditReset"),
            Self::Decrypt => write!(f, "Decrypt"),
            Self::Encrypt => write!(f, "Encrypt"),
            Self::Audit => write!(f, "Audit"),
        }

    }

}

impl std::ops::BitOr for TPMA_SESSION {
type Output = Self;
    fn bitor(self, rhs: Self) -> Self::Output {
    unsafe { std::mem::transmute(self as u8 | rhs as u8) }
    }

}

impl From<u8> for TPMA_SESSION {
fn from(value: u8) -> Self {
    unsafe { std::mem::transmute(value) }
    }

}

/// In a TPMS_CREATION_DATA structure, this structure is used to indicate the locality of
/// the command that created the object. No more than one of the locality attributes shall
/// be set in the creation data.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum TPMA_LOCALITY {
    LocZero = 0x1,
    LocOne = 0x2,
    LocTwo = 0x4,
    LocThree = 0x8,
    LocFour = 0x10,

    /// If any of these bits is set, an extended locality is indicated
    ExtendedBitMask = 0xE0,
    ExtendedBitOffset = 5,
    ExtendedBitLength = 3
}

impl TryFrom<u8> for TPMA_LOCALITY {
    type Error = TpmError;

    fn try_from(value: u8) -> Result<Self, Self::Error> {
        match value {
            0x1 => Ok(Self::LocZero),
            0x2 => Ok(Self::LocOne),
            0x4 => Ok(Self::LocTwo),
            0x8 => Ok(Self::LocThree),
            0x10 => Ok(Self::LocFour),
            0xE0 => Ok(Self::ExtendedBitMask),
            5 => Ok(Self::ExtendedBitOffset),
            3 => Ok(Self::ExtendedBitLength),
            _ => Err(TpmError::InvalidEnumValue),
        }

    }

}

impl fmt::Display for TPMA_LOCALITY {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::LocZero => write!(f, "LocZero"),
            Self::LocOne => write!(f, "LocOne"),
            Self::LocTwo => write!(f, "LocTwo"),
            Self::LocThree => write!(f, "LocThree"),
            Self::LocFour => write!(f, "LocFour"),
            Self::ExtendedBitMask => write!(f, "ExtendedBitMask"),
            Self::ExtendedBitOffset => write!(f, "ExtendedBitOffset"),
            Self::ExtendedBitLength => write!(f, "ExtendedBitLength"),
        }

    }

}

impl std::ops::BitOr for TPMA_LOCALITY {
type Output = Self;
    fn bitor(self, rhs: Self) -> Self::Output {
    unsafe { std::mem::transmute(self as u8 | rhs as u8) }
    }

}

impl From<u8> for TPMA_LOCALITY {
fn from(value: u8) -> Self {
    unsafe { std::mem::transmute(value) }
    }

}

/// The attributes in this structure are persistent and are not changed as a result of
/// _TPM_Init or any TPM2_Startup(). Some of the attributes in this structure may change
/// as the result of specific Protected Capabilities. This structure may be read using
/// TPM2_GetCapability(capability = TPM_CAP_TPM_PROPERTIES, property = TPM_PT_PERMANENT).
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u32)]
pub enum TPMA_PERMANENT {
    /// SET (1): TPM2_HierarchyChangeAuth() with ownerAuth has been executed since the last TPM2_Clear().
    /// CLEAR (0): ownerAuth has not been changed since TPM2_Clear().
    OwnerAuthSet = 0x1,

    /// SET (1): TPM2_HierarchyChangeAuth() with endorsementAuth has been executed since the
    /// last TPM2_Clear().
    /// CLEAR (0): endorsementAuth has not been changed since TPM2_Clear().
    EndorsementAuthSet = 0x2,

    /// SET (1): TPM2_HierarchyChangeAuth() with lockoutAuth has been executed since the last
    /// TPM2_Clear().
    /// CLEAR (0): lockoutAuth has not been changed since TPM2_Clear().
    LockoutAuthSet = 0x4,

    /// SET (1): TPM2_Clear() is disabled.
    /// CLEAR (0): TPM2_Clear() is enabled.
    /// NOTE See TPM2_ClearControl in TPM 2.0 Part 3 for details on changing this attribute.
    DisableClear = 0x100,

    /// SET (1): The TPM is in lockout, when failedTries is equal to maxTries.
    InLockout = 0x200,

    /// SET (1): The EPS was created by the TPM.
    /// CLEAR (0): The EPS was created outside of the TPM using a manufacturer-specific process.
    TpmGeneratedEPS = 0x400
}

impl TryFrom<u32> for TPMA_PERMANENT {
    type Error = TpmError;

    fn try_from(value: u32) -> Result<Self, Self::Error> {
        match value {
            0x1 => Ok(Self::OwnerAuthSet),
            0x2 => Ok(Self::EndorsementAuthSet),
            0x4 => Ok(Self::LockoutAuthSet),
            0x100 => Ok(Self::DisableClear),
            0x200 => Ok(Self::InLockout),
            0x400 => Ok(Self::TpmGeneratedEPS),
            _ => Err(TpmError::InvalidEnumValue),
        }

    }

}

impl fmt::Display for TPMA_PERMANENT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::OwnerAuthSet => write!(f, "OwnerAuthSet"),
            Self::EndorsementAuthSet => write!(f, "EndorsementAuthSet"),
            Self::LockoutAuthSet => write!(f, "LockoutAuthSet"),
            Self::DisableClear => write!(f, "DisableClear"),
            Self::InLockout => write!(f, "InLockout"),
            Self::TpmGeneratedEPS => write!(f, "TpmGeneratedEPS"),
        }

    }

}

impl std::ops::BitOr for TPMA_PERMANENT {
type Output = Self;
    fn bitor(self, rhs: Self) -> Self::Output {
    unsafe { std::mem::transmute(self as u32 | rhs as u32) }
    }

}

impl From<u32> for TPMA_PERMANENT {
fn from(value: u32) -> Self {
    unsafe { std::mem::transmute(value) }
    }

}

/// This structure may be read using TPM2_GetCapability(capability =
/// TPM_CAP_TPM_PROPERTIES, property = TPM_PT_STARTUP_CLEAR).
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u32)]
pub enum TPMA_STARTUP_CLEAR {
    /// SET (1): The platform hierarchy is enabled and platformAuth or platformPolicy may be
    /// used for authorization.
    /// CLEAR (0): platformAuth and platformPolicy may not be used for authorizations, and
    /// objects in the platform hierarchy, including persistent objects, cannot be used.
    /// NOTE See TPM2_HierarchyControl in TPM 2.0 Part 3 for details on changing this attribute.
    PhEnable = 0x1,

    /// SET (1): The Storage hierarchy is enabled and ownerAuth or ownerPolicy may be used for
    /// authorization. NV indices defined using owner authorization are accessible.
    /// CLEAR (0): ownerAuth and ownerPolicy may not be used for authorizations, and objects
    /// in the Storage hierarchy, persistent objects, and NV indices defined using owner
    /// authorization cannot be used.
    /// NOTE See TPM2_HierarchyControl in TPM 2.0 Part 3 for details on changing this attribute.
    ShEnable = 0x2,

    /// SET (1): The EPS hierarchy is enabled and Endorsement Authorization may be used to
    /// authorize commands.
    /// CLEAR (0): Endorsement Authorization may not be used for authorizations, and objects
    /// in the endorsement hierarchy, including persistent objects, cannot be used.
    /// NOTE See TPM2_HierarchyControl in TPM 2.0 Part 3 for details on changing this attribute.
    EhEnable = 0x4,

    /// SET (1): NV indices that have TPMA_NV_PLATFORMCREATE SET may be read or written. The
    /// platform can create define and undefine indices.
    /// CLEAR (0): NV indices that have TPMA_NV_PLATFORMCREATE SET may not be read or written
    /// (TPM_RC_HANDLE). The platform cannot define (TPM_RC_HIERARCHY) or undefined
    /// (TPM_RC_HANDLE) indices.
    /// NOTE See TPM2_HierarchyControl in TPM 2.0 Part 3 for details on changing this attribute.
    /// NOTE
    /// read refers to these commands: TPM2_NV_Read, TPM2_NV_ReadPublic, TPM_NV_Certify, TPM2_PolicyNV
    /// write refers to these commands: TPM2_NV_Write, TPM2_NV_Increment, TPM2_NV_Extend, TPM2_NV_SetBits
    /// NOTE The TPM must query the index TPMA_NV_PLATFORMCREATE attribute to determine
    /// whether phEnableNV is applicable. Since the TPM will return TPM_RC_HANDLE if the index
    /// does not exist, it also returns this error code if the index is disabled. Otherwise,
    /// the TPM would leak the existence of an index even when disabled.
    PhEnableNV = 0x8,

    /// SET (1): The TPM received a TPM2_Shutdown() and a matching TPM2_Startup().
    /// CLEAR (0): TPM2_Startup(TPM_SU_CLEAR) was not preceded by a TPM2_Shutdown() of any type.
    /// NOTE A shutdown is orderly if the TPM receives a TPM2_Shutdown() of any type followed
    /// by a TPM2_Startup() of any type. However, the TPM will return an error if
    /// TPM2_Startup(TPM_SU_STATE) was not preceded by TPM2_Shutdown(TPM_SU_STATE).
    Orderly = 0x80000000
}

impl TryFrom<u32> for TPMA_STARTUP_CLEAR {
    type Error = TpmError;

    fn try_from(value: u32) -> Result<Self, Self::Error> {
        match value {
            0x1 => Ok(Self::PhEnable),
            0x2 => Ok(Self::ShEnable),
            0x4 => Ok(Self::EhEnable),
            0x8 => Ok(Self::PhEnableNV),
            0x80000000 => Ok(Self::Orderly),
            _ => Err(TpmError::InvalidEnumValue),
        }

    }

}

impl fmt::Display for TPMA_STARTUP_CLEAR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::PhEnable => write!(f, "PhEnable"),
            Self::ShEnable => write!(f, "ShEnable"),
            Self::EhEnable => write!(f, "EhEnable"),
            Self::PhEnableNV => write!(f, "PhEnableNV"),
            Self::Orderly => write!(f, "Orderly"),
        }

    }

}

impl std::ops::BitOr for TPMA_STARTUP_CLEAR {
type Output = Self;
    fn bitor(self, rhs: Self) -> Self::Output {
    unsafe { std::mem::transmute(self as u32 | rhs as u32) }
    }

}

impl From<u32> for TPMA_STARTUP_CLEAR {
fn from(value: u32) -> Self {
    unsafe { std::mem::transmute(value) }
    }

}

/// This structure of this attribute is used to report the memory management method used
/// by the TPM for transient objects and authorization sessions. This structure may be
/// read using TPM2_GetCapability(capability = TPM_CAP_TPM_PROPERTIES, property = TPM_PT_MEMORY).
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u32)]
pub enum TPMA_MEMORY {
    /// SET (1): indicates that the RAM memory used for authorization session contexts is
    /// shared with the memory used for transient objects
    /// CLEAR (0): indicates that the memory used for authorization sessions is not shared
    /// with memory used for transient objects
    SharedRAM = 0x1,

    /// SET (1): indicates that the NV memory used for persistent objects is shared with the
    /// NV memory used for NV Index values
    /// CLEAR (0): indicates that the persistent objects and NV Index values are allocated
    /// from separate sections of NV
    SharedNV = 0x2,

    /// SET (1): indicates that the TPM copies persistent objects to a transient-object slot
    /// in RAM when the persistent object is referenced in a command. The TRM is required to
    /// make sure that an object slot is available.
    /// CLEAR (0): indicates that the TPM does not use transient-object slots when persistent
    /// objects are referenced
    ObjectCopiedToRam = 0x4
}

impl TryFrom<u32> for TPMA_MEMORY {
    type Error = TpmError;

    fn try_from(value: u32) -> Result<Self, Self::Error> {
        match value {
            0x1 => Ok(Self::SharedRAM),
            0x2 => Ok(Self::SharedNV),
            0x4 => Ok(Self::ObjectCopiedToRam),
            _ => Err(TpmError::InvalidEnumValue),
        }

    }

}

impl fmt::Display for TPMA_MEMORY {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::SharedRAM => write!(f, "SharedRAM"),
            Self::SharedNV => write!(f, "SharedNV"),
            Self::ObjectCopiedToRam => write!(f, "ObjectCopiedToRam"),
        }

    }

}

impl std::ops::BitOr for TPMA_MEMORY {
type Output = Self;
    fn bitor(self, rhs: Self) -> Self::Output {
    unsafe { std::mem::transmute(self as u32 | rhs as u32) }
    }

}

impl From<u32> for TPMA_MEMORY {
fn from(value: u32) -> Self {
    unsafe { std::mem::transmute(value) }
    }

}

/// This structure defines the attributes of a command from a context management
/// perspective. The fields of the structure indicate to the TPM Resource Manager (TRM)
/// the number of resources required by a command and how the command affects the TPMs resources.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u32)]
pub enum TPMA_CC {
    /// Indicates the command being selected
    CommandindexBitMask = 0xFFFF,
    CommandindexBitOffset = 0,
    CommandindexBitLength = 16,

    /// SET (1): indicates that the command may write to NV
    /// CLEAR (0): indicates that the command does not write to NV
    Nv = 0x400000,

    /// SET (1): This command could flush any number of loaded contexts.
    /// CLEAR (0): no additional changes other than indicated by the flushed attribute
    Extensive = 0x800000,

    /// SET (1): The context associated with any transient handle in the command will be
    /// flushed when this command completes.
    /// CLEAR (0): No context is flushed as a side effect of this command.
    Flushed = 0x1000000,

    /// Indicates the number of the handles in the handle area for this command
    ChandlesBitMask = 0xE000000,
    ChandlesBitOffset = 25,
    ChandlesBitLength = 3,

    /// SET (1): indicates the presence of the handle area in the response
    RHandle = 0x10000000,

    /// SET (1): indicates that the command is vendor-specific
    /// CLEAR (0): indicates that the command is defined in a version of this specification
    V = 0x20000000,

    /// Allocated for software; shall be zero
    ResBitMask = 0xC0000000,
    ResBitOffset = 30,
    ResBitLength = 2
}

impl TryFrom<u32> for TPMA_CC {
    type Error = TpmError;

    fn try_from(value: u32) -> Result<Self, Self::Error> {
        match value {
            0xFFFF => Ok(Self::CommandindexBitMask),
            0 => Ok(Self::CommandindexBitOffset),
            16 => Ok(Self::CommandindexBitLength),
            0x400000 => Ok(Self::Nv),
            0x800000 => Ok(Self::Extensive),
            0x1000000 => Ok(Self::Flushed),
            0xE000000 => Ok(Self::ChandlesBitMask),
            25 => Ok(Self::ChandlesBitOffset),
            3 => Ok(Self::ChandlesBitLength),
            0x10000000 => Ok(Self::RHandle),
            0x20000000 => Ok(Self::V),
            0xC0000000 => Ok(Self::ResBitMask),
            30 => Ok(Self::ResBitOffset),
            2 => Ok(Self::ResBitLength),
            _ => Err(TpmError::InvalidEnumValue),
        }

    }

}

impl fmt::Display for TPMA_CC {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::CommandindexBitMask => write!(f, "CommandindexBitMask"),
            Self::CommandindexBitOffset => write!(f, "CommandindexBitOffset"),
            Self::CommandindexBitLength => write!(f, "CommandindexBitLength"),
            Self::Nv => write!(f, "Nv"),
            Self::Extensive => write!(f, "Extensive"),
            Self::Flushed => write!(f, "Flushed"),
            Self::ChandlesBitMask => write!(f, "ChandlesBitMask"),
            Self::ChandlesBitOffset => write!(f, "ChandlesBitOffset"),
            Self::ChandlesBitLength => write!(f, "ChandlesBitLength"),
            Self::RHandle => write!(f, "RHandle"),
            Self::V => write!(f, "V"),
            Self::ResBitMask => write!(f, "ResBitMask"),
            Self::ResBitOffset => write!(f, "ResBitOffset"),
            Self::ResBitLength => write!(f, "ResBitLength"),
        }

    }

}

impl std::ops::BitOr for TPMA_CC {
type Output = Self;
    fn bitor(self, rhs: Self) -> Self::Output {
    unsafe { std::mem::transmute(self as u32 | rhs as u32) }
    }

}

impl From<u32> for TPMA_CC {
fn from(value: u32) -> Self {
    unsafe { std::mem::transmute(value) }
    }

}

/// This structure of this attribute is used to report that the TPM is designed for these
/// modes. This structure may be read using TPM2_GetCapability(capability =
/// TPM_CAP_TPM_PROPERTIES, property = TPM_PT_MODES).
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u32)]
pub enum TPMA_MODES {
    /// SET (1): indicates that the TPM is designed to comply with all of the FIPS 140-2
    /// requirements at Level 1 or higher.
    Fips1402 = 0x1
}

impl TryFrom<u32> for TPMA_MODES {
    type Error = TpmError;

    fn try_from(value: u32) -> Result<Self, Self::Error> {
        match value {
            0x1 => Ok(Self::Fips1402),
            _ => Err(TpmError::InvalidEnumValue),
        }

    }

}

impl fmt::Display for TPMA_MODES {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::Fips1402 => write!(f, "Fips1402"),
        }

    }

}

impl std::ops::BitOr for TPMA_MODES {
type Output = Self;
    fn bitor(self, rhs: Self) -> Self::Output {
    unsafe { std::mem::transmute(self as u32 | rhs as u32) }
    }

}

impl From<u32> for TPMA_MODES {
fn from(value: u32) -> Self {
    unsafe { std::mem::transmute(value) }
    }

}

/// These attributes are as specified in clause 4.2.1.3. of RFC 5280 Internet X.509 Public
/// Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile. For
/// TPM2_CertifyX509, when a caller provides a DER encoded Key Usage in
/// partialCertificate, the TPM will validate that the key to be certified meets the
/// requirements of Key Usage.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u32)]
pub enum TPMA_X509_KEY_USAGE {
    /// Attributes.Decrypt SET
    DecipherOnly = 0x800000,

    /// Attributes.Decrypt SET
    EncipherOnly = 0x1000000,

    /// Attributes.sign SET
    CRLSign = 0x2000000,

    /// Attributes.sign SET
    KeyCertSign = 0x4000000,

    /// Attributes.Decrypt SET
    KeyAgreement = 0x8000000,

    /// Attributes.Decrypt SET
    DataEncipherment = 0x10000000,

    /// Asymmetric key with decrypt and restricted SET key has the attributes of a parent key
    KeyEncipherment = 0x20000000,

    /// FixedTPM SET in Subject Key (objectHandle)
    Nonrepudiation = 0x40000000,

    /// Alias to the nonrepudiation value.
    ContentCommitment = 0x40000000,

    /// Sign SET in Subject Key (objectHandle)
    DigitalSignature = 0x80000000
}

impl TryFrom<u32> for TPMA_X509_KEY_USAGE {
    type Error = TpmError;

    fn try_from(value: u32) -> Result<Self, Self::Error> {
        match value {
            0x800000 => Ok(Self::DecipherOnly),
            0x1000000 => Ok(Self::EncipherOnly),
            0x2000000 => Ok(Self::CRLSign),
            0x4000000 => Ok(Self::KeyCertSign),
            0x8000000 => Ok(Self::KeyAgreement),
            0x10000000 => Ok(Self::DataEncipherment),
            0x20000000 => Ok(Self::KeyEncipherment),
            0x40000000 => Ok(Self::Nonrepudiation),
            0x40000000 => Ok(Self::ContentCommitment),
            0x80000000 => Ok(Self::DigitalSignature),
            _ => Err(TpmError::InvalidEnumValue),
        }

    }

}

impl fmt::Display for TPMA_X509_KEY_USAGE {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::DecipherOnly => write!(f, "DecipherOnly"),
            Self::EncipherOnly => write!(f, "EncipherOnly"),
            Self::CRLSign => write!(f, "CRLSign"),
            Self::KeyCertSign => write!(f, "KeyCertSign"),
            Self::KeyAgreement => write!(f, "KeyAgreement"),
            Self::DataEncipherment => write!(f, "DataEncipherment"),
            Self::KeyEncipherment => write!(f, "KeyEncipherment"),
            Self::Nonrepudiation => write!(f, "Nonrepudiation"),
            Self::ContentCommitment => write!(f, "ContentCommitment"),
            Self::DigitalSignature => write!(f, "DigitalSignature"),
        }

    }

}

impl std::ops::BitOr for TPMA_X509_KEY_USAGE {
type Output = Self;
    fn bitor(self, rhs: Self) -> Self::Output {
    unsafe { std::mem::transmute(self as u32 | rhs as u32) }
    }

}

impl From<u32> for TPMA_X509_KEY_USAGE {
fn from(value: u32) -> Self {
    unsafe { std::mem::transmute(value) }
    }

}

/// This attribute is used to report the ACT state. This attribute may be read using
/// TPM2_GetCapability(capability = TPM_CAP_ACT, property = TPM_RH_ACT_x where x is the
/// ACT number (0-F)). The signaled value must be preserved across TPM Resume or if the
/// TPM has not lost power. The signaled value may be preserved over a power cycle of a TPM.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u32)]
pub enum TPMA_ACT {
    /// SET (1): The ACT has signaled
    /// CLEAR (0): The ACT has not signaled
    Signaled = 0x1,

    /// Preserves the state of signaled, depending on the power cycle
    PreserveSignaled = 0x2
}

impl TryFrom<u32> for TPMA_ACT {
    type Error = TpmError;

    fn try_from(value: u32) -> Result<Self, Self::Error> {
        match value {
            0x1 => Ok(Self::Signaled),
            0x2 => Ok(Self::PreserveSignaled),
            _ => Err(TpmError::InvalidEnumValue),
        }

    }

}

impl fmt::Display for TPMA_ACT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::Signaled => write!(f, "Signaled"),
            Self::PreserveSignaled => write!(f, "PreserveSignaled"),
        }

    }

}

impl std::ops::BitOr for TPMA_ACT {
type Output = Self;
    fn bitor(self, rhs: Self) -> Self::Output {
    unsafe { std::mem::transmute(self as u32 | rhs as u32) }
    }

}

impl From<u32> for TPMA_ACT {
fn from(value: u32) -> Self {
    unsafe { std::mem::transmute(value) }
    }

}

/// A TPM_NV_INDEX is used to reference a defined location in NV memory. The format of the
/// Index is changed from TPM 1.2 in order to include the Index in the reserved handle
/// space. Handles in this range use the digest of the public area of the Index as the
/// Name of the entity in authorization computations
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u32)]
pub enum TPM_NV_INDEX {
    /// The Index of the NV location
    IndexBitMask = 0xFFFFFF,
    IndexBitOffset = 0,
    IndexBitLength = 24,

    /// Constant value of TPM_HT_NV_INDEX indicating the NV Index range
    RhnvBitMask = 0xFF000000,
    RhnvBitOffset = 24,
    RhnvBitLength = 8
}

impl TryFrom<u32> for TPM_NV_INDEX {
    type Error = TpmError;

    fn try_from(value: u32) -> Result<Self, Self::Error> {
        match value {
            0xFFFFFF => Ok(Self::IndexBitMask),
            0 => Ok(Self::IndexBitOffset),
            24 => Ok(Self::IndexBitLength),
            0xFF000000 => Ok(Self::RhnvBitMask),
            24 => Ok(Self::RhnvBitOffset),
            8 => Ok(Self::RhnvBitLength),
            _ => Err(TpmError::InvalidEnumValue),
        }

    }

}

impl fmt::Display for TPM_NV_INDEX {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::IndexBitMask => write!(f, "IndexBitMask"),
            Self::IndexBitOffset => write!(f, "IndexBitOffset"),
            Self::IndexBitLength => write!(f, "IndexBitLength"),
            Self::RhnvBitMask => write!(f, "RhnvBitMask"),
            Self::RhnvBitOffset => write!(f, "RhnvBitOffset"),
            Self::RhnvBitLength => write!(f, "RhnvBitLength"),
        }

    }

}

impl std::ops::BitOr for TPM_NV_INDEX {
type Output = Self;
    fn bitor(self, rhs: Self) -> Self::Output {
    unsafe { std::mem::transmute(self as u32 | rhs as u32) }
    }

}

impl From<u32> for TPM_NV_INDEX {
fn from(value: u32) -> Self {
    unsafe { std::mem::transmute(value) }
    }

}

/// This structure allows the TPM to keep track of the data and permissions to manipulate
/// an NV Index.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u32)]
pub enum TPMA_NV {
    /// SET (1): The Index data can be written if Platform Authorization is provided.
    /// CLEAR (0): Writing of the Index data cannot be authorized with Platform Authorization.
    PPWRITE = 0x1,

    /// SET (1): The Index data can be written if Owner Authorization is provided.
    /// CLEAR (0): Writing of the Index data cannot be authorized with Owner Authorization.
    OWNERWRITE = 0x2,

    /// SET (1): Authorizations to change the Index contents that require USER role may be
    /// provided with an HMAC session or password.
    /// CLEAR (0): Authorizations to change the Index contents that require USER role may not
    /// be provided with an HMAC session or password.
    AUTHWRITE = 0x4,

    /// SET (1): Authorizations to change the Index contents that require USER role may be
    /// provided with a policy session.
    /// CLEAR (0): Authorizations to change the Index contents that require USER role may not
    /// be provided with a policy session.
    /// NOTE TPM2_NV_ChangeAuth() always requires that authorization be provided in a policy session.
    POLICYWRITE = 0x8,

    /// Ordinary contains data that is opaque to the TPM that can only be modified using TPM2_NV_Write().
    ORDINARY = 0x0,

    /// Counter contains an 8-octet value that is to be used as a counter and can only be
    /// modified with TPM2_NV_Increment()
    COUNTER = 0x10,

    /// Bit Field contains an 8-octet value to be used as a bit field and can only be modified
    /// with TPM2_NV_SetBits().
    BITS = 0x20,

    /// Extend contains a digest-sized value used like a PCR. The Index can only be modified
    /// using TPM2_NV_Extend(). The extend will use the nameAlg of the Index.
    EXTEND = 0x40,

    /// PIN Fail - contains pinCount that increments on a PIN authorization failure and a pinLimit
    PinFail = 0x80,

    /// PIN Pass - contains pinCount that increments on a PIN authorization success and a pinLimit
    PinPass = 0x90,

    /// The type of the index.
    /// NOTE A TPM is not required to support all TPM_NT values
    TpmntBitMask = 0xF0,
    TpmntBitOffset = 4,
    TpmntBitLength = 4,

    /// SET (1): Index may not be deleted unless the authPolicy is satisfied using
    /// TPM2_NV_UndefineSpaceSpecial().
    /// CLEAR (0): Index may be deleted with proper platform or owner authorization using
    /// TPM2_NV_UndefineSpace().
    /// NOTE An Index with this attribute and a policy that cannot be satisfied (e.g., an
    /// Empty Policy) cannot be deleted.
    PolicyDelete = 0x400,

    /// SET (1): Index cannot be written.
    /// CLEAR (0): Index can be written.
    WRITELOCKED = 0x800,

    /// SET (1): A partial write of the Index data is not allowed. The write size shall match
    /// the defined space size.
    /// CLEAR (0): Partial writes are allowed. This setting is required if the .dataSize of
    /// the Index is larger than NV_MAX_BUFFER_SIZE for the implementation.
    WRITEALL = 0x1000,

    /// SET (1): TPM2_NV_WriteLock() may be used to prevent further writes to this location.
    /// CLEAR (0): TPM2_NV_WriteLock() does not block subsequent writes if
    /// TPMA_NV_WRITE_STCLEAR is also CLEAR.
    WRITEDEFINE = 0x2000,

    /// SET (1): TPM2_NV_WriteLock() may be used to prevent further writes to this location
    /// until the next TPM Reset or TPM Restart.
    /// CLEAR (0): TPM2_NV_WriteLock() does not block subsequent writes if TPMA_NV_WRITEDEFINE
    /// is also CLEAR.
    WriteStclear = 0x4000,

    /// SET (1): If TPM2_NV_GlobalWriteLock() is successful, TPMA_NV_WRITELOCKED is set.
    /// CLEAR (0): TPM2_NV_GlobalWriteLock() has no effect on the writing of the data at this Index.
    GLOBALLOCK = 0x8000,

    /// SET (1): The Index data can be read if Platform Authorization is provided.
    /// CLEAR (0): Reading of the Index data cannot be authorized with Platform Authorization.
    PPREAD = 0x10000,

    /// SET (1): The Index data can be read if Owner Authorization is provided.
    /// CLEAR (0): Reading of the Index data cannot be authorized with Owner Authorization.
    OWNERREAD = 0x20000,

    /// SET (1): The Index data may be read if the authValue is provided.
    /// CLEAR (0): Reading of the Index data cannot be authorized with the Index authValue.
    AUTHREAD = 0x40000,

    /// SET (1): The Index data may be read if the authPolicy is satisfied.
    /// CLEAR (0): Reading of the Index data cannot be authorized with the Index authPolicy.
    POLICYREAD = 0x80000,

    /// SET (1): Authorization failures of the Index do not affect the DA logic and
    /// authorization of the Index is not blocked when the TPM is in Lockout mode.
    /// CLEAR (0): Authorization failures of the Index will increment the authorization
    /// failure counter and authorizations of this Index are not allowed when the TPM is in
    /// Lockout mode.
    NoDa = 0x2000000,

    /// SET (1): NV Index state is only required to be saved when the TPM performs an orderly
    /// shutdown (TPM2_Shutdown()).
    /// CLEAR (0): NV Index state is required to be persistent after the command to update the
    /// Index completes successfully (that is, the NV update is synchronous with the update command).
    ORDERLY = 0x4000000,

    /// SET (1): TPMA_NV_WRITTEN for the Index is CLEAR by TPM Reset or TPM Restart.
    /// CLEAR (0): TPMA_NV_WRITTEN is not changed by TPM Restart.
    /// NOTE This attribute may only be SET if TPM_NT is not TPM_NT_COUNTER.
    ClearStclear = 0x8000000,

    /// SET (1): Reads of the Index are blocked until the next TPM Reset or TPM Restart.
    /// CLEAR (0): Reads of the Index are allowed if proper authorization is provided.
    READLOCKED = 0x10000000,

    /// SET (1): Index has been written.
    /// CLEAR (0): Index has not been written.
    WRITTEN = 0x20000000,

    /// SET (1): This Index may be undefined with Platform Authorization but not with Owner
    /// Authorization.
    /// CLEAR (0): This Index may be undefined using Owner Authorization but not with Platform
    /// Authorization.
    /// The TPM will validate that this attribute is SET when the Index is defined using
    /// Platform Authorization and will validate that this attribute is CLEAR when the Index
    /// is defined using Owner Authorization.
    PLATFORMCREATE = 0x40000000,

    /// SET (1): TPM2_NV_ReadLock() may be used to SET TPMA_NV_READLOCKED for this Index.
    /// CLEAR (0): TPM2_NV_ReadLock() has no effect on this Index.
    ReadStclear = 0x80000000
}

impl TryFrom<u32> for TPMA_NV {
    type Error = TpmError;

    fn try_from(value: u32) -> Result<Self, Self::Error> {
        match value {
            0x1 => Ok(Self::PPWRITE),
            0x2 => Ok(Self::OWNERWRITE),
            0x4 => Ok(Self::AUTHWRITE),
            0x8 => Ok(Self::POLICYWRITE),
            0x0 => Ok(Self::ORDINARY),
            0x10 => Ok(Self::COUNTER),
            0x20 => Ok(Self::BITS),
            0x40 => Ok(Self::EXTEND),
            0x80 => Ok(Self::PinFail),
            0x90 => Ok(Self::PinPass),
            0xF0 => Ok(Self::TpmntBitMask),
            4 => Ok(Self::TpmntBitOffset),
            4 => Ok(Self::TpmntBitLength),
            0x400 => Ok(Self::PolicyDelete),
            0x800 => Ok(Self::WRITELOCKED),
            0x1000 => Ok(Self::WRITEALL),
            0x2000 => Ok(Self::WRITEDEFINE),
            0x4000 => Ok(Self::WriteStclear),
            0x8000 => Ok(Self::GLOBALLOCK),
            0x10000 => Ok(Self::PPREAD),
            0x20000 => Ok(Self::OWNERREAD),
            0x40000 => Ok(Self::AUTHREAD),
            0x80000 => Ok(Self::POLICYREAD),
            0x2000000 => Ok(Self::NoDa),
            0x4000000 => Ok(Self::ORDERLY),
            0x8000000 => Ok(Self::ClearStclear),
            0x10000000 => Ok(Self::READLOCKED),
            0x20000000 => Ok(Self::WRITTEN),
            0x40000000 => Ok(Self::PLATFORMCREATE),
            0x80000000 => Ok(Self::ReadStclear),
            _ => Err(TpmError::InvalidEnumValue),
        }

    }

}

impl fmt::Display for TPMA_NV {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::PPWRITE => write!(f, "PPWRITE"),
            Self::OWNERWRITE => write!(f, "OWNERWRITE"),
            Self::AUTHWRITE => write!(f, "AUTHWRITE"),
            Self::POLICYWRITE => write!(f, "POLICYWRITE"),
            Self::ORDINARY => write!(f, "ORDINARY"),
            Self::COUNTER => write!(f, "COUNTER"),
            Self::BITS => write!(f, "BITS"),
            Self::EXTEND => write!(f, "EXTEND"),
            Self::PinFail => write!(f, "PinFail"),
            Self::PinPass => write!(f, "PinPass"),
            Self::TpmntBitMask => write!(f, "TpmntBitMask"),
            Self::TpmntBitOffset => write!(f, "TpmntBitOffset"),
            Self::TpmntBitLength => write!(f, "TpmntBitLength"),
            Self::PolicyDelete => write!(f, "PolicyDelete"),
            Self::WRITELOCKED => write!(f, "WRITELOCKED"),
            Self::WRITEALL => write!(f, "WRITEALL"),
            Self::WRITEDEFINE => write!(f, "WRITEDEFINE"),
            Self::WriteStclear => write!(f, "WriteStclear"),
            Self::GLOBALLOCK => write!(f, "GLOBALLOCK"),
            Self::PPREAD => write!(f, "PPREAD"),
            Self::OWNERREAD => write!(f, "OWNERREAD"),
            Self::AUTHREAD => write!(f, "AUTHREAD"),
            Self::POLICYREAD => write!(f, "POLICYREAD"),
            Self::NoDa => write!(f, "NoDa"),
            Self::ORDERLY => write!(f, "ORDERLY"),
            Self::ClearStclear => write!(f, "ClearStclear"),
            Self::READLOCKED => write!(f, "READLOCKED"),
            Self::WRITTEN => write!(f, "WRITTEN"),
            Self::PLATFORMCREATE => write!(f, "PLATFORMCREATE"),
            Self::ReadStclear => write!(f, "ReadStclear"),
        }

    }

}

impl std::ops::BitOr for TPMA_NV {
type Output = Self;
    fn bitor(self, rhs: Self) -> Self::Output {
    unsafe { std::mem::transmute(self as u32 | rhs as u32) }
    }

}

impl From<u32> for TPMA_NV {
fn from(value: u32) -> Self {
    unsafe { std::mem::transmute(value) }
    }

}

/// Base trait for TPM union types
pub trait TpmUnion {
/// Get the union selector value
    fn get_union_selector(&self) -> u32;
}

/// Table 119 Definition of TPMU_CAPABILITIES Union [OUT]
/// One of: TPML_ALG_PROPERTY, TPML_HANDLE, TPML_CCA, TPML_CC, TPML_PCR_SELECTION,
/// TPML_TAGGED_TPM_PROPERTY, TPML_TAGGED_PCR_PROPERTY, TPML_ECC_CURVE,
/// TPML_TAGGED_POLICY, TPML_ACT_DATA.
pub enum TPMU_CAPABILITIES {
    Algorithms(TPML_ALG_PROPERTY),
    Handles(TPML_HANDLE),
    Command(TPML_CCA),
    PpCommands(TPML_CC),
    AuditCommands(TPML_CC),
    AssignedPCR(TPML_PCR_SELECTION),
    TpmProperties(TPML_TAGGED_TPM_PROPERTY),
    PcrProperties(TPML_TAGGED_PCR_PROPERTY),
    EccCurves(TPML_ECC_CURVE),
    AuthPolicies(TPML_TAGGED_POLICY),
    ActData(TPML_ACT_DATA),
}

impl TpmUnion for TPMU_CAPABILITIES {
    fn get_union_selector(&self) -> u32 {
        match self {
            Self::Algorithms(_) => TPM_CAP:ALGS as u32,
            Self::Handles(_) => TPM_CAP:HANDLES as u32,
            Self::Command(_) => TPM_CAP:COMMANDS as u32,
            Self::PpCommands(_) => TPM_CAP:PP_COMMANDS as u32,
            Self::AuditCommands(_) => TPM_CAP:AUDIT_COMMANDS as u32,
            Self::AssignedPCR(_) => TPM_CAP:PCRS as u32,
            Self::TpmProperties(_) => TPM_CAP:TPM_PROPERTIES as u32,
            Self::PcrProperties(_) => TPM_CAP:PCR_PROPERTIES as u32,
            Self::EccCurves(_) => TPM_CAP:ECC_CURVES as u32,
            Self::AuthPolicies(_) => TPM_CAP:AUTH_POLICIES as u32,
            Self::ActData(_) => TPM_CAP:ACT as u32,
        }

    }

}

impl fmt::Debug for TPMU_CAPABILITIES {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::Algorithms(inner) => write!(f, "TPMU_CAPABILITIES::Algorithms({:?})", inner),
            Self::Handles(inner) => write!(f, "TPMU_CAPABILITIES::Handles({:?})", inner),
            Self::Command(inner) => write!(f, "TPMU_CAPABILITIES::Command({:?})", inner),
            Self::PpCommands(inner) => write!(f, "TPMU_CAPABILITIES::PpCommands({:?})", inner),
            Self::AuditCommands(inner) => write!(f, "TPMU_CAPABILITIES::AuditCommands({:?})", inner),
            Self::AssignedPCR(inner) => write!(f, "TPMU_CAPABILITIES::AssignedPCR({:?})", inner),
            Self::TpmProperties(inner) => write!(f, "TPMU_CAPABILITIES::TpmProperties({:?})", inner),
            Self::PcrProperties(inner) => write!(f, "TPMU_CAPABILITIES::PcrProperties({:?})", inner),
            Self::EccCurves(inner) => write!(f, "TPMU_CAPABILITIES::EccCurves({:?})", inner),
            Self::AuthPolicies(inner) => write!(f, "TPMU_CAPABILITIES::AuthPolicies({:?})", inner),
            Self::ActData(inner) => write!(f, "TPMU_CAPABILITIES::ActData({:?})", inner),
        }

    }

}

/// Table 132 Definition of TPMU_ATTEST Union [OUT]
/// One of: TPMS_CERTIFY_INFO, TPMS_CREATION_INFO, TPMS_QUOTE_INFO,
/// TPMS_COMMAND_AUDIT_INFO, TPMS_SESSION_AUDIT_INFO, TPMS_TIME_ATTEST_INFO,
/// TPMS_NV_CERTIFY_INFO, TPMS_NV_DIGEST_CERTIFY_INFO.
pub enum TPMU_ATTEST {
    Certify(TPMS_CERTIFY_INFO),
    Creation(TPMS_CREATION_INFO),
    Quote(TPMS_QUOTE_INFO),
    CommandAudit(TPMS_COMMAND_AUDIT_INFO),
    SessionAudit(TPMS_SESSION_AUDIT_INFO),
    Time(TPMS_TIME_ATTEST_INFO),
    Nv(TPMS_NV_CERTIFY_INFO),
    NvDigest(TPMS_NV_DIGEST_CERTIFY_INFO),
}

impl TpmUnion for TPMU_ATTEST {
    fn get_union_selector(&self) -> u32 {
        match self {
            Self::Certify(_) => TPM_ST:ATTEST_CERTIFY as u32,
            Self::Creation(_) => TPM_ST:ATTEST_CREATION as u32,
            Self::Quote(_) => TPM_ST:ATTEST_QUOTE as u32,
            Self::CommandAudit(_) => TPM_ST:ATTEST_COMMAND_AUDIT as u32,
            Self::SessionAudit(_) => TPM_ST:ATTEST_SESSION_AUDIT as u32,
            Self::Time(_) => TPM_ST:ATTEST_TIME as u32,
            Self::Nv(_) => TPM_ST:ATTEST_NV as u32,
            Self::NvDigest(_) => TPM_ST:ATTEST_NV_DIGEST as u32,
        }

    }

}

impl fmt::Debug for TPMU_ATTEST {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::Certify(inner) => write!(f, "TPMU_ATTEST::Certify({:?})", inner),
            Self::Creation(inner) => write!(f, "TPMU_ATTEST::Creation({:?})", inner),
            Self::Quote(inner) => write!(f, "TPMU_ATTEST::Quote({:?})", inner),
            Self::CommandAudit(inner) => write!(f, "TPMU_ATTEST::CommandAudit({:?})", inner),
            Self::SessionAudit(inner) => write!(f, "TPMU_ATTEST::SessionAudit({:?})", inner),
            Self::Time(inner) => write!(f, "TPMU_ATTEST::Time({:?})", inner),
            Self::Nv(inner) => write!(f, "TPMU_ATTEST::Nv({:?})", inner),
            Self::NvDigest(inner) => write!(f, "TPMU_ATTEST::NvDigest({:?})", inner),
        }

    }

}

/// This union allows additional parameters to be added for a symmetric cipher. Currently,
/// no additional parameters are required for any of the symmetric algorithms.
/// One of: TPMS_TDES_SYM_DETAILS, TPMS_AES_SYM_DETAILS, TPMS_SM4_SYM_DETAILS,
/// TPMS_CAMELLIA_SYM_DETAILS, TPMS_ANY_SYM_DETAILS, TPMS_XOR_SYM_DETAILS, TPMS_NULL_SYM_DETAILS.
pub enum TPMU_SYM_DETAILS {
    Tdes(TPMS_TDES_SYM_DETAILS),
    Aes(TPMS_AES_SYM_DETAILS),
    Sm4(TPMS_SM4_SYM_DETAILS),
    Camellia(TPMS_CAMELLIA_SYM_DETAILS),
    Sym(TPMS_ANY_SYM_DETAILS),
    Xor(TPMS_XOR_SYM_DETAILS),
    Null(TPMS_NULL_SYM_DETAILS),
}

impl TpmUnion for TPMU_SYM_DETAILS {
    fn get_union_selector(&self) -> u32 {
        match self {
            Self::Tdes(_) => TPM_ALG_ID:TDES as u32,
            Self::Aes(_) => TPM_ALG_ID:AES as u32,
            Self::Sm4(_) => TPM_ALG_ID:SM4 as u32,
            Self::Camellia(_) => TPM_ALG_ID:CAMELLIA as u32,
            Self::Sym(_) => TPM_ALG_ID:ANY as u32,
            Self::Xor(_) => TPM_ALG_ID:XOR as u32,
            Self::Null(_) => TPM_ALG_ID:NULL as u32,
        }

    }

}

impl fmt::Debug for TPMU_SYM_DETAILS {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::Tdes(inner) => write!(f, "TPMU_SYM_DETAILS::Tdes({:?})", inner),
            Self::Aes(inner) => write!(f, "TPMU_SYM_DETAILS::Aes({:?})", inner),
            Self::Sm4(inner) => write!(f, "TPMU_SYM_DETAILS::Sm4({:?})", inner),
            Self::Camellia(inner) => write!(f, "TPMU_SYM_DETAILS::Camellia({:?})", inner),
            Self::Sym(inner) => write!(f, "TPMU_SYM_DETAILS::Sym({:?})", inner),
            Self::Xor(inner) => write!(f, "TPMU_SYM_DETAILS::Xor({:?})", inner),
            Self::Null(inner) => write!(f, "TPMU_SYM_DETAILS::Null({:?})", inner),
        }

    }

}

/// This structure allows a TPM2B_SENSITIVE_CREATE structure to carry either a
/// TPM2B_SENSITVE_DATA or a TPM2B_DERIVE structure. The contents of the union are
/// determined by context. When an object is being derived, the derivation values are present.
/// One of: u8, TPMS_DERIVE.
pub enum TPMU_SENSITIVE_CREATE {
    Create,
    Derive(TPMS_DERIVE),
}

impl TpmUnion for TPMU_SENSITIVE_CREATE {
    fn get_union_selector(&self) -> u32 {
        match self {
            Self::Create => TPM_ALG_ID:ANY as u32,
            Self::Derive(_) => TPM_ALG_ID:ANY2 as u32,
        }

    }

}

impl fmt::Debug for TPMU_SENSITIVE_CREATE {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::Create => write!(f, "TPMU_SENSITIVE_CREATE::Create"),
            Self::Derive(inner) => write!(f, "TPMU_SENSITIVE_CREATE::Derive({:?})", inner),
        }

    }

}

/// Table 157 Definition of TPMU_SCHEME_KEYEDHASH Union [IN/OUT]
/// One of: TPMS_SCHEME_HMAC, TPMS_SCHEME_XOR, TPMS_NULL_SCHEME_KEYEDHASH.
pub enum TPMU_SCHEME_KEYEDHASH {
    Hmac(TPMS_SCHEME_HMAC),
    Xor(TPMS_SCHEME_XOR),
    Null(TPMS_NULL_SCHEME_KEYEDHASH),
}

impl TpmUnion for TPMU_SCHEME_KEYEDHASH {
    fn get_union_selector(&self) -> u32 {
        match self {
            Self::Hmac(_) => TPM_ALG_ID:HMAC as u32,
            Self::Xor(_) => TPM_ALG_ID:XOR as u32,
            Self::Null(_) => TPM_ALG_ID:NULL as u32,
        }

    }

}

impl fmt::Debug for TPMU_SCHEME_KEYEDHASH {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::Hmac(inner) => write!(f, "TPMU_SCHEME_KEYEDHASH::Hmac({:?})", inner),
            Self::Xor(inner) => write!(f, "TPMU_SCHEME_KEYEDHASH::Xor({:?})", inner),
            Self::Null(inner) => write!(f, "TPMU_SCHEME_KEYEDHASH::Null({:?})", inner),
        }

    }

}

/// This is the union of all of the signature schemes.
/// One of: TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA,
/// TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR,
/// TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME.
pub enum TPMU_SIG_SCHEME {
    Rsassa(TPMS_SIG_SCHEME_RSASSA),
    Rsapss(TPMS_SIG_SCHEME_RSAPSS),
    Ecdsa(TPMS_SIG_SCHEME_ECDSA),
    Ecdaa(TPMS_SIG_SCHEME_ECDAA),
    Sm2(TPMS_SIG_SCHEME_SM2),
    Ecschnorr(TPMS_SIG_SCHEME_ECSCHNORR),
    Hmac(TPMS_SCHEME_HMAC),
    Any(TPMS_SCHEME_HASH),
    Null(TPMS_NULL_SIG_SCHEME),
}

impl TpmUnion for TPMU_SIG_SCHEME {
    fn get_union_selector(&self) -> u32 {
        match self {
            Self::Rsassa(_) => TPM_ALG_ID:RSASSA as u32,
            Self::Rsapss(_) => TPM_ALG_ID:RSAPSS as u32,
            Self::Ecdsa(_) => TPM_ALG_ID:ECDSA as u32,
            Self::Ecdaa(_) => TPM_ALG_ID:ECDAA as u32,
            Self::Sm2(_) => TPM_ALG_ID:SM2 as u32,
            Self::Ecschnorr(_) => TPM_ALG_ID:ECSCHNORR as u32,
            Self::Hmac(_) => TPM_ALG_ID:HMAC as u32,
            Self::Any(_) => TPM_ALG_ID:ANY as u32,
            Self::Null(_) => TPM_ALG_ID:NULL as u32,
        }

    }

}

impl fmt::Debug for TPMU_SIG_SCHEME {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::Rsassa(inner) => write!(f, "TPMU_SIG_SCHEME::Rsassa({:?})", inner),
            Self::Rsapss(inner) => write!(f, "TPMU_SIG_SCHEME::Rsapss({:?})", inner),
            Self::Ecdsa(inner) => write!(f, "TPMU_SIG_SCHEME::Ecdsa({:?})", inner),
            Self::Ecdaa(inner) => write!(f, "TPMU_SIG_SCHEME::Ecdaa({:?})", inner),
            Self::Sm2(inner) => write!(f, "TPMU_SIG_SCHEME::Sm2({:?})", inner),
            Self::Ecschnorr(inner) => write!(f, "TPMU_SIG_SCHEME::Ecschnorr({:?})", inner),
            Self::Hmac(inner) => write!(f, "TPMU_SIG_SCHEME::Hmac({:?})", inner),
            Self::Any(inner) => write!(f, "TPMU_SIG_SCHEME::Any({:?})", inner),
            Self::Null(inner) => write!(f, "TPMU_SIG_SCHEME::Null({:?})", inner),
        }

    }

}

/// Table 166 Definition of TPMU_KDF_SCHEME Union [IN/OUT]
/// One of: TPMS_KDF_SCHEME_MGF1, TPMS_KDF_SCHEME_KDF1_SP800_56A, TPMS_KDF_SCHEME_KDF2,
/// TPMS_KDF_SCHEME_KDF1_SP800_108, TPMS_SCHEME_HASH, TPMS_NULL_KDF_SCHEME.
pub enum TPMU_KDF_SCHEME {
    Mgf1(TPMS_KDF_SCHEME_MGF1),
    Kdf1Sp80056a(TPMS_KDF_SCHEME_KDF1_SP800_56A),
    Kdf2(TPMS_KDF_SCHEME_KDF2),
    Kdf1Sp800108(TPMS_KDF_SCHEME_KDF1_SP800_108),
    AnyKdf(TPMS_SCHEME_HASH),
    Null(TPMS_NULL_KDF_SCHEME),
}

impl TpmUnion for TPMU_KDF_SCHEME {
    fn get_union_selector(&self) -> u32 {
        match self {
            Self::Mgf1(_) => TPM_ALG_ID:MGF1 as u32,
            Self::Kdf1Sp80056a(_) => TPM_ALG_ID:KDF1_SP800_56A as u32,
            Self::Kdf2(_) => TPM_ALG_ID:KDF2 as u32,
            Self::Kdf1Sp800108(_) => TPM_ALG_ID:KDF1_SP800_108 as u32,
            Self::AnyKdf(_) => TPM_ALG_ID:ANY as u32,
            Self::Null(_) => TPM_ALG_ID:NULL as u32,
        }

    }

}

impl fmt::Debug for TPMU_KDF_SCHEME {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::Mgf1(inner) => write!(f, "TPMU_KDF_SCHEME::Mgf1({:?})", inner),
            Self::Kdf1Sp80056a(inner) => write!(f, "TPMU_KDF_SCHEME::Kdf1Sp80056a({:?})", inner),
            Self::Kdf2(inner) => write!(f, "TPMU_KDF_SCHEME::Kdf2({:?})", inner),
            Self::Kdf1Sp800108(inner) => write!(f, "TPMU_KDF_SCHEME::Kdf1Sp800108({:?})", inner),
            Self::AnyKdf(inner) => write!(f, "TPMU_KDF_SCHEME::AnyKdf({:?})", inner),
            Self::Null(inner) => write!(f, "TPMU_KDF_SCHEME::Null({:?})", inner),
        }

    }

}

/// This union of all asymmetric schemes is used in each of the asymmetric scheme
/// structures. The actual scheme structure is defined by the interface type used for the
/// selector (TPMI_ALG_ASYM_SCHEME).
/// One of: TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA,
/// TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA,
/// TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES,
/// TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME.
pub enum TPMU_ASYM_SCHEME {
    Ecdh(TPMS_KEY_SCHEME_ECDH),
    Ecmqv(TPMS_KEY_SCHEME_ECMQV),
    Rsassa(TPMS_SIG_SCHEME_RSASSA),
    Rsapss(TPMS_SIG_SCHEME_RSAPSS),
    Ecdsa(TPMS_SIG_SCHEME_ECDSA),
    Ecdaa(TPMS_SIG_SCHEME_ECDAA),
    Sm2(TPMS_SIG_SCHEME_SM2),
    Ecschnorr(TPMS_SIG_SCHEME_ECSCHNORR),
    Rsaes(TPMS_ENC_SCHEME_RSAES),
    Oaep(TPMS_ENC_SCHEME_OAEP),
    AnySig(TPMS_SCHEME_HASH),
    Null(TPMS_NULL_ASYM_SCHEME),
}

impl TpmUnion for TPMU_ASYM_SCHEME {
    fn get_union_selector(&self) -> u32 {
        match self {
            Self::Ecdh(_) => TPM_ALG_ID:ECDH as u32,
            Self::Ecmqv(_) => TPM_ALG_ID:ECMQV as u32,
            Self::Rsassa(_) => TPM_ALG_ID:RSASSA as u32,
            Self::Rsapss(_) => TPM_ALG_ID:RSAPSS as u32,
            Self::Ecdsa(_) => TPM_ALG_ID:ECDSA as u32,
            Self::Ecdaa(_) => TPM_ALG_ID:ECDAA as u32,
            Self::Sm2(_) => TPM_ALG_ID:SM2 as u32,
            Self::Ecschnorr(_) => TPM_ALG_ID:ECSCHNORR as u32,
            Self::Rsaes(_) => TPM_ALG_ID:RSAES as u32,
            Self::Oaep(_) => TPM_ALG_ID:OAEP as u32,
            Self::AnySig(_) => TPM_ALG_ID:ANY as u32,
            Self::Null(_) => TPM_ALG_ID:NULL as u32,
        }

    }

}

impl fmt::Debug for TPMU_ASYM_SCHEME {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::Ecdh(inner) => write!(f, "TPMU_ASYM_SCHEME::Ecdh({:?})", inner),
            Self::Ecmqv(inner) => write!(f, "TPMU_ASYM_SCHEME::Ecmqv({:?})", inner),
            Self::Rsassa(inner) => write!(f, "TPMU_ASYM_SCHEME::Rsassa({:?})", inner),
            Self::Rsapss(inner) => write!(f, "TPMU_ASYM_SCHEME::Rsapss({:?})", inner),
            Self::Ecdsa(inner) => write!(f, "TPMU_ASYM_SCHEME::Ecdsa({:?})", inner),
            Self::Ecdaa(inner) => write!(f, "TPMU_ASYM_SCHEME::Ecdaa({:?})", inner),
            Self::Sm2(inner) => write!(f, "TPMU_ASYM_SCHEME::Sm2({:?})", inner),
            Self::Ecschnorr(inner) => write!(f, "TPMU_ASYM_SCHEME::Ecschnorr({:?})", inner),
            Self::Rsaes(inner) => write!(f, "TPMU_ASYM_SCHEME::Rsaes({:?})", inner),
            Self::Oaep(inner) => write!(f, "TPMU_ASYM_SCHEME::Oaep({:?})", inner),
            Self::AnySig(inner) => write!(f, "TPMU_ASYM_SCHEME::AnySig({:?})", inner),
            Self::Null(inner) => write!(f, "TPMU_ASYM_SCHEME::Null({:?})", inner),
        }

    }

}

/// A TPMU_SIGNATURE_COMPOSITE is a union of the various signatures that are supported by
/// a particular TPM implementation. The union allows substitution of any signature
/// algorithm wherever a signature is required in a structure.
/// One of: TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA,
/// TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TPMT_HA,
/// TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE.
pub enum TPMU_SIGNATURE {
    Rsassa(TPMS_SIGNATURE_RSASSA),
    Rsapss(TPMS_SIGNATURE_RSAPSS),
    Ecdsa(TPMS_SIGNATURE_ECDSA),
    Ecdaa(TPMS_SIGNATURE_ECDAA),
    Sm2(TPMS_SIGNATURE_SM2),
    Ecschnorr(TPMS_SIGNATURE_ECSCHNORR),
    Hmac(TPMT_HA),
    Any(TPMS_SCHEME_HASH),
    Null(TPMS_NULL_SIGNATURE),
}

impl TpmUnion for TPMU_SIGNATURE {
    fn get_union_selector(&self) -> u32 {
        match self {
            Self::Rsassa(_) => TPM_ALG_ID:RSASSA as u32,
            Self::Rsapss(_) => TPM_ALG_ID:RSAPSS as u32,
            Self::Ecdsa(_) => TPM_ALG_ID:ECDSA as u32,
            Self::Ecdaa(_) => TPM_ALG_ID:ECDAA as u32,
            Self::Sm2(_) => TPM_ALG_ID:SM2 as u32,
            Self::Ecschnorr(_) => TPM_ALG_ID:ECSCHNORR as u32,
            Self::Hmac(_) => TPM_ALG_ID:HMAC as u32,
            Self::Any(_) => TPM_ALG_ID:ANY as u32,
            Self::Null(_) => TPM_ALG_ID:NULL as u32,
        }

    }

}

impl fmt::Debug for TPMU_SIGNATURE {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::Rsassa(inner) => write!(f, "TPMU_SIGNATURE::Rsassa({:?})", inner),
            Self::Rsapss(inner) => write!(f, "TPMU_SIGNATURE::Rsapss({:?})", inner),
            Self::Ecdsa(inner) => write!(f, "TPMU_SIGNATURE::Ecdsa({:?})", inner),
            Self::Ecdaa(inner) => write!(f, "TPMU_SIGNATURE::Ecdaa({:?})", inner),
            Self::Sm2(inner) => write!(f, "TPMU_SIGNATURE::Sm2({:?})", inner),
            Self::Ecschnorr(inner) => write!(f, "TPMU_SIGNATURE::Ecschnorr({:?})", inner),
            Self::Hmac(inner) => write!(f, "TPMU_SIGNATURE::Hmac({:?})", inner),
            Self::Any(inner) => write!(f, "TPMU_SIGNATURE::Any({:?})", inner),
            Self::Null(inner) => write!(f, "TPMU_SIGNATURE::Null({:?})", inner),
        }

    }

}

/// This is the union of all values allowed in in the unique field of a TPMT_PUBLIC.
/// One of: TPM2B_DIGEST_KEYEDHASH, TPM2B_DIGEST_SYMCIPHER, TPM2B_PUBLIC_KEY_RSA,
/// TPMS_ECC_POINT, TPMS_DERIVE.
pub enum TPMU_PUBLIC_ID {
    KeyedHash(TPM2B_DIGEST_KEYEDHASH),
    Sym(TPM2B_DIGEST_SYMCIPHER),
    Rsa(TPM2B_PUBLIC_KEY_RSA),
    Ecc(TPMS_ECC_POINT),
    Derive(TPMS_DERIVE),
}

impl TpmUnion for TPMU_PUBLIC_ID {
    fn get_union_selector(&self) -> u32 {
        match self {
            Self::KeyedHash(_) => TPM_ALG_ID:KEYEDHASH as u32,
            Self::Sym(_) => TPM_ALG_ID:SYMCIPHER as u32,
            Self::Rsa(_) => TPM_ALG_ID:RSA as u32,
            Self::Ecc(_) => TPM_ALG_ID:ECC as u32,
            Self::Derive(_) => TPM_ALG_ID:ANY as u32,
        }

    }

}

impl fmt::Debug for TPMU_PUBLIC_ID {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::KeyedHash(inner) => write!(f, "TPMU_PUBLIC_ID::KeyedHash({:?})", inner),
            Self::Sym(inner) => write!(f, "TPMU_PUBLIC_ID::Sym({:?})", inner),
            Self::Rsa(inner) => write!(f, "TPMU_PUBLIC_ID::Rsa({:?})", inner),
            Self::Ecc(inner) => write!(f, "TPMU_PUBLIC_ID::Ecc({:?})", inner),
            Self::Derive(inner) => write!(f, "TPMU_PUBLIC_ID::Derive({:?})", inner),
        }

    }

}

/// Table 199 defines the possible parameter definition structures that may be contained
/// in the public portion of a key. If the Object can be a parent, the first field must be
/// a TPMT_SYM_DEF_OBJECT. See 11.1.7.
/// One of: TPMS_KEYEDHASH_PARMS, TPMS_SYMCIPHER_PARMS, TPMS_RSA_PARMS, TPMS_ECC_PARMS,
/// TPMS_ASYM_PARMS.
pub enum TPMU_PUBLIC_PARMS {
    KeyedHashDetail(TPMS_KEYEDHASH_PARMS),
    SymDetail(TPMS_SYMCIPHER_PARMS),
    RsaDetail(TPMS_RSA_PARMS),
    EccDetail(TPMS_ECC_PARMS),
    AsymDetail(TPMS_ASYM_PARMS),
}

impl TpmUnion for TPMU_PUBLIC_PARMS {
    fn get_union_selector(&self) -> u32 {
        match self {
            Self::KeyedHashDetail(_) => TPM_ALG_ID:KEYEDHASH as u32,
            Self::SymDetail(_) => TPM_ALG_ID:SYMCIPHER as u32,
            Self::RsaDetail(_) => TPM_ALG_ID:RSA as u32,
            Self::EccDetail(_) => TPM_ALG_ID:ECC as u32,
            Self::AsymDetail(_) => TPM_ALG_ID:ANY as u32,
        }

    }

}

impl fmt::Debug for TPMU_PUBLIC_PARMS {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::KeyedHashDetail(inner) => write!(f, "TPMU_PUBLIC_PARMS::KeyedHashDetail({:?})", inner),
            Self::SymDetail(inner) => write!(f, "TPMU_PUBLIC_PARMS::SymDetail({:?})", inner),
            Self::RsaDetail(inner) => write!(f, "TPMU_PUBLIC_PARMS::RsaDetail({:?})", inner),
            Self::EccDetail(inner) => write!(f, "TPMU_PUBLIC_PARMS::EccDetail({:?})", inner),
            Self::AsymDetail(inner) => write!(f, "TPMU_PUBLIC_PARMS::AsymDetail({:?})", inner),
        }

    }

}

/// Table 205 Definition of TPMU_SENSITIVE_COMPOSITE Union [IN/OUT]
/// One of: TPM2B_PRIVATE_KEY_RSA, TPM2B_ECC_PARAMETER, TPM2B_SENSITIVE_DATA,
/// TPM2B_SYM_KEY, TPM2B_PRIVATE_VENDOR_SPECIFIC.
pub enum TPMU_SENSITIVE_COMPOSITE {
    Rsa(TPM2B_PRIVATE_KEY_RSA),
    Ecc(TPM2B_ECC_PARAMETER),
    Bits(TPM2B_SENSITIVE_DATA),
    Sym(TPM2B_SYM_KEY),
    Any(TPM2B_PRIVATE_VENDOR_SPECIFIC),
}

impl TpmUnion for TPMU_SENSITIVE_COMPOSITE {
    fn get_union_selector(&self) -> u32 {
        match self {
            Self::Rsa(_) => TPM_ALG_ID:RSA as u32,
            Self::Ecc(_) => TPM_ALG_ID:ECC as u32,
            Self::Bits(_) => TPM_ALG_ID:KEYEDHASH as u32,
            Self::Sym(_) => TPM_ALG_ID:SYMCIPHER as u32,
            Self::Any(_) => TPM_ALG_ID:ANY as u32,
        }

    }

}

impl fmt::Debug for TPMU_SENSITIVE_COMPOSITE {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::Rsa(inner) => write!(f, "TPMU_SENSITIVE_COMPOSITE::Rsa({:?})", inner),
            Self::Ecc(inner) => write!(f, "TPMU_SENSITIVE_COMPOSITE::Ecc({:?})", inner),
            Self::Bits(inner) => write!(f, "TPMU_SENSITIVE_COMPOSITE::Bits({:?})", inner),
            Self::Sym(inner) => write!(f, "TPMU_SENSITIVE_COMPOSITE::Sym({:?})", inner),
            Self::Any(inner) => write!(f, "TPMU_SENSITIVE_COMPOSITE::Any({:?})", inner),
        }

    }

}

/// Handle of a loaded TPM key or other object [TSS]
#[derive(Debug, Clone)]
pub struct TPM_HANDLE {
    /// Handle value
    pub handle: u32,
}

impl Default for TPM_HANDLE {
    fn default() -> Self {
        Self {
            handle = as u32TPM_RH:NULL;
        }

    }

}

impl TPM_HANDLE {
    /// Creates a new instance with the specified values
    pub fn new(
        handle: u32
        ) -> Self {
        Self {
            handle,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// Base class for empty union elements.
/// An empty union element does not contain any data to marshal.
/// This data structure can be used in place of any other union
/// initialized with its own empty element.
#[derive(Debug, Clone)]
pub struct TPMS_NULL_UNION {
}

impl Default for TPMS_NULL_UNION {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPMS_NULL_UNION {
    // Union trait implementations
    impl TpmUnion for TPMS_NULL_UNION {
    }

    impl TpmUnion for TPMS_NULL_UNION {
    }

    impl TpmUnion for TPMS_NULL_UNION {
    }

    impl TpmUnion for TPMS_NULL_UNION {
    }

    impl TpmUnion for TPMS_NULL_UNION {
    }

    impl TpmUnion for TPMS_NULL_UNION {
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This structure is used as a placeholder. In some cases, a union will have a selector
/// value with no data to unmarshal when that type is selected. Rather than leave the
/// entry empty, TPMS_EMPTY may be selected.
#[derive(Debug, Clone)]
pub struct TPMS_EMPTY {
}

impl Default for TPMS_EMPTY {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPMS_EMPTY {
    // Union trait implementations
    impl TpmUnion for TPMS_EMPTY {
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This structure is a return value for a TPM2_GetCapability() that reads the installed algorithms.
#[derive(Debug, Clone)]
pub struct TPMS_ALGORITHM_DESCRIPTION {
    /// An algorithm
    pub alg: tpm_alg_id,

    /// The attributes of the algorithm
    pub attributes: tpma_algorithm,
}

impl Default for TPMS_ALGORITHM_DESCRIPTION {
    fn default() -> Self {
        Self {
            alg = TPM_ALG_ID:NULL;
        }

    }

}

impl TPMS_ALGORITHM_DESCRIPTION {
    /// Creates a new instance with the specified values
    pub fn new(
        alg: tpm_alg_id
        ,
        attributes: tpma_algorithm
        ) -> Self {
        Self {
            alg,
            attributes,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// Table 80 shows the basic hash-agile structure used in this specification. To handle
/// hash agility, this structure uses the hashAlg parameter to indicate the algorithm used
/// to compute the digest and, by implication, the size of the digest.
#[derive(Debug, Clone)]
pub struct TPMT_HA {
    /// Selector of the hash contained in the digest that implies the size of the digest
    /// NOTE The leading + on the type indicates that this structure should pass an indication
    /// to the unmarshaling function for TPMI_ALG_HASH so that TPM_ALG_NULL will be allowed if
    /// a use of a TPMT_HA allows TPM_ALG_NULL.
    pub hash_alg: tpm_alg_id,

    /// Hash value
    pub digest: vec<u8>,
}

impl Default for TPMT_HA {
    fn default() -> Self {
        Self {
            hashAlg = TPM_ALG_ID:NULL;
        }

    }

}

impl TPMT_HA {
    /// Creates a new instance with the specified values
    pub fn new(
        hash_alg: tpm_alg_id
        ,
        digest: vec<u8>
        ) -> Self {
        Self {
            hash_alg,
            digest,
        }

    }

    // Union trait implementations
    impl TpmUnion for TPMT_HA {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
        TPMU_SIGNATURE::HMAC as u32
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This structure is used for a sized buffer that cannot be larger than the largest
/// digest produced by any hash algorithm implemented on the TPM.
#[derive(Debug, Clone)]
pub struct TPM2B_DIGEST {
    /// The buffer area that can be no larger than a digest
    pub buffer: vec<u8>,
}

impl Default for TPM2B_DIGEST {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPM2B_DIGEST {
    /// Creates a new instance with the specified values
    pub fn new(
        buffer: vec<u8>
        ) -> Self {
        Self {
            buffer,
        }

    }

    // Union trait implementations
    impl TpmUnion for TPM2B_DIGEST {
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This structure is used for a data buffer that is required to be no larger than the
/// size of the Name of an object.
#[derive(Debug, Clone)]
pub struct TPM2B_DATA {
    pub buffer: vec<u8>,
}

impl Default for TPM2B_DATA {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPM2B_DATA {
    /// Creates a new instance with the specified values
    pub fn new(
        buffer: vec<u8>
        ) -> Self {
        Self {
            buffer,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// Table 83 Definition of Types for TPM2B_NONCE
pub type TPM2B_NONCE = TPM2B_DIGEST;

/// This structure is used for an authorization value and limits an authValue to being no
/// larger than the largest digest produced by a TPM. In order to ensure consistency
/// within an object, the authValue may be no larger than the size of the digest produced
/// by the objects nameAlg. This ensures that any TPM that can load the object will be
/// able to handle the authValue of the object.
pub type TPM2B_AUTH = TPM2B_DIGEST;

/// This type is a sized buffer that can hold an operand for a comparison with an NV Index
/// location. The maximum size of the operand is implementation dependent but a TPM is
/// required to support an operand size that is at least as big as the digest produced by
/// any of the hash algorithms implemented on the TPM.
pub type TPM2B_OPERAND = TPM2B_DIGEST;

/// This type is a sized buffer that can hold event data.
#[derive(Debug, Clone)]
pub struct TPM2B_EVENT {
    /// The operand
    pub buffer: vec<u8>,
}

impl Default for TPM2B_EVENT {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPM2B_EVENT {
    /// Creates a new instance with the specified values
    pub fn new(
        buffer: vec<u8>
        ) -> Self {
        Self {
            buffer,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This type is a sized buffer that can hold a maximally sized buffer for commands that
/// use a large data buffer such as TPM2_Hash(), TPM2_SequenceUpdate(), or TPM2_FieldUpgradeData().
#[derive(Debug, Clone)]
pub struct TPM2B_MAX_BUFFER {
    /// The operand
    pub buffer: vec<u8>,
}

impl Default for TPM2B_MAX_BUFFER {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPM2B_MAX_BUFFER {
    /// Creates a new instance with the specified values
    pub fn new(
        buffer: vec<u8>
        ) -> Self {
        Self {
            buffer,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This type is a sized buffer that can hold a maximally sized buffer for NV data
/// commands such as TPM2_NV_Read(), TPM2_NV_Write(), and TPM2_NV_Certify().
#[derive(Debug, Clone)]
pub struct TPM2B_MAX_NV_BUFFER {
    /// The operand
    /// NOTE MAX_NV_BUFFER_SIZE is TPM-dependent
    pub buffer: vec<u8>,
}

impl Default for TPM2B_MAX_NV_BUFFER {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPM2B_MAX_NV_BUFFER {
    /// Creates a new instance with the specified values
    pub fn new(
        buffer: vec<u8>
        ) -> Self {
        Self {
            buffer,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This TPM-dependent structure is used to provide the timeout value for an
/// authorization. The size shall be 8 or less.
#[derive(Debug, Clone)]
pub struct TPM2B_TIMEOUT {
    /// The timeout value
    pub buffer: vec<u8>,
}

impl Default for TPM2B_TIMEOUT {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPM2B_TIMEOUT {
    /// Creates a new instance with the specified values
    pub fn new(
        buffer: vec<u8>
        ) -> Self {
        Self {
            buffer,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This structure is used for passing an initial value for a symmetric block cipher to or
/// from the TPM. The size is set to be the largest block size of any implemented
/// symmetric cipher implemented on the TPM.
#[derive(Debug, Clone)]
pub struct TPM2B_IV {
    /// The IV value
    pub buffer: vec<u8>,
}

impl Default for TPM2B_IV {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPM2B_IV {
    /// Creates a new instance with the specified values
    pub fn new(
        buffer: vec<u8>
        ) -> Self {
        Self {
            buffer,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This buffer holds a Name for any entity type.
#[derive(Debug, Clone)]
pub struct TPM2B_NAME {
    /// The Name structure
    pub name: vec<u8>,
}

impl Default for TPM2B_NAME {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPM2B_NAME {
    /// Creates a new instance with the specified values
    pub fn new(
        name: vec<u8>
        ) -> Self {
        Self {
            name,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This structure provides a standard method of specifying a list of PCR.
#[derive(Debug, Clone)]
pub struct TPMS_PCR_SELECT {
    /// The bit map of selected PCR
    pub pcr_select: vec<u8>,
}

impl Default for TPMS_PCR_SELECT {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPMS_PCR_SELECT {
    /// Creates a new instance with the specified values
    pub fn new(
        pcr_select: vec<u8>
        ) -> Self {
        Self {
            pcr_select,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// Table 94 Definition of TPMS_PCR_SELECTION Structure
#[derive(Debug, Clone)]
pub struct TPMS_PCR_SELECTION {
    /// The hash algorithm associated with the selection
    pub hash: tpm_alg_id,

    /// The bit map of selected PCR
    pub pcr_select: vec<u8>,
}

impl Default for TPMS_PCR_SELECTION {
    fn default() -> Self {
        Self {
            hash = TPM_ALG_ID:NULL;
        }

    }

}

impl TPMS_PCR_SELECTION {
    /// Creates a new instance with the specified values
    pub fn new(
        hash: tpm_alg_id
        ,
        pcr_select: vec<u8>
        ) -> Self {
        Self {
            hash,
            pcr_select,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This ticket is produced by TPM2_Create() or TPM2_CreatePrimary(). It is used to bind
/// the creation data to the object to which it applies. The ticket is computed by
#[derive(Debug, Clone)]
pub struct TPMT_TK_CREATION {
    /// The hierarchy containing name
    pub hierarchy: tpm_handle,

    /// This shall be the HMAC produced using a proof value of hierarchy.
    pub digest: vec<u8>,
}

impl Default for TPMT_TK_CREATION {
    fn default() -> Self {
        Self {
            hierarchy = TPM_HANDLE();
        }

    }

}

impl TPMT_TK_CREATION {
    /// Creates a new instance with the specified values
    pub fn new(
        hierarchy: tpm_handle
        ,
        digest: vec<u8>
        ) -> Self {
        Self {
            hierarchy,
            digest,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This ticket is produced by TPM2_VerifySignature(). This formulation is used for
/// multiple ticket uses. The ticket provides evidence that the TPM has validated that a
/// digest was signed by a key with the Name of keyName. The ticket is computed by
#[derive(Debug, Clone)]
pub struct TPMT_TK_VERIFIED {
    /// The hierarchy containing keyName
    pub hierarchy: tpm_handle,

    /// This shall be the HMAC produced using a proof value of hierarchy.
    pub digest: vec<u8>,
}

impl Default for TPMT_TK_VERIFIED {
    fn default() -> Self {
        Self {
            hierarchy = TPM_HANDLE();
        }

    }

}

impl TPMT_TK_VERIFIED {
    /// Creates a new instance with the specified values
    pub fn new(
        hierarchy: tpm_handle
        ,
        digest: vec<u8>
        ) -> Self {
        Self {
            hierarchy,
            digest,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This ticket is produced by TPM2_PolicySigned() and TPM2_PolicySecret() when the
/// authorization has an expiration time. If nonceTPM was provided in the policy command,
/// the ticket is computed by
#[derive(Debug, Clone)]
pub struct TPMT_TK_AUTH {
    /// Ticket structure tag
    pub tag: tpm_st,

    /// The hierarchy of the object used to produce the ticket
    pub hierarchy: tpm_handle,

    /// This shall be the HMAC produced using a proof value of hierarchy.
    pub digest: vec<u8>,
}

impl Default for TPMT_TK_AUTH {
    fn default() -> Self {
        Self {
            hierarchy = TPM_HANDLE();
        }

    }

}

impl TPMT_TK_AUTH {
    /// Creates a new instance with the specified values
    pub fn new(
        tag: tpm_st
        ,
        hierarchy: tpm_handle
        ,
        digest: vec<u8>
        ) -> Self {
        Self {
            tag,
            hierarchy,
            digest,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This ticket is produced by TPM2_SequenceComplete() or TPM2_Hash() when the message
/// that was digested did not start with TPM_GENERATED_VALUE. The ticket is computed by
#[derive(Debug, Clone)]
pub struct TPMT_TK_HASHCHECK {
    /// The hierarchy
    pub hierarchy: tpm_handle,

    /// This shall be the HMAC produced using a proof value of hierarchy.
    pub digest: vec<u8>,
}

impl Default for TPMT_TK_HASHCHECK {
    fn default() -> Self {
        Self {
            hierarchy = TPM_HANDLE();
        }

    }

}

impl TPMT_TK_HASHCHECK {
    /// Creates a new instance with the specified values
    pub fn new(
        hierarchy: tpm_handle
        ,
        digest: vec<u8>
        ) -> Self {
        Self {
            hierarchy,
            digest,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This structure is used to report the properties of an algorithm identifier. It is
/// returned in response to a TPM2_GetCapability() with capability = TPM_CAP_ALG.
#[derive(Debug, Clone)]
pub struct TPMS_ALG_PROPERTY {
    /// An algorithm identifier
    pub alg: tpm_alg_id,

    /// The attributes of the algorithm
    pub alg_properties: tpma_algorithm,
}

impl Default for TPMS_ALG_PROPERTY {
    fn default() -> Self {
        Self {
            alg = TPM_ALG_ID:NULL;
        }

    }

}

impl TPMS_ALG_PROPERTY {
    /// Creates a new instance with the specified values
    pub fn new(
        alg: tpm_alg_id
        ,
        alg_properties: tpma_algorithm
        ) -> Self {
        Self {
            alg,
            alg_properties,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This structure is used to report the properties that are UINT32 values. It is returned
/// in response to a TPM2_GetCapability().
#[derive(Debug, Clone)]
pub struct TPMS_TAGGED_PROPERTY {
    /// A property identifier
    pub property: tpm_pt,

    /// The value of the property
    pub value: u32,
}

impl Default for TPMS_TAGGED_PROPERTY {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPMS_TAGGED_PROPERTY {
    /// Creates a new instance with the specified values
    pub fn new(
        property: tpm_pt
        ,
        value: u32
        ) -> Self {
        Self {
            property,
            value,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This structure is used in TPM2_GetCapability() to return the attributes of the PCR.
#[derive(Debug, Clone)]
pub struct TPMS_TAGGED_PCR_SELECT {
    /// The property identifier
    pub tag: tpm_pt_pcr,

    /// The bit map of PCR with the identified property
    pub pcr_select: vec<u8>,
}

impl Default for TPMS_TAGGED_PCR_SELECT {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPMS_TAGGED_PCR_SELECT {
    /// Creates a new instance with the specified values
    pub fn new(
        tag: tpm_pt_pcr
        ,
        pcr_select: vec<u8>
        ) -> Self {
        Self {
            tag,
            pcr_select,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This structure is used in TPM2_GetCapability() to return the policy associated with a
/// permanent handle.
#[derive(Debug, Clone)]
pub struct TPMS_TAGGED_POLICY {
    /// A permanent handle
    pub handle: tpm_handle,

    /// The policy algorithm and hash
    pub policy_hash: tpmt_ha,
}

impl Default for TPMS_TAGGED_POLICY {
    fn default() -> Self {
        Self {
            handle = TPM_HANDLE();
        }

    }

}

impl TPMS_TAGGED_POLICY {
    /// Creates a new instance with the specified values
    pub fn new(
        handle: tpm_handle
        ,
        policy_hash: tpmt_ha
        ) -> Self {
        Self {
            handle,
            policy_hash,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This structure is used in TPM2_GetCapability() to return the ACT data.
#[derive(Debug, Clone)]
pub struct TPMS_ACT_DATA {
    /// A permanent handle
    pub handle: tpm_handle,

    /// The current timeout of the ACT
    pub timeout: u32,

    /// The state of the ACT
    pub attributes: tpma_act,
}

impl Default for TPMS_ACT_DATA {
    fn default() -> Self {
        Self {
            handle = TPM_HANDLE();
        }

    }

}

impl TPMS_ACT_DATA {
    /// Creates a new instance with the specified values
    pub fn new(
        handle: tpm_handle
        ,
        timeout: u32
        ,
        attributes: tpma_act
        ) -> Self {
        Self {
            handle,
            timeout,
            attributes,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// A list of command codes may be input to the TPM or returned by the TPM depending on
/// the command.
#[derive(Debug, Clone)]
pub struct TPML_CC {
    /// A list of command codes
    /// The maximum only applies to a command code list in a command. The response size is
    /// limited only by the size of the parameter buffer.
    pub command_codes: vec<tpm_cc>,
}

impl Default for TPML_CC {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPML_CC {
    /// Creates a new instance with the specified values
    pub fn new(
        command_codes: vec<tpm_cc>
        ) -> Self {
        Self {
            command_codes,
        }

    }

    // Union trait implementations
    impl TpmUnion for TPML_CC {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
        TPMU_CAPABILITIES::PpCommands as u32
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This list is only used in TPM2_GetCapability(capability = TPM_CAP_COMMANDS).
#[derive(Debug, Clone)]
pub struct TPML_CCA {
    /// A list of command codes attributes
    pub command_attributes: vec<tpma_cc>,
}

impl Default for TPML_CCA {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPML_CCA {
    /// Creates a new instance with the specified values
    pub fn new(
        command_attributes: vec<tpma_cc>
        ) -> Self {
        Self {
            command_attributes,
        }

    }

    // Union trait implementations
    impl TpmUnion for TPML_CCA {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
        TPMU_CAPABILITIES::COMMANDS as u32
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This list is returned by TPM2_IncrementalSelfTest().
#[derive(Debug, Clone)]
pub struct TPML_ALG {
    /// A list of algorithm IDs
    /// The maximum only applies to an algorithm list in a command. The response size is
    /// limited only by the size of the parameter buffer.
    pub algorithms: vec<tpm_alg_id>,
}

impl Default for TPML_ALG {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPML_ALG {
    /// Creates a new instance with the specified values
    pub fn new(
        algorithms: vec<tpm_alg_id>
        ) -> Self {
        Self {
            algorithms,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This structure is used when the TPM returns a list of loaded handles when the
/// capability in TPM2_GetCapability() is TPM_CAP_HANDLE.
#[derive(Debug, Clone)]
pub struct TPML_HANDLE {
    /// An array of handles
    pub handle: vec<tpm_handle>,
}

impl Default for TPML_HANDLE {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPML_HANDLE {
    /// Creates a new instance with the specified values
    pub fn new(
        handle: vec<tpm_handle>
        ) -> Self {
        Self {
            handle,
        }

    }

    // Union trait implementations
    impl TpmUnion for TPML_HANDLE {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
        TPMU_CAPABILITIES::HANDLES as u32
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This list is used to convey a list of digest values. This type is used in
/// TPM2_PolicyOR() and in TPM2_PCR_Read().
#[derive(Debug, Clone)]
pub struct TPML_DIGEST {
    /// A list of digests
    /// For TPM2_PolicyOR(), all digests will have been computed using the digest of the
    /// policy session. For TPM2_PCR_Read(), each digest will be the size of the digest for
    /// the bank containing the PCR.
    pub digests: vec<tpm2_b_digest>,
}

impl Default for TPML_DIGEST {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPML_DIGEST {
    /// Creates a new instance with the specified values
    pub fn new(
        digests: vec<tpm2_b_digest>
        ) -> Self {
        Self {
            digests,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This list is used to convey a list of digest values. This type is returned by
/// TPM2_PCR_Event() and TPM2_EventSequenceComplete() and is an input for TPM2_PCR_Extend().
#[derive(Debug, Clone)]
pub struct TPML_DIGEST_VALUES {
    /// A list of tagged digests
    pub digests: vec<tpmt_ha>,
}

impl Default for TPML_DIGEST_VALUES {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPML_DIGEST_VALUES {
    /// Creates a new instance with the specified values
    pub fn new(
        digests: vec<tpmt_ha>
        ) -> Self {
        Self {
            digests,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This list is used to indicate the PCR that are included in a selection when more than
/// one PCR value may be selected.
#[derive(Debug, Clone)]
pub struct TPML_PCR_SELECTION {
    /// List of selections
    pub pcr_selections: vec<tpms_pcr_selection>,
}

impl Default for TPML_PCR_SELECTION {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPML_PCR_SELECTION {
    /// Creates a new instance with the specified values
    pub fn new(
        pcr_selections: vec<tpms_pcr_selection>
        ) -> Self {
        Self {
            pcr_selections,
        }

    }

    // Union trait implementations
    impl TpmUnion for TPML_PCR_SELECTION {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
        TPMU_CAPABILITIES::PCRS as u32
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This list is used to report on a list of algorithm attributes. It is returned in a
/// TPM2_GetCapability().
#[derive(Debug, Clone)]
pub struct TPML_ALG_PROPERTY {
    /// List of properties
    pub alg_properties: vec<tpms_alg_property>,
}

impl Default for TPML_ALG_PROPERTY {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPML_ALG_PROPERTY {
    /// Creates a new instance with the specified values
    pub fn new(
        alg_properties: vec<tpms_alg_property>
        ) -> Self {
        Self {
            alg_properties,
        }

    }

    // Union trait implementations
    impl TpmUnion for TPML_ALG_PROPERTY {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
        TPMU_CAPABILITIES::ALGS as u32
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This list is used to report on a list of properties that are TPMS_TAGGED_PROPERTY
/// values. It is returned by a TPM2_GetCapability().
#[derive(Debug, Clone)]
pub struct TPML_TAGGED_TPM_PROPERTY {
    /// An array of tagged properties
    pub tpm_property: vec<tpms_tagged_property>,
}

impl Default for TPML_TAGGED_TPM_PROPERTY {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPML_TAGGED_TPM_PROPERTY {
    /// Creates a new instance with the specified values
    pub fn new(
        tpm_property: vec<tpms_tagged_property>
        ) -> Self {
        Self {
            tpm_property,
        }

    }

    // Union trait implementations
    impl TpmUnion for TPML_TAGGED_TPM_PROPERTY {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
        TPMU_CAPABILITIES::TpmProperties as u32
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This list is used to report on a list of properties that are TPMS_PCR_SELECT values.
/// It is returned by a TPM2_GetCapability().
#[derive(Debug, Clone)]
pub struct TPML_TAGGED_PCR_PROPERTY {
    /// A tagged PCR selection
    pub pcr_property: vec<tpms_tagged_pcr_select>,
}

impl Default for TPML_TAGGED_PCR_PROPERTY {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPML_TAGGED_PCR_PROPERTY {
    /// Creates a new instance with the specified values
    pub fn new(
        pcr_property: vec<tpms_tagged_pcr_select>
        ) -> Self {
        Self {
            pcr_property,
        }

    }

    // Union trait implementations
    impl TpmUnion for TPML_TAGGED_PCR_PROPERTY {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
        TPMU_CAPABILITIES::PcrProperties as u32
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This list is used to report the ECC curve ID values supported by the TPM. It is
/// returned by a TPM2_GetCapability().
#[derive(Debug, Clone)]
pub struct TPML_ECC_CURVE {
    /// Array of ECC curve identifiers
    pub ecc_curves: vec<tpm_ecc_curve>,
}

impl Default for TPML_ECC_CURVE {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPML_ECC_CURVE {
    /// Creates a new instance with the specified values
    pub fn new(
        ecc_curves: vec<tpm_ecc_curve>
        ) -> Self {
        Self {
            ecc_curves,
        }

    }

    // Union trait implementations
    impl TpmUnion for TPML_ECC_CURVE {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
        TPMU_CAPABILITIES::EccCurves as u32
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This list is used to report the authorization policy values for permanent handles.
/// This is list may be generated by TPM2_GetCapabiltiy(). A permanent handle that cannot
/// have a policy is not included in the list.
#[derive(Debug, Clone)]
pub struct TPML_TAGGED_POLICY {
    /// Array of tagged policies
    pub policies: vec<tpms_tagged_policy>,
}

impl Default for TPML_TAGGED_POLICY {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPML_TAGGED_POLICY {
    /// Creates a new instance with the specified values
    pub fn new(
        policies: vec<tpms_tagged_policy>
        ) -> Self {
        Self {
            policies,
        }

    }

    // Union trait implementations
    impl TpmUnion for TPML_TAGGED_POLICY {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
        TPMU_CAPABILITIES::AuthPolicies as u32
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This list is used to report the timeout and state for the ACT. This list may be
/// generated by TPM2_GetCapabilty(). Only implemented ACT are present in the list
#[derive(Debug, Clone)]
pub struct TPML_ACT_DATA {
    /// Array of ACT data
    pub act_data: vec<tpms_act_data>,
}

impl Default for TPML_ACT_DATA {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPML_ACT_DATA {
    /// Creates a new instance with the specified values
    pub fn new(
        act_data: vec<tpms_act_data>
        ) -> Self {
        Self {
            act_data,
        }

    }

    // Union trait implementations
    impl TpmUnion for TPML_ACT_DATA {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
        TPMU_CAPABILITIES::ACT as u32
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This data area is returned in response to a TPM2_GetCapability().
#[derive(Debug, Clone)]
pub struct TPMS_CAPABILITY_DATA {
    /// The capability

    /// The capability data
    /// One of: TPML_ALG_PROPERTY, TPML_HANDLE, TPML_CCA, TPML_CC, TPML_PCR_SELECTION,
    /// TPML_TAGGED_TPM_PROPERTY, TPML_TAGGED_PCR_PROPERTY, TPML_ECC_CURVE,
    /// TPML_TAGGED_POLICY, TPML_ACT_DATA.
    pub data: Option<Box<dyn TPMU_CAPABILITIES>>,
}

impl Default for TPMS_CAPABILITY_DATA {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPMS_CAPABILITY_DATA {
    /// Creates a new instance with the specified values
    pub fn new(
        data: Option<Box<dyn TPMU_CAPABILITIES>>
        ) -> Self {
        Self {
            data,
        }

    }

    /// Get the capability selector value
    pub fn capability(&self) -> TPM_CAP {
        match &self.data {
        Some(u) => u.get_union_selector() as _,
            None => 0 as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This structure is used in each of the attestation commands.
#[derive(Debug, Clone)]
pub struct TPMS_CLOCK_INFO {
    /// Time value in milliseconds that advances while the TPM is powered
    /// NOTE The interpretation of the time-origin (clock=0) is out of the scope of this
    /// specification, although Coordinated Universal Time (UTC) is expected to be a common
    /// convention. This structure element is used to report on the TPM's Clock value.
    /// This value is reset to zero when the Storage Primary Seed is changed (TPM2_Clear()).
    /// This value may be advanced by TPM2_ClockSet().
    pub clock: u64,

    /// Number of occurrences of TPM Reset since the last TPM2_Clear()
    pub reset_count: u32,

    /// Number of times that TPM2_Shutdown() or _TPM_Hash_Start have occurred since the last
    /// TPM Reset or TPM2_Clear().
    pub restart_count: u32,

    /// No value of Clock greater than the current value of Clock has been previously reported
    /// by the TPM. Set to YES on TPM2_Clear().
    pub safe: u8,
}

impl Default for TPMS_CLOCK_INFO {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPMS_CLOCK_INFO {
    /// Creates a new instance with the specified values
    pub fn new(
        clock: u64
        ,
        reset_count: u32
        ,
        restart_count: u32
        ,
        safe: u8
        ) -> Self {
        Self {
            clock,
            reset_count,
            restart_count,
            safe,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This structure is used in, e.g., the TPM2_GetTime() attestation and TPM2_ReadClock().
#[derive(Debug, Clone)]
pub struct TPMS_TIME_INFO {
    /// Time in milliseconds since the TIme circuit was last reset
    /// This structure element is used to report on the TPM's Time value.
    pub time: u64,

    /// A structure containing the clock information
    pub clock_info: tpms_clock_info,
}

impl Default for TPMS_TIME_INFO {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPMS_TIME_INFO {
    /// Creates a new instance with the specified values
    pub fn new(
        time: u64
        ,
        clock_info: tpms_clock_info
        ) -> Self {
        Self {
            time,
            clock_info,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This structure is used when the TPM performs TPM2_GetTime.
#[derive(Debug, Clone)]
pub struct TPMS_TIME_ATTEST_INFO {
    /// The Time, Clock, resetCount, restartCount, and Safe indicator
    pub time: tpms_time_info,

    /// A TPM vendor-specific value indicating the version number of the firmware
    pub firmware_version: u64,
}

impl Default for TPMS_TIME_ATTEST_INFO {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPMS_TIME_ATTEST_INFO {
    /// Creates a new instance with the specified values
    pub fn new(
        time: tpms_time_info
        ,
        firmware_version: u64
        ) -> Self {
        Self {
            time,
            firmware_version,
        }

    }

    // Union trait implementations
    impl TpmUnion for TPMS_TIME_ATTEST_INFO {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
        TPMU_ATTEST::AttestTime as u32
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This is the attested data for TPM2_Certify().
#[derive(Debug, Clone)]
pub struct TPMS_CERTIFY_INFO {
    /// Name of the certified object
    pub name: vec<u8>,

    /// Qualified Name of the certified object
    pub qualified_name: vec<u8>,
}

impl Default for TPMS_CERTIFY_INFO {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPMS_CERTIFY_INFO {
    /// Creates a new instance with the specified values
    pub fn new(
        name: vec<u8>
        ,
        qualified_name: vec<u8>
        ) -> Self {
        Self {
            name,
            qualified_name,
        }

    }

    // Union trait implementations
    impl TpmUnion for TPMS_CERTIFY_INFO {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
        TPMU_ATTEST::AttestCertify as u32
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This is the attested data for TPM2_Quote().
#[derive(Debug, Clone)]
pub struct TPMS_QUOTE_INFO {
    /// Information on algID, PCR selected and digest
    pub pcr_select: vec<tpms_pcr_selection>,

    /// Digest of the selected PCR using the hash of the signing key
    pub pcr_digest: vec<u8>,
}

impl Default for TPMS_QUOTE_INFO {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPMS_QUOTE_INFO {
    /// Creates a new instance with the specified values
    pub fn new(
        pcr_select: vec<tpms_pcr_selection>
        ,
        pcr_digest: vec<u8>
        ) -> Self {
        Self {
            pcr_select,
            pcr_digest,
        }

    }

    // Union trait implementations
    impl TpmUnion for TPMS_QUOTE_INFO {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
        TPMU_ATTEST::AttestQuote as u32
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This is the attested data for TPM2_GetCommandAuditDigest().
#[derive(Debug, Clone)]
pub struct TPMS_COMMAND_AUDIT_INFO {
    /// The monotonic audit counter
    pub audit_counter: u64,

    /// Hash algorithm used for the command audit
    pub digest_alg: tpm_alg_id,

    /// The current value of the audit digest
    pub audit_digest: vec<u8>,

    /// Digest of the command codes being audited using digestAlg
    pub command_digest: vec<u8>,
}

impl Default for TPMS_COMMAND_AUDIT_INFO {
    fn default() -> Self {
        Self {
            digestAlg = TPM_ALG_ID:NULL;
        }

    }

}

impl TPMS_COMMAND_AUDIT_INFO {
    /// Creates a new instance with the specified values
    pub fn new(
        audit_counter: u64
        ,
        digest_alg: tpm_alg_id
        ,
        audit_digest: vec<u8>
        ,
        command_digest: vec<u8>
        ) -> Self {
        Self {
            audit_counter,
            digest_alg,
            audit_digest,
            command_digest,
        }

    }

    // Union trait implementations
    impl TpmUnion for TPMS_COMMAND_AUDIT_INFO {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
        TPMU_ATTEST::AttestCommandAudit as u32
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This is the attested data for TPM2_GetSessionAuditDigest().
#[derive(Debug, Clone)]
pub struct TPMS_SESSION_AUDIT_INFO {
    /// Current exclusive status of the session
    /// TRUE if all of the commands recorded in the sessionDigest were executed without any
    /// intervening TPM command that did not use this audit session
    pub exclusive_session: u8,

    /// The current value of the session audit digest
    pub session_digest: vec<u8>,
}

impl Default for TPMS_SESSION_AUDIT_INFO {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPMS_SESSION_AUDIT_INFO {
    /// Creates a new instance with the specified values
    pub fn new(
        exclusive_session: u8
        ,
        session_digest: vec<u8>
        ) -> Self {
        Self {
            exclusive_session,
            session_digest,
        }

    }

    // Union trait implementations
    impl TpmUnion for TPMS_SESSION_AUDIT_INFO {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
        TPMU_ATTEST::AttestSessionAudit as u32
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This is the attested data for TPM2_CertifyCreation().
#[derive(Debug, Clone)]
pub struct TPMS_CREATION_INFO {
    /// Name of the object
    pub object_name: vec<u8>,

    /// CreationHash
    pub creation_hash: vec<u8>,
}

impl Default for TPMS_CREATION_INFO {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPMS_CREATION_INFO {
    /// Creates a new instance with the specified values
    pub fn new(
        object_name: vec<u8>
        ,
        creation_hash: vec<u8>
        ) -> Self {
        Self {
            object_name,
            creation_hash,
        }

    }

    // Union trait implementations
    impl TpmUnion for TPMS_CREATION_INFO {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
        TPMU_ATTEST::AttestCreation as u32
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This structure contains the Name and contents of the selected NV Index that is
/// certified by TPM2_NV_Certify().
#[derive(Debug, Clone)]
pub struct TPMS_NV_CERTIFY_INFO {
    /// Name of the NV Index
    pub index_name: vec<u8>,

    /// The offset parameter of TPM2_NV_Certify()
    pub offset: u16,

    /// Contents of the NV Index
    pub nv_contents: vec<u8>,
}

impl Default for TPMS_NV_CERTIFY_INFO {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPMS_NV_CERTIFY_INFO {
    /// Creates a new instance with the specified values
    pub fn new(
        index_name: vec<u8>
        ,
        offset: u16
        ,
        nv_contents: vec<u8>
        ) -> Self {
        Self {
            index_name,
            offset,
            nv_contents,
        }

    }

    // Union trait implementations
    impl TpmUnion for TPMS_NV_CERTIFY_INFO {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
        TPMU_ATTEST::AttestNv as u32
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This structure contains the Name and hash of the contents of the selected NV Index
/// that is certified by TPM2_NV_Certify(). The data is hashed using hash of the signing scheme.
#[derive(Debug, Clone)]
pub struct TPMS_NV_DIGEST_CERTIFY_INFO {
    /// Name of the NV Index
    pub index_name: vec<u8>,

    /// Hash of the contents of the index
    pub nv_digest: vec<u8>,
}

impl Default for TPMS_NV_DIGEST_CERTIFY_INFO {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPMS_NV_DIGEST_CERTIFY_INFO {
    /// Creates a new instance with the specified values
    pub fn new(
        index_name: vec<u8>
        ,
        nv_digest: vec<u8>
        ) -> Self {
        Self {
            index_name,
            nv_digest,
        }

    }

    // Union trait implementations
    impl TpmUnion for TPMS_NV_DIGEST_CERTIFY_INFO {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
        TPMU_ATTEST::AttestNvDigest as u32
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This structure is used on each TPM-generated signed structure. The signature is over
/// this structure.
#[derive(Debug, Clone)]
pub struct TPMS_ATTEST {
    /// The indication that this structure was created by a TPM (always TPM_GENERATED_VALUE)
    pub magic: tpm_generated,

    /// Type of the attestation structure

    /// Qualified Name of the signing key
    pub qualified_signer: vec<u8>,

    /// External information supplied by caller
    /// NOTE A TPM2B_DATA structure provides room for a digest and a method indicator to
    /// indicate the components of the digest. The definition of this method indicator is
    /// outside the scope of this specification.
    pub extra_data: vec<u8>,

    /// Clock, resetCount, restartCount, and Safe
    pub clock_info: tpms_clock_info,

    /// TPM-vendor-specific value identifying the version number of the firmware
    pub firmware_version: u64,

    /// The type-specific attestation information
    /// One of: TPMS_CERTIFY_INFO, TPMS_CREATION_INFO, TPMS_QUOTE_INFO,
    /// TPMS_COMMAND_AUDIT_INFO, TPMS_SESSION_AUDIT_INFO, TPMS_TIME_ATTEST_INFO,
    /// TPMS_NV_CERTIFY_INFO, TPMS_NV_DIGEST_CERTIFY_INFO.
    pub attested: Option<Box<dyn TPMU_ATTEST>>,
}

impl Default for TPMS_ATTEST {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPMS_ATTEST {
    /// Creates a new instance with the specified values
    pub fn new(
        magic: tpm_generated
        ,
        qualified_signer: vec<u8>
        ,
        extra_data: vec<u8>
        ,
        clock_info: tpms_clock_info
        ,
        firmware_version: u64
        ,
        attested: Option<Box<dyn TPMU_ATTEST>>
        ) -> Self {
        Self {
            magic,
            qualified_signer,
            extra_data,
            clock_info,
            firmware_version,
            attested,
        }

    }

    /// Get the type selector value
    pub fn type(&self) -> TPM_ST {
        match &self.attested {
        Some(u) => u.get_union_selector() as _,
            None => 0 as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This sized buffer to contain the signed structure. The attestationData is the signed
/// portion of the structure. The size parameter is not signed.
#[derive(Debug, Clone)]
pub struct TPM2B_ATTEST {
    /// The signed structure
    pub attestation_data: tpms_attest,
}

impl Default for TPM2B_ATTEST {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPM2B_ATTEST {
    /// Creates a new instance with the specified values
    pub fn new(
        attestation_data: tpms_attest
        ) -> Self {
        Self {
            attestation_data,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This is the format used for each of the authorizations in the session area of a command.
#[derive(Debug, Clone)]
pub struct TPMS_AUTH_COMMAND {
    /// The session handle
    pub session_handle: tpm_handle,

    /// The session nonce, may be the Empty Buffer
    pub nonce: vec<u8>,

    /// The session attributes
    pub session_attributes: tpma_session,

    /// Either an HMAC, a password, or an EmptyAuth
    pub hmac: vec<u8>,
}

impl Default for TPMS_AUTH_COMMAND {
    fn default() -> Self {
        Self {
            sessionHandle = TPM_HANDLE();
        }

    }

}

impl TPMS_AUTH_COMMAND {
    /// Creates a new instance with the specified values
    pub fn new(
        session_handle: tpm_handle
        ,
        nonce: vec<u8>
        ,
        session_attributes: tpma_session
        ,
        hmac: vec<u8>
        ) -> Self {
        Self {
            session_handle,
            nonce,
            session_attributes,
            hmac,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This is the format for each of the authorizations in the session area of the response.
/// If the TPM returns TPM_RC_SUCCESS, then the session area of the response contains the
/// same number of authorizations as the command and the authorizations are in the same order.
#[derive(Debug, Clone)]
pub struct TPMS_AUTH_RESPONSE {
    /// The session nonce, may be the Empty Buffer
    pub nonce: vec<u8>,

    /// The session attributes
    pub session_attributes: tpma_session,

    /// Either an HMAC or an EmptyAuth
    pub hmac: vec<u8>,
}

impl Default for TPMS_AUTH_RESPONSE {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPMS_AUTH_RESPONSE {
    /// Creates a new instance with the specified values
    pub fn new(
        nonce: vec<u8>
        ,
        session_attributes: tpma_session
        ,
        hmac: vec<u8>
        ) -> Self {
        Self {
            nonce,
            session_attributes,
            hmac,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_TDES for the union TPMU_SYM_DETAILS
#[derive(Debug, Clone)]
pub struct TPMS_TDES_SYM_DETAILS {
}

impl Default for TPMS_TDES_SYM_DETAILS {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPMS_TDES_SYM_DETAILS {
    // Union trait implementations
    impl TpmUnion for TPMS_TDES_SYM_DETAILS {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
        TPMU_SYM_DETAILS::TDES as u32
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_AES for the union TPMU_SYM_DETAILS
#[derive(Debug, Clone)]
pub struct TPMS_AES_SYM_DETAILS {
}

impl Default for TPMS_AES_SYM_DETAILS {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPMS_AES_SYM_DETAILS {
    // Union trait implementations
    impl TpmUnion for TPMS_AES_SYM_DETAILS {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
        TPMU_SYM_DETAILS::AES as u32
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_SM4 for the union TPMU_SYM_DETAILS
#[derive(Debug, Clone)]
pub struct TPMS_SM4_SYM_DETAILS {
}

impl Default for TPMS_SM4_SYM_DETAILS {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPMS_SM4_SYM_DETAILS {
    // Union trait implementations
    impl TpmUnion for TPMS_SM4_SYM_DETAILS {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
        TPMU_SYM_DETAILS::SM4 as u32
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_CAMELLIA for the union TPMU_SYM_DETAILS
#[derive(Debug, Clone)]
pub struct TPMS_CAMELLIA_SYM_DETAILS {
}

impl Default for TPMS_CAMELLIA_SYM_DETAILS {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPMS_CAMELLIA_SYM_DETAILS {
    // Union trait implementations
    impl TpmUnion for TPMS_CAMELLIA_SYM_DETAILS {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
        TPMU_SYM_DETAILS::CAMELLIA as u32
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_ANY for the union TPMU_SYM_DETAILS
#[derive(Debug, Clone)]
pub struct TPMS_ANY_SYM_DETAILS {
}

impl Default for TPMS_ANY_SYM_DETAILS {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPMS_ANY_SYM_DETAILS {
    // Union trait implementations
    impl TpmUnion for TPMS_ANY_SYM_DETAILS {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
        TPMU_SYM_DETAILS::ANY as u32
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_XOR for the union TPMU_SYM_DETAILS
#[derive(Debug, Clone)]
pub struct TPMS_XOR_SYM_DETAILS {
}

impl Default for TPMS_XOR_SYM_DETAILS {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPMS_XOR_SYM_DETAILS {
    // Union trait implementations
    impl TpmUnion for TPMS_XOR_SYM_DETAILS {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
        TPMU_SYM_DETAILS::XOR as u32
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TPMU_SYM_DETAILS
#[derive(Debug, Clone)]
pub struct TPMS_NULL_SYM_DETAILS {
}

impl Default for TPMS_NULL_SYM_DETAILS {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPMS_NULL_SYM_DETAILS {
    // Union trait implementations
    impl TpmUnion for TPMS_NULL_SYM_DETAILS {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
        TPMU_SYM_DETAILS::NULL as u32
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// The TPMT_SYM_DEF structure is used to select an algorithm to be used for parameter
/// encryption in those cases when different symmetric algorithms may be selected.
#[derive(Debug, Clone)]
pub struct TPMT_SYM_DEF {
    /// Indicates a symmetric algorithm
    pub algorithm: tpm_alg_id,

    /// A supported key size
    pub key_bits: u16,

    /// The mode for the key
    pub mode: tpm_alg_id,
}

impl Default for TPMT_SYM_DEF {
    fn default() -> Self {
        Self {
            algorithm = TPM_ALG_ID:NULL;
            mode = TPM_ALG_ID:NULL;
        }

    }

}

impl TPMT_SYM_DEF {
    /// Creates a new instance with the specified values
    pub fn new(
        algorithm: tpm_alg_id
        ,
        key_bits: u16
        ,
        mode: tpm_alg_id
        ) -> Self {
        Self {
            algorithm,
            key_bits,
            mode,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This structure is used when different symmetric block cipher (not XOR) algorithms may
/// be selected. If the Object can be an ordinary parent (not a derivation parent), this
/// must be the first field in the Object's parameter (see 12.2.3.7) field.
#[derive(Debug, Clone)]
pub struct TPMT_SYM_DEF_OBJECT {
    /// Selects a symmetric block cipher
    /// When used in the parameter area of a parent object, this shall be a supported block
    /// cipher and not TPM_ALG_NULL
    pub algorithm: tpm_alg_id,

    /// The key size
    pub key_bits: u16,

    /// Default mode
    /// When used in the parameter area of a parent object, this shall be TPM_ALG_CFB.
    pub mode: tpm_alg_id,
}

impl Default for TPMT_SYM_DEF_OBJECT {
    fn default() -> Self {
        Self {
            algorithm = TPM_ALG_ID:NULL;
            mode = TPM_ALG_ID:NULL;
        }

    }

}

impl TPMT_SYM_DEF_OBJECT {
    /// Creates a new instance with the specified values
    pub fn new(
        algorithm: tpm_alg_id
        ,
        key_bits: u16
        ,
        mode: tpm_alg_id
        ) -> Self {
        Self {
            algorithm,
            key_bits,
            mode,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This structure is used to hold a symmetric key in the sensitive area of an asymmetric object.
#[derive(Debug, Clone)]
pub struct TPM2B_SYM_KEY {
    /// The key
    pub buffer: vec<u8>,
}

impl Default for TPM2B_SYM_KEY {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPM2B_SYM_KEY {
    /// Creates a new instance with the specified values
    pub fn new(
        buffer: vec<u8>
        ) -> Self {
        Self {
            buffer,
        }

    }

    // Union trait implementations
    impl TpmUnion for TPM2B_SYM_KEY {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
        TPMU_SENSITIVE_COMPOSITE::SYMCIPHER as u32
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This structure contains the parameters for a symmetric block cipher object.
#[derive(Debug, Clone)]
pub struct TPMS_SYMCIPHER_PARMS {
    /// A symmetric block cipher
    pub sym: tpmt_sym_def_object,
}

impl Default for TPMS_SYMCIPHER_PARMS {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPMS_SYMCIPHER_PARMS {
    /// Creates a new instance with the specified values
    pub fn new(
        sym: tpmt_sym_def_object
        ) -> Self {
        Self {
            sym,
        }

    }

    // Union trait implementations
    impl TpmUnion for TPMS_SYMCIPHER_PARMS {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
        TPMU_PUBLIC_PARMS::SYMCIPHER as u32
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This buffer holds a label or context value. For interoperability and backwards
/// compatibility, LABEL_MAX_BUFFER is the minimum of the largest digest on the device and
/// the largest ECC parameter (MAX_ECC_KEY_BYTES) but no more than 32 bytes.
#[derive(Debug, Clone)]
pub struct TPM2B_LABEL {
    /// Symmetric data for a created object or the label and context for a derived object
    pub buffer: vec<u8>,
}

impl Default for TPM2B_LABEL {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPM2B_LABEL {
    /// Creates a new instance with the specified values
    pub fn new(
        buffer: vec<u8>
        ) -> Self {
        Self {
            buffer,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This structure contains the label and context fields for a derived object. These
/// values are used in the derivation KDF. The values in the unique field of inPublic area
/// template take precedence over the values in the inSensitive parameter.
#[derive(Debug, Clone)]
pub struct TPMS_DERIVE {
    pub label: vec<u8>,
    pub context: vec<u8>,
}

impl Default for TPMS_DERIVE {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPMS_DERIVE {
    /// Creates a new instance with the specified values
    pub fn new(
        label: vec<u8>
        ,
        context: vec<u8>
        ) -> Self {
        Self {
            label,
            context,
        }

    }

    // Union trait implementations
    impl TpmUnion for TPMS_DERIVE {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
        TPMU_SENSITIVE_CREATE::ANY2 as u32
        }

    }

    impl TpmUnion for TPMS_DERIVE {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
        TPMU_SENSITIVE_CREATE::ANY2 as u32
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// Table 147 Definition of TPM2B_DERIVE Structure
#[derive(Debug, Clone)]
pub struct TPM2B_DERIVE {
    /// Symmetric data for a created object or the label and context for a derived object
    pub buffer: tpms_derive,
}

impl Default for TPM2B_DERIVE {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPM2B_DERIVE {
    /// Creates a new instance with the specified values
    pub fn new(
        buffer: tpms_derive
        ) -> Self {
        Self {
            buffer,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This buffer wraps the TPMU_SENSITIVE_CREATE structure.
#[derive(Debug, Clone)]
pub struct TPM2B_SENSITIVE_DATA {
    /// Symmetric data for a created object or the label and context for a derived object
    pub buffer: vec<u8>,
}

impl Default for TPM2B_SENSITIVE_DATA {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPM2B_SENSITIVE_DATA {
    /// Creates a new instance with the specified values
    pub fn new(
        buffer: vec<u8>
        ) -> Self {
        Self {
            buffer,
        }

    }

    // Union trait implementations
    impl TpmUnion for TPM2B_SENSITIVE_DATA {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
        TPMU_SENSITIVE_COMPOSITE::KEYEDHASH as u32
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This structure defines the values to be placed in the sensitive area of a created
/// object. This structure is only used within a TPM2B_SENSITIVE_CREATE structure.
#[derive(Debug, Clone)]
pub struct TPMS_SENSITIVE_CREATE {
    /// The USER auth secret value
    pub user_auth: vec<u8>,

    /// Data to be sealed, a key, or derivation values
    pub data: vec<u8>,
}

impl Default for TPMS_SENSITIVE_CREATE {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPMS_SENSITIVE_CREATE {
    /// Creates a new instance with the specified values
    pub fn new(
        user_auth: vec<u8>
        ,
        data: vec<u8>
        ) -> Self {
        Self {
            user_auth,
            data,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This structure contains the sensitive creation data in a sized buffer. This structure
/// is defined so that both the userAuth and data values of the TPMS_SENSITIVE_CREATE may
/// be passed as a single parameter for parameter encryption purposes.
#[derive(Debug, Clone)]
pub struct TPM2B_SENSITIVE_CREATE {
    /// Data to be sealed or a symmetric key value.
    pub sensitive: tpms_sensitive_create,
}

impl Default for TPM2B_SENSITIVE_CREATE {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPM2B_SENSITIVE_CREATE {
    /// Creates a new instance with the specified values
    pub fn new(
        sensitive: tpms_sensitive_create
        ) -> Self {
        Self {
            sensitive,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This structure is the scheme data for schemes that only require a hash to complete
/// their definition.
#[derive(Debug, Clone)]
pub struct TPMS_SCHEME_HASH {
    /// The hash algorithm used to digest the message
    pub hash_alg: tpm_alg_id,
}

impl Default for TPMS_SCHEME_HASH {
    fn default() -> Self {
        Self {
            hashAlg = TPM_ALG_ID:NULL;
        }

    }

}

impl TPMS_SCHEME_HASH {
    /// Creates a new instance with the specified values
    pub fn new(
        hash_alg: tpm_alg_id
        ) -> Self {
        Self {
            hash_alg,
        }

    }

    // Union trait implementations
    impl TpmUnion for TPMS_SCHEME_HASH {
    }

    impl TpmUnion for TPMS_SCHEME_HASH {
    }

    impl TpmUnion for TPMS_SCHEME_HASH {
    }

    impl TpmUnion for TPMS_SCHEME_HASH {
    }

    impl TpmUnion for TPMS_SCHEME_HASH {
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This definition is for split signing schemes that require a commit count.
#[derive(Debug, Clone)]
pub struct TPMS_SCHEME_ECDAA {
    /// The hash algorithm used to digest the message
    pub hash_alg: tpm_alg_id,

    /// The counter value that is used between TPM2_Commit() and the sign operation
    pub count: u16,
}

impl Default for TPMS_SCHEME_ECDAA {
    fn default() -> Self {
        Self {
            hashAlg = TPM_ALG_ID:NULL;
        }

    }

}

impl TPMS_SCHEME_ECDAA {
    /// Creates a new instance with the specified values
    pub fn new(
        hash_alg: tpm_alg_id
        ,
        count: u16
        ) -> Self {
        Self {
            hash_alg,
            count,
        }

    }

    // Union trait implementations
    impl TpmUnion for TPMS_SCHEME_ECDAA {
    }

    impl TpmUnion for TPMS_SCHEME_ECDAA {
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// Table 155 Definition of Types for HMAC_SIG_SCHEME
#[derive(Debug, Clone)]
pub struct TPMS_SCHEME_HMAC {
}

impl Default for TPMS_SCHEME_HMAC {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPMS_SCHEME_HMAC {
    // Union trait implementations
    impl TpmUnion for TPMS_SCHEME_HMAC {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
        TPMU_SCHEME_KEYEDHASH::HMAC as u32
        }

    }

    impl TpmUnion for TPMS_SCHEME_HMAC {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
        TPMU_SCHEME_KEYEDHASH::HMAC as u32
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This structure is for the XOR encryption scheme.
#[derive(Debug, Clone)]
pub struct TPMS_SCHEME_XOR {
    /// The hash algorithm used to digest the message
    pub hash_alg: tpm_alg_id,

    /// The key derivation function
    pub kdf: tpm_alg_id,
}

impl Default for TPMS_SCHEME_XOR {
    fn default() -> Self {
        Self {
            hashAlg = TPM_ALG_ID:NULL;
            kdf = TPM_ALG_ID:NULL;
        }

    }

}

impl TPMS_SCHEME_XOR {
    /// Creates a new instance with the specified values
    pub fn new(
        hash_alg: tpm_alg_id
        ,
        kdf: tpm_alg_id
        ) -> Self {
        Self {
            hash_alg,
            kdf,
        }

    }

    // Union trait implementations
    impl TpmUnion for TPMS_SCHEME_XOR {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
        TPMU_SCHEME_KEYEDHASH::XOR as u32
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TPMU_SCHEME_KEYEDHASH
#[derive(Debug, Clone)]
pub struct TPMS_NULL_SCHEME_KEYEDHASH {
}

impl Default for TPMS_NULL_SCHEME_KEYEDHASH {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPMS_NULL_SCHEME_KEYEDHASH {
    // Union trait implementations
    impl TpmUnion for TPMS_NULL_SCHEME_KEYEDHASH {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
        TPMU_SCHEME_KEYEDHASH::NULL as u32
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This structure is used for a hash signing object.
#[derive(Debug, Clone)]
pub struct TPMT_KEYEDHASH_SCHEME {
    /// Selects the scheme

    /// The scheme parameters
    /// One of: TPMS_SCHEME_HMAC, TPMS_SCHEME_XOR, TPMS_NULL_SCHEME_KEYEDHASH.
    pub details: Option<Box<dyn TPMU_SCHEME_KEYEDHASH>>,
}

impl Default for TPMT_KEYEDHASH_SCHEME {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPMT_KEYEDHASH_SCHEME {
    /// Creates a new instance with the specified values
    pub fn new(
        details: Option<Box<dyn TPMU_SCHEME_KEYEDHASH>>
        ) -> Self {
        Self {
            details,
        }

    }

    /// Get the scheme selector value
    pub fn scheme(&self) -> TPM_ALG_ID {
        match &self.details {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// These are the RSA schemes that only need a hash algorithm as a scheme parameter.
#[derive(Debug, Clone)]
pub struct TPMS_SIG_SCHEME_RSASSA {
}

impl Default for TPMS_SIG_SCHEME_RSASSA {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPMS_SIG_SCHEME_RSASSA {
    // Union trait implementations
    impl TpmUnion for TPMS_SIG_SCHEME_RSASSA {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
        TPMU_SIG_SCHEME::RSASSA as u32
        }

    }

    impl TpmUnion for TPMS_SIG_SCHEME_RSASSA {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
        TPMU_SIG_SCHEME::RSASSA as u32
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// These are the RSA schemes that only need a hash algorithm as a scheme parameter.
#[derive(Debug, Clone)]
pub struct TPMS_SIG_SCHEME_RSAPSS {
}

impl Default for TPMS_SIG_SCHEME_RSAPSS {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPMS_SIG_SCHEME_RSAPSS {
    // Union trait implementations
    impl TpmUnion for TPMS_SIG_SCHEME_RSAPSS {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
        TPMU_SIG_SCHEME::RSAPSS as u32
        }

    }

    impl TpmUnion for TPMS_SIG_SCHEME_RSAPSS {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
        TPMU_SIG_SCHEME::RSAPSS as u32
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// Most of the ECC signature schemes only require a hash algorithm to complete the
/// definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a
/// count value so they are typed to be TPMS_SCHEME_ECDAA.
#[derive(Debug, Clone)]
pub struct TPMS_SIG_SCHEME_ECDSA {
}

impl Default for TPMS_SIG_SCHEME_ECDSA {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPMS_SIG_SCHEME_ECDSA {
    // Union trait implementations
    impl TpmUnion for TPMS_SIG_SCHEME_ECDSA {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
        TPMU_SIG_SCHEME::ECDSA as u32
        }

    }

    impl TpmUnion for TPMS_SIG_SCHEME_ECDSA {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
        TPMU_SIG_SCHEME::ECDSA as u32
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// Most of the ECC signature schemes only require a hash algorithm to complete the
/// definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a
/// count value so they are typed to be TPMS_SCHEME_ECDAA.
#[derive(Debug, Clone)]
pub struct TPMS_SIG_SCHEME_SM2 {
}

impl Default for TPMS_SIG_SCHEME_SM2 {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPMS_SIG_SCHEME_SM2 {
    // Union trait implementations
    impl TpmUnion for TPMS_SIG_SCHEME_SM2 {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
        TPMU_SIG_SCHEME::SM2 as u32
        }

    }

    impl TpmUnion for TPMS_SIG_SCHEME_SM2 {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
        TPMU_SIG_SCHEME::SM2 as u32
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// Most of the ECC signature schemes only require a hash algorithm to complete the
/// definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a
/// count value so they are typed to be TPMS_SCHEME_ECDAA.
#[derive(Debug, Clone)]
pub struct TPMS_SIG_SCHEME_ECSCHNORR {
}

impl Default for TPMS_SIG_SCHEME_ECSCHNORR {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPMS_SIG_SCHEME_ECSCHNORR {
    // Union trait implementations
    impl TpmUnion for TPMS_SIG_SCHEME_ECSCHNORR {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
        TPMU_SIG_SCHEME::ECSCHNORR as u32
        }

    }

    impl TpmUnion for TPMS_SIG_SCHEME_ECSCHNORR {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
        TPMU_SIG_SCHEME::ECSCHNORR as u32
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// Most of the ECC signature schemes only require a hash algorithm to complete the
/// definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a
/// count value so they are typed to be TPMS_SCHEME_ECDAA.
#[derive(Debug, Clone)]
pub struct TPMS_SIG_SCHEME_ECDAA {
}

impl Default for TPMS_SIG_SCHEME_ECDAA {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPMS_SIG_SCHEME_ECDAA {
    // Union trait implementations
    impl TpmUnion for TPMS_SIG_SCHEME_ECDAA {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
        TPMU_SIG_SCHEME::ECDAA as u32
        }

    }

    impl TpmUnion for TPMS_SIG_SCHEME_ECDAA {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
        TPMU_SIG_SCHEME::ECDAA as u32
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TPMU_SIG_SCHEME
#[derive(Debug, Clone)]
pub struct TPMS_NULL_SIG_SCHEME {
}

impl Default for TPMS_NULL_SIG_SCHEME {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPMS_NULL_SIG_SCHEME {
    // Union trait implementations
    impl TpmUnion for TPMS_NULL_SIG_SCHEME {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
        TPMU_SIG_SCHEME::NULL as u32
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// Table 162 Definition of TPMT_SIG_SCHEME Structure
#[derive(Debug, Clone)]
pub struct TPMT_SIG_SCHEME {
    /// Scheme selector

    /// Scheme parameters
    /// One of: TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA,
    /// TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR,
    /// TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME.
    pub details: Option<Box<dyn TPMU_SIG_SCHEME>>,
}

impl Default for TPMT_SIG_SCHEME {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPMT_SIG_SCHEME {
    /// Creates a new instance with the specified values
    pub fn new(
        details: Option<Box<dyn TPMU_SIG_SCHEME>>
        ) -> Self {
        Self {
            details,
        }

    }

    /// Get the scheme selector value
    pub fn scheme(&self) -> TPM_ALG_ID {
        match &self.details {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// These are the RSA encryption schemes that only need a hash algorithm as a controlling parameter.
#[derive(Debug, Clone)]
pub struct TPMS_ENC_SCHEME_OAEP {
}

impl Default for TPMS_ENC_SCHEME_OAEP {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPMS_ENC_SCHEME_OAEP {
    // Union trait implementations
    impl TpmUnion for TPMS_ENC_SCHEME_OAEP {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
        TPMU_ASYM_SCHEME::OAEP as u32
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// These are the RSA encryption schemes that only need a hash algorithm as a controlling parameter.
#[derive(Debug, Clone)]
pub struct TPMS_ENC_SCHEME_RSAES {
}

impl Default for TPMS_ENC_SCHEME_RSAES {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPMS_ENC_SCHEME_RSAES {
    // Union trait implementations
    impl TpmUnion for TPMS_ENC_SCHEME_RSAES {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
        TPMU_ASYM_SCHEME::RSAES as u32
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// These are the ECC schemes that only need a hash algorithm as a controlling parameter.
#[derive(Debug, Clone)]
pub struct TPMS_KEY_SCHEME_ECDH {
}

impl Default for TPMS_KEY_SCHEME_ECDH {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPMS_KEY_SCHEME_ECDH {
    // Union trait implementations
    impl TpmUnion for TPMS_KEY_SCHEME_ECDH {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
        TPMU_ASYM_SCHEME::ECDH as u32
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// These are the ECC schemes that only need a hash algorithm as a controlling parameter.
#[derive(Debug, Clone)]
pub struct TPMS_KEY_SCHEME_ECMQV {
}

impl Default for TPMS_KEY_SCHEME_ECMQV {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPMS_KEY_SCHEME_ECMQV {
    // Union trait implementations
    impl TpmUnion for TPMS_KEY_SCHEME_ECMQV {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
        TPMU_ASYM_SCHEME::ECMQV as u32
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// These structures are used to define the key derivation for symmetric secret sharing
/// using asymmetric methods. A secret sharing scheme is required in any asymmetric key
/// with the decrypt attribute SET.
#[derive(Debug, Clone)]
pub struct TPMS_KDF_SCHEME_MGF1 {
}

impl Default for TPMS_KDF_SCHEME_MGF1 {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPMS_KDF_SCHEME_MGF1 {
    // Union trait implementations
    impl TpmUnion for TPMS_KDF_SCHEME_MGF1 {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
        TPMU_KDF_SCHEME::MGF1 as u32
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// These structures are used to define the key derivation for symmetric secret sharing
/// using asymmetric methods. A secret sharing scheme is required in any asymmetric key
/// with the decrypt attribute SET.
#[derive(Debug, Clone)]
pub struct TPMS_KDF_SCHEME_KDF1_SP800_56A {
}

impl Default for TPMS_KDF_SCHEME_KDF1_SP800_56A {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPMS_KDF_SCHEME_KDF1_SP800_56A {
    // Union trait implementations
    impl TpmUnion for TPMS_KDF_SCHEME_KDF1_SP800_56A {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
        TPMU_KDF_SCHEME::Kdf1Sp80056a as u32
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// These structures are used to define the key derivation for symmetric secret sharing
/// using asymmetric methods. A secret sharing scheme is required in any asymmetric key
/// with the decrypt attribute SET.
#[derive(Debug, Clone)]
pub struct TPMS_KDF_SCHEME_KDF2 {
}

impl Default for TPMS_KDF_SCHEME_KDF2 {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPMS_KDF_SCHEME_KDF2 {
    // Union trait implementations
    impl TpmUnion for TPMS_KDF_SCHEME_KDF2 {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
        TPMU_KDF_SCHEME::KDF2 as u32
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// These structures are used to define the key derivation for symmetric secret sharing
/// using asymmetric methods. A secret sharing scheme is required in any asymmetric key
/// with the decrypt attribute SET.
#[derive(Debug, Clone)]
pub struct TPMS_KDF_SCHEME_KDF1_SP800_108 {
}

impl Default for TPMS_KDF_SCHEME_KDF1_SP800_108 {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPMS_KDF_SCHEME_KDF1_SP800_108 {
    // Union trait implementations
    impl TpmUnion for TPMS_KDF_SCHEME_KDF1_SP800_108 {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
        TPMU_KDF_SCHEME::Kdf1Sp800108 as u32
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TPMU_KDF_SCHEME
#[derive(Debug, Clone)]
pub struct TPMS_NULL_KDF_SCHEME {
}

impl Default for TPMS_NULL_KDF_SCHEME {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPMS_NULL_KDF_SCHEME {
    // Union trait implementations
    impl TpmUnion for TPMS_NULL_KDF_SCHEME {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
        TPMU_KDF_SCHEME::NULL as u32
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// Table 167 Definition of TPMT_KDF_SCHEME Structure
#[derive(Debug, Clone)]
pub struct TPMT_KDF_SCHEME {
    /// Scheme selector

    /// Scheme parameters
    /// One of: TPMS_KDF_SCHEME_MGF1, TPMS_KDF_SCHEME_KDF1_SP800_56A, TPMS_KDF_SCHEME_KDF2,
    /// TPMS_KDF_SCHEME_KDF1_SP800_108, TPMS_SCHEME_HASH, TPMS_NULL_KDF_SCHEME.
    pub details: Option<Box<dyn TPMU_KDF_SCHEME>>,
}

impl Default for TPMT_KDF_SCHEME {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPMT_KDF_SCHEME {
    /// Creates a new instance with the specified values
    pub fn new(
        details: Option<Box<dyn TPMU_KDF_SCHEME>>
        ) -> Self {
        Self {
            details,
        }

    }

    /// Get the scheme selector value
    pub fn scheme(&self) -> TPM_ALG_ID {
        match &self.details {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TPMU_ASYM_SCHEME
#[derive(Debug, Clone)]
pub struct TPMS_NULL_ASYM_SCHEME {
}

impl Default for TPMS_NULL_ASYM_SCHEME {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPMS_NULL_ASYM_SCHEME {
    // Union trait implementations
    impl TpmUnion for TPMS_NULL_ASYM_SCHEME {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
        TPMU_ASYM_SCHEME::NULL as u32
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This structure is defined to allow overlay of all of the schemes for any asymmetric
/// object. This structure is not sent on the interface. It is defined so that common
/// functions may operate on any similar scheme structure.
#[derive(Debug, Clone)]
pub struct TPMT_ASYM_SCHEME {
    /// Scheme selector

    /// Scheme parameters
    /// One of: TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA,
    /// TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA,
    /// TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES,
    /// TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME.
    pub details: Option<Box<dyn TPMU_ASYM_SCHEME>>,
}

impl Default for TPMT_ASYM_SCHEME {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPMT_ASYM_SCHEME {
    /// Creates a new instance with the specified values
    pub fn new(
        details: Option<Box<dyn TPMU_ASYM_SCHEME>>
        ) -> Self {
        Self {
            details,
        }

    }

    /// Get the scheme selector value
    pub fn scheme(&self) -> TPM_ALG_ID {
        match &self.details {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// Table 172 Definition of {RSA} TPMT_RSA_SCHEME Structure
#[derive(Debug, Clone)]
pub struct TPMT_RSA_SCHEME {
    /// Scheme selector

    /// Scheme parameters
    /// One of: TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA,
    /// TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA,
    /// TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES,
    /// TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME.
    pub details: Option<Box<dyn TPMU_ASYM_SCHEME>>,
}

impl Default for TPMT_RSA_SCHEME {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPMT_RSA_SCHEME {
    /// Creates a new instance with the specified values
    pub fn new(
        details: Option<Box<dyn TPMU_ASYM_SCHEME>>
        ) -> Self {
        Self {
            details,
        }

    }

    /// Get the scheme selector value
    pub fn scheme(&self) -> TPM_ALG_ID {
        match &self.details {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// Table 174 Definition of {RSA} TPMT_RSA_DECRYPT Structure
#[derive(Debug, Clone)]
pub struct TPMT_RSA_DECRYPT {
    /// Scheme selector

    /// Scheme parameters
    /// One of: TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA,
    /// TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA,
    /// TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES,
    /// TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME.
    pub details: Option<Box<dyn TPMU_ASYM_SCHEME>>,
}

impl Default for TPMT_RSA_DECRYPT {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPMT_RSA_DECRYPT {
    /// Creates a new instance with the specified values
    pub fn new(
        details: Option<Box<dyn TPMU_ASYM_SCHEME>>
        ) -> Self {
        Self {
            details,
        }

    }

    /// Get the scheme selector value
    pub fn scheme(&self) -> TPM_ALG_ID {
        match &self.details {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This sized buffer holds the largest RSA public key supported by the TPM.
#[derive(Debug, Clone)]
pub struct TPM2B_PUBLIC_KEY_RSA {
    /// Value
    pub buffer: vec<u8>,
}

impl Default for TPM2B_PUBLIC_KEY_RSA {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPM2B_PUBLIC_KEY_RSA {
    /// Creates a new instance with the specified values
    pub fn new(
        buffer: vec<u8>
        ) -> Self {
        Self {
            buffer,
        }

    }

    // Union trait implementations
    impl TpmUnion for TPM2B_PUBLIC_KEY_RSA {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
        TPMU_PUBLIC_ID::RSA as u32
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This sized buffer holds the largest RSA prime number supported by the TPM.
#[derive(Debug, Clone)]
pub struct TPM2B_PRIVATE_KEY_RSA {
    pub buffer: vec<u8>,
}

impl Default for TPM2B_PRIVATE_KEY_RSA {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPM2B_PRIVATE_KEY_RSA {
    /// Creates a new instance with the specified values
    pub fn new(
        buffer: vec<u8>
        ) -> Self {
        Self {
            buffer,
        }

    }

    // Union trait implementations
    impl TpmUnion for TPM2B_PRIVATE_KEY_RSA {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
        TPMU_SENSITIVE_COMPOSITE::RSA as u32
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This sized buffer holds the largest ECC parameter (coordinate) supported by the TPM.
#[derive(Debug, Clone)]
pub struct TPM2B_ECC_PARAMETER {
    /// The parameter data
    pub buffer: vec<u8>,
}

impl Default for TPM2B_ECC_PARAMETER {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPM2B_ECC_PARAMETER {
    /// Creates a new instance with the specified values
    pub fn new(
        buffer: vec<u8>
        ) -> Self {
        Self {
            buffer,
        }

    }

    // Union trait implementations
    impl TpmUnion for TPM2B_ECC_PARAMETER {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
        TPMU_SENSITIVE_COMPOSITE::ECC as u32
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This structure holds two ECC coordinates that, together, make up an ECC point.
#[derive(Debug, Clone)]
pub struct TPMS_ECC_POINT {
    /// X coordinate
    pub x: vec<u8>,

    /// Y coordinate
    pub y: vec<u8>,
}

impl Default for TPMS_ECC_POINT {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPMS_ECC_POINT {
    /// Creates a new instance with the specified values
    pub fn new(
        x: vec<u8>
        ,
        y: vec<u8>
        ) -> Self {
        Self {
            x,
            y,
        }

    }

    // Union trait implementations
    impl TpmUnion for TPMS_ECC_POINT {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
        TPMU_PUBLIC_ID::ECC as u32
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This structure is defined to allow a point to be a single sized parameter so that it
/// may be encrypted.
#[derive(Debug, Clone)]
pub struct TPM2B_ECC_POINT {
    /// Coordinates
    pub point: tpms_ecc_point,
}

impl Default for TPM2B_ECC_POINT {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPM2B_ECC_POINT {
    /// Creates a new instance with the specified values
    pub fn new(
        point: tpms_ecc_point
        ) -> Self {
        Self {
            point,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// Table 183 Definition of (TPMT_SIG_SCHEME) {ECC} TPMT_ECC_SCHEME Structure
#[derive(Debug, Clone)]
pub struct TPMT_ECC_SCHEME {
    /// Scheme selector

    /// Scheme parameters
    /// One of: TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA,
    /// TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA,
    /// TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES,
    /// TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME.
    pub details: Option<Box<dyn TPMU_ASYM_SCHEME>>,
}

impl Default for TPMT_ECC_SCHEME {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPMT_ECC_SCHEME {
    /// Creates a new instance with the specified values
    pub fn new(
        details: Option<Box<dyn TPMU_ASYM_SCHEME>>
        ) -> Self {
        Self {
            details,
        }

    }

    /// Get the scheme selector value
    pub fn scheme(&self) -> TPM_ALG_ID {
        match &self.details {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This structure is used to report on the curve parameters of an ECC curve. It is
/// returned by TPM2_ECC_Parameters().
#[derive(Debug, Clone)]
pub struct TPMS_ALGORITHM_DETAIL_ECC {
    /// Identifier for the curve
    pub curve_id: tpm_ecc_curve,

    /// Size in bits of the key
    pub key_size: u16,

    /// Scheme selector

    /// If not TPM_ALG_NULL, the required KDF and hash algorithm used in secret sharing operations
    /// One of: TPMS_KDF_SCHEME_MGF1, TPMS_KDF_SCHEME_KDF1_SP800_56A, TPMS_KDF_SCHEME_KDF2,
    /// TPMS_KDF_SCHEME_KDF1_SP800_108, TPMS_SCHEME_HASH, TPMS_NULL_KDF_SCHEME.
    pub kdf: Option<Box<dyn TPMU_KDF_SCHEME>>,

    /// Scheme selector

    /// If not TPM_ALG_NULL, this is the mandatory signature scheme that is required to be
    /// used with this curve.
    /// One of: TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA,
    /// TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA,
    /// TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES,
    /// TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME.
    pub sign: Option<Box<dyn TPMU_ASYM_SCHEME>>,

    /// Fp (the modulus)
    pub p: vec<u8>,

    /// Coefficient of the linear term in the curve equation
    pub a: vec<u8>,

    /// Constant term for curve equation
    pub b: vec<u8>,

    /// X coordinate of base point G
    pub gx: vec<u8>,

    /// Y coordinate of base point G
    pub gy: vec<u8>,

    /// Order of G
    pub n: vec<u8>,

    /// Cofactor (a size of zero indicates a cofactor of 1)
    pub h: vec<u8>,
}

impl Default for TPMS_ALGORITHM_DETAIL_ECC {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPMS_ALGORITHM_DETAIL_ECC {
    /// Creates a new instance with the specified values
    pub fn new(
        curve_id: tpm_ecc_curve
        ,
        key_size: u16
        ,
        kdf: Option<Box<dyn TPMU_KDF_SCHEME>>
        ,
        sign: Option<Box<dyn TPMU_ASYM_SCHEME>>
        ,
        p: vec<u8>
        ,
        a: vec<u8>
        ,
        b: vec<u8>
        ,
        gx: vec<u8>
        ,
        gy: vec<u8>
        ,
        n: vec<u8>
        ,
        h: vec<u8>
        ) -> Self {
        Self {
            curve_id,
            key_size,
            kdf,
            sign,
            p,
            a,
            b,
            gx,
            gy,
            n,
            h,
        }

    }

    /// Get the kdfScheme selector value
    pub fn kdf_scheme(&self) -> TPM_ALG_ID {
        match &self.kdf {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    /// Get the signScheme selector value
    pub fn sign_scheme(&self) -> TPM_ALG_ID {
        match &self.sign {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// Table 185 Definition of {RSA} TPMS_SIGNATURE_RSA Structure
#[derive(Debug, Clone)]
pub struct TPMS_SIGNATURE_RSA {
    /// The hash algorithm used to digest the message
    /// TPM_ALG_NULL is not allowed.
    pub hash: tpm_alg_id,

    /// The signature is the size of a public key.
    pub sig: vec<u8>,
}

impl Default for TPMS_SIGNATURE_RSA {
    fn default() -> Self {
        Self {
            hash = TPM_ALG_ID:NULL;
        }

    }

}

impl TPMS_SIGNATURE_RSA {
    /// Creates a new instance with the specified values
    pub fn new(
        hash: tpm_alg_id
        ,
        sig: vec<u8>
        ) -> Self {
        Self {
            hash,
            sig,
        }

    }

    // Union trait implementations
    impl TpmUnion for TPMS_SIGNATURE_RSA {
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// Table 185 Definition of {RSA} TPMS_SIGNATURE_RSA Structure
#[derive(Debug, Clone)]
pub struct TPMS_SIGNATURE_RSASSA {
}

impl Default for TPMS_SIGNATURE_RSASSA {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPMS_SIGNATURE_RSASSA {
    // Union trait implementations
    impl TpmUnion for TPMS_SIGNATURE_RSASSA {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
        TPMU_SIGNATURE::RSASSA as u32
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// Table 185 Definition of {RSA} TPMS_SIGNATURE_RSA Structure
#[derive(Debug, Clone)]
pub struct TPMS_SIGNATURE_RSAPSS {
}

impl Default for TPMS_SIGNATURE_RSAPSS {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPMS_SIGNATURE_RSAPSS {
    // Union trait implementations
    impl TpmUnion for TPMS_SIGNATURE_RSAPSS {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
        TPMU_SIGNATURE::RSAPSS as u32
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// Table 187 Definition of {ECC} TPMS_SIGNATURE_ECC Structure
#[derive(Debug, Clone)]
pub struct TPMS_SIGNATURE_ECC {
    /// The hash algorithm used in the signature process
    /// TPM_ALG_NULL is not allowed.
    pub hash: tpm_alg_id,
    pub signature_r: vec<u8>,
    pub signature_s: vec<u8>,
}

impl Default for TPMS_SIGNATURE_ECC {
    fn default() -> Self {
        Self {
            hash = TPM_ALG_ID:NULL;
        }

    }

}

impl TPMS_SIGNATURE_ECC {
    /// Creates a new instance with the specified values
    pub fn new(
        hash: tpm_alg_id
        ,
        signature_r: vec<u8>
        ,
        signature_s: vec<u8>
        ) -> Self {
        Self {
            hash,
            signature_r,
            signature_s,
        }

    }

    // Union trait implementations
    impl TpmUnion for TPMS_SIGNATURE_ECC {
    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// Table 187 Definition of {ECC} TPMS_SIGNATURE_ECC Structure
#[derive(Debug, Clone)]
pub struct TPMS_SIGNATURE_ECDSA {
}

impl Default for TPMS_SIGNATURE_ECDSA {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPMS_SIGNATURE_ECDSA {
    // Union trait implementations
    impl TpmUnion for TPMS_SIGNATURE_ECDSA {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
        TPMU_SIGNATURE::ECDSA as u32
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// Table 187 Definition of {ECC} TPMS_SIGNATURE_ECC Structure
#[derive(Debug, Clone)]
pub struct TPMS_SIGNATURE_ECDAA {
}

impl Default for TPMS_SIGNATURE_ECDAA {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPMS_SIGNATURE_ECDAA {
    // Union trait implementations
    impl TpmUnion for TPMS_SIGNATURE_ECDAA {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
        TPMU_SIGNATURE::ECDAA as u32
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// Table 187 Definition of {ECC} TPMS_SIGNATURE_ECC Structure
#[derive(Debug, Clone)]
pub struct TPMS_SIGNATURE_SM2 {
}

impl Default for TPMS_SIGNATURE_SM2 {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPMS_SIGNATURE_SM2 {
    // Union trait implementations
    impl TpmUnion for TPMS_SIGNATURE_SM2 {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
        TPMU_SIGNATURE::SM2 as u32
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// Table 187 Definition of {ECC} TPMS_SIGNATURE_ECC Structure
#[derive(Debug, Clone)]
pub struct TPMS_SIGNATURE_ECSCHNORR {
}

impl Default for TPMS_SIGNATURE_ECSCHNORR {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPMS_SIGNATURE_ECSCHNORR {
    // Union trait implementations
    impl TpmUnion for TPMS_SIGNATURE_ECSCHNORR {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
        TPMU_SIGNATURE::ECSCHNORR as u32
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TPMU_SIGNATURE
#[derive(Debug, Clone)]
pub struct TPMS_NULL_SIGNATURE {
}

impl Default for TPMS_NULL_SIGNATURE {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPMS_NULL_SIGNATURE {
    // Union trait implementations
    impl TpmUnion for TPMS_NULL_SIGNATURE {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
        TPMU_SIGNATURE::NULL as u32
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// Table 190 shows the basic algorithm-agile structure when a symmetric or asymmetric
/// signature is indicated. The sigAlg parameter indicates the algorithm used for the
/// signature. This structure is output from commands such as the attestation commands and
/// TPM2_Sign, and is an input to commands such as TPM2_VerifySignature(),
/// TPM2_PolicySigned(), and TPM2_FieldUpgradeStart().
#[derive(Debug, Clone)]
pub struct TPMT_SIGNATURE {
    /// Selector of the algorithm used to construct the signature

    /// This shall be the actual signature information.
    /// One of: TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA,
    /// TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TPMT_HA,
    /// TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE.
    pub signature: Option<Box<dyn TPMU_SIGNATURE>>,
}

impl Default for TPMT_SIGNATURE {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPMT_SIGNATURE {
    /// Creates a new instance with the specified values
    pub fn new(
        signature: Option<Box<dyn TPMU_SIGNATURE>>
        ) -> Self {
        Self {
            signature,
        }

    }

    /// Get the sigAlg selector value
    pub fn sig_alg(&self) -> TPM_ALG_ID {
        match &self.signature {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// Table 192 Definition of TPM2B_ENCRYPTED_SECRET Structure
#[derive(Debug, Clone)]
pub struct TPM2B_ENCRYPTED_SECRET {
    /// Secret
    pub secret: vec<u8>,
}

impl Default for TPM2B_ENCRYPTED_SECRET {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPM2B_ENCRYPTED_SECRET {
    /// Creates a new instance with the specified values
    pub fn new(
        secret: vec<u8>
        ) -> Self {
        Self {
            secret,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This structure describes the parameters that would appear in the public area of a
/// KEYEDHASH object.
#[derive(Debug, Clone)]
pub struct TPMS_KEYEDHASH_PARMS {
    /// Selects the scheme

    /// Indicates the signing method used for a keyedHash signing object. This field also
    /// determines the size of the data field for a data object created with TPM2_Create() or
    /// TPM2_CreatePrimary().
    /// One of: TPMS_SCHEME_HMAC, TPMS_SCHEME_XOR, TPMS_NULL_SCHEME_KEYEDHASH.
    pub scheme: Option<Box<dyn TPMU_SCHEME_KEYEDHASH>>,
}

impl Default for TPMS_KEYEDHASH_PARMS {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPMS_KEYEDHASH_PARMS {
    /// Creates a new instance with the specified values
    pub fn new(
        scheme: Option<Box<dyn TPMU_SCHEME_KEYEDHASH>>
        ) -> Self {
        Self {
            scheme,
        }

    }

    /// Get the schemeScheme selector value
    pub fn scheme_scheme(&self) -> TPM_ALG_ID {
        match &self.scheme {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    // Union trait implementations
    impl TpmUnion for TPMS_KEYEDHASH_PARMS {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
        TPMU_PUBLIC_PARMS::KEYEDHASH as u32
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This structure contains the common public area parameters for an asymmetric key. The
/// first two parameters of the parameter definition structures of an asymmetric key shall
/// have the same two first components.
#[derive(Debug, Clone)]
pub struct TPMS_ASYM_PARMS {
    /// The companion symmetric algorithm for a restricted decryption key and shall be set to
    /// a supported symmetric algorithm
    /// This field is optional for keys that are not decryption keys and shall be set to
    /// TPM_ALG_NULL if not used.
    pub symmetric: tpmt_sym_def_object,

    /// Scheme selector

    /// For a key with the sign attribute SET, a valid signing scheme for the key type
    /// for a key with the decrypt attribute SET, a valid key exchange protocol
    /// for a key with sign and decrypt attributes, shall be TPM_ALG_NULL
    /// One of: TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA,
    /// TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA,
    /// TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES,
    /// TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME.
    pub scheme: Option<Box<dyn TPMU_ASYM_SCHEME>>,
}

impl Default for TPMS_ASYM_PARMS {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPMS_ASYM_PARMS {
    /// Creates a new instance with the specified values
    pub fn new(
        symmetric: tpmt_sym_def_object
        ,
        scheme: Option<Box<dyn TPMU_ASYM_SCHEME>>
        ) -> Self {
        Self {
            symmetric,
            scheme,
        }

    }

    /// Get the schemeScheme selector value
    pub fn scheme_scheme(&self) -> TPM_ALG_ID {
        match &self.scheme {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    // Union trait implementations
    impl TpmUnion for TPMS_ASYM_PARMS {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
        TPMU_PUBLIC_PARMS::ANY as u32
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// A TPM compatible with this specification and supporting RSA shall support two primes
/// and an exponent of zero. An exponent of zero indicates that the exponent is the
/// default of 216 + 1. Support for other values is optional. Use of other exponents in
/// duplicated keys is not recommended because the resulting keys would not be
/// interoperable with other TPMs.
#[derive(Debug, Clone)]
pub struct TPMS_RSA_PARMS {
    /// For a restricted decryption key, shall be set to a supported symmetric algorithm, key
    /// size, and mode.
    /// if the key is not a restricted decryption key, this field shall be set to TPM_ALG_NULL.
    pub symmetric: tpmt_sym_def_object,

    /// Scheme selector

    /// Scheme.scheme shall be:
    /// for an unrestricted signing key, either TPM_ALG_RSAPSS TPM_ALG_RSASSA or TPM_ALG_NULL
    /// for a restricted signing key, either TPM_ALG_RSAPSS or TPM_ALG_RSASSA
    /// for an unrestricted decryption key, TPM_ALG_RSAES, TPM_ALG_OAEP, or TPM_ALG_NULL
    /// unless the object also has the sign attribute
    /// for a restricted decryption key, TPM_ALG_NULL
    /// NOTE When both sign and decrypt are SET, restricted shall be CLEAR and scheme shall be
    /// TPM_ALG_NULL.
    /// One of: TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA,
    /// TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA,
    /// TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES,
    /// TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME.
    pub scheme: Option<Box<dyn TPMU_ASYM_SCHEME>>,

    /// Number of bits in the public modulus
    pub key_bits: u16,

    /// The public exponent
    /// A prime number greater than 2.
    pub exponent: u32,
}

impl Default for TPMS_RSA_PARMS {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPMS_RSA_PARMS {
    /// Creates a new instance with the specified values
    pub fn new(
        symmetric: tpmt_sym_def_object
        ,
        scheme: Option<Box<dyn TPMU_ASYM_SCHEME>>
        ,
        key_bits: u16
        ,
        exponent: u32
        ) -> Self {
        Self {
            symmetric,
            scheme,
            key_bits,
            exponent,
        }

    }

    /// Get the schemeScheme selector value
    pub fn scheme_scheme(&self) -> TPM_ALG_ID {
        match &self.scheme {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    // Union trait implementations
    impl TpmUnion for TPMS_RSA_PARMS {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
        TPMU_PUBLIC_PARMS::RSA as u32
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This structure contains the parameters for prime modulus ECC.
#[derive(Debug, Clone)]
pub struct TPMS_ECC_PARMS {
    /// For a restricted decryption key, shall be set to a supported symmetric algorithm, key
    /// size. and mode.
    /// if the key is not a restricted decryption key, this field shall be set to TPM_ALG_NULL.
    pub symmetric: tpmt_sym_def_object,

    /// Scheme selector

    /// If the sign attribute of the key is SET, then this shall be a valid signing scheme.
    /// NOTE If the sign parameter in curveID indicates a mandatory scheme, then this field
    /// shall have the same value.
    /// If the decrypt attribute of the key is SET, then this shall be a valid key exchange
    /// scheme or TPM_ALG_NULL.
    /// If the key is a Storage Key, then this field shall be TPM_ALG_NULL.
    /// One of: TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA,
    /// TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA,
    /// TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES,
    /// TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME.
    pub scheme: Option<Box<dyn TPMU_ASYM_SCHEME>>,

    /// ECC curve ID
    pub curve_id: tpm_ecc_curve,

    /// Scheme selector

    /// An optional key derivation scheme for generating a symmetric key from a Z value
    /// If the kdf parameter associated with curveID is not TPM_ALG_NULL then this is required
    /// to be NULL.
    /// NOTE There are currently no commands where this parameter has effect and, in the
    /// reference code, this field needs to be set to TPM_ALG_NULL.
    /// One of: TPMS_KDF_SCHEME_MGF1, TPMS_KDF_SCHEME_KDF1_SP800_56A, TPMS_KDF_SCHEME_KDF2,
    /// TPMS_KDF_SCHEME_KDF1_SP800_108, TPMS_SCHEME_HASH, TPMS_NULL_KDF_SCHEME.
    pub kdf: Option<Box<dyn TPMU_KDF_SCHEME>>,
}

impl Default for TPMS_ECC_PARMS {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPMS_ECC_PARMS {
    /// Creates a new instance with the specified values
    pub fn new(
        symmetric: tpmt_sym_def_object
        ,
        scheme: Option<Box<dyn TPMU_ASYM_SCHEME>>
        ,
        curve_id: tpm_ecc_curve
        ,
        kdf: Option<Box<dyn TPMU_KDF_SCHEME>>
        ) -> Self {
        Self {
            symmetric,
            scheme,
            curve_id,
            kdf,
        }

    }

    /// Get the schemeScheme selector value
    pub fn scheme_scheme(&self) -> TPM_ALG_ID {
        match &self.scheme {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    /// Get the kdfScheme selector value
    pub fn kdf_scheme(&self) -> TPM_ALG_ID {
        match &self.kdf {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    // Union trait implementations
    impl TpmUnion for TPMS_ECC_PARMS {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
        TPMU_PUBLIC_PARMS::ECC as u32
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This structure is used in TPM2_TestParms() to validate that a set of algorithm
/// parameters is supported by the TPM.
#[derive(Debug, Clone)]
pub struct TPMT_PUBLIC_PARMS {
    /// The algorithm to be tested

    /// The algorithm details
    /// One of: TPMS_KEYEDHASH_PARMS, TPMS_SYMCIPHER_PARMS, TPMS_RSA_PARMS, TPMS_ECC_PARMS,
    /// TPMS_ASYM_PARMS.
    pub parameters: Option<Box<dyn TPMU_PUBLIC_PARMS>>,
}

impl Default for TPMT_PUBLIC_PARMS {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPMT_PUBLIC_PARMS {
    /// Creates a new instance with the specified values
    pub fn new(
        parameters: Option<Box<dyn TPMU_PUBLIC_PARMS>>
        ) -> Self {
        Self {
            parameters,
        }

    }

    /// Get the type selector value
    pub fn type(&self) -> TPM_ALG_ID {
        match &self.parameters {
        Some(u) => u.get_union_selector() as _,
            None => 0 as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// Table 201 defines the public area structure. The Name of the object is nameAlg
/// concatenated with the digest of this structure using nameAlg.
#[derive(Debug, Clone)]
pub struct TPMT_PUBLIC {
    /// Algorithm associated with this object

    /// Algorithm used for computing the Name of the object
    /// NOTE The "+" indicates that the instance of a TPMT_PUBLIC may have a "+" to indicate
    /// that the nameAlg may be TPM_ALG_NULL.
    pub name_alg: tpm_alg_id,

    /// Attributes that, along with type, determine the manipulations of this object
    pub object_attributes: tpma_object,

    /// Optional policy for using this key
    /// The policy is computed using the nameAlg of the object.
    /// NOTE Shall be the Empty Policy if no authorization policy is present.
    pub auth_policy: vec<u8>,

    /// The algorithm or structure details
    /// One of: TPMS_KEYEDHASH_PARMS, TPMS_SYMCIPHER_PARMS, TPMS_RSA_PARMS, TPMS_ECC_PARMS,
    /// TPMS_ASYM_PARMS.
    pub parameters: Option<Box<dyn TPMU_PUBLIC_PARMS>>,

    /// The unique identifier of the structure
    /// For an asymmetric key, this would be the public key.
    /// One of: TPM2B_DIGEST_KEYEDHASH, TPM2B_DIGEST_SYMCIPHER, TPM2B_PUBLIC_KEY_RSA,
    /// TPMS_ECC_POINT, TPMS_DERIVE.
    pub unique: Option<Box<dyn TPMU_PUBLIC_ID>>,
}

impl Default for TPMT_PUBLIC {
    fn default() -> Self {
        Self {
            nameAlg = TPM_ALG_ID:NULL;
        }

    }

}

impl TPMT_PUBLIC {
    /// Creates a new instance with the specified values
    pub fn new(
        name_alg: tpm_alg_id
        ,
        object_attributes: tpma_object
        ,
        auth_policy: vec<u8>
        ,
        parameters: Option<Box<dyn TPMU_PUBLIC_PARMS>>
        ,
        unique: Option<Box<dyn TPMU_PUBLIC_ID>>
        ) -> Self {
        Self {
            name_alg,
            object_attributes,
            auth_policy,
            parameters,
            unique,
        }

    }

    /// Get the type selector value
    pub fn type(&self) -> TPM_ALG_ID {
        match &self.parameters {
        Some(u) => u.get_union_selector() as _,
            None => 0 as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This sized buffer is used to embed a TPMT_PUBLIC in a load command and in any response
/// that returns a public area.
#[derive(Debug, Clone)]
pub struct TPM2B_PUBLIC {
    /// The public area
    /// NOTE The + indicates that the caller may specify that use of TPM_ALG_NULL is allowed
    /// for nameAlg.
    pub public_area: tpmt_public,
}

impl Default for TPM2B_PUBLIC {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPM2B_PUBLIC {
    /// Creates a new instance with the specified values
    pub fn new(
        public_area: tpmt_public
        ) -> Self {
        Self {
            public_area,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This sized buffer is used to embed a TPMT_TEMPLATE for TPM2_CreateLoaded().
#[derive(Debug, Clone)]
pub struct TPM2B_TEMPLATE {
    /// The public area
    pub buffer: vec<u8>,
}

impl Default for TPM2B_TEMPLATE {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPM2B_TEMPLATE {
    /// Creates a new instance with the specified values
    pub fn new(
        buffer: vec<u8>
        ) -> Self {
        Self {
            buffer,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This structure is defined for coding purposes. For IO to the TPM, the sensitive
/// portion of the key will be in a canonical form. For an RSA key, this will be one of
/// the prime factors of the public modulus. After loading, it is typical that other
/// values will be computed so that computations using the private key will not need to
/// start with just one prime factor. This structure can be used to store the results of
/// such vendor-specific calculations.
#[derive(Debug, Clone)]
pub struct TPM2B_PRIVATE_VENDOR_SPECIFIC {
    pub buffer: vec<u8>,
}

impl Default for TPM2B_PRIVATE_VENDOR_SPECIFIC {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPM2B_PRIVATE_VENDOR_SPECIFIC {
    /// Creates a new instance with the specified values
    pub fn new(
        buffer: vec<u8>
        ) -> Self {
        Self {
            buffer,
        }

    }

    // Union trait implementations
    impl TpmUnion for TPM2B_PRIVATE_VENDOR_SPECIFIC {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
        TPMU_SENSITIVE_COMPOSITE::ANY as u32
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// AuthValue shall not be larger than the size of the digest produced by the nameAlg of
/// the object. seedValue shall be the size of the digest produced by the nameAlg of the object.
#[derive(Debug, Clone)]
pub struct TPMT_SENSITIVE {
    /// Identifier for the sensitive area
    /// This shall be the same as the type parameter of the associated public area.

    /// User authorization data
    /// The authValue may be a zero-length string.
    pub auth_value: vec<u8>,

    /// For a parent object, the optional protection seed; for other objects, the obfuscation value
    pub seed_value: vec<u8>,

    /// The type-specific private data
    /// One of: TPM2B_PRIVATE_KEY_RSA, TPM2B_ECC_PARAMETER, TPM2B_SENSITIVE_DATA,
    /// TPM2B_SYM_KEY, TPM2B_PRIVATE_VENDOR_SPECIFIC.
    pub sensitive: Option<Box<dyn TPMU_SENSITIVE_COMPOSITE>>,
}

impl Default for TPMT_SENSITIVE {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPMT_SENSITIVE {
    /// Creates a new instance with the specified values
    pub fn new(
        auth_value: vec<u8>
        ,
        seed_value: vec<u8>
        ,
        sensitive: Option<Box<dyn TPMU_SENSITIVE_COMPOSITE>>
        ) -> Self {
        Self {
            auth_value,
            seed_value,
            sensitive,
        }

    }

    /// Get the sensitiveType selector value
    pub fn sensitive_type(&self) -> TPM_ALG_ID {
        match &self.sensitive {
        Some(u) => u.get_union_selector() as _,
            None => 0 as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// The TPM2B_SENSITIVE structure is used as a parameter in TPM2_LoadExternal(). It is an
/// unencrypted sensitive area but it may be encrypted using parameter encryption.
#[derive(Debug, Clone)]
pub struct TPM2B_SENSITIVE {
    /// An unencrypted sensitive area
    pub sensitive_area: tpmt_sensitive,
}

impl Default for TPM2B_SENSITIVE {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPM2B_SENSITIVE {
    /// Creates a new instance with the specified values
    pub fn new(
        sensitive_area: tpmt_sensitive
        ) -> Self {
        Self {
            sensitive_area,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This structure is defined to size the contents of a TPM2B_PRIVATE. This structure is
/// not directly marshaled or unmarshaled.
#[derive(Debug, Clone)]
pub struct _PRIVATE {
    pub integrity_outer: vec<u8>,

    /// Could also be a TPM2B_IV
    pub integrity_inner: vec<u8>,

    /// The sensitive area
    pub sensitive: tpmt_sensitive,
}

impl Default for _PRIVATE {
    fn default() -> Self {
        Self {
        }

    }

}

impl _PRIVATE {
    /// Creates a new instance with the specified values
    pub fn new(
        integrity_outer: vec<u8>
        ,
        integrity_inner: vec<u8>
        ,
        sensitive: tpmt_sensitive
        ) -> Self {
        Self {
            integrity_outer,
            integrity_inner,
            sensitive,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// The TPM2B_PRIVATE structure is used as a parameter in multiple commands that create,
/// load, and modify the sensitive area of an object.
#[derive(Debug, Clone)]
pub struct TPM2B_PRIVATE {
    /// An encrypted private area
    pub buffer: vec<u8>,
}

impl Default for TPM2B_PRIVATE {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPM2B_PRIVATE {
    /// Creates a new instance with the specified values
    pub fn new(
        buffer: vec<u8>
        ) -> Self {
        Self {
            buffer,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This structure is used for sizing the TPM2B_ID_OBJECT.
#[derive(Debug, Clone)]
pub struct TPMS_ID_OBJECT {
    /// HMAC using the nameAlg of the storage key on the target TPM
    pub integrity_hmac: vec<u8>,

    /// Credential protector information returned if name matches the referenced object
    /// All of the encIdentity is encrypted, including the size field.
    /// NOTE The TPM is not required to check that the size is not larger than the digest of
    /// the nameAlg. However, if the size is larger, the ID object may not be usable on a TPM
    /// that has no digest larger than produced by nameAlg.
    pub enc_identity: vec<u8>,
}

impl Default for TPMS_ID_OBJECT {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPMS_ID_OBJECT {
    /// Creates a new instance with the specified values
    pub fn new(
        integrity_hmac: vec<u8>
        ,
        enc_identity: vec<u8>
        ) -> Self {
        Self {
            integrity_hmac,
            enc_identity,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This structure is an output from TPM2_MakeCredential() and is an input to
/// TPM2_ActivateCredential().
#[derive(Debug, Clone)]
pub struct TPM2B_ID_OBJECT {
    /// An encrypted credential area
    pub credential: tpms_id_object,
}

impl Default for TPM2B_ID_OBJECT {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPM2B_ID_OBJECT {
    /// Creates a new instance with the specified values
    pub fn new(
        credential: tpms_id_object
        ) -> Self {
        Self {
            credential,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This is the data that can be written to and read from a TPM_NT_PIN_PASS or
/// TPM_NT_PIN_FAIL non-volatile index. pinCount is the most significant octets. pinLimit
/// is the least significant octets.
#[derive(Debug, Clone)]
pub struct TPMS_NV_PIN_COUNTER_PARAMETERS {
    /// This counter shows the current number of successful authValue authorization attempts
    /// to access a TPM_NT_PIN_PASS index or the current number of unsuccessful authValue
    /// authorization attempts to access a TPM_NT_PIN_FAIL index.
    pub pin_count: u32,

    /// This threshold is the value of pinCount at which the authValue authorization of the
    /// host TPM_NT_PIN_PASS or TPM_NT_PIN_FAIL index is locked out.
    pub pin_limit: u32,
}

impl Default for TPMS_NV_PIN_COUNTER_PARAMETERS {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPMS_NV_PIN_COUNTER_PARAMETERS {
    /// Creates a new instance with the specified values
    pub fn new(
        pin_count: u32
        ,
        pin_limit: u32
        ) -> Self {
        Self {
            pin_count,
            pin_limit,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This structure describes an NV Index.
#[derive(Debug, Clone)]
pub struct TPMS_NV_PUBLIC {
    /// The handle of the data area
    pub nv_index: tpm_handle,

    /// Hash algorithm used to compute the name of the Index and used for the authPolicy. For
    /// an extend index, the hash algorithm used for the extend.
    pub name_alg: tpm_alg_id,

    /// The Index attributes
    pub attributes: tpma_nv,

    /// Optional access policy for the Index
    /// The policy is computed using the nameAlg
    /// NOTE Shall be the Empty Policy if no authorization policy is present.
    pub auth_policy: vec<u8>,

    /// The size of the data area
    /// The maximum size is implementation-dependent. The minimum maximum size is platform-specific.
    pub data_size: u16,
}

impl Default for TPMS_NV_PUBLIC {
    fn default() -> Self {
        Self {
            nvIndex = TPM_HANDLE();
            nameAlg = TPM_ALG_ID:NULL;
        }

    }

}

impl TPMS_NV_PUBLIC {
    /// Creates a new instance with the specified values
    pub fn new(
        nv_index: tpm_handle
        ,
        name_alg: tpm_alg_id
        ,
        attributes: tpma_nv
        ,
        auth_policy: vec<u8>
        ,
        data_size: u16
        ) -> Self {
        Self {
            nv_index,
            name_alg,
            attributes,
            auth_policy,
            data_size,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This structure is used when a TPMS_NV_PUBLIC is sent on the TPM interface.
#[derive(Debug, Clone)]
pub struct TPM2B_NV_PUBLIC {
    /// The public area
    pub nv_public: tpms_nv_public,
}

impl Default for TPM2B_NV_PUBLIC {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPM2B_NV_PUBLIC {
    /// Creates a new instance with the specified values
    pub fn new(
        nv_public: tpms_nv_public
        ) -> Self {
        Self {
            nv_public,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This structure holds the object or session context data. When saved, the full
/// structure is encrypted.
#[derive(Debug, Clone)]
pub struct TPM2B_CONTEXT_SENSITIVE {
    /// The sensitive data
    pub buffer: vec<u8>,
}

impl Default for TPM2B_CONTEXT_SENSITIVE {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPM2B_CONTEXT_SENSITIVE {
    /// Creates a new instance with the specified values
    pub fn new(
        buffer: vec<u8>
        ) -> Self {
        Self {
            buffer,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This structure holds the integrity value and the encrypted data for a context.
#[derive(Debug, Clone)]
pub struct TPMS_CONTEXT_DATA {
    /// The integrity value
    pub integrity: vec<u8>,

    /// The sensitive area
    pub encrypted: vec<u8>,
}

impl Default for TPMS_CONTEXT_DATA {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPMS_CONTEXT_DATA {
    /// Creates a new instance with the specified values
    pub fn new(
        integrity: vec<u8>
        ,
        encrypted: vec<u8>
        ) -> Self {
        Self {
            integrity,
            encrypted,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This structure is used in a TPMS_CONTEXT.
#[derive(Debug, Clone)]
pub struct TPM2B_CONTEXT_DATA {
    pub buffer: tpms_context_data,
}

impl Default for TPM2B_CONTEXT_DATA {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPM2B_CONTEXT_DATA {
    /// Creates a new instance with the specified values
    pub fn new(
        buffer: tpms_context_data
        ) -> Self {
        Self {
            buffer,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This structure is used in TPM2_ContextLoad() and TPM2_ContextSave(). If the values of
/// the TPMS_CONTEXT structure in TPM2_ContextLoad() are not the same as the values when
/// the context was saved (TPM2_ContextSave()), then the TPM shall not load the context.
#[derive(Debug, Clone)]
pub struct TPMS_CONTEXT {
    /// The sequence number of the context
    /// NOTE Transient object contexts and session contexts used different counters.
    pub sequence: u64,

    /// A handle indicating if the context is a session, object, or sequence object (see Table
    /// 222 Context Handle Values
    pub saved_handle: tpm_handle,

    /// The hierarchy of the context
    pub hierarchy: tpm_handle,

    /// The context data and integrity HMAC
    pub context_blob: tpms_context_data,
}

impl Default for TPMS_CONTEXT {
    fn default() -> Self {
        Self {
            savedHandle = TPM_HANDLE();
            hierarchy = TPM_HANDLE();
        }

    }

}

impl TPMS_CONTEXT {
    /// Creates a new instance with the specified values
    pub fn new(
        sequence: u64
        ,
        saved_handle: tpm_handle
        ,
        hierarchy: tpm_handle
        ,
        context_blob: tpms_context_data
        ) -> Self {
        Self {
            sequence,
            saved_handle,
            hierarchy,
            context_blob,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This structure provides information relating to the creation environment for the
/// object. The creation data includes the parent Name, parent Qualified Name, and the
/// digest of selected PCR. These values represent the environment in which the object was
/// created. Creation data allows a relying party to determine if an object was created
/// when some appropriate protections were present.
#[derive(Debug, Clone)]
pub struct TPMS_CREATION_DATA {
    /// List indicating the PCR included in pcrDigest
    pub pcr_select: vec<tpms_pcr_selection>,

    /// Digest of the selected PCR using nameAlg of the object for which this structure is
    /// being created
    /// pcrDigest.size shall be zero if the pcrSelect list is empty.
    pub pcr_digest: vec<u8>,

    /// The locality at which the object was created
    pub locality: tpma_locality,

    /// NameAlg of the parent
    pub parent_name_alg: tpm_alg_id,

    /// Name of the parent at time of creation
    /// The size will match digest size associated with parentNameAlg unless it is
    /// TPM_ALG_NULL, in which case the size will be 4 and parentName will be the hierarchy handle.
    pub parent_name: vec<u8>,

    /// Qualified Name of the parent at the time of creation
    /// Size is the same as parentName.
    pub parent_qualified_name: vec<u8>,

    /// Association with additional information added by the key creator
    /// This will be the contents of the outsideInfo parameter in TPM2_Create() or TPM2_CreatePrimary().
    pub outside_info: vec<u8>,
}

impl Default for TPMS_CREATION_DATA {
    fn default() -> Self {
        Self {
            parentNameAlg = TPM_ALG_ID:NULL;
        }

    }

}

impl TPMS_CREATION_DATA {
    /// Creates a new instance with the specified values
    pub fn new(
        pcr_select: vec<tpms_pcr_selection>
        ,
        pcr_digest: vec<u8>
        ,
        locality: tpma_locality
        ,
        parent_name_alg: tpm_alg_id
        ,
        parent_name: vec<u8>
        ,
        parent_qualified_name: vec<u8>
        ,
        outside_info: vec<u8>
        ) -> Self {
        Self {
            pcr_select,
            pcr_digest,
            locality,
            parent_name_alg,
            parent_name,
            parent_qualified_name,
            outside_info,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This structure is created by TPM2_Create() and TPM2_CreatePrimary(). It is never
/// entered into the TPM and never has a size of zero.
#[derive(Debug, Clone)]
pub struct TPM2B_CREATION_DATA {
    pub creation_data: tpms_creation_data,
}

impl Default for TPM2B_CREATION_DATA {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPM2B_CREATION_DATA {
    /// Creates a new instance with the specified values
    pub fn new(
        creation_data: tpms_creation_data
        ) -> Self {
        Self {
            creation_data,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// TPMS_AC_OUTPUT is used to return information about an AC. The tag structure parameter
/// indicates the type of the data value.
#[derive(Debug, Clone)]
pub struct TPMS_AC_OUTPUT {
    /// Tag indicating the contents of data
    pub tag: tpm_at,

    /// The data returned from the AC
    pub data: u32,
}

impl Default for TPMS_AC_OUTPUT {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPMS_AC_OUTPUT {
    /// Creates a new instance with the specified values
    pub fn new(
        tag: tpm_at
        ,
        data: u32
        ) -> Self {
        Self {
            tag,
            data,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This list is only used in TPM2_AC_GetCapability().
#[derive(Debug, Clone)]
pub struct TPML_AC_CAPABILITIES {
    /// A list of AC values
    pub ac_capabilities: vec<tpms_ac_output>,
}

impl Default for TPML_AC_CAPABILITIES {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPML_AC_CAPABILITIES {
    /// Creates a new instance with the specified values
    pub fn new(
        ac_capabilities: vec<tpms_ac_output>
        ) -> Self {
        Self {
            ac_capabilities,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// TPM2_Startup() is always preceded by _TPM_Init, which is the physical indication that
/// TPM initialization is necessary because of a system-wide reset. TPM2_Startup() is only
/// valid after _TPM_Init. Additional TPM2_Startup() commands are not allowed after it has
/// completed successfully. If a TPM requires TPM2_Startup() and another command is
/// received, or if the TPM receives TPM2_Startup() when it is not required, the TPM shall
/// return TPM_RC_INITIALIZE.
#[derive(Debug, Clone)]
pub struct TPM2_Startup_REQUEST {
    /// TPM_SU_CLEAR or TPM_SU_STATE
    pub startup_type: tpm_su,
}

impl Default for TPM2_Startup_REQUEST {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPM2_Startup_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        startup_type: tpm_su
        ) -> Self {
        Self {
            startup_type,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command is used to prepare the TPM for a power cycle. The shutdownType parameter
/// indicates how the subsequent TPM2_Startup() will be processed.
#[derive(Debug, Clone)]
pub struct TPM2_Shutdown_REQUEST {
    /// TPM_SU_CLEAR or TPM_SU_STATE
    pub shutdown_type: tpm_su,
}

impl Default for TPM2_Shutdown_REQUEST {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPM2_Shutdown_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        shutdown_type: tpm_su
        ) -> Self {
        Self {
            shutdown_type,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command causes the TPM to perform a test of its capabilities. If the fullTest is
/// YES, the TPM will test all functions. If fullTest = NO, the TPM will only test those
/// functions that have not previously been tested.
#[derive(Debug, Clone)]
pub struct TPM2_SelfTest_REQUEST {
    /// YES if full test to be performed
    /// NO if only test of untested functions required
    pub full_test: u8,
}

impl Default for TPM2_SelfTest_REQUEST {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPM2_SelfTest_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        full_test: u8
        ) -> Self {
        Self {
            full_test,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command causes the TPM to perform a test of the selected algorithms.
#[derive(Debug, Clone)]
pub struct TPM2_IncrementalSelfTest_REQUEST {
    /// List of algorithms that should be tested
    pub to_test: vec<tpm_alg_id>,
}

impl Default for TPM2_IncrementalSelfTest_REQUEST {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPM2_IncrementalSelfTest_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        to_test: vec<tpm_alg_id>
        ) -> Self {
        Self {
            to_test,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command causes the TPM to perform a test of the selected algorithms.
#[derive(Debug, Clone)]
pub struct IncrementalSelfTestResponse {
    /// List of algorithms that need testing
    pub to_do_list: vec<tpm_alg_id>,
}

impl Default for IncrementalSelfTestResponse {
    fn default() -> Self {
        Self {
        }

    }

}

impl IncrementalSelfTestResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command returns manufacturer-specific information regarding the results of a
/// self-test and an indication of the test status.
#[derive(Debug, Clone)]
pub struct TPM2_GetTestResult_REQUEST {
}

impl Default for TPM2_GetTestResult_REQUEST {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPM2_GetTestResult_REQUEST {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command returns manufacturer-specific information regarding the results of a
/// self-test and an indication of the test status.
#[derive(Debug, Clone)]
pub struct GetTestResultResponse {
    /// Test result data
    /// contains manufacturer-specific information
    pub out_data: vec<u8>,
    pub test_result: tpm_rc,
}

impl Default for GetTestResultResponse {
    fn default() -> Self {
        Self {
        }

    }

}

impl GetTestResultResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command is used to start an authorization session using alternative methods of
/// establishing the session key (sessionKey). The session key is then used to derive
/// values used for authorization and for encrypting parameters.
#[derive(Debug, Clone)]
pub struct TPM2_StartAuthSession_REQUEST {
    /// Handle of a loaded decrypt key used to encrypt salt
    /// may be TPM_RH_NULL
    /// Auth Index: None
    pub tpm_key: tpm_handle,

    /// Entity providing the authValue
    /// may be TPM_RH_NULL
    /// Auth Index: None
    pub bind: tpm_handle,

    /// Initial nonceCaller, sets nonceTPM size for the session
    /// shall be at least 16 octets
    pub nonce_caller: vec<u8>,

    /// Value encrypted according to the type of tpmKey
    /// If tpmKey is TPM_RH_NULL, this shall be the Empty Buffer.
    pub encrypted_salt: vec<u8>,

    /// Indicates the type of the session; simple HMAC or policy (including a trial policy)
    pub session_type: tpm_se,

    /// The algorithm and key size for parameter encryption
    /// may select TPM_ALG_NULL
    pub symmetric: tpmt_sym_def,

    /// Hash algorithm to use for the session
    /// Shall be a hash algorithm supported by the TPM and not TPM_ALG_NULL
    pub auth_hash: tpm_alg_id,
}

impl Default for TPM2_StartAuthSession_REQUEST {
    fn default() -> Self {
        Self {
            tpmKey = TPM_HANDLE();
            bind = TPM_HANDLE();
            authHash = TPM_ALG_ID:NULL;
        }

    }

}

impl TPM2_StartAuthSession_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        tpm_key: tpm_handle
        ,
        bind: tpm_handle
        ,
        nonce_caller: vec<u8>
        ,
        encrypted_salt: vec<u8>
        ,
        session_type: tpm_se
        ,
        symmetric: tpmt_sym_def
        ,
        auth_hash: tpm_alg_id
        ) -> Self {
        Self {
            tpm_key,
            bind,
            nonce_caller,
            encrypted_salt,
            session_type,
            symmetric,
            auth_hash,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command is used to start an authorization session using alternative methods of
/// establishing the session key (sessionKey). The session key is then used to derive
/// values used for authorization and for encrypting parameters.
#[derive(Debug, Clone)]
pub struct StartAuthSessionResponse {
    /// Handle for the newly created session
    pub handle: tpm_handle,

    /// The initial nonce from the TPM, used in the computation of the sessionKey
    pub nonce_tpm: vec<u8>,
}

impl Default for StartAuthSessionResponse {
    fn default() -> Self {
        Self {
            handle = TPM_HANDLE();
        }

    }

}

impl StartAuthSessionResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command allows a policy authorization session to be returned to its initial
/// state. This command is used after the TPM returns TPM_RC_PCR_CHANGED. That response
/// code indicates that a policy will fail because the PCR have changed after
/// TPM2_PolicyPCR() was executed. Restarting the session allows the authorizations to be
/// replayed because the session restarts with the same nonceTPM. If the PCR are valid for
/// the policy, the policy may then succeed.
#[derive(Debug, Clone)]
pub struct TPM2_PolicyRestart_REQUEST {
    /// The handle for the policy session
    pub session_handle: tpm_handle,
}

impl Default for TPM2_PolicyRestart_REQUEST {
    fn default() -> Self {
        Self {
            sessionHandle = TPM_HANDLE();
        }

    }

}

impl TPM2_PolicyRestart_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        session_handle: tpm_handle
        ) -> Self {
        Self {
            session_handle,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command is used to create an object that can be loaded into a TPM using
/// TPM2_Load(). If the command completes successfully, the TPM will create the new object
/// and return the objects creation data (creationData), its public area (outPublic), and
/// its encrypted sensitive area (outPrivate). Preservation of the returned data is the
/// responsibility of the caller. The object will need to be loaded (TPM2_Load()) before
/// it may be used. The only difference between the inPublic TPMT_PUBLIC template and the
/// outPublic TPMT_PUBLIC object is in the unique field.
#[derive(Debug, Clone)]
pub struct TPM2_Create_REQUEST {
    /// Handle of parent for new object
    /// Auth Index: 1
    /// Auth Role: USER
    pub parent_handle: tpm_handle,

    /// The sensitive data
    pub in_sensitive: tpms_sensitive_create,

    /// The public template
    pub in_public: tpmt_public,

    /// Data that will be included in the creation data for this object to provide permanent,
    /// verifiable linkage between this object and some object owner data
    pub outside_info: vec<u8>,

    /// PCR that will be used in creation data
    pub creation_pcr: vec<tpms_pcr_selection>,
}

impl Default for TPM2_Create_REQUEST {
    fn default() -> Self {
        Self {
            parentHandle = TPM_HANDLE();
        }

    }

}

impl TPM2_Create_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        parent_handle: tpm_handle
        ,
        in_sensitive: tpms_sensitive_create
        ,
        in_public: tpmt_public
        ,
        outside_info: vec<u8>
        ,
        creation_pcr: vec<tpms_pcr_selection>
        ) -> Self {
        Self {
            parent_handle,
            in_sensitive,
            in_public,
            outside_info,
            creation_pcr,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command is used to create an object that can be loaded into a TPM using
/// TPM2_Load(). If the command completes successfully, the TPM will create the new object
/// and return the objects creation data (creationData), its public area (outPublic), and
/// its encrypted sensitive area (outPrivate). Preservation of the returned data is the
/// responsibility of the caller. The object will need to be loaded (TPM2_Load()) before
/// it may be used. The only difference between the inPublic TPMT_PUBLIC template and the
/// outPublic TPMT_PUBLIC object is in the unique field.
#[derive(Debug, Clone)]
pub struct CreateResponse {
    /// The private portion of the object
    pub out_private: tpm2b_private,

    /// The public portion of the created object
    pub out_public: tpmt_public,

    /// Contains a TPMS_CREATION_DATA
    pub creation_data: tpms_creation_data,

    /// Digest of creationData using nameAlg of outPublic
    pub creation_hash: vec<u8>,

    /// Ticket used by TPM2_CertifyCreation() to validate that the creation data was produced
    /// by the TPM
    pub creation_ticket: tpmt_tk_creation,
}

impl Default for CreateResponse {
    fn default() -> Self {
        Self {
        }

    }

}

impl CreateResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command is used to load objects into the TPM. This command is used when both a
/// TPM2B_PUBLIC and TPM2B_PRIVATE are to be loaded. If only a TPM2B_PUBLIC is to be
/// loaded, the TPM2_LoadExternal command is used.
#[derive(Debug, Clone)]
pub struct TPM2_Load_REQUEST {
    /// TPM handle of parent key; shall not be a reserved handle
    /// Auth Index: 1
    /// Auth Role: USER
    pub parent_handle: tpm_handle,

    /// The private portion of the object
    pub in_private: tpm2b_private,

    /// The public portion of the object
    pub in_public: tpmt_public,
}

impl Default for TPM2_Load_REQUEST {
    fn default() -> Self {
        Self {
            parentHandle = TPM_HANDLE();
        }

    }

}

impl TPM2_Load_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        parent_handle: tpm_handle
        ,
        in_private: tpm2b_private
        ,
        in_public: tpmt_public
        ) -> Self {
        Self {
            parent_handle,
            in_private,
            in_public,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command is used to load objects into the TPM. This command is used when both a
/// TPM2B_PUBLIC and TPM2B_PRIVATE are to be loaded. If only a TPM2B_PUBLIC is to be
/// loaded, the TPM2_LoadExternal command is used.
#[derive(Debug, Clone)]
pub struct LoadResponse {
    /// Handle of type TPM_HT_TRANSIENT for the loaded object
    pub handle: tpm_handle,

    /// Name of the loaded object
    pub name: vec<u8>,
}

impl Default for LoadResponse {
    fn default() -> Self {
        Self {
            handle = TPM_HANDLE();
        }

    }

}

impl LoadResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command is used to load an object that is not a Protected Object into the TPM.
/// The command allows loading of a public area or both a public and sensitive area.
#[derive(Debug, Clone)]
pub struct TPM2_LoadExternal_REQUEST {
    /// The sensitive portion of the object (optional)
    pub in_private: tpmt_sensitive,

    /// The public portion of the object
    pub in_public: tpmt_public,

    /// Hierarchy with which the object area is associated
    pub hierarchy: tpm_handle,
}

impl Default for TPM2_LoadExternal_REQUEST {
    fn default() -> Self {
        Self {
            hierarchy = TPM_HANDLE();
        }

    }

}

impl TPM2_LoadExternal_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        in_private: tpmt_sensitive
        ,
        in_public: tpmt_public
        ,
        hierarchy: tpm_handle
        ) -> Self {
        Self {
            in_private,
            in_public,
            hierarchy,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command is used to load an object that is not a Protected Object into the TPM.
/// The command allows loading of a public area or both a public and sensitive area.
#[derive(Debug, Clone)]
pub struct LoadExternalResponse {
    /// Handle of type TPM_HT_TRANSIENT for the loaded object
    pub handle: tpm_handle,

    /// Name of the loaded object
    pub name: vec<u8>,
}

impl Default for LoadExternalResponse {
    fn default() -> Self {
        Self {
            handle = TPM_HANDLE();
        }

    }

}

impl LoadExternalResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command allows access to the public area of a loaded object.
#[derive(Debug, Clone)]
pub struct TPM2_ReadPublic_REQUEST {
    /// TPM handle of an object
    /// Auth Index: None
    pub object_handle: tpm_handle,
}

impl Default for TPM2_ReadPublic_REQUEST {
    fn default() -> Self {
        Self {
            objectHandle = TPM_HANDLE();
        }

    }

}

impl TPM2_ReadPublic_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        object_handle: tpm_handle
        ) -> Self {
        Self {
            object_handle,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command allows access to the public area of a loaded object.
#[derive(Debug, Clone)]
pub struct ReadPublicResponse {
    /// Structure containing the public area of an object
    pub out_public: tpmt_public,

    /// Name of the object
    pub name: vec<u8>,

    /// The Qualified Name of the object
    pub qualified_name: vec<u8>,
}

impl Default for ReadPublicResponse {
    fn default() -> Self {
        Self {
        }

    }

}

impl ReadPublicResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command enables the association of a credential with an object in a way that
/// ensures that the TPM has validated the parameters of the credentialed object.
#[derive(Debug, Clone)]
pub struct TPM2_ActivateCredential_REQUEST {
    /// Handle of the object associated with certificate in credentialBlob
    /// Auth Index: 1
    /// Auth Role: ADMIN
    pub activate_handle: tpm_handle,

    /// Loaded key used to decrypt the TPMS_SENSITIVE in credentialBlob
    /// Auth Index: 2
    /// Auth Role: USER
    pub key_handle: tpm_handle,

    /// The credential
    pub credential_blob: tpms_id_object,

    /// KeyHandle algorithm-dependent encrypted seed that protects credentialBlob
    pub secret: vec<u8>,
}

impl Default for TPM2_ActivateCredential_REQUEST {
    fn default() -> Self {
        Self {
            activateHandle = TPM_HANDLE();
            keyHandle = TPM_HANDLE();
        }

    }

}

impl TPM2_ActivateCredential_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        activate_handle: tpm_handle
        ,
        key_handle: tpm_handle
        ,
        credential_blob: tpms_id_object
        ,
        secret: vec<u8>
        ) -> Self {
        Self {
            activate_handle,
            key_handle,
            credential_blob,
            secret,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command enables the association of a credential with an object in a way that
/// ensures that the TPM has validated the parameters of the credentialed object.
#[derive(Debug, Clone)]
pub struct ActivateCredentialResponse {
    /// The decrypted certificate information
    /// the data should be no larger than the size of the digest of the nameAlg associated
    /// with keyHandle
    pub cert_info: vec<u8>,
}

impl Default for ActivateCredentialResponse {
    fn default() -> Self {
        Self {
        }

    }

}

impl ActivateCredentialResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command allows the TPM to perform the actions required of a Certificate Authority
/// (CA) in creating a TPM2B_ID_OBJECT containing an activation credential.
#[derive(Debug, Clone)]
pub struct TPM2_MakeCredential_REQUEST {
    /// Loaded public area, used to encrypt the sensitive area containing the credential key
    /// Auth Index: None
    pub handle: tpm_handle,

    /// The credential information
    pub credential: vec<u8>,

    /// Name of the object to which the credential applies
    pub object_name: vec<u8>,
}

impl Default for TPM2_MakeCredential_REQUEST {
    fn default() -> Self {
        Self {
            handle = TPM_HANDLE();
        }

    }

}

impl TPM2_MakeCredential_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        handle: tpm_handle
        ,
        credential: vec<u8>
        ,
        object_name: vec<u8>
        ) -> Self {
        Self {
            handle,
            credential,
            object_name,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command allows the TPM to perform the actions required of a Certificate Authority
/// (CA) in creating a TPM2B_ID_OBJECT containing an activation credential.
#[derive(Debug, Clone)]
pub struct MakeCredentialResponse {
    /// The credential
    pub credential_blob: tpms_id_object,

    /// Handle algorithm-dependent data that wraps the key that encrypts credentialBlob
    pub secret: vec<u8>,
}

impl Default for MakeCredentialResponse {
    fn default() -> Self {
        Self {
        }

    }

}

impl MakeCredentialResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command returns the data in a loaded Sealed Data Object.
#[derive(Debug, Clone)]
pub struct TPM2_Unseal_REQUEST {
    /// Handle of a loaded data object
    /// Auth Index: 1
    /// Auth Role: USER
    pub item_handle: tpm_handle,
}

impl Default for TPM2_Unseal_REQUEST {
    fn default() -> Self {
        Self {
            itemHandle = TPM_HANDLE();
        }

    }

}

impl TPM2_Unseal_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        item_handle: tpm_handle
        ) -> Self {
        Self {
            item_handle,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command returns the data in a loaded Sealed Data Object.
#[derive(Debug, Clone)]
pub struct UnsealResponse {
    /// Unsealed data
    /// Size of outData is limited to be no more than 128 octets.
    pub out_data: vec<u8>,
}

impl Default for UnsealResponse {
    fn default() -> Self {
        Self {
        }

    }

}

impl UnsealResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command is used to change the authorization secret for a TPM-resident object.
#[derive(Debug, Clone)]
pub struct TPM2_ObjectChangeAuth_REQUEST {
    /// Handle of the object
    /// Auth Index: 1
    /// Auth Role: ADMIN
    pub object_handle: tpm_handle,

    /// Handle of the parent
    /// Auth Index: None
    pub parent_handle: tpm_handle,

    /// New authorization value
    pub new_auth: vec<u8>,
}

impl Default for TPM2_ObjectChangeAuth_REQUEST {
    fn default() -> Self {
        Self {
            objectHandle = TPM_HANDLE();
            parentHandle = TPM_HANDLE();
        }

    }

}

impl TPM2_ObjectChangeAuth_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        object_handle: tpm_handle
        ,
        parent_handle: tpm_handle
        ,
        new_auth: vec<u8>
        ) -> Self {
        Self {
            object_handle,
            parent_handle,
            new_auth,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command is used to change the authorization secret for a TPM-resident object.
#[derive(Debug, Clone)]
pub struct ObjectChangeAuthResponse {
    /// Private area containing the new authorization value
    pub out_private: tpm2b_private,
}

impl Default for ObjectChangeAuthResponse {
    fn default() -> Self {
        Self {
        }

    }

}

impl ObjectChangeAuthResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command creates an object and loads it in the TPM. This command allows creation
/// of any type of object (Primary, Ordinary, or Derived) depending on the type of
/// parentHandle. If parentHandle references a Primary Seed, then a Primary Object is
/// created; if parentHandle references a Storage Parent, then an Ordinary Object is
/// created; and if parentHandle references a Derivation Parent, then a Derived Object is generated.
#[derive(Debug, Clone)]
pub struct TPM2_CreateLoaded_REQUEST {
    /// Handle of a transient storage key, a persistent storage key, TPM_RH_ENDORSEMENT,
    /// TPM_RH_OWNER, TPM_RH_PLATFORM+{PP}, or TPM_RH_NULL
    /// Auth Index: 1
    /// Auth Role: USER
    pub parent_handle: tpm_handle,

    /// The sensitive data, see TPM 2.0 Part 1 Sensitive Values
    pub in_sensitive: tpms_sensitive_create,

    /// The public template
    pub in_public: vec<u8>,
}

impl Default for TPM2_CreateLoaded_REQUEST {
    fn default() -> Self {
        Self {
            parentHandle = TPM_HANDLE();
        }

    }

}

impl TPM2_CreateLoaded_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        parent_handle: tpm_handle
        ,
        in_sensitive: tpms_sensitive_create
        ,
        in_public: vec<u8>
        ) -> Self {
        Self {
            parent_handle,
            in_sensitive,
            in_public,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command creates an object and loads it in the TPM. This command allows creation
/// of any type of object (Primary, Ordinary, or Derived) depending on the type of
/// parentHandle. If parentHandle references a Primary Seed, then a Primary Object is
/// created; if parentHandle references a Storage Parent, then an Ordinary Object is
/// created; and if parentHandle references a Derivation Parent, then a Derived Object is generated.
#[derive(Debug, Clone)]
pub struct CreateLoadedResponse {
    /// Handle of type TPM_HT_TRANSIENT for created object
    pub handle: tpm_handle,

    /// The sensitive area of the object (optional)
    pub out_private: tpm2b_private,

    /// The public portion of the created object
    pub out_public: tpmt_public,

    /// The name of the created object
    pub name: vec<u8>,
}

impl Default for CreateLoadedResponse {
    fn default() -> Self {
        Self {
            handle = TPM_HANDLE();
        }

    }

}

impl CreateLoadedResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command duplicates a loaded object so that it may be used in a different
/// hierarchy. The new parent key for the duplicate may be on the same or different TPM or
/// TPM_RH_NULL. Only the public area of newParentHandle is required to be loaded.
#[derive(Debug, Clone)]
pub struct TPM2_Duplicate_REQUEST {
    /// Loaded object to duplicate
    /// Auth Index: 1
    /// Auth Role: DUP
    pub object_handle: tpm_handle,

    /// Shall reference the public area of an asymmetric key
    /// Auth Index: None
    pub new_parent_handle: tpm_handle,

    /// Optional symmetric encryption key
    /// The size for this key is set to zero when the TPM is to generate the key. This
    /// parameter may be encrypted.
    pub encryption_key_in: vec<u8>,

    /// Definition for the symmetric algorithm to be used for the inner wrapper
    /// may be TPM_ALG_NULL if no inner wrapper is applied
    pub symmetric_alg: tpmt_sym_def_object,
}

impl Default for TPM2_Duplicate_REQUEST {
    fn default() -> Self {
        Self {
            objectHandle = TPM_HANDLE();
            newParentHandle = TPM_HANDLE();
        }

    }

}

impl TPM2_Duplicate_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        object_handle: tpm_handle
        ,
        new_parent_handle: tpm_handle
        ,
        encryption_key_in: vec<u8>
        ,
        symmetric_alg: tpmt_sym_def_object
        ) -> Self {
        Self {
            object_handle,
            new_parent_handle,
            encryption_key_in,
            symmetric_alg,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command duplicates a loaded object so that it may be used in a different
/// hierarchy. The new parent key for the duplicate may be on the same or different TPM or
/// TPM_RH_NULL. Only the public area of newParentHandle is required to be loaded.
#[derive(Debug, Clone)]
pub struct DuplicateResponse {
    /// If the caller provided an encryption key or if symmetricAlg was TPM_ALG_NULL, then
    /// this will be the Empty Buffer; otherwise, it shall contain the TPM-generated,
    /// symmetric encryption key for the inner wrapper.
    pub encryption_key_out: vec<u8>,

    /// Private area that may be encrypted by encryptionKeyIn; and may be doubly encrypted
    pub duplicate: tpm2b_private,

    /// Seed protected by the asymmetric algorithms of new parent (NP)
    pub out_sym_seed: vec<u8>,
}

impl Default for DuplicateResponse {
    fn default() -> Self {
        Self {
        }

    }

}

impl DuplicateResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command allows the TPM to serve in the role as a Duplication Authority. If proper
/// authorization for use of the oldParent is provided, then an HMAC key and a symmetric
/// key are recovered from inSymSeed and used to integrity check and decrypt inDuplicate.
/// A new protection seed value is generated according to the methods appropriate for
/// newParent and the blob is re-encrypted and a new integrity value is computed. The
/// re-encrypted blob is returned in outDuplicate and the symmetric key returned in outSymKey.
#[derive(Debug, Clone)]
pub struct TPM2_Rewrap_REQUEST {
    /// Parent of object
    /// Auth Index: 1
    /// Auth Role: User
    pub old_parent: tpm_handle,

    /// New parent of the object
    /// Auth Index: None
    pub new_parent: tpm_handle,

    /// An object encrypted using symmetric key derived from inSymSeed
    pub in_duplicate: tpm2b_private,

    /// The Name of the object being rewrapped
    pub name: vec<u8>,

    /// The seed for the symmetric key and HMAC key
    /// needs oldParent private key to recover the seed and generate the symmetric key
    pub in_sym_seed: vec<u8>,
}

impl Default for TPM2_Rewrap_REQUEST {
    fn default() -> Self {
        Self {
            oldParent = TPM_HANDLE();
            newParent = TPM_HANDLE();
        }

    }

}

impl TPM2_Rewrap_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        old_parent: tpm_handle
        ,
        new_parent: tpm_handle
        ,
        in_duplicate: tpm2b_private
        ,
        name: vec<u8>
        ,
        in_sym_seed: vec<u8>
        ) -> Self {
        Self {
            old_parent,
            new_parent,
            in_duplicate,
            name,
            in_sym_seed,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command allows the TPM to serve in the role as a Duplication Authority. If proper
/// authorization for use of the oldParent is provided, then an HMAC key and a symmetric
/// key are recovered from inSymSeed and used to integrity check and decrypt inDuplicate.
/// A new protection seed value is generated according to the methods appropriate for
/// newParent and the blob is re-encrypted and a new integrity value is computed. The
/// re-encrypted blob is returned in outDuplicate and the symmetric key returned in outSymKey.
#[derive(Debug, Clone)]
pub struct RewrapResponse {
    /// An object encrypted using symmetric key derived from outSymSeed
    pub out_duplicate: tpm2b_private,

    /// Seed for a symmetric key protected by newParent asymmetric key
    pub out_sym_seed: vec<u8>,
}

impl Default for RewrapResponse {
    fn default() -> Self {
        Self {
        }

    }

}

impl RewrapResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command allows an object to be encrypted using the symmetric encryption values of
/// a Storage Key. After encryption, the object may be loaded and used in the new
/// hierarchy. The imported object (duplicate) may be singly encrypted, multiply
/// encrypted, or unencrypted.
#[derive(Debug, Clone)]
pub struct TPM2_Import_REQUEST {
    /// The handle of the new parent for the object
    /// Auth Index: 1
    /// Auth Role: USER
    pub parent_handle: tpm_handle,

    /// The optional symmetric encryption key used as the inner wrapper for duplicate
    /// If symmetricAlg is TPM_ALG_NULL, then this parameter shall be the Empty Buffer.
    pub encryption_key: vec<u8>,

    /// The public area of the object to be imported
    /// This is provided so that the integrity value for duplicate and the object attributes
    /// can be checked.
    /// NOTE Even if the integrity value of the object is not checked on input, the object
    /// Name is required to create the integrity value for the imported object.
    pub object_public: tpmt_public,

    /// The symmetrically encrypted duplicate object that may contain an inner symmetric wrapper
    pub duplicate: tpm2b_private,

    /// The seed for the symmetric key and HMAC key
    /// inSymSeed is encrypted/encoded using the algorithms of newParent.
    pub in_sym_seed: vec<u8>,

    /// Definition for the symmetric algorithm to use for the inner wrapper
    /// If this algorithm is TPM_ALG_NULL, no inner wrapper is present and encryptionKey shall
    /// be the Empty Buffer.
    pub symmetric_alg: tpmt_sym_def_object,
}

impl Default for TPM2_Import_REQUEST {
    fn default() -> Self {
        Self {
            parentHandle = TPM_HANDLE();
        }

    }

}

impl TPM2_Import_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        parent_handle: tpm_handle
        ,
        encryption_key: vec<u8>
        ,
        object_public: tpmt_public
        ,
        duplicate: tpm2b_private
        ,
        in_sym_seed: vec<u8>
        ,
        symmetric_alg: tpmt_sym_def_object
        ) -> Self {
        Self {
            parent_handle,
            encryption_key,
            object_public,
            duplicate,
            in_sym_seed,
            symmetric_alg,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command allows an object to be encrypted using the symmetric encryption values of
/// a Storage Key. After encryption, the object may be loaded and used in the new
/// hierarchy. The imported object (duplicate) may be singly encrypted, multiply
/// encrypted, or unencrypted.
#[derive(Debug, Clone)]
pub struct ImportResponse {
    /// The sensitive area encrypted with the symmetric key of parentHandle
    pub out_private: tpm2b_private,
}

impl Default for ImportResponse {
    fn default() -> Self {
        Self {
        }

    }

}

impl ImportResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command performs RSA encryption using the indicated padding scheme according to
/// IETF RFC 8017. If the scheme of keyHandle is TPM_ALG_NULL, then the caller may use
/// inScheme to specify the padding scheme. If scheme of keyHandle is not TPM_ALG_NULL,
/// then inScheme shall either be TPM_ALG_NULL or be the same as scheme (TPM_RC_SCHEME).
#[derive(Debug, Clone)]
pub struct TPM2_RSA_Encrypt_REQUEST {
    /// Reference to public portion of RSA key to use for encryption
    /// Auth Index: None
    pub key_handle: tpm_handle,

    /// Message to be encrypted
    /// NOTE 1 The data type was chosen because it limits the overall size of the input to no
    /// greater than the size of the largest RSA public key. This may be larger than allowed
    /// for keyHandle.
    pub message: vec<u8>,

    /// Scheme selector

    /// The padding scheme to use if scheme associated with keyHandle is TPM_ALG_NULL
    /// One of: TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA,
    /// TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA,
    /// TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES,
    /// TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME.
    pub in_scheme: Option<Box<dyn TPMU_ASYM_SCHEME>>,

    /// Optional label L to be associated with the message
    /// Size of the buffer is zero if no label is present
    /// NOTE 2 See description of label above.
    pub label: vec<u8>,
}

impl Default for TPM2_RSA_Encrypt_REQUEST {
    fn default() -> Self {
        Self {
            keyHandle = TPM_HANDLE();
        }

    }

}

impl TPM2_RSA_Encrypt_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        key_handle: tpm_handle
        ,
        message: vec<u8>
        ,
        in_scheme: Option<Box<dyn TPMU_ASYM_SCHEME>>
        ,
        label: vec<u8>
        ) -> Self {
        Self {
            key_handle,
            message,
            in_scheme,
            label,
        }

    }

    /// Get the inSchemeScheme selector value
    pub fn in_scheme_scheme(&self) -> TPM_ALG_ID {
        match &self.in_scheme {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command performs RSA encryption using the indicated padding scheme according to
/// IETF RFC 8017. If the scheme of keyHandle is TPM_ALG_NULL, then the caller may use
/// inScheme to specify the padding scheme. If scheme of keyHandle is not TPM_ALG_NULL,
/// then inScheme shall either be TPM_ALG_NULL or be the same as scheme (TPM_RC_SCHEME).
#[derive(Debug, Clone)]
pub struct RSA_EncryptResponse {
    /// Encrypted output
    pub out_data: vec<u8>,
}

impl Default for RSA_EncryptResponse {
    fn default() -> Self {
        Self {
        }

    }

}

impl RSA_EncryptResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command performs RSA decryption using the indicated padding scheme according to
/// IETF RFC 8017 ((PKCS#1).
#[derive(Debug, Clone)]
pub struct TPM2_RSA_Decrypt_REQUEST {
    /// RSA key to use for decryption
    /// Auth Index: 1
    /// Auth Role: USER
    pub key_handle: tpm_handle,

    /// Cipher text to be decrypted
    /// NOTE An encrypted RSA data block is the size of the public modulus.
    pub cipher_text: vec<u8>,

    /// Scheme selector

    /// The padding scheme to use if scheme associated with keyHandle is TPM_ALG_NULL
    /// One of: TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA,
    /// TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA,
    /// TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES,
    /// TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME.
    pub in_scheme: Option<Box<dyn TPMU_ASYM_SCHEME>>,

    /// Label whose association with the message is to be verified
    pub label: vec<u8>,
}

impl Default for TPM2_RSA_Decrypt_REQUEST {
    fn default() -> Self {
        Self {
            keyHandle = TPM_HANDLE();
        }

    }

}

impl TPM2_RSA_Decrypt_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        key_handle: tpm_handle
        ,
        cipher_text: vec<u8>
        ,
        in_scheme: Option<Box<dyn TPMU_ASYM_SCHEME>>
        ,
        label: vec<u8>
        ) -> Self {
        Self {
            key_handle,
            cipher_text,
            in_scheme,
            label,
        }

    }

    /// Get the inSchemeScheme selector value
    pub fn in_scheme_scheme(&self) -> TPM_ALG_ID {
        match &self.in_scheme {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command performs RSA decryption using the indicated padding scheme according to
/// IETF RFC 8017 ((PKCS#1).
#[derive(Debug, Clone)]
pub struct RSA_DecryptResponse {
    /// Decrypted output
    pub message: vec<u8>,
}

impl Default for RSA_DecryptResponse {
    fn default() -> Self {
        Self {
        }

    }

}

impl RSA_DecryptResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command uses the TPM to generate an ephemeral key pair (de, Qe where Qe [de]G).
/// It uses the private ephemeral key and a loaded public key (QS) to compute the shared
/// secret value (P [hde]QS).
#[derive(Debug, Clone)]
pub struct TPM2_ECDH_KeyGen_REQUEST {
    /// Handle of a loaded ECC key public area.
    /// Auth Index: None
    pub key_handle: tpm_handle,
}

impl Default for TPM2_ECDH_KeyGen_REQUEST {
    fn default() -> Self {
        Self {
            keyHandle = TPM_HANDLE();
        }

    }

}

impl TPM2_ECDH_KeyGen_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        key_handle: tpm_handle
        ) -> Self {
        Self {
            key_handle,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command uses the TPM to generate an ephemeral key pair (de, Qe where Qe [de]G).
/// It uses the private ephemeral key and a loaded public key (QS) to compute the shared
/// secret value (P [hde]QS).
#[derive(Debug, Clone)]
pub struct ECDH_KeyGenResponse {
    /// Results of P h[de]Qs
    pub zpoint: tpms_ecc_point,

    /// Generated ephemeral public point (Qe)
    pub pub_point: tpms_ecc_point,
}

impl Default for ECDH_KeyGenResponse {
    fn default() -> Self {
        Self {
        }

    }

}

impl ECDH_KeyGenResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command uses the TPM to recover the Z value from a public point (QB) and a
/// private key (ds). It will perform the multiplication of the provided inPoint (QB) with
/// the private key (ds) and return the coordinates of the resultant point (Z = (xZ , yZ)
/// [hds]QB; where h is the cofactor of the curve).
#[derive(Debug, Clone)]
pub struct TPM2_ECDH_ZGen_REQUEST {
    /// Handle of a loaded ECC key
    /// Auth Index: 1
    /// Auth Role: USER
    pub key_handle: tpm_handle,

    /// A public key
    pub in_point: tpms_ecc_point,
}

impl Default for TPM2_ECDH_ZGen_REQUEST {
    fn default() -> Self {
        Self {
            keyHandle = TPM_HANDLE();
        }

    }

}

impl TPM2_ECDH_ZGen_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        key_handle: tpm_handle
        ,
        in_point: tpms_ecc_point
        ) -> Self {
        Self {
            key_handle,
            in_point,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command uses the TPM to recover the Z value from a public point (QB) and a
/// private key (ds). It will perform the multiplication of the provided inPoint (QB) with
/// the private key (ds) and return the coordinates of the resultant point (Z = (xZ , yZ)
/// [hds]QB; where h is the cofactor of the curve).
#[derive(Debug, Clone)]
pub struct ECDH_ZGenResponse {
    /// X and Y coordinates of the product of the multiplication Z = (xZ , yZ) [hdS]QB
    pub out_point: tpms_ecc_point,
}

impl Default for ECDH_ZGenResponse {
    fn default() -> Self {
        Self {
        }

    }

}

impl ECDH_ZGenResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command returns the parameters of an ECC curve identified by its TCG-assigned curveID.
#[derive(Debug, Clone)]
pub struct TPM2_ECC_Parameters_REQUEST {
    /// Parameter set selector
    pub curve_id: tpm_ecc_curve,
}

impl Default for TPM2_ECC_Parameters_REQUEST {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPM2_ECC_Parameters_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        curve_id: tpm_ecc_curve
        ) -> Self {
        Self {
            curve_id,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command returns the parameters of an ECC curve identified by its TCG-assigned curveID.
#[derive(Debug, Clone)]
pub struct ECC_ParametersResponse {
    /// ECC parameters for the selected curve
    pub parameters: tpms_algorithm_detail_ecc,
}

impl Default for ECC_ParametersResponse {
    fn default() -> Self {
        Self {
        }

    }

}

impl ECC_ParametersResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command supports two-phase key exchange protocols. The command is used in
/// combination with TPM2_EC_Ephemeral(). TPM2_EC_Ephemeral() generates an ephemeral key
/// and returns the public point of that ephemeral key along with a numeric value that
/// allows the TPM to regenerate the associated private key.
#[derive(Debug, Clone)]
pub struct TPM2_ZGen_2Phase_REQUEST {
    /// Handle of an unrestricted decryption key ECC
    /// The private key referenced by this handle is used as dS,A
    /// Auth Index: 1
    /// Auth Role: USER
    pub key_a: tpm_handle,

    /// Other partys static public key (Qs,B = (Xs,B, Ys,B))
    pub in_qs_b: tpms_ecc_point,

    /// Other party's ephemeral public key (Qe,B = (Xe,B, Ye,B))
    pub in_qe_b: tpms_ecc_point,

    /// The key exchange scheme
    pub in_scheme: tpm_alg_id,

    /// Value returned by TPM2_EC_Ephemeral()
    pub counter: u16,
}

impl Default for TPM2_ZGen_2Phase_REQUEST {
    fn default() -> Self {
        Self {
            keyA = TPM_HANDLE();
            inScheme = TPM_ALG_ID:NULL;
        }

    }

}

impl TPM2_ZGen_2Phase_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        key_a: tpm_handle
        ,
        in_qs_b: tpms_ecc_point
        ,
        in_qe_b: tpms_ecc_point
        ,
        in_scheme: tpm_alg_id
        ,
        counter: u16
        ) -> Self {
        Self {
            key_a,
            in_qs_b,
            in_qe_b,
            in_scheme,
            counter,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command supports two-phase key exchange protocols. The command is used in
/// combination with TPM2_EC_Ephemeral(). TPM2_EC_Ephemeral() generates an ephemeral key
/// and returns the public point of that ephemeral key along with a numeric value that
/// allows the TPM to regenerate the associated private key.
#[derive(Debug, Clone)]
pub struct ZGen_2PhaseResponse {
    /// X and Y coordinates of the computed value (scheme dependent)
    pub out_z1: tpms_ecc_point,

    /// X and Y coordinates of the second computed value (scheme dependent)
    pub out_z2: tpms_ecc_point,
}

impl Default for ZGen_2PhaseResponse {
    fn default() -> Self {
        Self {
        }

    }

}

impl ZGen_2PhaseResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command performs ECC encryption as described in Part 1, Annex D.
#[derive(Debug, Clone)]
pub struct TPM2_ECC_Encrypt_REQUEST {
    /// Reference to public portion of ECC key to use for encryption
    /// Auth Index: None
    pub key_handle: tpm_handle,

    /// Plaintext to be encrypted
    pub plain_text: vec<u8>,

    /// Scheme selector

    /// The KDF to use if scheme associated with keyHandle is TPM_ALG_NULL
    /// One of: TPMS_KDF_SCHEME_MGF1, TPMS_KDF_SCHEME_KDF1_SP800_56A, TPMS_KDF_SCHEME_KDF2,
    /// TPMS_KDF_SCHEME_KDF1_SP800_108, TPMS_SCHEME_HASH, TPMS_NULL_KDF_SCHEME.
    pub in_scheme: Option<Box<dyn TPMU_KDF_SCHEME>>,
}

impl Default for TPM2_ECC_Encrypt_REQUEST {
    fn default() -> Self {
        Self {
            keyHandle = TPM_HANDLE();
        }

    }

}

impl TPM2_ECC_Encrypt_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        key_handle: tpm_handle
        ,
        plain_text: vec<u8>
        ,
        in_scheme: Option<Box<dyn TPMU_KDF_SCHEME>>
        ) -> Self {
        Self {
            key_handle,
            plain_text,
            in_scheme,
        }

    }

    /// Get the inSchemeScheme selector value
    pub fn in_scheme_scheme(&self) -> TPM_ALG_ID {
        match &self.in_scheme {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command performs ECC encryption as described in Part 1, Annex D.
#[derive(Debug, Clone)]
pub struct ECC_EncryptResponse {
    /// The public ephemeral key used for ECDH
    pub c1: tpms_ecc_point,

    /// The data block produced by the XOR process
    pub c2: vec<u8>,

    /// The integrity value
    pub c3: vec<u8>,
}

impl Default for ECC_EncryptResponse {
    fn default() -> Self {
        Self {
        }

    }

}

impl ECC_EncryptResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command performs ECC decryption.
#[derive(Debug, Clone)]
pub struct TPM2_ECC_Decrypt_REQUEST {
    /// ECC key to use for decryption
    /// Auth Index: 1
    /// Auth Role: USER
    pub key_handle: tpm_handle,

    /// The public ephemeral key used for ECDH
    pub c1: tpms_ecc_point,

    /// The data block produced by the XOR process
    pub c2: vec<u8>,

    /// The integrity value
    pub c3: vec<u8>,

    /// Scheme selector

    /// The KDF to use if scheme associated with keyHandle is TPM_ALG_NULL
    /// One of: TPMS_KDF_SCHEME_MGF1, TPMS_KDF_SCHEME_KDF1_SP800_56A, TPMS_KDF_SCHEME_KDF2,
    /// TPMS_KDF_SCHEME_KDF1_SP800_108, TPMS_SCHEME_HASH, TPMS_NULL_KDF_SCHEME.
    pub in_scheme: Option<Box<dyn TPMU_KDF_SCHEME>>,
}

impl Default for TPM2_ECC_Decrypt_REQUEST {
    fn default() -> Self {
        Self {
            keyHandle = TPM_HANDLE();
        }

    }

}

impl TPM2_ECC_Decrypt_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        key_handle: tpm_handle
        ,
        c1: tpms_ecc_point
        ,
        c2: vec<u8>
        ,
        c3: vec<u8>
        ,
        in_scheme: Option<Box<dyn TPMU_KDF_SCHEME>>
        ) -> Self {
        Self {
            key_handle,
            c1,
            c2,
            c3,
            in_scheme,
        }

    }

    /// Get the inSchemeScheme selector value
    pub fn in_scheme_scheme(&self) -> TPM_ALG_ID {
        match &self.in_scheme {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command performs ECC decryption.
#[derive(Debug, Clone)]
pub struct ECC_DecryptResponse {
    /// Decrypted output
    pub plain_text: vec<u8>,
}

impl Default for ECC_DecryptResponse {
    fn default() -> Self {
        Self {
        }

    }

}

impl ECC_DecryptResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// NOTE 1 This command is deprecated, and TPM2_EncryptDecrypt2() is preferred. This
/// should be reflected in platform-specific specifications.
#[derive(Debug, Clone)]
pub struct TPM2_EncryptDecrypt_REQUEST {
    /// The symmetric key used for the operation
    /// Auth Index: 1
    /// Auth Role: USER
    pub key_handle: tpm_handle,

    /// If YES, then the operation is decryption; if NO, the operation is encryption
    pub decrypt: u8,

    /// Symmetric encryption/decryption mode
    /// this field shall match the default mode of the key or be TPM_ALG_NULL.
    pub mode: tpm_alg_id,

    /// An initial value as required by the algorithm
    pub iv_in: vec<u8>,

    /// The data to be encrypted/decrypted
    pub in_data: vec<u8>,
}

impl Default for TPM2_EncryptDecrypt_REQUEST {
    fn default() -> Self {
        Self {
            keyHandle = TPM_HANDLE();
            mode = TPM_ALG_ID:NULL;
        }

    }

}

impl TPM2_EncryptDecrypt_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        key_handle: tpm_handle
        ,
        decrypt: u8
        ,
        mode: tpm_alg_id
        ,
        iv_in: vec<u8>
        ,
        in_data: vec<u8>
        ) -> Self {
        Self {
            key_handle,
            decrypt,
            mode,
            iv_in,
            in_data,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// NOTE 1 This command is deprecated, and TPM2_EncryptDecrypt2() is preferred. This
/// should be reflected in platform-specific specifications.
#[derive(Debug, Clone)]
pub struct EncryptDecryptResponse {
    /// Encrypted or decrypted output
    pub out_data: vec<u8>,

    /// Chaining value to use for IV in next round
    pub iv_out: vec<u8>,
}

impl Default for EncryptDecryptResponse {
    fn default() -> Self {
        Self {
        }

    }

}

impl EncryptDecryptResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command is identical to TPM2_EncryptDecrypt(), except that the inData parameter
/// is the first parameter. This permits inData to be parameter encrypted.
#[derive(Debug, Clone)]
pub struct TPM2_EncryptDecrypt2_REQUEST {
    /// The symmetric key used for the operation
    /// Auth Index: 1
    /// Auth Role: USER
    pub key_handle: tpm_handle,

    /// The data to be encrypted/decrypted
    pub in_data: vec<u8>,

    /// If YES, then the operation is decryption; if NO, the operation is encryption
    pub decrypt: u8,

    /// Symmetric mode
    /// this field shall match the default mode of the key or be TPM_ALG_NULL.
    pub mode: tpm_alg_id,

    /// An initial value as required by the algorithm
    pub iv_in: vec<u8>,
}

impl Default for TPM2_EncryptDecrypt2_REQUEST {
    fn default() -> Self {
        Self {
            keyHandle = TPM_HANDLE();
            mode = TPM_ALG_ID:NULL;
        }

    }

}

impl TPM2_EncryptDecrypt2_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        key_handle: tpm_handle
        ,
        in_data: vec<u8>
        ,
        decrypt: u8
        ,
        mode: tpm_alg_id
        ,
        iv_in: vec<u8>
        ) -> Self {
        Self {
            key_handle,
            in_data,
            decrypt,
            mode,
            iv_in,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command is identical to TPM2_EncryptDecrypt(), except that the inData parameter
/// is the first parameter. This permits inData to be parameter encrypted.
#[derive(Debug, Clone)]
pub struct EncryptDecrypt2Response {
    /// Encrypted or decrypted output
    pub out_data: vec<u8>,

    /// Chaining value to use for IV in next round
    pub iv_out: vec<u8>,
}

impl Default for EncryptDecrypt2Response {
    fn default() -> Self {
        Self {
        }

    }

}

impl EncryptDecrypt2Response {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command performs a hash operation on a data buffer and returns the results.
#[derive(Debug, Clone)]
pub struct TPM2_Hash_REQUEST {
    /// Data to be hashed
    pub data: vec<u8>,

    /// Algorithm for the hash being computed shall not be TPM_ALG_NULL
    pub hash_alg: tpm_alg_id,

    /// Hierarchy to use for the ticket (TPM_RH_NULL allowed)
    pub hierarchy: tpm_handle,
}

impl Default for TPM2_Hash_REQUEST {
    fn default() -> Self {
        Self {
            hashAlg = TPM_ALG_ID:NULL;
            hierarchy = TPM_HANDLE();
        }

    }

}

impl TPM2_Hash_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        data: vec<u8>
        ,
        hash_alg: tpm_alg_id
        ,
        hierarchy: tpm_handle
        ) -> Self {
        Self {
            data,
            hash_alg,
            hierarchy,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command performs a hash operation on a data buffer and returns the results.
#[derive(Debug, Clone)]
pub struct HashResponse {
    /// Results
    pub out_hash: vec<u8>,

    /// Ticket indicating that the sequence of octets used to compute outDigest did not start
    /// with TPM_GENERATED_VALUE
    /// will be a NULL ticket if the digest may not be signed with a restricted key
    pub validation: tpmt_tk_hashcheck,
}

impl Default for HashResponse {
    fn default() -> Self {
        Self {
        }

    }

}

impl HashResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command performs an HMAC on the supplied data using the indicated hash algorithm.
#[derive(Debug, Clone)]
pub struct TPM2_HMAC_REQUEST {
    /// Handle for the symmetric signing key providing the HMAC key
    /// Auth Index: 1
    /// Auth Role: USER
    pub handle: tpm_handle,

    /// HMAC data
    pub buffer: vec<u8>,

    /// Algorithm to use for HMAC
    pub hash_alg: tpm_alg_id,
}

impl Default for TPM2_HMAC_REQUEST {
    fn default() -> Self {
        Self {
            handle = TPM_HANDLE();
            hashAlg = TPM_ALG_ID:NULL;
        }

    }

}

impl TPM2_HMAC_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        handle: tpm_handle
        ,
        buffer: vec<u8>
        ,
        hash_alg: tpm_alg_id
        ) -> Self {
        Self {
            handle,
            buffer,
            hash_alg,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command performs an HMAC on the supplied data using the indicated hash algorithm.
#[derive(Debug, Clone)]
pub struct HMACResponse {
    /// The returned HMAC in a sized buffer
    pub out_hmac: vec<u8>,
}

impl Default for HMACResponse {
    fn default() -> Self {
        Self {
        }

    }

}

impl HMACResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command performs an HMAC or a block cipher MAC on the supplied data using the
/// indicated algorithm.
#[derive(Debug, Clone)]
pub struct TPM2_MAC_REQUEST {
    /// Handle for the symmetric signing key providing the MAC key
    /// Auth Index: 1
    /// Auth Role: USER
    pub handle: tpm_handle,

    /// MAC data
    pub buffer: vec<u8>,

    /// Algorithm to use for MAC
    pub in_scheme: tpm_alg_id,
}

impl Default for TPM2_MAC_REQUEST {
    fn default() -> Self {
        Self {
            handle = TPM_HANDLE();
            inScheme = TPM_ALG_ID:NULL;
        }

    }

}

impl TPM2_MAC_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        handle: tpm_handle
        ,
        buffer: vec<u8>
        ,
        in_scheme: tpm_alg_id
        ) -> Self {
        Self {
            handle,
            buffer,
            in_scheme,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command performs an HMAC or a block cipher MAC on the supplied data using the
/// indicated algorithm.
#[derive(Debug, Clone)]
pub struct MACResponse {
    /// The returned MAC in a sized buffer
    pub out_mac: vec<u8>,
}

impl Default for MACResponse {
    fn default() -> Self {
        Self {
        }

    }

}

impl MACResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command returns the next bytesRequested octets from the random number generator (RNG).
#[derive(Debug, Clone)]
pub struct TPM2_GetRandom_REQUEST {
    /// Number of octets to return
    pub bytes_requested: u16,
}

impl Default for TPM2_GetRandom_REQUEST {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPM2_GetRandom_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        bytes_requested: u16
        ) -> Self {
        Self {
            bytes_requested,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command returns the next bytesRequested octets from the random number generator (RNG).
#[derive(Debug, Clone)]
pub struct GetRandomResponse {
    /// The random octets
    pub random_bytes: vec<u8>,
}

impl Default for GetRandomResponse {
    fn default() -> Self {
        Self {
        }

    }

}

impl GetRandomResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command is used to add "additional information" to the RNG state.
#[derive(Debug, Clone)]
pub struct TPM2_StirRandom_REQUEST {
    /// Additional information
    pub in_data: vec<u8>,
}

impl Default for TPM2_StirRandom_REQUEST {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPM2_StirRandom_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        in_data: vec<u8>
        ) -> Self {
        Self {
            in_data,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command starts an HMAC sequence. The TPM will create and initialize an HMAC
/// sequence structure, assign a handle to the sequence, and set the authValue of the
/// sequence object to the value in auth.
#[derive(Debug, Clone)]
pub struct TPM2_HMAC_Start_REQUEST {
    /// Handle of an HMAC key
    /// Auth Index: 1
    /// Auth Role: USER
    pub handle: tpm_handle,

    /// Authorization value for subsequent use of the sequence
    pub auth: vec<u8>,

    /// The hash algorithm to use for the HMAC
    pub hash_alg: tpm_alg_id,
}

impl Default for TPM2_HMAC_Start_REQUEST {
    fn default() -> Self {
        Self {
            handle = TPM_HANDLE();
            hashAlg = TPM_ALG_ID:NULL;
        }

    }

}

impl TPM2_HMAC_Start_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        handle: tpm_handle
        ,
        auth: vec<u8>
        ,
        hash_alg: tpm_alg_id
        ) -> Self {
        Self {
            handle,
            auth,
            hash_alg,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command starts an HMAC sequence. The TPM will create and initialize an HMAC
/// sequence structure, assign a handle to the sequence, and set the authValue of the
/// sequence object to the value in auth.
#[derive(Debug, Clone)]
pub struct HMAC_StartResponse {
    /// A handle to reference the sequence
    pub handle: tpm_handle,
}

impl Default for HMAC_StartResponse {
    fn default() -> Self {
        Self {
            handle = TPM_HANDLE();
        }

    }

}

impl HMAC_StartResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command starts a MAC sequence. The TPM will create and initialize a MAC sequence
/// structure, assign a handle to the sequence, and set the authValue of the sequence
/// object to the value in auth.
#[derive(Debug, Clone)]
pub struct TPM2_MAC_Start_REQUEST {
    /// Handle of a MAC key
    /// Auth Index: 1
    /// Auth Role: USER
    pub handle: tpm_handle,

    /// Authorization value for subsequent use of the sequence
    pub auth: vec<u8>,

    /// The algorithm to use for the MAC
    pub in_scheme: tpm_alg_id,
}

impl Default for TPM2_MAC_Start_REQUEST {
    fn default() -> Self {
        Self {
            handle = TPM_HANDLE();
            inScheme = TPM_ALG_ID:NULL;
        }

    }

}

impl TPM2_MAC_Start_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        handle: tpm_handle
        ,
        auth: vec<u8>
        ,
        in_scheme: tpm_alg_id
        ) -> Self {
        Self {
            handle,
            auth,
            in_scheme,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command starts a MAC sequence. The TPM will create and initialize a MAC sequence
/// structure, assign a handle to the sequence, and set the authValue of the sequence
/// object to the value in auth.
#[derive(Debug, Clone)]
pub struct MAC_StartResponse {
    /// A handle to reference the sequence
    pub handle: tpm_handle,
}

impl Default for MAC_StartResponse {
    fn default() -> Self {
        Self {
            handle = TPM_HANDLE();
        }

    }

}

impl MAC_StartResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command starts a hash or an Event Sequence. If hashAlg is an implemented hash,
/// then a hash sequence is started. If hashAlg is TPM_ALG_NULL, then an Event Sequence is
/// started. If hashAlg is neither an implemented algorithm nor TPM_ALG_NULL, then the TPM
/// shall return TPM_RC_HASH.
#[derive(Debug, Clone)]
pub struct TPM2_HashSequenceStart_REQUEST {
    /// Authorization value for subsequent use of the sequence
    pub auth: vec<u8>,

    /// The hash algorithm to use for the hash sequence
    /// An Event Sequence starts if this is TPM_ALG_NULL.
    pub hash_alg: tpm_alg_id,
}

impl Default for TPM2_HashSequenceStart_REQUEST {
    fn default() -> Self {
        Self {
            hashAlg = TPM_ALG_ID:NULL;
        }

    }

}

impl TPM2_HashSequenceStart_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        auth: vec<u8>
        ,
        hash_alg: tpm_alg_id
        ) -> Self {
        Self {
            auth,
            hash_alg,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command starts a hash or an Event Sequence. If hashAlg is an implemented hash,
/// then a hash sequence is started. If hashAlg is TPM_ALG_NULL, then an Event Sequence is
/// started. If hashAlg is neither an implemented algorithm nor TPM_ALG_NULL, then the TPM
/// shall return TPM_RC_HASH.
#[derive(Debug, Clone)]
pub struct HashSequenceStartResponse {
    /// A handle to reference the sequence
    pub handle: tpm_handle,
}

impl Default for HashSequenceStartResponse {
    fn default() -> Self {
        Self {
            handle = TPM_HANDLE();
        }

    }

}

impl HashSequenceStartResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command is used to add data to a hash or HMAC sequence. The amount of data in
/// buffer may be any size up to the limits of the TPM.
#[derive(Debug, Clone)]
pub struct TPM2_SequenceUpdate_REQUEST {
    /// Handle for the sequence object
    /// Auth Index: 1
    /// Auth Role: USER
    pub sequence_handle: tpm_handle,

    /// Data to be added to hash
    pub buffer: vec<u8>,
}

impl Default for TPM2_SequenceUpdate_REQUEST {
    fn default() -> Self {
        Self {
            sequenceHandle = TPM_HANDLE();
        }

    }

}

impl TPM2_SequenceUpdate_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        sequence_handle: tpm_handle
        ,
        buffer: vec<u8>
        ) -> Self {
        Self {
            sequence_handle,
            buffer,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command adds the last part of data, if any, to a hash/HMAC sequence and returns
/// the result.
#[derive(Debug, Clone)]
pub struct TPM2_SequenceComplete_REQUEST {
    /// Authorization for the sequence
    /// Auth Index: 1
    /// Auth Role: USER
    pub sequence_handle: tpm_handle,

    /// Data to be added to the hash/HMAC
    pub buffer: vec<u8>,

    /// Hierarchy of the ticket for a hash
    pub hierarchy: tpm_handle,
}

impl Default for TPM2_SequenceComplete_REQUEST {
    fn default() -> Self {
        Self {
            sequenceHandle = TPM_HANDLE();
            hierarchy = TPM_HANDLE();
        }

    }

}

impl TPM2_SequenceComplete_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        sequence_handle: tpm_handle
        ,
        buffer: vec<u8>
        ,
        hierarchy: tpm_handle
        ) -> Self {
        Self {
            sequence_handle,
            buffer,
            hierarchy,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command adds the last part of data, if any, to a hash/HMAC sequence and returns
/// the result.
#[derive(Debug, Clone)]
pub struct SequenceCompleteResponse {
    /// The returned HMAC or digest in a sized buffer
    pub result: vec<u8>,

    /// Ticket indicating that the sequence of octets used to compute outDigest did not start
    /// with TPM_GENERATED_VALUE
    /// This is a NULL Ticket when the sequence is HMAC.
    pub validation: tpmt_tk_hashcheck,
}

impl Default for SequenceCompleteResponse {
    fn default() -> Self {
        Self {
        }

    }

}

impl SequenceCompleteResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command adds the last part of data, if any, to an Event Sequence and returns the
/// result in a digest list. If pcrHandle references a PCR and not TPM_RH_NULL, then the
/// returned digest list is processed in the same manner as the digest list input
/// parameter to TPM2_PCR_Extend(). That is, if a bank contains a PCR associated with
/// pcrHandle, it is extended with the associated digest value from the list.
#[derive(Debug, Clone)]
pub struct TPM2_EventSequenceComplete_REQUEST {
    /// PCR to be extended with the Event data
    /// Auth Index: 1
    /// Auth Role: USER
    pub pcr_handle: tpm_handle,

    /// Authorization for the sequence
    /// Auth Index: 2
    /// Auth Role: USER
    pub sequence_handle: tpm_handle,

    /// Data to be added to the Event
    pub buffer: vec<u8>,
}

impl Default for TPM2_EventSequenceComplete_REQUEST {
    fn default() -> Self {
        Self {
            pcrHandle = TPM_HANDLE();
            sequenceHandle = TPM_HANDLE();
        }

    }

}

impl TPM2_EventSequenceComplete_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        pcr_handle: tpm_handle
        ,
        sequence_handle: tpm_handle
        ,
        buffer: vec<u8>
        ) -> Self {
        Self {
            pcr_handle,
            sequence_handle,
            buffer,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command adds the last part of data, if any, to an Event Sequence and returns the
/// result in a digest list. If pcrHandle references a PCR and not TPM_RH_NULL, then the
/// returned digest list is processed in the same manner as the digest list input
/// parameter to TPM2_PCR_Extend(). That is, if a bank contains a PCR associated with
/// pcrHandle, it is extended with the associated digest value from the list.
#[derive(Debug, Clone)]
pub struct EventSequenceCompleteResponse {
    /// List of digests computed for the PCR
    pub results: vec<tpmt_ha>,
}

impl Default for EventSequenceCompleteResponse {
    fn default() -> Self {
        Self {
        }

    }

}

impl EventSequenceCompleteResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// The purpose of this command is to prove that an object with a specific Name is loaded
/// in the TPM. By certifying that the object is loaded, the TPM warrants that a public
/// area with a given Name is self-consistent and associated with a valid sensitive area.
/// If a relying party has a public area that has the same Name as a Name certified with
/// this command, then the values in that public area are correct.
#[derive(Debug, Clone)]
pub struct TPM2_Certify_REQUEST {
    /// Handle of the object to be certified
    /// Auth Index: 1
    /// Auth Role: ADMIN
    pub object_handle: tpm_handle,

    /// Handle of the key used to sign the attestation structure
    /// Auth Index: 2
    /// Auth Role: USER
    pub sign_handle: tpm_handle,

    /// User provided qualifying data
    pub qualifying_data: vec<u8>,

    /// Scheme selector

    /// Signing scheme to use if the scheme for signHandle is TPM_ALG_NULL
    /// One of: TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA,
    /// TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR,
    /// TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME.
    pub in_scheme: Option<Box<dyn TPMU_SIG_SCHEME>>,
}

impl Default for TPM2_Certify_REQUEST {
    fn default() -> Self {
        Self {
            objectHandle = TPM_HANDLE();
            signHandle = TPM_HANDLE();
        }

    }

}

impl TPM2_Certify_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        object_handle: tpm_handle
        ,
        sign_handle: tpm_handle
        ,
        qualifying_data: vec<u8>
        ,
        in_scheme: Option<Box<dyn TPMU_SIG_SCHEME>>
        ) -> Self {
        Self {
            object_handle,
            sign_handle,
            qualifying_data,
            in_scheme,
        }

    }

    /// Get the inSchemeScheme selector value
    pub fn in_scheme_scheme(&self) -> TPM_ALG_ID {
        match &self.in_scheme {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// The purpose of this command is to prove that an object with a specific Name is loaded
/// in the TPM. By certifying that the object is loaded, the TPM warrants that a public
/// area with a given Name is self-consistent and associated with a valid sensitive area.
/// If a relying party has a public area that has the same Name as a Name certified with
/// this command, then the values in that public area are correct.
#[derive(Debug, Clone)]
pub struct CertifyResponse {
    /// The structure that was signed
    pub certify_info: tpms_attest,

    /// Selector of the algorithm used to construct the signature

    /// The asymmetric signature over certifyInfo using the key referenced by signHandle
    /// One of: TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA,
    /// TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TPMT_HA,
    /// TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE.
    pub signature: Option<Box<dyn TPMU_SIGNATURE>>,
}

impl Default for CertifyResponse {
    fn default() -> Self {
        Self {
        }

    }

}

impl CertifyResponse {
    /// Get the signatureSigAlg selector value
    pub fn signature_sig_alg(&self) -> TPM_ALG_ID {
        match &self.signature {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command is used to prove the association between an object and its creation data.
/// The TPM will validate that the ticket was produced by the TPM and that the ticket
/// validates the association between a loaded public area and the provided hash of the
/// creation data (creationHash).
#[derive(Debug, Clone)]
pub struct TPM2_CertifyCreation_REQUEST {
    /// Handle of the key that will sign the attestation block
    /// Auth Index: 1
    /// Auth Role: USER
    pub sign_handle: tpm_handle,

    /// The object associated with the creation data
    /// Auth Index: None
    pub object_handle: tpm_handle,

    /// User-provided qualifying data
    pub qualifying_data: vec<u8>,

    /// Hash of the creation data produced by TPM2_Create() or TPM2_CreatePrimary()
    pub creation_hash: vec<u8>,

    /// Scheme selector

    /// Signing scheme to use if the scheme for signHandle is TPM_ALG_NULL
    /// One of: TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA,
    /// TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR,
    /// TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME.
    pub in_scheme: Option<Box<dyn TPMU_SIG_SCHEME>>,

    /// Ticket produced by TPM2_Create() or TPM2_CreatePrimary()
    pub creation_ticket: tpmt_tk_creation,
}

impl Default for TPM2_CertifyCreation_REQUEST {
    fn default() -> Self {
        Self {
            signHandle = TPM_HANDLE();
            objectHandle = TPM_HANDLE();
        }

    }

}

impl TPM2_CertifyCreation_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        sign_handle: tpm_handle
        ,
        object_handle: tpm_handle
        ,
        qualifying_data: vec<u8>
        ,
        creation_hash: vec<u8>
        ,
        in_scheme: Option<Box<dyn TPMU_SIG_SCHEME>>
        ,
        creation_ticket: tpmt_tk_creation
        ) -> Self {
        Self {
            sign_handle,
            object_handle,
            qualifying_data,
            creation_hash,
            in_scheme,
            creation_ticket,
        }

    }

    /// Get the inSchemeScheme selector value
    pub fn in_scheme_scheme(&self) -> TPM_ALG_ID {
        match &self.in_scheme {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command is used to prove the association between an object and its creation data.
/// The TPM will validate that the ticket was produced by the TPM and that the ticket
/// validates the association between a loaded public area and the provided hash of the
/// creation data (creationHash).
#[derive(Debug, Clone)]
pub struct CertifyCreationResponse {
    /// The structure that was signed
    pub certify_info: tpms_attest,

    /// Selector of the algorithm used to construct the signature

    /// The signature over certifyInfo
    /// One of: TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA,
    /// TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TPMT_HA,
    /// TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE.
    pub signature: Option<Box<dyn TPMU_SIGNATURE>>,
}

impl Default for CertifyCreationResponse {
    fn default() -> Self {
        Self {
        }

    }

}

impl CertifyCreationResponse {
    /// Get the signatureSigAlg selector value
    pub fn signature_sig_alg(&self) -> TPM_ALG_ID {
        match &self.signature {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command is used to quote PCR values.
#[derive(Debug, Clone)]
pub struct TPM2_Quote_REQUEST {
    /// Handle of key that will perform signature
    /// Auth Index: 1
    /// Auth Role: USER
    pub sign_handle: tpm_handle,

    /// Data supplied by the caller
    pub qualifying_data: vec<u8>,

    /// Scheme selector

    /// Signing scheme to use if the scheme for signHandle is TPM_ALG_NULL
    /// One of: TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA,
    /// TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR,
    /// TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME.
    pub in_scheme: Option<Box<dyn TPMU_SIG_SCHEME>>,

    /// PCR set to quote
    pub pcrselect: vec<tpms_pcr_selection>,
}

impl Default for TPM2_Quote_REQUEST {
    fn default() -> Self {
        Self {
            signHandle = TPM_HANDLE();
        }

    }

}

impl TPM2_Quote_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        sign_handle: tpm_handle
        ,
        qualifying_data: vec<u8>
        ,
        in_scheme: Option<Box<dyn TPMU_SIG_SCHEME>>
        ,
        pcrselect: vec<tpms_pcr_selection>
        ) -> Self {
        Self {
            sign_handle,
            qualifying_data,
            in_scheme,
            pcrselect,
        }

    }

    /// Get the inSchemeScheme selector value
    pub fn in_scheme_scheme(&self) -> TPM_ALG_ID {
        match &self.in_scheme {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command is used to quote PCR values.
#[derive(Debug, Clone)]
pub struct QuoteResponse {
    /// The quoted information
    pub quoted: tpms_attest,

    /// Selector of the algorithm used to construct the signature

    /// The signature over quoted
    /// One of: TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA,
    /// TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TPMT_HA,
    /// TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE.
    pub signature: Option<Box<dyn TPMU_SIGNATURE>>,
}

impl Default for QuoteResponse {
    fn default() -> Self {
        Self {
        }

    }

}

impl QuoteResponse {
    /// Get the signatureSigAlg selector value
    pub fn signature_sig_alg(&self) -> TPM_ALG_ID {
        match &self.signature {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command returns a digital signature of the audit session digest.
#[derive(Debug, Clone)]
pub struct TPM2_GetSessionAuditDigest_REQUEST {
    /// Handle of the privacy administrator (TPM_RH_ENDORSEMENT)
    /// Auth Index: 1
    /// Auth Role: USER
    pub privacy_admin_handle: tpm_handle,

    /// Handle of the signing key
    /// Auth Index: 2
    /// Auth Role: USER
    pub sign_handle: tpm_handle,

    /// Handle of the audit session
    /// Auth Index: None
    pub session_handle: tpm_handle,

    /// User-provided qualifying data may be zero-length
    pub qualifying_data: vec<u8>,

    /// Scheme selector

    /// Signing scheme to use if the scheme for signHandle is TPM_ALG_NULL
    /// One of: TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA,
    /// TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR,
    /// TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME.
    pub in_scheme: Option<Box<dyn TPMU_SIG_SCHEME>>,
}

impl Default for TPM2_GetSessionAuditDigest_REQUEST {
    fn default() -> Self {
        Self {
            privacyAdminHandle = TPM_HANDLE();
            signHandle = TPM_HANDLE();
            sessionHandle = TPM_HANDLE();
        }

    }

}

impl TPM2_GetSessionAuditDigest_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        privacy_admin_handle: tpm_handle
        ,
        sign_handle: tpm_handle
        ,
        session_handle: tpm_handle
        ,
        qualifying_data: vec<u8>
        ,
        in_scheme: Option<Box<dyn TPMU_SIG_SCHEME>>
        ) -> Self {
        Self {
            privacy_admin_handle,
            sign_handle,
            session_handle,
            qualifying_data,
            in_scheme,
        }

    }

    /// Get the inSchemeScheme selector value
    pub fn in_scheme_scheme(&self) -> TPM_ALG_ID {
        match &self.in_scheme {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command returns a digital signature of the audit session digest.
#[derive(Debug, Clone)]
pub struct GetSessionAuditDigestResponse {
    /// The audit information that was signed
    pub audit_info: tpms_attest,

    /// Selector of the algorithm used to construct the signature

    /// The signature over auditInfo
    /// One of: TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA,
    /// TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TPMT_HA,
    /// TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE.
    pub signature: Option<Box<dyn TPMU_SIGNATURE>>,
}

impl Default for GetSessionAuditDigestResponse {
    fn default() -> Self {
        Self {
        }

    }

}

impl GetSessionAuditDigestResponse {
    /// Get the signatureSigAlg selector value
    pub fn signature_sig_alg(&self) -> TPM_ALG_ID {
        match &self.signature {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command returns the current value of the command audit digest, a digest of the
/// commands being audited, and the audit hash algorithm. These values are placed in an
/// attestation structure and signed with the key referenced by signHandle.
#[derive(Debug, Clone)]
pub struct TPM2_GetCommandAuditDigest_REQUEST {
    /// Handle of the privacy administrator (TPM_RH_ENDORSEMENT)
    /// Auth Index: 1
    /// Auth Role: USER
    pub privacy_handle: tpm_handle,

    /// The handle of the signing key
    /// Auth Index: 2
    /// Auth Role: USER
    pub sign_handle: tpm_handle,

    /// Other data to associate with this audit digest
    pub qualifying_data: vec<u8>,

    /// Scheme selector

    /// Signing scheme to use if the scheme for signHandle is TPM_ALG_NULL
    /// One of: TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA,
    /// TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR,
    /// TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME.
    pub in_scheme: Option<Box<dyn TPMU_SIG_SCHEME>>,
}

impl Default for TPM2_GetCommandAuditDigest_REQUEST {
    fn default() -> Self {
        Self {
            privacyHandle = TPM_HANDLE();
            signHandle = TPM_HANDLE();
        }

    }

}

impl TPM2_GetCommandAuditDigest_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        privacy_handle: tpm_handle
        ,
        sign_handle: tpm_handle
        ,
        qualifying_data: vec<u8>
        ,
        in_scheme: Option<Box<dyn TPMU_SIG_SCHEME>>
        ) -> Self {
        Self {
            privacy_handle,
            sign_handle,
            qualifying_data,
            in_scheme,
        }

    }

    /// Get the inSchemeScheme selector value
    pub fn in_scheme_scheme(&self) -> TPM_ALG_ID {
        match &self.in_scheme {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command returns the current value of the command audit digest, a digest of the
/// commands being audited, and the audit hash algorithm. These values are placed in an
/// attestation structure and signed with the key referenced by signHandle.
#[derive(Debug, Clone)]
pub struct GetCommandAuditDigestResponse {
    /// The auditInfo that was signed
    pub audit_info: tpms_attest,

    /// Selector of the algorithm used to construct the signature

    /// The signature over auditInfo
    /// One of: TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA,
    /// TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TPMT_HA,
    /// TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE.
    pub signature: Option<Box<dyn TPMU_SIGNATURE>>,
}

impl Default for GetCommandAuditDigestResponse {
    fn default() -> Self {
        Self {
        }

    }

}

impl GetCommandAuditDigestResponse {
    /// Get the signatureSigAlg selector value
    pub fn signature_sig_alg(&self) -> TPM_ALG_ID {
        match &self.signature {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command returns the current values of Time and Clock.
#[derive(Debug, Clone)]
pub struct TPM2_GetTime_REQUEST {
    /// Handle of the privacy administrator (TPM_RH_ENDORSEMENT)
    /// Auth Index: 1
    /// Auth Role: USER
    pub privacy_admin_handle: tpm_handle,

    /// The keyHandle identifier of a loaded key that can perform digital signatures
    /// Auth Index: 2
    /// Auth Role: USER
    pub sign_handle: tpm_handle,

    /// Data to tick stamp
    pub qualifying_data: vec<u8>,

    /// Scheme selector

    /// Signing scheme to use if the scheme for signHandle is TPM_ALG_NULL
    /// One of: TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA,
    /// TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR,
    /// TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME.
    pub in_scheme: Option<Box<dyn TPMU_SIG_SCHEME>>,
}

impl Default for TPM2_GetTime_REQUEST {
    fn default() -> Self {
        Self {
            privacyAdminHandle = TPM_HANDLE();
            signHandle = TPM_HANDLE();
        }

    }

}

impl TPM2_GetTime_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        privacy_admin_handle: tpm_handle
        ,
        sign_handle: tpm_handle
        ,
        qualifying_data: vec<u8>
        ,
        in_scheme: Option<Box<dyn TPMU_SIG_SCHEME>>
        ) -> Self {
        Self {
            privacy_admin_handle,
            sign_handle,
            qualifying_data,
            in_scheme,
        }

    }

    /// Get the inSchemeScheme selector value
    pub fn in_scheme_scheme(&self) -> TPM_ALG_ID {
        match &self.in_scheme {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command returns the current values of Time and Clock.
#[derive(Debug, Clone)]
pub struct GetTimeResponse {
    /// Standard TPM-generated attestation block
    pub time_info: tpms_attest,

    /// Selector of the algorithm used to construct the signature

    /// The signature over timeInfo
    /// One of: TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA,
    /// TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TPMT_HA,
    /// TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE.
    pub signature: Option<Box<dyn TPMU_SIGNATURE>>,
}

impl Default for GetTimeResponse {
    fn default() -> Self {
        Self {
        }

    }

}

impl GetTimeResponse {
    /// Get the signatureSigAlg selector value
    pub fn signature_sig_alg(&self) -> TPM_ALG_ID {
        match &self.signature {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// The purpose of this command is to generate an X.509 certificate that proves an object
/// with a specific public key and attributes is loaded in the TPM. In contrast to
/// TPM2_Certify, which uses a TCG-defined data structure to convey attestation
/// information, TPM2_CertifyX509 encodes the attestation information in a DER-encoded
/// X.509 certificate that is compliant with RFC5280 Internet X.509 Public Key
/// Infrastructure Certificate and Certificate Revocation List (CRL) Profile.
#[derive(Debug, Clone)]
pub struct TPM2_CertifyX509_REQUEST {
    /// Handle of the object to be certified
    /// Auth Index: 1
    /// Auth Role: ADMIN
    pub object_handle: tpm_handle,

    /// Handle of the key used to sign the attestation structure
    /// Auth Index: 2
    /// Auth Role: USER
    pub sign_handle: tpm_handle,

    /// Shall be an Empty Buffer
    pub reserved: vec<u8>,

    /// Scheme selector

    /// Signing scheme to use if the scheme for signHandle is TPM_ALG_NULL
    /// One of: TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA,
    /// TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR,
    /// TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME.
    pub in_scheme: Option<Box<dyn TPMU_SIG_SCHEME>>,

    /// A DER encoded partial certificate
    pub partial_certificate: vec<u8>,
}

impl Default for TPM2_CertifyX509_REQUEST {
    fn default() -> Self {
        Self {
            objectHandle = TPM_HANDLE();
            signHandle = TPM_HANDLE();
        }

    }

}

impl TPM2_CertifyX509_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        object_handle: tpm_handle
        ,
        sign_handle: tpm_handle
        ,
        reserved: vec<u8>
        ,
        in_scheme: Option<Box<dyn TPMU_SIG_SCHEME>>
        ,
        partial_certificate: vec<u8>
        ) -> Self {
        Self {
            object_handle,
            sign_handle,
            reserved,
            in_scheme,
            partial_certificate,
        }

    }

    /// Get the inSchemeScheme selector value
    pub fn in_scheme_scheme(&self) -> TPM_ALG_ID {
        match &self.in_scheme {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// The purpose of this command is to generate an X.509 certificate that proves an object
/// with a specific public key and attributes is loaded in the TPM. In contrast to
/// TPM2_Certify, which uses a TCG-defined data structure to convey attestation
/// information, TPM2_CertifyX509 encodes the attestation information in a DER-encoded
/// X.509 certificate that is compliant with RFC5280 Internet X.509 Public Key
/// Infrastructure Certificate and Certificate Revocation List (CRL) Profile.
#[derive(Debug, Clone)]
pub struct CertifyX509Response {
    /// A DER encoded SEQUENCE containing the DER encoded fields added to partialCertificate
    /// to make it a complete RFC5280 TBSCertificate.
    pub added_to_certificate: vec<u8>,

    /// The digest that was signed
    pub tbs_digest: vec<u8>,

    /// Selector of the algorithm used to construct the signature

    /// The signature over tbsDigest
    /// One of: TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA,
    /// TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TPMT_HA,
    /// TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE.
    pub signature: Option<Box<dyn TPMU_SIGNATURE>>,
}

impl Default for CertifyX509Response {
    fn default() -> Self {
        Self {
        }

    }

}

impl CertifyX509Response {
    /// Get the signatureSigAlg selector value
    pub fn signature_sig_alg(&self) -> TPM_ALG_ID {
        match &self.signature {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// TPM2_Commit() performs the first part of an ECC anonymous signing operation. The TPM
/// will perform the point multiplications on the provided points and return intermediate
/// signing values. The signHandle parameter shall refer to an ECC key and the signing
/// scheme must be anonymous (TPM_RC_SCHEME).
#[derive(Debug, Clone)]
pub struct TPM2_Commit_REQUEST {
    /// Handle of the key that will be used in the signing operation
    /// Auth Index: 1
    /// Auth Role: USER
    pub sign_handle: tpm_handle,

    /// A point (M) on the curve used by signHandle
    pub p1: tpms_ecc_point,

    /// Octet array used to derive x-coordinate of a base point
    pub s2: vec<u8>,

    /// Y coordinate of the point associated with s2
    pub y2: vec<u8>,
}

impl Default for TPM2_Commit_REQUEST {
    fn default() -> Self {
        Self {
            signHandle = TPM_HANDLE();
        }

    }

}

impl TPM2_Commit_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        sign_handle: tpm_handle
        ,
        p1: tpms_ecc_point
        ,
        s2: vec<u8>
        ,
        y2: vec<u8>
        ) -> Self {
        Self {
            sign_handle,
            p1,
            s2,
            y2,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// TPM2_Commit() performs the first part of an ECC anonymous signing operation. The TPM
/// will perform the point multiplications on the provided points and return intermediate
/// signing values. The signHandle parameter shall refer to an ECC key and the signing
/// scheme must be anonymous (TPM_RC_SCHEME).
#[derive(Debug, Clone)]
pub struct CommitResponse {
    /// ECC point K [ds](x2, y2)
    pub k: tpms_ecc_point,

    /// ECC point L [r](x2, y2)
    pub l: tpms_ecc_point,

    /// ECC point E [r]P1
    pub e: tpms_ecc_point,

    /// Least-significant 16 bits of commitCount
    pub counter: u16,
}

impl Default for CommitResponse {
    fn default() -> Self {
        Self {
        }

    }

}

impl CommitResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// TPM2_EC_Ephemeral() creates an ephemeral key for use in a two-phase key exchange protocol.
#[derive(Debug, Clone)]
pub struct TPM2_EC_Ephemeral_REQUEST {
    /// The curve for the computed ephemeral point
    pub curve_id: tpm_ecc_curve,
}

impl Default for TPM2_EC_Ephemeral_REQUEST {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPM2_EC_Ephemeral_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        curve_id: tpm_ecc_curve
        ) -> Self {
        Self {
            curve_id,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// TPM2_EC_Ephemeral() creates an ephemeral key for use in a two-phase key exchange protocol.
#[derive(Debug, Clone)]
pub struct EC_EphemeralResponse {
    /// Ephemeral public key Q [r]G
    pub q: tpms_ecc_point,

    /// Least-significant 16 bits of commitCount
    pub counter: u16,
}

impl Default for EC_EphemeralResponse {
    fn default() -> Self {
        Self {
        }

    }

}

impl EC_EphemeralResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command uses loaded keys to validate a signature on a message with the message
/// digest passed to the TPM.
#[derive(Debug, Clone)]
pub struct TPM2_VerifySignature_REQUEST {
    /// Handle of public key that will be used in the validation
    /// Auth Index: None
    pub key_handle: tpm_handle,

    /// Digest of the signed message
    pub digest: vec<u8>,

    /// Selector of the algorithm used to construct the signature

    /// Signature to be tested
    /// One of: TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA,
    /// TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TPMT_HA,
    /// TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE.
    pub signature: Option<Box<dyn TPMU_SIGNATURE>>,
}

impl Default for TPM2_VerifySignature_REQUEST {
    fn default() -> Self {
        Self {
            keyHandle = TPM_HANDLE();
        }

    }

}

impl TPM2_VerifySignature_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        key_handle: tpm_handle
        ,
        digest: vec<u8>
        ,
        signature: Option<Box<dyn TPMU_SIGNATURE>>
        ) -> Self {
        Self {
            key_handle,
            digest,
            signature,
        }

    }

    /// Get the signatureSigAlg selector value
    pub fn signature_sig_alg(&self) -> TPM_ALG_ID {
        match &self.signature {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command uses loaded keys to validate a signature on a message with the message
/// digest passed to the TPM.
#[derive(Debug, Clone)]
pub struct VerifySignatureResponse {
    pub validation: tpmt_tk_verified,
}

impl Default for VerifySignatureResponse {
    fn default() -> Self {
        Self {
        }

    }

}

impl VerifySignatureResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command causes the TPM to sign an externally provided hash with the specified
/// symmetric or asymmetric signing key.
#[derive(Debug, Clone)]
pub struct TPM2_Sign_REQUEST {
    /// Handle of key that will perform signing
    /// Auth Index: 1
    /// Auth Role: USER
    pub key_handle: tpm_handle,

    /// Digest to be signed
    pub digest: vec<u8>,

    /// Scheme selector

    /// Signing scheme to use if the scheme for keyHandle is TPM_ALG_NULL
    /// One of: TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA,
    /// TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR,
    /// TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME.
    pub in_scheme: Option<Box<dyn TPMU_SIG_SCHEME>>,

    /// Proof that digest was created by the TPM
    /// If keyHandle is not a restricted signing key, then this may be a NULL Ticket with tag
    /// = TPM_ST_CHECKHASH.
    pub validation: tpmt_tk_hashcheck,
}

impl Default for TPM2_Sign_REQUEST {
    fn default() -> Self {
        Self {
            keyHandle = TPM_HANDLE();
        }

    }

}

impl TPM2_Sign_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        key_handle: tpm_handle
        ,
        digest: vec<u8>
        ,
        in_scheme: Option<Box<dyn TPMU_SIG_SCHEME>>
        ,
        validation: tpmt_tk_hashcheck
        ) -> Self {
        Self {
            key_handle,
            digest,
            in_scheme,
            validation,
        }

    }

    /// Get the inSchemeScheme selector value
    pub fn in_scheme_scheme(&self) -> TPM_ALG_ID {
        match &self.in_scheme {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command causes the TPM to sign an externally provided hash with the specified
/// symmetric or asymmetric signing key.
#[derive(Debug, Clone)]
pub struct SignResponse {
    /// Selector of the algorithm used to construct the signature

    /// The signature
    /// One of: TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA,
    /// TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TPMT_HA,
    /// TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE.
    pub signature: Option<Box<dyn TPMU_SIGNATURE>>,
}

impl Default for SignResponse {
    fn default() -> Self {
        Self {
        }

    }

}

impl SignResponse {
    /// Get the signatureSigAlg selector value
    pub fn signature_sig_alg(&self) -> TPM_ALG_ID {
        match &self.signature {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command may be used by the Privacy Administrator or platform to change the audit
/// status of a command or to set the hash algorithm used for the audit digest, but not
/// both at the same time.
#[derive(Debug, Clone)]
pub struct TPM2_SetCommandCodeAuditStatus_REQUEST {
    /// TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
    /// Auth Index: 1
    /// Auth Role: USER
    pub auth: tpm_handle,

    /// Hash algorithm for the audit digest; if TPM_ALG_NULL, then the hash is not changed
    pub audit_alg: tpm_alg_id,

    /// List of commands that will be added to those that will be audited
    pub set_list: vec<tpm_cc>,

    /// List of commands that will no longer be audited
    pub clear_list: vec<tpm_cc>,
}

impl Default for TPM2_SetCommandCodeAuditStatus_REQUEST {
    fn default() -> Self {
        Self {
            auth = TPM_HANDLE();
            auditAlg = TPM_ALG_ID:NULL;
        }

    }

}

impl TPM2_SetCommandCodeAuditStatus_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        auth: tpm_handle
        ,
        audit_alg: tpm_alg_id
        ,
        set_list: vec<tpm_cc>
        ,
        clear_list: vec<tpm_cc>
        ) -> Self {
        Self {
            auth,
            audit_alg,
            set_list,
            clear_list,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command is used to cause an update to the indicated PCR. The digests parameter
/// contains one or more tagged digest values identified by an algorithm ID. For each
/// digest, the PCR associated with pcrHandle is Extended into the bank identified by the
/// tag (hashAlg).
#[derive(Debug, Clone)]
pub struct TPM2_PCR_Extend_REQUEST {
    /// Handle of the PCR
    /// Auth Handle: 1
    /// Auth Role: USER
    pub pcr_handle: tpm_handle,

    /// List of tagged digest values to be extended
    pub digests: vec<tpmt_ha>,
}

impl Default for TPM2_PCR_Extend_REQUEST {
    fn default() -> Self {
        Self {
            pcrHandle = TPM_HANDLE();
        }

    }

}

impl TPM2_PCR_Extend_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        pcr_handle: tpm_handle
        ,
        digests: vec<tpmt_ha>
        ) -> Self {
        Self {
            pcr_handle,
            digests,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command is used to cause an update to the indicated PCR.
#[derive(Debug, Clone)]
pub struct TPM2_PCR_Event_REQUEST {
    /// Handle of the PCR
    /// Auth Handle: 1
    /// Auth Role: USER
    pub pcr_handle: tpm_handle,

    /// Event data in sized buffer
    pub event_data: vec<u8>,
}

impl Default for TPM2_PCR_Event_REQUEST {
    fn default() -> Self {
        Self {
            pcrHandle = TPM_HANDLE();
        }

    }

}

impl TPM2_PCR_Event_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        pcr_handle: tpm_handle
        ,
        event_data: vec<u8>
        ) -> Self {
        Self {
            pcr_handle,
            event_data,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command is used to cause an update to the indicated PCR.
#[derive(Debug, Clone)]
pub struct PCR_EventResponse {
    pub digests: vec<tpmt_ha>,
}

impl Default for PCR_EventResponse {
    fn default() -> Self {
        Self {
        }

    }

}

impl PCR_EventResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command returns the values of all PCR specified in pcrSelectionIn.
#[derive(Debug, Clone)]
pub struct TPM2_PCR_Read_REQUEST {
    /// The selection of PCR to read
    pub pcr_selection_in: vec<tpms_pcr_selection>,
}

impl Default for TPM2_PCR_Read_REQUEST {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPM2_PCR_Read_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        pcr_selection_in: vec<tpms_pcr_selection>
        ) -> Self {
        Self {
            pcr_selection_in,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command returns the values of all PCR specified in pcrSelectionIn.
#[derive(Debug, Clone)]
pub struct PCR_ReadResponse {
    /// The current value of the PCR update counter
    pub pcr_update_counter: u32,

    /// The PCR in the returned list
    pub pcr_selection_out: vec<tpms_pcr_selection>,

    /// The contents of the PCR indicated in pcrSelectOut- pcrSelection[] as tagged digests
    pub pcr_values: vec<tpm2_b_digest>,
}

impl Default for PCR_ReadResponse {
    fn default() -> Self {
        Self {
        }

    }

}

impl PCR_ReadResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command is used to set the desired PCR allocation of PCR and algorithms. This
/// command requires Platform Authorization.
#[derive(Debug, Clone)]
pub struct TPM2_PCR_Allocate_REQUEST {
    /// TPM_RH_PLATFORM+{PP}
    /// Auth Index: 1
    /// Auth Role: USER
    pub auth_handle: tpm_handle,

    /// The requested allocation
    pub pcr_allocation: vec<tpms_pcr_selection>,
}

impl Default for TPM2_PCR_Allocate_REQUEST {
    fn default() -> Self {
        Self {
            authHandle = TPM_HANDLE();
        }

    }

}

impl TPM2_PCR_Allocate_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        auth_handle: tpm_handle
        ,
        pcr_allocation: vec<tpms_pcr_selection>
        ) -> Self {
        Self {
            auth_handle,
            pcr_allocation,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command is used to set the desired PCR allocation of PCR and algorithms. This
/// command requires Platform Authorization.
#[derive(Debug, Clone)]
pub struct PCR_AllocateResponse {
    /// YES if the allocation succeeded
    pub allocation_success: u8,

    /// Maximum number of PCR that may be in a bank
    pub max_pcr: u32,

    /// Number of octets required to satisfy the request
    pub size_needed: u32,

    /// Number of octets available. Computed before the allocation.
    pub size_available: u32,
}

impl Default for PCR_AllocateResponse {
    fn default() -> Self {
        Self {
        }

    }

}

impl PCR_AllocateResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command is used to associate a policy with a PCR or group of PCR. The policy
/// determines the conditions under which a PCR may be extended or reset.
#[derive(Debug, Clone)]
pub struct TPM2_PCR_SetAuthPolicy_REQUEST {
    /// TPM_RH_PLATFORM+{PP}
    /// Auth Index: 1
    /// Auth Role: USER
    pub auth_handle: tpm_handle,

    /// The desired authPolicy
    pub auth_policy: vec<u8>,

    /// The hash algorithm of the policy
    pub hash_alg: tpm_alg_id,

    /// The PCR for which the policy is to be set
    pub pcr_num: tpm_handle,
}

impl Default for TPM2_PCR_SetAuthPolicy_REQUEST {
    fn default() -> Self {
        Self {
            authHandle = TPM_HANDLE();
            hashAlg = TPM_ALG_ID:NULL;
            pcrNum = TPM_HANDLE();
        }

    }

}

impl TPM2_PCR_SetAuthPolicy_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        auth_handle: tpm_handle
        ,
        auth_policy: vec<u8>
        ,
        hash_alg: tpm_alg_id
        ,
        pcr_num: tpm_handle
        ) -> Self {
        Self {
            auth_handle,
            auth_policy,
            hash_alg,
            pcr_num,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command changes the authValue of a PCR or group of PCR.
#[derive(Debug, Clone)]
pub struct TPM2_PCR_SetAuthValue_REQUEST {
    /// Handle for a PCR that may have an authorization value set
    /// Auth Index: 1
    /// Auth Role: USER
    pub pcr_handle: tpm_handle,

    /// The desired authorization value
    pub auth: vec<u8>,
}

impl Default for TPM2_PCR_SetAuthValue_REQUEST {
    fn default() -> Self {
        Self {
            pcrHandle = TPM_HANDLE();
        }

    }

}

impl TPM2_PCR_SetAuthValue_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        pcr_handle: tpm_handle
        ,
        auth: vec<u8>
        ) -> Self {
        Self {
            pcr_handle,
            auth,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// If the attribute of a PCR allows the PCR to be reset and proper authorization is
/// provided, then this command may be used to set the PCR in all banks to zero. The
/// attributes of the PCR may restrict the locality that can perform the reset operation.
#[derive(Debug, Clone)]
pub struct TPM2_PCR_Reset_REQUEST {
    /// The PCR to reset
    /// Auth Index: 1
    /// Auth Role: USER
    pub pcr_handle: tpm_handle,
}

impl Default for TPM2_PCR_Reset_REQUEST {
    fn default() -> Self {
        Self {
            pcrHandle = TPM_HANDLE();
        }

    }

}

impl TPM2_PCR_Reset_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        pcr_handle: tpm_handle
        ) -> Self {
        Self {
            pcr_handle,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command includes a signed authorization in a policy. The command ties the policy
/// to a signing key by including the Name of the signing key in the policyDigest
#[derive(Debug, Clone)]
pub struct TPM2_PolicySigned_REQUEST {
    /// Handle for a key that will validate the signature
    /// Auth Index: None
    pub auth_object: tpm_handle,

    /// Handle for the policy session being extended
    /// Auth Index: None
    pub policy_session: tpm_handle,

    /// The policy nonce for the session
    /// This can be the Empty Buffer.
    pub nonce_tpm: vec<u8>,

    /// Digest of the command parameters to which this authorization is limited
    /// This is not the cpHash for this command but the cpHash for the command to which this
    /// policy session will be applied. If it is not limited, the parameter will be the Empty Buffer.
    pub cp_hash_a: vec<u8>,

    /// A reference to a policy relating to the authorization may be the Empty Buffer
    /// Size is limited to be no larger than the nonce size supported on the TPM.
    pub policy_ref: vec<u8>,

    /// Time when authorization will expire, measured in seconds from the time that nonceTPM
    /// was generated
    /// If expiration is non-negative, a NULL Ticket is returned. See 23.2.5.
    pub expiration: i32,

    /// Selector of the algorithm used to construct the signature

    /// Signed authorization (not optional)
    /// One of: TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA,
    /// TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TPMT_HA,
    /// TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE.
    pub auth: Option<Box<dyn TPMU_SIGNATURE>>,
}

impl Default for TPM2_PolicySigned_REQUEST {
    fn default() -> Self {
        Self {
            authObject = TPM_HANDLE();
            policySession = TPM_HANDLE();
        }

    }

}

impl TPM2_PolicySigned_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        auth_object: tpm_handle
        ,
        policy_session: tpm_handle
        ,
        nonce_tpm: vec<u8>
        ,
        cp_hash_a: vec<u8>
        ,
        policy_ref: vec<u8>
        ,
        expiration: i32
        ,
        auth: Option<Box<dyn TPMU_SIGNATURE>>
        ) -> Self {
        Self {
            auth_object,
            policy_session,
            nonce_tpm,
            cp_hash_a,
            policy_ref,
            expiration,
            auth,
        }

    }

    /// Get the authSigAlg selector value
    pub fn auth_sig_alg(&self) -> TPM_ALG_ID {
        match &self.auth {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command includes a signed authorization in a policy. The command ties the policy
/// to a signing key by including the Name of the signing key in the policyDigest
#[derive(Debug, Clone)]
pub struct PolicySignedResponse {
    /// Implementation-specific time value, used to indicate to the TPM when the ticket expires
    /// NOTE If policyTicket is a NULL Ticket, then this shall be the Empty Buffer.
    pub timeout: vec<u8>,

    /// Produced if the command succeeds and expiration in the command was non-zero; this
    /// ticket will use the TPMT_ST_AUTH_SIGNED structure tag. See 23.2.5
    pub policy_ticket: tpmt_tk_auth,
}

impl Default for PolicySignedResponse {
    fn default() -> Self {
        Self {
        }

    }

}

impl PolicySignedResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command includes a secret-based authorization to a policy. The caller proves
/// knowledge of the secret value using an authorization session using the authValue
/// associated with authHandle. A password session, an HMAC session, or a policy session
/// containing TPM2_PolicyAuthValue() or TPM2_PolicyPassword() will satisfy this requirement.
#[derive(Debug, Clone)]
pub struct TPM2_PolicySecret_REQUEST {
    /// Handle for an entity providing the authorization
    /// Auth Index: 1
    /// Auth Role: USER
    pub auth_handle: tpm_handle,

    /// Handle for the policy session being extended
    /// Auth Index: None
    pub policy_session: tpm_handle,

    /// The policy nonce for the session
    /// This can be the Empty Buffer.
    pub nonce_tpm: vec<u8>,

    /// Digest of the command parameters to which this authorization is limited
    /// This not the cpHash for this command but the cpHash for the command to which this
    /// policy session will be applied. If it is not limited, the parameter will be the Empty Buffer.
    pub cp_hash_a: vec<u8>,

    /// A reference to a policy relating to the authorization may be the Empty Buffer
    /// Size is limited to be no larger than the nonce size supported on the TPM.
    pub policy_ref: vec<u8>,

    /// Time when authorization will expire, measured in seconds from the time that nonceTPM
    /// was generated
    /// If expiration is non-negative, a NULL Ticket is returned. See 23.2.5.
    pub expiration: i32,
}

impl Default for TPM2_PolicySecret_REQUEST {
    fn default() -> Self {
        Self {
            authHandle = TPM_HANDLE();
            policySession = TPM_HANDLE();
        }

    }

}

impl TPM2_PolicySecret_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        auth_handle: tpm_handle
        ,
        policy_session: tpm_handle
        ,
        nonce_tpm: vec<u8>
        ,
        cp_hash_a: vec<u8>
        ,
        policy_ref: vec<u8>
        ,
        expiration: i32
        ) -> Self {
        Self {
            auth_handle,
            policy_session,
            nonce_tpm,
            cp_hash_a,
            policy_ref,
            expiration,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command includes a secret-based authorization to a policy. The caller proves
/// knowledge of the secret value using an authorization session using the authValue
/// associated with authHandle. A password session, an HMAC session, or a policy session
/// containing TPM2_PolicyAuthValue() or TPM2_PolicyPassword() will satisfy this requirement.
#[derive(Debug, Clone)]
pub struct PolicySecretResponse {
    /// Implementation-specific time value used to indicate to the TPM when the ticket expires
    pub timeout: vec<u8>,

    /// Produced if the command succeeds and expiration in the command was non-zero ( See
    /// 23.2.5). This ticket will use the TPMT_ST_AUTH_SECRET structure tag
    pub policy_ticket: tpmt_tk_auth,
}

impl Default for PolicySecretResponse {
    fn default() -> Self {
        Self {
        }

    }

}

impl PolicySecretResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command is similar to TPM2_PolicySigned() except that it takes a ticket instead
/// of a signed authorization. The ticket represents a validated authorization that had an
/// expiration time associated with it.
#[derive(Debug, Clone)]
pub struct TPM2_PolicyTicket_REQUEST {
    /// Handle for the policy session being extended
    /// Auth Index: None
    pub policy_session: tpm_handle,

    /// Time when authorization will expire
    /// The contents are TPM specific. This shall be the value returned when ticket was produced.
    pub timeout: vec<u8>,

    /// Digest of the command parameters to which this authorization is limited
    /// If it is not limited, the parameter will be the Empty Buffer.
    pub cp_hash_a: vec<u8>,

    /// Reference to a qualifier for the policy may be the Empty Buffer
    pub policy_ref: vec<u8>,

    /// Name of the object that provided the authorization
    pub auth_name: vec<u8>,

    /// An authorization ticket returned by the TPM in response to a TPM2_PolicySigned() or
    /// TPM2_PolicySecret()
    pub ticket: tpmt_tk_auth,
}

impl Default for TPM2_PolicyTicket_REQUEST {
    fn default() -> Self {
        Self {
            policySession = TPM_HANDLE();
        }

    }

}

impl TPM2_PolicyTicket_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        policy_session: tpm_handle
        ,
        timeout: vec<u8>
        ,
        cp_hash_a: vec<u8>
        ,
        policy_ref: vec<u8>
        ,
        auth_name: vec<u8>
        ,
        ticket: tpmt_tk_auth
        ) -> Self {
        Self {
            policy_session,
            timeout,
            cp_hash_a,
            policy_ref,
            auth_name,
            ticket,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command allows options in authorizations without requiring that the TPM evaluate
/// all of the options. If a policy may be satisfied by different sets of conditions, the
/// TPM need only evaluate one set that satisfies the policy. This command will indicate
/// that one of the required sets of conditions has been satisfied.
#[derive(Debug, Clone)]
pub struct TPM2_PolicyOR_REQUEST {
    /// Handle for the policy session being extended
    /// Auth Index: None
    pub policy_session: tpm_handle,

    /// The list of hashes to check for a match
    pub phashlist: vec<tpm2_b_digest>,
}

impl Default for TPM2_PolicyOR_REQUEST {
    fn default() -> Self {
        Self {
            policySession = TPM_HANDLE();
        }

    }

}

impl TPM2_PolicyOR_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        policy_session: tpm_handle
        ,
        phashlist: vec<tpm2_b_digest>
        ) -> Self {
        Self {
            policy_session,
            phashlist,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command is used to cause conditional gating of a policy based on PCR. This
/// command together with TPM2_PolicyOR() allows one group of authorizations to occur when
/// PCR are in one state and a different set of authorizations when the PCR are in a
/// different state.
#[derive(Debug, Clone)]
pub struct TPM2_PolicyPCR_REQUEST {
    /// Handle for the policy session being extended
    /// Auth Index: None
    pub policy_session: tpm_handle,

    /// Expected digest value of the selected PCR using the hash algorithm of the session; may
    /// be zero length
    pub pcr_digest: vec<u8>,

    /// The PCR to include in the check digest
    pub pcrs: vec<tpms_pcr_selection>,
}

impl Default for TPM2_PolicyPCR_REQUEST {
    fn default() -> Self {
        Self {
            policySession = TPM_HANDLE();
        }

    }

}

impl TPM2_PolicyPCR_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        policy_session: tpm_handle
        ,
        pcr_digest: vec<u8>
        ,
        pcrs: vec<tpms_pcr_selection>
        ) -> Self {
        Self {
            policy_session,
            pcr_digest,
            pcrs,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command indicates that the authorization will be limited to a specific locality.
#[derive(Debug, Clone)]
pub struct TPM2_PolicyLocality_REQUEST {
    /// Handle for the policy session being extended
    /// Auth Index: None
    pub policy_session: tpm_handle,

    /// The allowed localities for the policy
    pub locality: tpma_locality,
}

impl Default for TPM2_PolicyLocality_REQUEST {
    fn default() -> Self {
        Self {
            policySession = TPM_HANDLE();
        }

    }

}

impl TPM2_PolicyLocality_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        policy_session: tpm_handle
        ,
        locality: tpma_locality
        ) -> Self {
        Self {
            policy_session,
            locality,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command is used to cause conditional gating of a policy based on the contents of
/// an NV Index. It is an immediate assertion. The NV index is validated during the
/// TPM2_PolicyNV() command, not when the session is used for authorization.
#[derive(Debug, Clone)]
pub struct TPM2_PolicyNV_REQUEST {
    /// Handle indicating the source of the authorization value
    /// Auth Index: 1
    /// Auth Role: USER
    pub auth_handle: tpm_handle,

    /// The NV Index of the area to read
    /// Auth Index: None
    pub nv_index: tpm_handle,

    /// Handle for the policy session being extended
    /// Auth Index: None
    pub policy_session: tpm_handle,

    /// The second operand
    pub operand_b: vec<u8>,

    /// The octet offset in the NV Index for the start of operand A
    pub offset: u16,

    /// The comparison to make
    pub operation: tpm_eo,
}

impl Default for TPM2_PolicyNV_REQUEST {
    fn default() -> Self {
        Self {
            authHandle = TPM_HANDLE();
            nvIndex = TPM_HANDLE();
            policySession = TPM_HANDLE();
        }

    }

}

impl TPM2_PolicyNV_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        auth_handle: tpm_handle
        ,
        nv_index: tpm_handle
        ,
        policy_session: tpm_handle
        ,
        operand_b: vec<u8>
        ,
        offset: u16
        ,
        operation: tpm_eo
        ) -> Self {
        Self {
            auth_handle,
            nv_index,
            policy_session,
            operand_b,
            offset,
            operation,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command is used to cause conditional gating of a policy based on the contents of
/// the TPMS_TIME_INFO structure.
#[derive(Debug, Clone)]
pub struct TPM2_PolicyCounterTimer_REQUEST {
    /// Handle for the policy session being extended
    /// Auth Index: None
    pub policy_session: tpm_handle,

    /// The second operand
    pub operand_b: vec<u8>,

    /// The octet offset in the TPMS_TIME_INFO structure for the start of operand A
    pub offset: u16,

    /// The comparison to make
    pub operation: tpm_eo,
}

impl Default for TPM2_PolicyCounterTimer_REQUEST {
    fn default() -> Self {
        Self {
            policySession = TPM_HANDLE();
        }

    }

}

impl TPM2_PolicyCounterTimer_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        policy_session: tpm_handle
        ,
        operand_b: vec<u8>
        ,
        offset: u16
        ,
        operation: tpm_eo
        ) -> Self {
        Self {
            policy_session,
            operand_b,
            offset,
            operation,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command indicates that the authorization will be limited to a specific command code.
#[derive(Debug, Clone)]
pub struct TPM2_PolicyCommandCode_REQUEST {
    /// Handle for the policy session being extended
    /// Auth Index: None
    pub policy_session: tpm_handle,

    /// The allowed commandCode
    pub code: tpm_cc,
}

impl Default for TPM2_PolicyCommandCode_REQUEST {
    fn default() -> Self {
        Self {
            policySession = TPM_HANDLE();
        }

    }

}

impl TPM2_PolicyCommandCode_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        policy_session: tpm_handle
        ,
        code: tpm_cc
        ) -> Self {
        Self {
            policy_session,
            code,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command indicates that physical presence will need to be asserted at the time the
/// authorization is performed.
#[derive(Debug, Clone)]
pub struct TPM2_PolicyPhysicalPresence_REQUEST {
    /// Handle for the policy session being extended
    /// Auth Index: None
    pub policy_session: tpm_handle,
}

impl Default for TPM2_PolicyPhysicalPresence_REQUEST {
    fn default() -> Self {
        Self {
            policySession = TPM_HANDLE();
        }

    }

}

impl TPM2_PolicyPhysicalPresence_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        policy_session: tpm_handle
        ) -> Self {
        Self {
            policy_session,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command is used to allow a policy to be bound to a specific command and command parameters.
#[derive(Debug, Clone)]
pub struct TPM2_PolicyCpHash_REQUEST {
    /// Handle for the policy session being extended
    /// Auth Index: None
    pub policy_session: tpm_handle,

    /// The cpHash added to the policy
    pub cp_hash_a: vec<u8>,
}

impl Default for TPM2_PolicyCpHash_REQUEST {
    fn default() -> Self {
        Self {
            policySession = TPM_HANDLE();
        }

    }

}

impl TPM2_PolicyCpHash_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        policy_session: tpm_handle
        ,
        cp_hash_a: vec<u8>
        ) -> Self {
        Self {
            policy_session,
            cp_hash_a,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command allows a policy to be bound to a specific set of TPM entities without
/// being bound to the parameters of the command. This is most useful for commands such as
/// TPM2_Duplicate() and for TPM2_PCR_Event() when the referenced PCR requires a policy.
#[derive(Debug, Clone)]
pub struct TPM2_PolicyNameHash_REQUEST {
    /// Handle for the policy session being extended
    /// Auth Index: None
    pub policy_session: tpm_handle,

    /// The digest to be added to the policy
    pub name_hash: vec<u8>,
}

impl Default for TPM2_PolicyNameHash_REQUEST {
    fn default() -> Self {
        Self {
            policySession = TPM_HANDLE();
        }

    }

}

impl TPM2_PolicyNameHash_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        policy_session: tpm_handle
        ,
        name_hash: vec<u8>
        ) -> Self {
        Self {
            policy_session,
            name_hash,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command allows qualification of duplication to allow duplication to a selected
/// new parent.
#[derive(Debug, Clone)]
pub struct TPM2_PolicyDuplicationSelect_REQUEST {
    /// Handle for the policy session being extended
    /// Auth Index: None
    pub policy_session: tpm_handle,

    /// The Name of the object to be duplicated
    pub object_name: vec<u8>,

    /// The Name of the new parent
    pub new_parent_name: vec<u8>,

    /// If YES, the objectName will be included in the value in policySessionpolicyDigest
    pub include_object: u8,
}

impl Default for TPM2_PolicyDuplicationSelect_REQUEST {
    fn default() -> Self {
        Self {
            policySession = TPM_HANDLE();
        }

    }

}

impl TPM2_PolicyDuplicationSelect_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        policy_session: tpm_handle
        ,
        object_name: vec<u8>
        ,
        new_parent_name: vec<u8>
        ,
        include_object: u8
        ) -> Self {
        Self {
            policy_session,
            object_name,
            new_parent_name,
            include_object,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command allows policies to change. If a policy were static, then it would be
/// difficult to add users to a policy. This command lets a policy authority sign a new
/// policy so that it may be used in an existing policy.
#[derive(Debug, Clone)]
pub struct TPM2_PolicyAuthorize_REQUEST {
    /// Handle for the policy session being extended
    /// Auth Index: None
    pub policy_session: tpm_handle,

    /// Digest of the policy being approved
    pub approved_policy: vec<u8>,

    /// A policy qualifier
    pub policy_ref: vec<u8>,

    /// Name of a key that can sign a policy addition
    pub key_sign: vec<u8>,

    /// Ticket validating that approvedPolicy and policyRef were signed by keySign
    pub check_ticket: tpmt_tk_verified,
}

impl Default for TPM2_PolicyAuthorize_REQUEST {
    fn default() -> Self {
        Self {
            policySession = TPM_HANDLE();
        }

    }

}

impl TPM2_PolicyAuthorize_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        policy_session: tpm_handle
        ,
        approved_policy: vec<u8>
        ,
        policy_ref: vec<u8>
        ,
        key_sign: vec<u8>
        ,
        check_ticket: tpmt_tk_verified
        ) -> Self {
        Self {
            policy_session,
            approved_policy,
            policy_ref,
            key_sign,
            check_ticket,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command allows a policy to be bound to the authorization value of the authorized entity.
#[derive(Debug, Clone)]
pub struct TPM2_PolicyAuthValue_REQUEST {
    /// Handle for the policy session being extended
    /// Auth Index: None
    pub policy_session: tpm_handle,
}

impl Default for TPM2_PolicyAuthValue_REQUEST {
    fn default() -> Self {
        Self {
            policySession = TPM_HANDLE();
        }

    }

}

impl TPM2_PolicyAuthValue_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        policy_session: tpm_handle
        ) -> Self {
        Self {
            policy_session,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command allows a policy to be bound to the authorization value of the authorized object.
#[derive(Debug, Clone)]
pub struct TPM2_PolicyPassword_REQUEST {
    /// Handle for the policy session being extended
    /// Auth Index: None
    pub policy_session: tpm_handle,
}

impl Default for TPM2_PolicyPassword_REQUEST {
    fn default() -> Self {
        Self {
            policySession = TPM_HANDLE();
        }

    }

}

impl TPM2_PolicyPassword_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        policy_session: tpm_handle
        ) -> Self {
        Self {
            policy_session,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command returns the current policyDigest of the session. This command allows the
/// TPM to be used to perform the actions required to pre-compute the authPolicy for an object.
#[derive(Debug, Clone)]
pub struct TPM2_PolicyGetDigest_REQUEST {
    /// Handle for the policy session
    /// Auth Index: None
    pub policy_session: tpm_handle,
}

impl Default for TPM2_PolicyGetDigest_REQUEST {
    fn default() -> Self {
        Self {
            policySession = TPM_HANDLE();
        }

    }

}

impl TPM2_PolicyGetDigest_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        policy_session: tpm_handle
        ) -> Self {
        Self {
            policy_session,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command returns the current policyDigest of the session. This command allows the
/// TPM to be used to perform the actions required to pre-compute the authPolicy for an object.
#[derive(Debug, Clone)]
pub struct PolicyGetDigestResponse {
    /// The current value of the policySessionpolicyDigest
    pub policy_digest: vec<u8>,
}

impl Default for PolicyGetDigestResponse {
    fn default() -> Self {
        Self {
        }

    }

}

impl PolicyGetDigestResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command allows a policy to be bound to the TPMA_NV_WRITTEN attributes. This is a
/// deferred assertion. Values are stored in the policy session context and checked when
/// the policy is used for authorization.
#[derive(Debug, Clone)]
pub struct TPM2_PolicyNvWritten_REQUEST {
    /// Handle for the policy session being extended
    /// Auth Index: None
    pub policy_session: tpm_handle,

    /// YES if NV Index is required to have been written
    /// NO if NV Index is required not to have been written
    pub written_set: u8,
}

impl Default for TPM2_PolicyNvWritten_REQUEST {
    fn default() -> Self {
        Self {
            policySession = TPM_HANDLE();
        }

    }

}

impl TPM2_PolicyNvWritten_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        policy_session: tpm_handle
        ,
        written_set: u8
        ) -> Self {
        Self {
            policy_session,
            written_set,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command allows a policy to be bound to a specific creation template. This is most
/// useful for an object creation command such as TPM2_Create(), TPM2_CreatePrimary(), or
/// TPM2_CreateLoaded().
#[derive(Debug, Clone)]
pub struct TPM2_PolicyTemplate_REQUEST {
    /// Handle for the policy session being extended
    /// Auth Index: None
    pub policy_session: tpm_handle,

    /// The digest to be added to the policy
    pub template_hash: vec<u8>,
}

impl Default for TPM2_PolicyTemplate_REQUEST {
    fn default() -> Self {
        Self {
            policySession = TPM_HANDLE();
        }

    }

}

impl TPM2_PolicyTemplate_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        policy_session: tpm_handle
        ,
        template_hash: vec<u8>
        ) -> Self {
        Self {
            policy_session,
            template_hash,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command provides a capability that is the equivalent of a revocable policy. With
/// TPM2_PolicyAuthorize(), the authorization ticket never expires, so the authorization
/// may not be withdrawn. With this command, the approved policy is kept in an NV Index
/// location so that the policy may be changed as needed to render the old policy unusable.
#[derive(Debug, Clone)]
pub struct TPM2_PolicyAuthorizeNV_REQUEST {
    /// Handle indicating the source of the authorization value
    /// Auth Index: 1
    /// Auth Role: USER
    pub auth_handle: tpm_handle,

    /// The NV Index of the area to read
    /// Auth Index: None
    pub nv_index: tpm_handle,

    /// Handle for the policy session being extended
    /// Auth Index: None
    pub policy_session: tpm_handle,
}

impl Default for TPM2_PolicyAuthorizeNV_REQUEST {
    fn default() -> Self {
        Self {
            authHandle = TPM_HANDLE();
            nvIndex = TPM_HANDLE();
            policySession = TPM_HANDLE();
        }

    }

}

impl TPM2_PolicyAuthorizeNV_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        auth_handle: tpm_handle
        ,
        nv_index: tpm_handle
        ,
        policy_session: tpm_handle
        ) -> Self {
        Self {
            auth_handle,
            nv_index,
            policy_session,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command is used to create a Primary Object under one of the Primary Seeds or a
/// Temporary Object under TPM_RH_NULL. The command uses a TPM2B_PUBLIC as a template for
/// the object to be created. The size of the unique field shall not be checked for
/// consistency with the other object parameters. The command will create and load a
/// Primary Object. The sensitive area is not returned.
#[derive(Debug, Clone)]
pub struct TPM2_CreatePrimary_REQUEST {
    /// TPM_RH_ENDORSEMENT, TPM_RH_OWNER, TPM_RH_PLATFORM+{PP}, or TPM_RH_NULL
    /// Auth Index: 1
    /// Auth Role: USER
    pub primary_handle: tpm_handle,

    /// The sensitive data, see TPM 2.0 Part 1 Sensitive Values
    pub in_sensitive: tpms_sensitive_create,

    /// The public template
    pub in_public: tpmt_public,

    /// Data that will be included in the creation data for this object to provide permanent,
    /// verifiable linkage between this object and some object owner data
    pub outside_info: vec<u8>,

    /// PCR that will be used in creation data
    pub creation_pcr: vec<tpms_pcr_selection>,
}

impl Default for TPM2_CreatePrimary_REQUEST {
    fn default() -> Self {
        Self {
            primaryHandle = TPM_HANDLE();
        }

    }

}

impl TPM2_CreatePrimary_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        primary_handle: tpm_handle
        ,
        in_sensitive: tpms_sensitive_create
        ,
        in_public: tpmt_public
        ,
        outside_info: vec<u8>
        ,
        creation_pcr: vec<tpms_pcr_selection>
        ) -> Self {
        Self {
            primary_handle,
            in_sensitive,
            in_public,
            outside_info,
            creation_pcr,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command is used to create a Primary Object under one of the Primary Seeds or a
/// Temporary Object under TPM_RH_NULL. The command uses a TPM2B_PUBLIC as a template for
/// the object to be created. The size of the unique field shall not be checked for
/// consistency with the other object parameters. The command will create and load a
/// Primary Object. The sensitive area is not returned.
#[derive(Debug, Clone)]
pub struct CreatePrimaryResponse {
    /// Handle of type TPM_HT_TRANSIENT for created Primary Object
    pub handle: tpm_handle,

    /// The public portion of the created object
    pub out_public: tpmt_public,

    /// Contains a TPMT_CREATION_DATA
    pub creation_data: tpms_creation_data,

    /// Digest of creationData using nameAlg of outPublic
    pub creation_hash: vec<u8>,

    /// Ticket used by TPM2_CertifyCreation() to validate that the creation data was produced
    /// by the TPM
    pub creation_ticket: tpmt_tk_creation,

    /// The name of the created object
    pub name: vec<u8>,
}

impl Default for CreatePrimaryResponse {
    fn default() -> Self {
        Self {
            handle = TPM_HANDLE();
        }

    }

}

impl CreatePrimaryResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command enables and disables use of a hierarchy and its associated NV storage.
/// The command allows phEnable, phEnableNV, shEnable, and ehEnable to be changed when the
/// proper authorization is provided.
#[derive(Debug, Clone)]
pub struct TPM2_HierarchyControl_REQUEST {
    /// TPM_RH_ENDORSEMENT, TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
    /// Auth Index: 1
    /// Auth Role: USER
    pub auth_handle: tpm_handle,

    /// The enable being modified
    /// TPM_RH_ENDORSEMENT, TPM_RH_OWNER, TPM_RH_PLATFORM, or TPM_RH_PLATFORM_NV
    pub enable: tpm_handle,

    /// YES if the enable should be SET, NO if the enable should be CLEAR
    pub state: u8,
}

impl Default for TPM2_HierarchyControl_REQUEST {
    fn default() -> Self {
        Self {
            authHandle = TPM_HANDLE();
            enable = TPM_HANDLE();
        }

    }

}

impl TPM2_HierarchyControl_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        auth_handle: tpm_handle
        ,
        enable: tpm_handle
        ,
        state: u8
        ) -> Self {
        Self {
            auth_handle,
            enable,
            state,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command allows setting of the authorization policy for the lockout
/// (lockoutPolicy), the platform hierarchy (platformPolicy), the storage hierarchy
/// (ownerPolicy), and the endorsement hierarchy (endorsementPolicy). On TPMs implementing
/// Authenticated Countdown Timers (ACT), this command may also be used to set the
/// authorization policy for an ACT.
#[derive(Debug, Clone)]
pub struct TPM2_SetPrimaryPolicy_REQUEST {
    /// TPM_RH_LOCKOUT, TPM_RH_ENDORSEMENT, TPM_RH_OWNER, TPMI_RH_ACT or TPM_RH_PLATFORM+{PP}
    /// Auth Index: 1
    /// Auth Role: USER
    pub auth_handle: tpm_handle,

    /// An authorization policy digest; may be the Empty Buffer
    /// If hashAlg is TPM_ALG_NULL, then this shall be an Empty Buffer.
    pub auth_policy: vec<u8>,

    /// The hash algorithm to use for the policy
    /// If the authPolicy is an Empty Buffer, then this field shall be TPM_ALG_NULL.
    pub hash_alg: tpm_alg_id,
}

impl Default for TPM2_SetPrimaryPolicy_REQUEST {
    fn default() -> Self {
        Self {
            authHandle = TPM_HANDLE();
            hashAlg = TPM_ALG_ID:NULL;
        }

    }

}

impl TPM2_SetPrimaryPolicy_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        auth_handle: tpm_handle
        ,
        auth_policy: vec<u8>
        ,
        hash_alg: tpm_alg_id
        ) -> Self {
        Self {
            auth_handle,
            auth_policy,
            hash_alg,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This replaces the current platform primary seed (PPS) with a value from the RNG and
/// sets platformPolicy to the default initialization value (the Empty Buffer).
#[derive(Debug, Clone)]
pub struct TPM2_ChangePPS_REQUEST {
    /// TPM_RH_PLATFORM+{PP}
    /// Auth Index: 1
    /// Auth Role: USER
    pub auth_handle: tpm_handle,
}

impl Default for TPM2_ChangePPS_REQUEST {
    fn default() -> Self {
        Self {
            authHandle = TPM_HANDLE();
        }

    }

}

impl TPM2_ChangePPS_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        auth_handle: tpm_handle
        ) -> Self {
        Self {
            auth_handle,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This replaces the current endorsement primary seed (EPS) with a value from the RNG and
/// sets the Endorsement hierarchy controls to their default initialization values:
/// ehEnable is SET, endorsementAuth and endorsementPolicy are both set to the Empty
/// Buffer. It will flush any resident objects (transient or persistent) in the
/// Endorsement hierarchy and not allow objects in the hierarchy associated with the
/// previous EPS to be loaded.
#[derive(Debug, Clone)]
pub struct TPM2_ChangeEPS_REQUEST {
    /// TPM_RH_PLATFORM+{PP}
    /// Auth Handle: 1
    /// Auth Role: USER
    pub auth_handle: tpm_handle,
}

impl Default for TPM2_ChangeEPS_REQUEST {
    fn default() -> Self {
        Self {
            authHandle = TPM_HANDLE();
        }

    }

}

impl TPM2_ChangeEPS_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        auth_handle: tpm_handle
        ) -> Self {
        Self {
            auth_handle,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command removes all TPM context associated with a specific Owner.
#[derive(Debug, Clone)]
pub struct TPM2_Clear_REQUEST {
    /// TPM_RH_LOCKOUT or TPM_RH_PLATFORM+{PP}
    /// Auth Handle: 1
    /// Auth Role: USER
    pub auth_handle: tpm_handle,
}

impl Default for TPM2_Clear_REQUEST {
    fn default() -> Self {
        Self {
            authHandle = TPM_HANDLE();
        }

    }

}

impl TPM2_Clear_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        auth_handle: tpm_handle
        ) -> Self {
        Self {
            auth_handle,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// TPM2_ClearControl() disables and enables the execution of TPM2_Clear().
#[derive(Debug, Clone)]
pub struct TPM2_ClearControl_REQUEST {
    /// TPM_RH_LOCKOUT or TPM_RH_PLATFORM+{PP}
    /// Auth Handle: 1
    /// Auth Role: USER
    pub auth: tpm_handle,

    /// YES if the disableOwnerClear flag is to be SET, NO if the flag is to be CLEAR.
    pub disable: u8,
}

impl Default for TPM2_ClearControl_REQUEST {
    fn default() -> Self {
        Self {
            auth = TPM_HANDLE();
        }

    }

}

impl TPM2_ClearControl_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        auth: tpm_handle
        ,
        disable: u8
        ) -> Self {
        Self {
            auth,
            disable,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command allows the authorization secret for a hierarchy or lockout to be changed
/// using the current authorization value as the command authorization.
#[derive(Debug, Clone)]
pub struct TPM2_HierarchyChangeAuth_REQUEST {
    /// TPM_RH_LOCKOUT, TPM_RH_ENDORSEMENT, TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
    /// Auth Index: 1
    /// Auth Role: USER
    pub auth_handle: tpm_handle,

    /// New authorization value
    pub new_auth: vec<u8>,
}

impl Default for TPM2_HierarchyChangeAuth_REQUEST {
    fn default() -> Self {
        Self {
            authHandle = TPM_HANDLE();
        }

    }

}

impl TPM2_HierarchyChangeAuth_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        auth_handle: tpm_handle
        ,
        new_auth: vec<u8>
        ) -> Self {
        Self {
            auth_handle,
            new_auth,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command cancels the effect of a TPM lockout due to a number of successive
/// authorization failures. If this command is properly authorized, the lockout counter is
/// set to zero.
#[derive(Debug, Clone)]
pub struct TPM2_DictionaryAttackLockReset_REQUEST {
    /// TPM_RH_LOCKOUT
    /// Auth Index: 1
    /// Auth Role: USER
    pub lock_handle: tpm_handle,
}

impl Default for TPM2_DictionaryAttackLockReset_REQUEST {
    fn default() -> Self {
        Self {
            lockHandle = TPM_HANDLE();
        }

    }

}

impl TPM2_DictionaryAttackLockReset_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        lock_handle: tpm_handle
        ) -> Self {
        Self {
            lock_handle,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command changes the lockout parameters.
#[derive(Debug, Clone)]
pub struct TPM2_DictionaryAttackParameters_REQUEST {
    /// TPM_RH_LOCKOUT
    /// Auth Index: 1
    /// Auth Role: USER
    pub lock_handle: tpm_handle,

    /// Count of authorization failures before the lockout is imposed
    pub new_max_tries: u32,

    /// Time in seconds before the authorization failure count is automatically decremented
    /// A value of zero indicates that DA protection is disabled.
    pub new_recovery_time: u32,

    /// Time in seconds after a lockoutAuth failure before use of lockoutAuth is allowed
    /// A value of zero indicates that a reboot is required.
    pub lockout_recovery: u32,
}

impl Default for TPM2_DictionaryAttackParameters_REQUEST {
    fn default() -> Self {
        Self {
            lockHandle = TPM_HANDLE();
        }

    }

}

impl TPM2_DictionaryAttackParameters_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        lock_handle: tpm_handle
        ,
        new_max_tries: u32
        ,
        new_recovery_time: u32
        ,
        lockout_recovery: u32
        ) -> Self {
        Self {
            lock_handle,
            new_max_tries,
            new_recovery_time,
            lockout_recovery,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command is used to determine which commands require assertion of Physical
/// Presence (PP) in addition to platformAuth/platformPolicy.
#[derive(Debug, Clone)]
pub struct TPM2_PP_Commands_REQUEST {
    /// TPM_RH_PLATFORM+PP
    /// Auth Index: 1
    /// Auth Role: USER + Physical Presence
    pub auth: tpm_handle,

    /// List of commands to be added to those that will require that Physical Presence be asserted
    pub set_list: vec<tpm_cc>,

    /// List of commands that will no longer require that Physical Presence be asserted
    pub clear_list: vec<tpm_cc>,
}

impl Default for TPM2_PP_Commands_REQUEST {
    fn default() -> Self {
        Self {
            auth = TPM_HANDLE();
        }

    }

}

impl TPM2_PP_Commands_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        auth: tpm_handle
        ,
        set_list: vec<tpm_cc>
        ,
        clear_list: vec<tpm_cc>
        ) -> Self {
        Self {
            auth,
            set_list,
            clear_list,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command allows the platform to change the set of algorithms that are used by the
/// TPM. The algorithmSet setting is a vendor-dependent value.
#[derive(Debug, Clone)]
pub struct TPM2_SetAlgorithmSet_REQUEST {
    /// TPM_RH_PLATFORM
    /// Auth Index: 1
    /// Auth Role: USER
    pub auth_handle: tpm_handle,

    /// A TPM vendor-dependent value indicating the algorithm set selection
    pub algorithm_set: u32,
}

impl Default for TPM2_SetAlgorithmSet_REQUEST {
    fn default() -> Self {
        Self {
            authHandle = TPM_HANDLE();
        }

    }

}

impl TPM2_SetAlgorithmSet_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        auth_handle: tpm_handle
        ,
        algorithm_set: u32
        ) -> Self {
        Self {
            auth_handle,
            algorithm_set,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command uses platformPolicy and a TPM Vendor Authorization Key to authorize a
/// Field Upgrade Manifest.
#[derive(Debug, Clone)]
pub struct TPM2_FieldUpgradeStart_REQUEST {
    /// TPM_RH_PLATFORM+{PP}
    /// Auth Index:1
    /// Auth Role: ADMIN
    pub authorization: tpm_handle,

    /// Handle of a public area that contains the TPM Vendor Authorization Key that will be
    /// used to validate manifestSignature
    /// Auth Index: None
    pub key_handle: tpm_handle,

    /// Digest of the first block in the field upgrade sequence
    pub fu_digest: vec<u8>,

    /// Selector of the algorithm used to construct the signature

    /// Signature over fuDigest using the key associated with keyHandle (not optional)
    /// One of: TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA,
    /// TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TPMT_HA,
    /// TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE.
    pub manifest_signature: Option<Box<dyn TPMU_SIGNATURE>>,
}

impl Default for TPM2_FieldUpgradeStart_REQUEST {
    fn default() -> Self {
        Self {
            authorization = TPM_HANDLE();
            keyHandle = TPM_HANDLE();
        }

    }

}

impl TPM2_FieldUpgradeStart_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        authorization: tpm_handle
        ,
        key_handle: tpm_handle
        ,
        fu_digest: vec<u8>
        ,
        manifest_signature: Option<Box<dyn TPMU_SIGNATURE>>
        ) -> Self {
        Self {
            authorization,
            key_handle,
            fu_digest,
            manifest_signature,
        }

    }

    /// Get the manifestSignatureSigAlg selector value
    pub fn manifest_signature_sig_alg(&self) -> TPM_ALG_ID {
        match &self.manifest_signature {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command will take the actual field upgrade image to be installed on the TPM. The
/// exact format of fuData is vendor-specific. This command is only possible following a
/// successful TPM2_FieldUpgradeStart(). If the TPM has not received a properly authorized
/// TPM2_FieldUpgradeStart(), then the TPM shall return TPM_RC_FIELDUPGRADE.
#[derive(Debug, Clone)]
pub struct TPM2_FieldUpgradeData_REQUEST {
    /// Field upgrade image data
    pub fu_data: vec<u8>,
}

impl Default for TPM2_FieldUpgradeData_REQUEST {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPM2_FieldUpgradeData_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        fu_data: vec<u8>
        ) -> Self {
        Self {
            fu_data,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command will take the actual field upgrade image to be installed on the TPM. The
/// exact format of fuData is vendor-specific. This command is only possible following a
/// successful TPM2_FieldUpgradeStart(). If the TPM has not received a properly authorized
/// TPM2_FieldUpgradeStart(), then the TPM shall return TPM_RC_FIELDUPGRADE.
#[derive(Debug, Clone)]
pub struct FieldUpgradeDataResponse {
    /// Tagged digest of the next block
    /// TPM_ALG_NULL if field update is complete
    pub next_digest: tpmt_ha,

    /// Tagged digest of the first block of the sequence
    pub first_digest: tpmt_ha,
}

impl Default for FieldUpgradeDataResponse {
    fn default() -> Self {
        Self {
        }

    }

}

impl FieldUpgradeDataResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command is used to read a copy of the current firmware installed in the TPM.
#[derive(Debug, Clone)]
pub struct TPM2_FirmwareRead_REQUEST {
    /// The number of previous calls to this command in this sequence
    /// set to 0 on the first call
    pub sequence_number: u32,
}

impl Default for TPM2_FirmwareRead_REQUEST {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPM2_FirmwareRead_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        sequence_number: u32
        ) -> Self {
        Self {
            sequence_number,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command is used to read a copy of the current firmware installed in the TPM.
#[derive(Debug, Clone)]
pub struct FirmwareReadResponse {
    /// Field upgrade image data
    pub fu_data: vec<u8>,
}

impl Default for FirmwareReadResponse {
    fn default() -> Self {
        Self {
        }

    }

}

impl FirmwareReadResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command saves a session context, object context, or sequence object context
/// outside the TPM.
#[derive(Debug, Clone)]
pub struct TPM2_ContextSave_REQUEST {
    /// Handle of the resource to save
    /// Auth Index: None
    pub save_handle: tpm_handle,
}

impl Default for TPM2_ContextSave_REQUEST {
    fn default() -> Self {
        Self {
            saveHandle = TPM_HANDLE();
        }

    }

}

impl TPM2_ContextSave_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        save_handle: tpm_handle
        ) -> Self {
        Self {
            save_handle,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command saves a session context, object context, or sequence object context
/// outside the TPM.
#[derive(Debug, Clone)]
pub struct ContextSaveResponse {
    pub context: tpms_context,
}

impl Default for ContextSaveResponse {
    fn default() -> Self {
        Self {
        }

    }

}

impl ContextSaveResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command is used to reload a context that has been saved by TPM2_ContextSave().
#[derive(Debug, Clone)]
pub struct TPM2_ContextLoad_REQUEST {
    /// The context blob
    pub context: tpms_context,
}

impl Default for TPM2_ContextLoad_REQUEST {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPM2_ContextLoad_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        context: tpms_context
        ) -> Self {
        Self {
            context,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command is used to reload a context that has been saved by TPM2_ContextSave().
#[derive(Debug, Clone)]
pub struct ContextLoadResponse {
    /// The handle assigned to the resource after it has been successfully loaded
    pub handle: tpm_handle,
}

impl Default for ContextLoadResponse {
    fn default() -> Self {
        Self {
            handle = TPM_HANDLE();
        }

    }

}

impl ContextLoadResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command causes all context associated with a loaded object, sequence object, or
/// session to be removed from TPM memory.
#[derive(Debug, Clone)]
pub struct TPM2_FlushContext_REQUEST {
    /// The handle of the item to flush
    /// NOTE This is a use of a handle as a parameter.
    pub flush_handle: tpm_handle,
}

impl Default for TPM2_FlushContext_REQUEST {
    fn default() -> Self {
        Self {
            flushHandle = TPM_HANDLE();
        }

    }

}

impl TPM2_FlushContext_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        flush_handle: tpm_handle
        ) -> Self {
        Self {
            flush_handle,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command allows certain Transient Objects to be made persistent or a persistent
/// object to be evicted.
#[derive(Debug, Clone)]
pub struct TPM2_EvictControl_REQUEST {
    /// TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
    /// Auth Handle: 1
    /// Auth Role: USER
    pub auth: tpm_handle,

    /// The handle of a loaded object
    /// Auth Index: None
    pub object_handle: tpm_handle,

    /// If objectHandle is a transient object handle, then this is the persistent handle for
    /// the object
    /// if objectHandle is a persistent object handle, then it shall be the same value as
    /// persistentHandle
    pub persistent_handle: tpm_handle,
}

impl Default for TPM2_EvictControl_REQUEST {
    fn default() -> Self {
        Self {
            auth = TPM_HANDLE();
            objectHandle = TPM_HANDLE();
            persistentHandle = TPM_HANDLE();
        }

    }

}

impl TPM2_EvictControl_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        auth: tpm_handle
        ,
        object_handle: tpm_handle
        ,
        persistent_handle: tpm_handle
        ) -> Self {
        Self {
            auth,
            object_handle,
            persistent_handle,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command reads the current TPMS_TIME_INFO structure that contains the current
/// setting of Time, Clock, resetCount, and restartCount.
#[derive(Debug, Clone)]
pub struct TPM2_ReadClock_REQUEST {
}

impl Default for TPM2_ReadClock_REQUEST {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPM2_ReadClock_REQUEST {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command reads the current TPMS_TIME_INFO structure that contains the current
/// setting of Time, Clock, resetCount, and restartCount.
#[derive(Debug, Clone)]
pub struct ReadClockResponse {
    pub current_time: tpms_time_info,
}

impl Default for ReadClockResponse {
    fn default() -> Self {
        Self {
        }

    }

}

impl ReadClockResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command is used to advance the value of the TPMs Clock. The command will fail if
/// newTime is less than the current value of Clock or if the new time is greater than
/// FFFF00000000000016. If both of these checks succeed, Clock is set to newTime. If
/// either of these checks fails, the TPM shall return TPM_RC_VALUE and make no change to Clock.
#[derive(Debug, Clone)]
pub struct TPM2_ClockSet_REQUEST {
    /// TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
    /// Auth Handle: 1
    /// Auth Role: USER
    pub auth: tpm_handle,

    /// New Clock setting in milliseconds
    pub new_time: u64,
}

impl Default for TPM2_ClockSet_REQUEST {
    fn default() -> Self {
        Self {
            auth = TPM_HANDLE();
        }

    }

}

impl TPM2_ClockSet_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        auth: tpm_handle
        ,
        new_time: u64
        ) -> Self {
        Self {
            auth,
            new_time,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command adjusts the rate of advance of Clock and Time to provide a better
/// approximation to real time.
#[derive(Debug, Clone)]
pub struct TPM2_ClockRateAdjust_REQUEST {
    /// TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
    /// Auth Handle: 1
    /// Auth Role: USER
    pub auth: tpm_handle,

    /// Adjustment to current Clock update rate
    pub rate_adjust: tpm_clock_adjust,
}

impl Default for TPM2_ClockRateAdjust_REQUEST {
    fn default() -> Self {
        Self {
            auth = TPM_HANDLE();
        }

    }

}

impl TPM2_ClockRateAdjust_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        auth: tpm_handle
        ,
        rate_adjust: tpm_clock_adjust
        ) -> Self {
        Self {
            auth,
            rate_adjust,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command returns various information regarding the TPM and its current state.
#[derive(Debug, Clone)]
pub struct TPM2_GetCapability_REQUEST {
    /// Group selection; determines the format of the response
    pub capability: tpm_cap,

    /// Further definition of information
    pub property: u32,

    /// Number of properties of the indicated type to return
    pub property_count: u32,
}

impl Default for TPM2_GetCapability_REQUEST {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPM2_GetCapability_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        capability: tpm_cap
        ,
        property: u32
        ,
        property_count: u32
        ) -> Self {
        Self {
            capability,
            property,
            property_count,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command returns various information regarding the TPM and its current state.
#[derive(Debug, Clone)]
pub struct GetCapabilityResponse {
    /// Flag to indicate if there are more values of this type
    pub more_data: u8,

    /// The capability

    /// The capability data
    /// One of: TPML_ALG_PROPERTY, TPML_HANDLE, TPML_CCA, TPML_CC, TPML_PCR_SELECTION,
    /// TPML_TAGGED_TPM_PROPERTY, TPML_TAGGED_PCR_PROPERTY, TPML_ECC_CURVE,
    /// TPML_TAGGED_POLICY, TPML_ACT_DATA.
    pub capability_data: Option<Box<dyn TPMU_CAPABILITIES>>,
}

impl Default for GetCapabilityResponse {
    fn default() -> Self {
        Self {
        }

    }

}

impl GetCapabilityResponse {
    /// Get the capabilityDataCapability selector value
    pub fn capability_data_capability(&self) -> TPM_CAP {
        match &self.capability_data {
        Some(u) => u.get_union_selector() as _,
            None => 0 as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command is used to check to see if specific combinations of algorithm parameters
/// are supported.
#[derive(Debug, Clone)]
pub struct TPM2_TestParms_REQUEST {
    /// The algorithm to be tested

    /// Algorithm parameters to be validated
    /// One of: TPMS_KEYEDHASH_PARMS, TPMS_SYMCIPHER_PARMS, TPMS_RSA_PARMS, TPMS_ECC_PARMS,
    /// TPMS_ASYM_PARMS.
    pub parameters: Option<Box<dyn TPMU_PUBLIC_PARMS>>,
}

impl Default for TPM2_TestParms_REQUEST {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPM2_TestParms_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        parameters: Option<Box<dyn TPMU_PUBLIC_PARMS>>
        ) -> Self {
        Self {
            parameters,
        }

    }

    /// Get the parametersType selector value
    pub fn parameters_type(&self) -> TPM_ALG_ID {
        match &self.parameters {
        Some(u) => u.get_union_selector() as _,
            None => 0 as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command defines the attributes of an NV Index and causes the TPM to reserve space
/// to hold the data associated with the NV Index. If a definition already exists at the
/// NV Index, the TPM will return TPM_RC_NV_DEFINED.
#[derive(Debug, Clone)]
pub struct TPM2_NV_DefineSpace_REQUEST {
    /// TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
    /// Auth Index: 1
    /// Auth Role: USER
    pub auth_handle: tpm_handle,

    /// The authorization value
    pub auth: vec<u8>,

    /// The public parameters of the NV area
    pub public_info: tpms_nv_public,
}

impl Default for TPM2_NV_DefineSpace_REQUEST {
    fn default() -> Self {
        Self {
            authHandle = TPM_HANDLE();
        }

    }

}

impl TPM2_NV_DefineSpace_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        auth_handle: tpm_handle
        ,
        auth: vec<u8>
        ,
        public_info: tpms_nv_public
        ) -> Self {
        Self {
            auth_handle,
            auth,
            public_info,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command removes an Index from the TPM.
#[derive(Debug, Clone)]
pub struct TPM2_NV_UndefineSpace_REQUEST {
    /// TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
    /// Auth Index: 1
    /// Auth Role: USER
    pub auth_handle: tpm_handle,

    /// The NV Index to remove from NV space
    /// Auth Index: None
    pub nv_index: tpm_handle,
}

impl Default for TPM2_NV_UndefineSpace_REQUEST {
    fn default() -> Self {
        Self {
            authHandle = TPM_HANDLE();
            nvIndex = TPM_HANDLE();
        }

    }

}

impl TPM2_NV_UndefineSpace_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        auth_handle: tpm_handle
        ,
        nv_index: tpm_handle
        ) -> Self {
        Self {
            auth_handle,
            nv_index,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command allows removal of a platform-created NV Index that has
/// TPMA_NV_POLICY_DELETE SET.
#[derive(Debug, Clone)]
pub struct TPM2_NV_UndefineSpaceSpecial_REQUEST {
    /// Index to be deleted
    /// Auth Index: 1
    /// Auth Role: ADMIN
    pub nv_index: tpm_handle,

    /// TPM_RH_PLATFORM + {PP}
    /// Auth Index: 2
    /// Auth Role: USER
    pub platform: tpm_handle,
}

impl Default for TPM2_NV_UndefineSpaceSpecial_REQUEST {
    fn default() -> Self {
        Self {
            nvIndex = TPM_HANDLE();
            platform = TPM_HANDLE();
        }

    }

}

impl TPM2_NV_UndefineSpaceSpecial_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        nv_index: tpm_handle
        ,
        platform: tpm_handle
        ) -> Self {
        Self {
            nv_index,
            platform,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command is used to read the public area and Name of an NV Index. The public area
/// of an Index is not privacy-sensitive and no authorization is required to read this data.
#[derive(Debug, Clone)]
pub struct TPM2_NV_ReadPublic_REQUEST {
    /// The NV Index
    /// Auth Index: None
    pub nv_index: tpm_handle,
}

impl Default for TPM2_NV_ReadPublic_REQUEST {
    fn default() -> Self {
        Self {
            nvIndex = TPM_HANDLE();
        }

    }

}

impl TPM2_NV_ReadPublic_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        nv_index: tpm_handle
        ) -> Self {
        Self {
            nv_index,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command is used to read the public area and Name of an NV Index. The public area
/// of an Index is not privacy-sensitive and no authorization is required to read this data.
#[derive(Debug, Clone)]
pub struct NV_ReadPublicResponse {
    /// The public area of the NV Index
    pub nv_public: tpms_nv_public,

    /// The Name of the nvIndex
    pub nv_name: vec<u8>,
}

impl Default for NV_ReadPublicResponse {
    fn default() -> Self {
        Self {
        }

    }

}

impl NV_ReadPublicResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command writes a value to an area in NV memory that was previously defined by
/// TPM2_NV_DefineSpace().
#[derive(Debug, Clone)]
pub struct TPM2_NV_Write_REQUEST {
    /// Handle indicating the source of the authorization value
    /// Auth Index: 1
    /// Auth Role: USER
    pub auth_handle: tpm_handle,

    /// The NV Index of the area to write
    /// Auth Index: None
    pub nv_index: tpm_handle,

    /// The data to write
    pub data: vec<u8>,

    /// The octet offset into the NV Area
    pub offset: u16,
}

impl Default for TPM2_NV_Write_REQUEST {
    fn default() -> Self {
        Self {
            authHandle = TPM_HANDLE();
            nvIndex = TPM_HANDLE();
        }

    }

}

impl TPM2_NV_Write_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        auth_handle: tpm_handle
        ,
        nv_index: tpm_handle
        ,
        data: vec<u8>
        ,
        offset: u16
        ) -> Self {
        Self {
            auth_handle,
            nv_index,
            data,
            offset,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command is used to increment the value in an NV Index that has the TPM_NT_COUNTER
/// attribute. The data value of the NV Index is incremented by one.
#[derive(Debug, Clone)]
pub struct TPM2_NV_Increment_REQUEST {
    /// Handle indicating the source of the authorization value
    /// Auth Index: 1
    /// Auth Role: USER
    pub auth_handle: tpm_handle,

    /// The NV Index to increment
    /// Auth Index: None
    pub nv_index: tpm_handle,
}

impl Default for TPM2_NV_Increment_REQUEST {
    fn default() -> Self {
        Self {
            authHandle = TPM_HANDLE();
            nvIndex = TPM_HANDLE();
        }

    }

}

impl TPM2_NV_Increment_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        auth_handle: tpm_handle
        ,
        nv_index: tpm_handle
        ) -> Self {
        Self {
            auth_handle,
            nv_index,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command extends a value to an area in NV memory that was previously defined by
/// TPM2_NV_DefineSpace.
#[derive(Debug, Clone)]
pub struct TPM2_NV_Extend_REQUEST {
    /// Handle indicating the source of the authorization value
    /// Auth Index: 1
    /// Auth Role: USER
    pub auth_handle: tpm_handle,

    /// The NV Index to extend
    /// Auth Index: None
    pub nv_index: tpm_handle,

    /// The data to extend
    pub data: vec<u8>,
}

impl Default for TPM2_NV_Extend_REQUEST {
    fn default() -> Self {
        Self {
            authHandle = TPM_HANDLE();
            nvIndex = TPM_HANDLE();
        }

    }

}

impl TPM2_NV_Extend_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        auth_handle: tpm_handle
        ,
        nv_index: tpm_handle
        ,
        data: vec<u8>
        ) -> Self {
        Self {
            auth_handle,
            nv_index,
            data,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command is used to SET bits in an NV Index that was created as a bit field. Any
/// number of bits from 0 to 64 may be SET. The contents of bits are ORed with the current
/// contents of the NV Index.
#[derive(Debug, Clone)]
pub struct TPM2_NV_SetBits_REQUEST {
    /// Handle indicating the source of the authorization value
    /// Auth Index: 1
    /// Auth Role: USER
    pub auth_handle: tpm_handle,

    /// NV Index of the area in which the bit is to be set
    /// Auth Index: None
    pub nv_index: tpm_handle,

    /// The data to OR with the current contents
    pub bits: u64,
}

impl Default for TPM2_NV_SetBits_REQUEST {
    fn default() -> Self {
        Self {
            authHandle = TPM_HANDLE();
            nvIndex = TPM_HANDLE();
        }

    }

}

impl TPM2_NV_SetBits_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        auth_handle: tpm_handle
        ,
        nv_index: tpm_handle
        ,
        bits: u64
        ) -> Self {
        Self {
            auth_handle,
            nv_index,
            bits,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// If the TPMA_NV_WRITEDEFINE or TPMA_NV_WRITE_STCLEAR attributes of an NV location are
/// SET, then this command may be used to inhibit further writes of the NV Index.
#[derive(Debug, Clone)]
pub struct TPM2_NV_WriteLock_REQUEST {
    /// Handle indicating the source of the authorization value
    /// Auth Index: 1
    /// Auth Role: USER
    pub auth_handle: tpm_handle,

    /// The NV Index of the area to lock
    /// Auth Index: None
    pub nv_index: tpm_handle,
}

impl Default for TPM2_NV_WriteLock_REQUEST {
    fn default() -> Self {
        Self {
            authHandle = TPM_HANDLE();
            nvIndex = TPM_HANDLE();
        }

    }

}

impl TPM2_NV_WriteLock_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        auth_handle: tpm_handle
        ,
        nv_index: tpm_handle
        ) -> Self {
        Self {
            auth_handle,
            nv_index,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// The command will SET TPMA_NV_WRITELOCKED for all indexes that have their
/// TPMA_NV_GLOBALLOCK attribute SET.
#[derive(Debug, Clone)]
pub struct TPM2_NV_GlobalWriteLock_REQUEST {
    /// TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
    /// Auth Index: 1
    /// Auth Role: USER
    pub auth_handle: tpm_handle,
}

impl Default for TPM2_NV_GlobalWriteLock_REQUEST {
    fn default() -> Self {
        Self {
            authHandle = TPM_HANDLE();
        }

    }

}

impl TPM2_NV_GlobalWriteLock_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        auth_handle: tpm_handle
        ) -> Self {
        Self {
            auth_handle,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command reads a value from an area in NV memory previously defined by TPM2_NV_DefineSpace().
#[derive(Debug, Clone)]
pub struct TPM2_NV_Read_REQUEST {
    /// The handle indicating the source of the authorization value
    /// Auth Index: 1
    /// Auth Role: USER
    pub auth_handle: tpm_handle,

    /// The NV Index to be read
    /// Auth Index: None
    pub nv_index: tpm_handle,

    /// Number of octets to read
    pub size: u16,

    /// Octet offset into the NV area
    /// This value shall be less than or equal to the size of the nvIndex data.
    pub offset: u16,
}

impl Default for TPM2_NV_Read_REQUEST {
    fn default() -> Self {
        Self {
            authHandle = TPM_HANDLE();
            nvIndex = TPM_HANDLE();
        }

    }

}

impl TPM2_NV_Read_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        auth_handle: tpm_handle
        ,
        nv_index: tpm_handle
        ,
        size: u16
        ,
        offset: u16
        ) -> Self {
        Self {
            auth_handle,
            nv_index,
            size,
            offset,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command reads a value from an area in NV memory previously defined by TPM2_NV_DefineSpace().
#[derive(Debug, Clone)]
pub struct NV_ReadResponse {
    /// The data read
    pub data: vec<u8>,
}

impl Default for NV_ReadResponse {
    fn default() -> Self {
        Self {
        }

    }

}

impl NV_ReadResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// If TPMA_NV_READ_STCLEAR is SET in an Index, then this command may be used to prevent
/// further reads of the NV Index until the next TPM2_Startup (TPM_SU_CLEAR).
#[derive(Debug, Clone)]
pub struct TPM2_NV_ReadLock_REQUEST {
    /// The handle indicating the source of the authorization value
    /// Auth Index: 1
    /// Auth Role: USER
    pub auth_handle: tpm_handle,

    /// The NV Index to be locked
    /// Auth Index: None
    pub nv_index: tpm_handle,
}

impl Default for TPM2_NV_ReadLock_REQUEST {
    fn default() -> Self {
        Self {
            authHandle = TPM_HANDLE();
            nvIndex = TPM_HANDLE();
        }

    }

}

impl TPM2_NV_ReadLock_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        auth_handle: tpm_handle
        ,
        nv_index: tpm_handle
        ) -> Self {
        Self {
            auth_handle,
            nv_index,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command allows the authorization secret for an NV Index to be changed.
#[derive(Debug, Clone)]
pub struct TPM2_NV_ChangeAuth_REQUEST {
    /// Handle of the entity
    /// Auth Index: 1
    /// Auth Role: ADMIN
    pub nv_index: tpm_handle,

    /// New authorization value
    pub new_auth: vec<u8>,
}

impl Default for TPM2_NV_ChangeAuth_REQUEST {
    fn default() -> Self {
        Self {
            nvIndex = TPM_HANDLE();
        }

    }

}

impl TPM2_NV_ChangeAuth_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        nv_index: tpm_handle
        ,
        new_auth: vec<u8>
        ) -> Self {
        Self {
            nv_index,
            new_auth,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// The purpose of this command is to certify the contents of an NV Index or portion of an
/// NV Index.
#[derive(Debug, Clone)]
pub struct TPM2_NV_Certify_REQUEST {
    /// Handle of the key used to sign the attestation structure
    /// Auth Index: 1
    /// Auth Role: USER
    pub sign_handle: tpm_handle,

    /// Handle indicating the source of the authorization value for the NV Index
    /// Auth Index: 2
    /// Auth Role: USER
    pub auth_handle: tpm_handle,

    /// Index for the area to be certified
    /// Auth Index: None
    pub nv_index: tpm_handle,

    /// User-provided qualifying data
    pub qualifying_data: vec<u8>,

    /// Scheme selector

    /// Signing scheme to use if the scheme for signHandle is TPM_ALG_NULL
    /// One of: TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA,
    /// TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR,
    /// TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME.
    pub in_scheme: Option<Box<dyn TPMU_SIG_SCHEME>>,

    /// Number of octets to certify
    pub size: u16,

    /// Octet offset into the NV area
    /// This value shall be less than or equal to the size of the nvIndex data.
    pub offset: u16,
}

impl Default for TPM2_NV_Certify_REQUEST {
    fn default() -> Self {
        Self {
            signHandle = TPM_HANDLE();
            authHandle = TPM_HANDLE();
            nvIndex = TPM_HANDLE();
        }

    }

}

impl TPM2_NV_Certify_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        sign_handle: tpm_handle
        ,
        auth_handle: tpm_handle
        ,
        nv_index: tpm_handle
        ,
        qualifying_data: vec<u8>
        ,
        in_scheme: Option<Box<dyn TPMU_SIG_SCHEME>>
        ,
        size: u16
        ,
        offset: u16
        ) -> Self {
        Self {
            sign_handle,
            auth_handle,
            nv_index,
            qualifying_data,
            in_scheme,
            size,
            offset,
        }

    }

    /// Get the inSchemeScheme selector value
    pub fn in_scheme_scheme(&self) -> TPM_ALG_ID {
        match &self.in_scheme {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// The purpose of this command is to certify the contents of an NV Index or portion of an
/// NV Index.
#[derive(Debug, Clone)]
pub struct NV_CertifyResponse {
    /// The structure that was signed
    pub certify_info: tpms_attest,

    /// Selector of the algorithm used to construct the signature

    /// The asymmetric signature over certifyInfo using the key referenced by signHandle
    /// One of: TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA,
    /// TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TPMT_HA,
    /// TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE.
    pub signature: Option<Box<dyn TPMU_SIGNATURE>>,
}

impl Default for NV_CertifyResponse {
    fn default() -> Self {
        Self {
        }

    }

}

impl NV_CertifyResponse {
    /// Get the signatureSigAlg selector value
    pub fn signature_sig_alg(&self) -> TPM_ALG_ID {
        match &self.signature {
        Some(u) => u.get_union_selector() as _,
            None => TPM_ALG_ID:NULL as _,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// The purpose of this command is to obtain information about an Attached Component
/// referenced by an AC handle.
#[derive(Debug, Clone)]
pub struct TPM2_AC_GetCapability_REQUEST {
    /// Handle indicating the Attached Component
    /// Auth Index: None
    pub ac: tpm_handle,

    /// Starting info type
    pub capability: tpm_at,

    /// Maximum number of values to return
    pub count: u32,
}

impl Default for TPM2_AC_GetCapability_REQUEST {
    fn default() -> Self {
        Self {
            ac = TPM_HANDLE();
        }

    }

}

impl TPM2_AC_GetCapability_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        ac: tpm_handle
        ,
        capability: tpm_at
        ,
        count: u32
        ) -> Self {
        Self {
            ac,
            capability,
            count,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// The purpose of this command is to obtain information about an Attached Component
/// referenced by an AC handle.
#[derive(Debug, Clone)]
pub struct AC_GetCapabilityResponse {
    /// Flag to indicate whether there are more values
    pub more_data: u8,

    /// List of capabilities
    pub capabilities_data: vec<tpms_ac_output>,
}

impl Default for AC_GetCapabilityResponse {
    fn default() -> Self {
        Self {
        }

    }

}

impl AC_GetCapabilityResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// The purpose of this command is to send (copy) a loaded object from the TPM to an
/// Attached Component.
#[derive(Debug, Clone)]
pub struct TPM2_AC_Send_REQUEST {
    /// Handle of the object being sent to ac
    /// Auth Index: 1
    /// Auth Role: DUP
    pub send_object: tpm_handle,

    /// The handle indicating the source of the authorization value
    /// Auth Index: 2
    /// Auth Role: USER
    pub auth_handle: tpm_handle,

    /// Handle indicating the Attached Component to which the object will be sent
    /// Auth Index: None
    pub ac: tpm_handle,

    /// Optional non sensitive information related to the object
    pub ac_data_in: vec<u8>,
}

impl Default for TPM2_AC_Send_REQUEST {
    fn default() -> Self {
        Self {
            sendObject = TPM_HANDLE();
            authHandle = TPM_HANDLE();
            ac = TPM_HANDLE();
        }

    }

}

impl TPM2_AC_Send_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        send_object: tpm_handle
        ,
        auth_handle: tpm_handle
        ,
        ac: tpm_handle
        ,
        ac_data_in: vec<u8>
        ) -> Self {
        Self {
            send_object,
            auth_handle,
            ac,
            ac_data_in,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// The purpose of this command is to send (copy) a loaded object from the TPM to an
/// Attached Component.
#[derive(Debug, Clone)]
pub struct AC_SendResponse {
    /// May include AC specific data or information about an error.
    pub ac_data_out: tpms_ac_output,
}

impl Default for AC_SendResponse {
    fn default() -> Self {
        Self {
        }

    }

}

impl AC_SendResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command allows qualification of the sending (copying) of an Object to an Attached
/// Component (AC). Qualification includes selection of the receiving AC and the method of
/// authentication for the AC, and, in certain circumstances, the Object to be sent may be
/// specified.
#[derive(Debug, Clone)]
pub struct TPM2_Policy_AC_SendSelect_REQUEST {
    /// Handle for the policy session being extended
    /// Auth Index: None
    pub policy_session: tpm_handle,

    /// The Name of the Object to be sent
    pub object_name: vec<u8>,

    /// The Name associated with authHandle used in the TPM2_AC_Send() command
    pub auth_handle_name: vec<u8>,

    /// The Name of the Attached Component to which the Object will be sent
    pub ac_name: vec<u8>,

    /// If SET, objectName will be included in the value in policySessionpolicyDigest
    pub include_object: u8,
}

impl Default for TPM2_Policy_AC_SendSelect_REQUEST {
    fn default() -> Self {
        Self {
            policySession = TPM_HANDLE();
        }

    }

}

impl TPM2_Policy_AC_SendSelect_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        policy_session: tpm_handle
        ,
        object_name: vec<u8>
        ,
        auth_handle_name: vec<u8>
        ,
        ac_name: vec<u8>
        ,
        include_object: u8
        ) -> Self {
        Self {
            policy_session,
            object_name,
            auth_handle_name,
            ac_name,
            include_object,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This command is used to set the time remaining before an Authenticated Countdown Timer
/// (ACT) expires.
#[derive(Debug, Clone)]
pub struct TPM2_ACT_SetTimeout_REQUEST {
    /// Handle of the selected ACT
    /// Auth Index: 1
    /// Auth Role: USER
    pub act_handle: tpm_handle,

    /// The start timeout value for the ACT in seconds
    pub start_timeout: u32,
}

impl Default for TPM2_ACT_SetTimeout_REQUEST {
    fn default() -> Self {
        Self {
            actHandle = TPM_HANDLE();
        }

    }

}

impl TPM2_ACT_SetTimeout_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        act_handle: tpm_handle
        ,
        start_timeout: u32
        ) -> Self {
        Self {
            act_handle,
            start_timeout,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This is a placeholder to allow testing of the dispatch code.
#[derive(Debug, Clone)]
pub struct TPM2_Vendor_TCG_Test_REQUEST {
    /// Dummy data
    pub input_data: vec<u8>,
}

impl Default for TPM2_Vendor_TCG_Test_REQUEST {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPM2_Vendor_TCG_Test_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        input_data: vec<u8>
        ) -> Self {
        Self {
            input_data,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// This is a placeholder to allow testing of the dispatch code.
#[derive(Debug, Clone)]
pub struct Vendor_TCG_TestResponse {
    /// Dummy data
    pub output_data: vec<u8>,
}

impl Default for Vendor_TCG_TestResponse {
    fn default() -> Self {
        Self {
        }

    }

}

impl Vendor_TCG_TestResponse {
    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// These are the RSA schemes that only need a hash algorithm as a scheme parameter.
pub type TPMS_SCHEME_RSASSA = TPMS_SIG_SCHEME_RSASSA;

/// These are the RSA schemes that only need a hash algorithm as a scheme parameter.
pub type TPMS_SCHEME_RSAPSS = TPMS_SIG_SCHEME_RSAPSS;

/// Most of the ECC signature schemes only require a hash algorithm to complete the
/// definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a
/// count value so they are typed to be TPMS_SCHEME_ECDAA.
pub type TPMS_SCHEME_ECDSA = TPMS_SIG_SCHEME_ECDSA;

/// Most of the ECC signature schemes only require a hash algorithm to complete the
/// definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a
/// count value so they are typed to be TPMS_SCHEME_ECDAA.
pub type TPMS_SCHEME_SM2 = TPMS_SIG_SCHEME_SM2;

/// Most of the ECC signature schemes only require a hash algorithm to complete the
/// definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a
/// count value so they are typed to be TPMS_SCHEME_ECDAA.
pub type TPMS_SCHEME_ECSCHNORR = TPMS_SIG_SCHEME_ECSCHNORR;

/// These are the RSA encryption schemes that only need a hash algorithm as a controlling parameter.
pub type TPMS_SCHEME_OAEP = TPMS_ENC_SCHEME_OAEP;

/// These are the RSA encryption schemes that only need a hash algorithm as a controlling parameter.
pub type TPMS_SCHEME_RSAES = TPMS_ENC_SCHEME_RSAES;

/// These are the ECC schemes that only need a hash algorithm as a controlling parameter.
pub type TPMS_SCHEME_ECDH = TPMS_KEY_SCHEME_ECDH;

/// These are the ECC schemes that only need a hash algorithm as a controlling parameter.
pub type TPMS_SCHEME_ECMQV = TPMS_KEY_SCHEME_ECMQV;

/// These structures are used to define the key derivation for symmetric secret sharing
/// using asymmetric methods. A secret sharing scheme is required in any asymmetric key
/// with the decrypt attribute SET.
pub type TPMS_SCHEME_MGF1 = TPMS_KDF_SCHEME_MGF1;

/// These structures are used to define the key derivation for symmetric secret sharing
/// using asymmetric methods. A secret sharing scheme is required in any asymmetric key
/// with the decrypt attribute SET.
pub type TPMS_SCHEME_KDF1_SP800_56A = TPMS_KDF_SCHEME_KDF1_SP800_56A;

/// These structures are used to define the key derivation for symmetric secret sharing
/// using asymmetric methods. A secret sharing scheme is required in any asymmetric key
/// with the decrypt attribute SET.
pub type TPMS_SCHEME_KDF2 = TPMS_KDF_SCHEME_KDF2;

/// These structures are used to define the key derivation for symmetric secret sharing
/// using asymmetric methods. A secret sharing scheme is required in any asymmetric key
/// with the decrypt attribute SET.
pub type TPMS_SCHEME_KDF1_SP800_108 = TPMS_KDF_SCHEME_KDF1_SP800_108;

/// Contains the public and the plaintext-sensitive and/or encrypted private part of a TPM
/// key (or other object)
#[derive(Debug, Clone)]
pub struct TssObject {
    /// Public part of key
    pub public: tpmt_public,

    /// Sensitive part of key
    pub sensitive: tpmt_sensitive,

    /// Private part is the encrypted sensitive part of key
    pub private: tpm2b_private,
}

impl Default for TssObject {
    fn default() -> Self {
        Self {
        }

    }

}

impl TssObject {
    /// Creates a new instance with the specified values
    pub fn new(
        public: tpmt_public
        ,
        sensitive: tpmt_sensitive
        ,
        private: tpm2b_private
        ) -> Self {
        Self {
            public,
            sensitive,
            private,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// Contains a PCR index and associated hash(pcr-value) [TSS]
#[derive(Debug, Clone)]
pub struct PcrValue {
    /// PCR Index
    pub index: u32,

    /// PCR Value
    pub value: tpmt_ha,
}

impl Default for PcrValue {
    fn default() -> Self {
        Self {
        }

    }

}

impl PcrValue {
    /// Creates a new instance with the specified values
    pub fn new(
        index: u32
        ,
        value: tpmt_ha
        ) -> Self {
        Self {
            index,
            value,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// Structure representing a session block in a command buffer [TSS]
#[derive(Debug, Clone)]
pub struct SessionIn {
    /// Session handle
    pub handle: tpm_handle,

    /// Caller nonce
    pub nonce_caller: vec<u8>,

    /// Session attributes
    pub attributes: tpma_session,

    /// AuthValue (or HMAC)
    pub auth: vec<u8>,
}

impl Default for SessionIn {
    fn default() -> Self {
        Self {
            handle = TPM_HANDLE();
        }

    }

}

impl SessionIn {
    /// Creates a new instance with the specified values
    pub fn new(
        handle: tpm_handle
        ,
        nonce_caller: vec<u8>
        ,
        attributes: tpma_session
        ,
        auth: vec<u8>
        ) -> Self {
        Self {
            handle,
            nonce_caller,
            attributes,
            auth,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// Structure representing a session block in a response buffer [TSS]
#[derive(Debug, Clone)]
pub struct SessionOut {
    /// TPM nonce
    pub nonce_tpm: vec<u8>,

    /// Session attributes
    pub attributes: tpma_session,

    /// HMAC value
    pub auth: vec<u8>,
}

impl Default for SessionOut {
    fn default() -> Self {
        Self {
        }

    }

}

impl SessionOut {
    /// Creates a new instance with the specified values
    pub fn new(
        nonce_tpm: vec<u8>
        ,
        attributes: tpma_session
        ,
        auth: vec<u8>
        ) -> Self {
        Self {
            nonce_tpm,
            attributes,
            auth,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// Command header [TSS]
#[derive(Debug, Clone)]
pub struct CommandHeader {
    /// Command tag (sessions, or no sessions)
    pub tag: tpm_st,

    /// Total command buffer length
    pub command_size: u32,

    /// Command code
    pub command_code: tpm_cc,
}

impl Default for CommandHeader {
    fn default() -> Self {
        Self {
        }

    }

}

impl CommandHeader {
    /// Creates a new instance with the specified values
    pub fn new(
        tag: tpm_st
        ,
        command_size: u32
        ,
        command_code: tpm_cc
        ) -> Self {
        Self {
            tag,
            command_size,
            command_code,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// Contains the public and private part of a TPM key
#[derive(Debug, Clone)]
pub struct TSS_KEY {
    /// Public part of key
    pub public_part: tpmt_public,

    /// Private part is the encrypted sensitive part of key
    pub private_part: vec<u8>,
}

impl Default for TSS_KEY {
    fn default() -> Self {
        Self {
        }

    }

}

impl TSS_KEY {
    /// Creates a new instance with the specified values
    pub fn new(
        public_part: tpmt_public
        ,
        private_part: vec<u8>
        ) -> Self {
        Self {
            public_part,
            private_part,
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// Auto-derived from TPM2B_DIGEST to provide unique GetUnionSelector() implementation
#[derive(Debug, Clone)]
pub struct TPM2B_DIGEST_SYMCIPHER {
}

impl Default for TPM2B_DIGEST_SYMCIPHER {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPM2B_DIGEST_SYMCIPHER {
    // Union trait implementations
    impl TpmUnion for TPM2B_DIGEST_SYMCIPHER {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
        TPMU_PUBLIC_ID::SYMCIPHER as u32
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

/// Auto-derived from TPM2B_DIGEST
#[derive(Debug, Clone)]
pub struct TPM2B_DIGEST_KEYEDHASH {
}

impl Default for TPM2B_DIGEST_KEYEDHASH {
    fn default() -> Self {
        Self {
        }

    }

}

impl TPM2B_DIGEST_KEYEDHASH {
    // Union trait implementations
    impl TpmUnion for TPM2B_DIGEST_KEYEDHASH {
        /// TpmUnion trait implementation
        fn get_union_selector(&self) -> u32 {
        TPMU_PUBLIC_ID::KEYEDHASH as u32
        }

    }

    /// Serialize this structure to a TPM buffer
    pub fn to_tpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
    // Implement serialization
        Ok(())
    }

    /// Deserialize this structure from a TPM buffer
    pub fn from_tpm(buffer: &mut TpmBuffer) -> Result<Self, TpmError> {
    // Implement deserialization
        Ok(Self::default())
    }

}

