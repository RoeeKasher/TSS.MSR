/*
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See the LICENSE file in the project root for full license information.
 */

/*
 * NOTE: this file is partially auto generated!
 *
 * All code after the point marked with the '// <<AUTOGEN_BEGIN>>' comment
 * is autogenerated from the TPM 2.0 Specification docs.
 *
 * DO NOT EDIT AUTOGENERATED PART - all manual changes will be lost!
 */

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        // <<AUTOGEN_BEGIN>>
// ------------------------------------------------------------------------------------------------
// DO NOT REMOVE the <<AUTOGEN_BEGIN>> comment!
// DO NOT MODIFY any code below this point - all manual changes will be lost!
// ------------------------------------------------------------------------------------------------

//! TPM type definitions

use crate::error::TpmError;
use crate::tpm_buffer::TpmBuffer;
use crate::crypto::Crypto;
use std::fmt;
use num_enum::TryFromPrimitive;
use std::collections::HashMap;
use std::fmt::Debug;

/// Common trait for all TPM enumeration types
pub trait TpmEnum {
/// Get the numeric value of the enum
    fn get_value(&self) -> u32;
}

/// Trait for structures that can be marshaled to/from TPM wire format
pub trait TpmStructure {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError>;
    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError>;
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError>;
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError>;
    fn fromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError>;
    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError>;
}

/// Trait for TPM union types
pub trait TpmUnion : TpmStructure { }

/// Table 2 is the list of algorithms to which the TCG has assigned an algorithm
/// identifier along with its numeric identifier.

/// Enum with duplicated values - using struct with constants
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Default)]
pub struct TPM_ALG_ID(pub u16);

impl TPM_ALG_ID {
    /// Should not occur
    pub const ERROR: Self = Self(0x0); // Original value: 0x0000

    /// An object type that contains an RSA key
    pub const FIRST: Self = Self(0x1); // Original value: 0x0001

    /// An object type that contains an RSA key
    pub const RSA: Self = Self(0x1); // Original value: 0x0001

    /// Block cipher with various key sizes (Triple Data Encryption Algorithm, commonly called
    /// Triple Data Encryption Standard)
    pub const TDES: Self = Self(0x3); // Original value: 0x0003

    /// Hash algorithm producing a 160-bit digest
    pub const SHA: Self = Self(0x4); // Original value: 0x0004

    /// Redefinition for documentation consistency
    pub const SHA1: Self = Self(0x4); // Original value: 0x0004

    /// Hash Message Authentication Code (HMAC) algorithm
    pub const HMAC: Self = Self(0x5); // Original value: 0x0005

    /// Block cipher with various key sizes
    pub const AES: Self = Self(0x6); // Original value: 0x0006

    /// Hash-based mask-generation function
    pub const MGF1: Self = Self(0x7); // Original value: 0x0007

    /// An object type that may use XOR for encryption or an HMAC for signing and may also
    /// refer to a data object that is neither signing nor encrypting
    pub const KEYEDHASH: Self = Self(0x8); // Original value: 0x0008

    /// Hash-based stream cipher
    pub const XOR: Self = Self(0xA); // Original value: 0x000A

    /// Hash algorithm producing a 256-bit digest
    pub const SHA256: Self = Self(0xB); // Original value: 0x000B

    /// Hash algorithm producing a 384-bit digest
    pub const SHA384: Self = Self(0xC); // Original value: 0x000C

    /// Hash algorithm producing a 512-bit digest
    pub const SHA512: Self = Self(0xD); // Original value: 0x000D

    /// Indication that no algorithm is selected
    pub const NULL: Self = Self(0x10); // Original value: 0x0010

    /// Hash algorithm producing a 256-bit digest
    pub const SM3_256: Self = Self(0x12); // Original value: 0x0012

    /// Symmetric block cipher with 128 bit key
    pub const SM4: Self = Self(0x13); // Original value: 0x0013

    /// A signature algorithm defined in section 8.2 (RSASSA-PKCS1-v1_5)
    pub const RSASSA: Self = Self(0x14); // Original value: 0x0014

    /// A padding algorithm defined in section 7.2 (RSAES-PKCS1-v1_5)
    pub const RSAES: Self = Self(0x15); // Original value: 0x0015

    /// A signature algorithm defined in section 8.1 (RSASSA-PSS)
    pub const RSAPSS: Self = Self(0x16); // Original value: 0x0016

    /// A padding algorithm defined in Section 7.1 (RSAES_OAEP)
    pub const OAEP: Self = Self(0x17); // Original value: 0x0017

    /// Signature algorithm using elliptic curve cryptography (ECC)
    pub const ECDSA: Self = Self(0x18); // Original value: 0x0018

    /// Secret sharing using ECC Based on context, this can be either One-Pass Diffie-Hellman,
    /// C(1, 1, ECC CDH) defined in 6.2.2.2 or Full Unified Model C(2, 2, ECC CDH) defined in 6.1.1.2
    pub const ECDH: Self = Self(0x19); // Original value: 0x0019

    /// Elliptic-curve based, anonymous signing scheme
    pub const ECDAA: Self = Self(0x1A); // Original value: 0x001A

    /// Depending on context, either an elliptic-curve-based signature algorithm, encryption
    /// algorithm, or key exchange protocol
    pub const SM2: Self = Self(0x1B); // Original value: 0x001B

    /// Elliptic-curve based Schnorr signature
    pub const ECSCHNORR: Self = Self(0x1C); // Original value: 0x001C

    /// Two-phase elliptic-curve key exchange C(2, 2, ECC MQV) Section 6.1.1.4
    pub const ECMQV: Self = Self(0x1D); // Original value: 0x001D

    /// Concatenation key derivation function (approved alternative 1) Section 5.8.1
    pub const KDF1_SP800_56A: Self = Self(0x20); // Original value: 0x0020

    /// Key derivation function KDF2 Section 13.2
    pub const KDF2: Self = Self(0x21); // Original value: 0x0021

    /// A key derivation method SP800-108, Section 5.1 KDF in Counter Mode
    pub const KDF1_SP800_108: Self = Self(0x22); // Original value: 0x0022

    /// Prime field ECC
    pub const ECC: Self = Self(0x23); // Original value: 0x0023

    /// The object type for a symmetric block cipher key
    pub const SYMCIPHER: Self = Self(0x25); // Original value: 0x0025

    /// Symmetric block cipher with various key sizes
    pub const CAMELLIA: Self = Self(0x26); // Original value: 0x0026

    /// Hash algorithm producing a 256-bit digest
    pub const SHA3_256: Self = Self(0x27); // Original value: 0x0027

    /// Hash algorithm producing a 384-bit digest
    pub const SHA3_384: Self = Self(0x28); // Original value: 0x0028

    /// Hash algorithm producing a 512-bit digest
    pub const SHA3_512: Self = Self(0x29); // Original value: 0x0029
    pub const CMAC: Self = Self(0x3F); // Original value: 0x003F

    /// Counter mode if implemented, all symmetric block ciphers (S type) implemented shall be
    /// capable of using this mode.
    pub const CTR: Self = Self(0x40); // Original value: 0x0040

    /// Output Feedback mode if implemented, all symmetric block ciphers (S type) implemented
    /// shall be capable of using this mode.
    pub const OFB: Self = Self(0x41); // Original value: 0x0041

    /// Cipher Block Chaining mode if implemented, all symmetric block ciphers (S type)
    /// implemented shall be capable of using this mode.
    pub const CBC: Self = Self(0x42); // Original value: 0x0042

    /// Cipher Feedback mode if implemented, all symmetric block ciphers (S type) implemented
    /// shall be capable of using this mode.
    pub const CFB: Self = Self(0x43); // Original value: 0x0043

    /// Electronic Codebook mode if implemented, all implemented symmetric block ciphers (S
    /// type) shall be capable of using this mode.
    /// NOTE This mode is not recommended for uses unless the key is frequently rotated such
    /// as in video codecs
    pub const ECB: Self = Self(0x44); // Original value: 0x0044
    pub const LAST: Self = Self(0x44); // Original value: 0x0044

    /// Phony alg ID to be used for the first union member with no selector
    pub const ANY: Self = Self(0x7FFF);

    /// Phony alg ID to be used for the second union member with no selector
    pub const ANY2: Self = Self(0x7FFE);

    pub fn try_from(value: i16) -> Result<Self, TpmError> {
        match value {
            0 => Ok(Self::ERROR), // Original value: 0x0000
            1 => Ok(Self::FIRST), // Original value: 0x0001
            3 => Ok(Self::TDES), // Original value: 0x0003
            4 => Ok(Self::SHA), // Original value: 0x0004
            5 => Ok(Self::HMAC), // Original value: 0x0005
            6 => Ok(Self::AES), // Original value: 0x0006
            7 => Ok(Self::MGF1), // Original value: 0x0007
            8 => Ok(Self::KEYEDHASH), // Original value: 0x0008
            10 => Ok(Self::XOR), // Original value: 0x000A
            11 => Ok(Self::SHA256), // Original value: 0x000B
            12 => Ok(Self::SHA384), // Original value: 0x000C
            13 => Ok(Self::SHA512), // Original value: 0x000D
            16 => Ok(Self::NULL), // Original value: 0x0010
            18 => Ok(Self::SM3_256), // Original value: 0x0012
            19 => Ok(Self::SM4), // Original value: 0x0013
            20 => Ok(Self::RSASSA), // Original value: 0x0014
            21 => Ok(Self::RSAES), // Original value: 0x0015
            22 => Ok(Self::RSAPSS), // Original value: 0x0016
            23 => Ok(Self::OAEP), // Original value: 0x0017
            24 => Ok(Self::ECDSA), // Original value: 0x0018
            25 => Ok(Self::ECDH), // Original value: 0x0019
            26 => Ok(Self::ECDAA), // Original value: 0x001A
            27 => Ok(Self::SM2), // Original value: 0x001B
            28 => Ok(Self::ECSCHNORR), // Original value: 0x001C
            29 => Ok(Self::ECMQV), // Original value: 0x001D
            32 => Ok(Self::KDF1_SP800_56A), // Original value: 0x0020
            33 => Ok(Self::KDF2), // Original value: 0x0021
            34 => Ok(Self::KDF1_SP800_108), // Original value: 0x0022
            35 => Ok(Self::ECC), // Original value: 0x0023
            37 => Ok(Self::SYMCIPHER), // Original value: 0x0025
            38 => Ok(Self::CAMELLIA), // Original value: 0x0026
            39 => Ok(Self::SHA3_256), // Original value: 0x0027
            40 => Ok(Self::SHA3_384), // Original value: 0x0028
            41 => Ok(Self::SHA3_512), // Original value: 0x0029
            63 => Ok(Self::CMAC), // Original value: 0x003F
            64 => Ok(Self::CTR), // Original value: 0x0040
            65 => Ok(Self::OFB), // Original value: 0x0041
            66 => Ok(Self::CBC), // Original value: 0x0042
            67 => Ok(Self::CFB), // Original value: 0x0043
            68 => Ok(Self::ECB), // Original value: 0x0044
            32767 => Ok(Self::ANY), // Original value: 0x7FFF
            32766 => Ok(Self::ANY2), // Original value: 0x7FFE
            _ => Err(TpmError::InvalidEnumValue),
        }

    }

}

impl TpmEnum for TPM_ALG_ID {
    fn get_value(&self) -> u32 {
        self.0.into()
    }

}

impl From<TPM_ALG_ID> for u32 {
    fn from(value: TPM_ALG_ID) -> Self {
        value.0.into()
    }
}

impl From<TPM_ALG_ID> for i32 {
    fn from(value: TPM_ALG_ID) -> Self {
        value.0 as i32
    }
}

impl fmt::Display for TPM_ALG_ID {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self.0 {
            0 => write!(f, "ERROR"),
            1 => write!(f, "One of <FIRST, RSA>"),
            3 => write!(f, "TDES"),
            4 => write!(f, "One of <SHA, SHA1>"),
            5 => write!(f, "HMAC"),
            6 => write!(f, "AES"),
            7 => write!(f, "MGF1"),
            8 => write!(f, "KEYEDHASH"),
            10 => write!(f, "XOR"),
            11 => write!(f, "SHA256"),
            12 => write!(f, "SHA384"),
            13 => write!(f, "SHA512"),
            16 => write!(f, "NULL"),
            18 => write!(f, "SM3_256"),
            19 => write!(f, "SM4"),
            20 => write!(f, "RSASSA"),
            21 => write!(f, "RSAES"),
            22 => write!(f, "RSAPSS"),
            23 => write!(f, "OAEP"),
            24 => write!(f, "ECDSA"),
            25 => write!(f, "ECDH"),
            26 => write!(f, "ECDAA"),
            27 => write!(f, "SM2"),
            28 => write!(f, "ECSCHNORR"),
            29 => write!(f, "ECMQV"),
            32 => write!(f, "KDF1_SP800_56A"),
            33 => write!(f, "KDF2"),
            34 => write!(f, "KDF1_SP800_108"),
            35 => write!(f, "ECC"),
            37 => write!(f, "SYMCIPHER"),
            38 => write!(f, "CAMELLIA"),
            39 => write!(f, "SHA3_256"),
            40 => write!(f, "SHA3_384"),
            41 => write!(f, "SHA3_512"),
            63 => write!(f, "CMAC"),
            64 => write!(f, "CTR"),
            65 => write!(f, "OFB"),
            66 => write!(f, "CBC"),
            67 => write!(f, "CFB"),
            68 => write!(f, "One of <ECB, LAST>"),
            32767 => write!(f, "ANY"),
            32766 => write!(f, "ANY2"),
            _ => write!(f, "Unknown({:?})", self.0),
        }

    }

}

/// Table 4 is the list of identifiers for TCG-registered curve ID values for elliptic
/// curve cryptography.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, TryFromPrimitive, Default)]
#[repr(i16)]
pub enum TPM_ECC_CURVE {
    #[default]
    NONE = 0x0, // Original value: 0x0000
    NIST_P192 = 0x1, // Original value: 0x0001
    NIST_P224 = 0x2, // Original value: 0x0002
    NIST_P256 = 0x3, // Original value: 0x0003
    NIST_P384 = 0x4, // Original value: 0x0004
    NIST_P521 = 0x5, // Original value: 0x0005

    /// Curve to support ECDAA
    BN_P256 = 0x10, // Original value: 0x0010

    /// Curve to support ECDAA
    BN_P638 = 0x11, // Original value: 0x0011
    SM2_P256 = 0x20, // Original value: 0x0020
    TEST_P192 = 0x21 // Original value: 0x0021
}

impl TpmEnum for TPM_ECC_CURVE {
    fn get_value(&self) -> u32 {
        *self as u32
    }

}

impl From<TPM_ECC_CURVE> for u32 {
    fn from(value: TPM_ECC_CURVE) -> Self {
        value as u32
    }

}

impl From<TPM_ECC_CURVE> for i32 {
    fn from(value: TPM_ECC_CURVE) -> Self {
        value as i32
    }

}

impl fmt::Display for TPM_ECC_CURVE {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::NONE => write!(f, "NONE"),
            Self::NIST_P192 => write!(f, "NIST_P192"),
            Self::NIST_P224 => write!(f, "NIST_P224"),
            Self::NIST_P256 => write!(f, "NIST_P256"),
            Self::NIST_P384 => write!(f, "NIST_P384"),
            Self::NIST_P521 => write!(f, "NIST_P521"),
            Self::BN_P256 => write!(f, "BN_P256"),
            Self::BN_P638 => write!(f, "BN_P638"),
            Self::SM2_P256 => write!(f, "SM2_P256"),
            Self::TEST_P192 => write!(f, "TEST_P192"),
        }
    }
}

/// Table 13 Defines for SHA1 Hash Values
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, TryFromPrimitive, Default)]
#[repr(i32)]
pub enum SHA1 {
    #[default]

    /// Size of digest in octets
    DIGEST_SIZE = 0x14, // Original value: 20

    /// Size of hash block in octets
    BLOCK_SIZE = 0x40 // Original value: 64
}

impl TpmEnum for SHA1 {
    fn get_value(&self) -> u32 {
        *self as u32
    }

}

impl From<SHA1> for u32 {
    fn from(value: SHA1) -> Self {
        value as u32
    }

}

impl From<SHA1> for i32 {
    fn from(value: SHA1) -> Self {
        value as i32
    }

}

impl fmt::Display for SHA1 {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::DIGEST_SIZE => write!(f, "DIGEST_SIZE"),
            Self::BLOCK_SIZE => write!(f, "BLOCK_SIZE"),
        }
    }
}

/// Table 14 Defines for SHA256 Hash Values
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, TryFromPrimitive, Default)]
#[repr(i32)]
pub enum SHA256 {
    #[default]

    /// Size of digest
    DIGEST_SIZE = 0x20, // Original value: 32

    /// Size of hash block
    BLOCK_SIZE = 0x40 // Original value: 64
}

impl TpmEnum for SHA256 {
    fn get_value(&self) -> u32 {
        *self as u32
    }

}

impl From<SHA256> for u32 {
    fn from(value: SHA256) -> Self {
        value as u32
    }

}

impl From<SHA256> for i32 {
    fn from(value: SHA256) -> Self {
        value as i32
    }

}

impl fmt::Display for SHA256 {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::DIGEST_SIZE => write!(f, "DIGEST_SIZE"),
            Self::BLOCK_SIZE => write!(f, "BLOCK_SIZE"),
        }
    }
}

/// Table 15 Defines for SHA384 Hash Values
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, TryFromPrimitive, Default)]
#[repr(i32)]
pub enum SHA384 {
    #[default]

    /// Size of digest in octets
    DIGEST_SIZE = 0x30, // Original value: 48

    /// Size of hash block in octets
    BLOCK_SIZE = 0x80 // Original value: 128
}

impl TpmEnum for SHA384 {
    fn get_value(&self) -> u32 {
        *self as u32
    }

}

impl From<SHA384> for u32 {
    fn from(value: SHA384) -> Self {
        value as u32
    }

}

impl From<SHA384> for i32 {
    fn from(value: SHA384) -> Self {
        value as i32
    }

}

impl fmt::Display for SHA384 {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::DIGEST_SIZE => write!(f, "DIGEST_SIZE"),
            Self::BLOCK_SIZE => write!(f, "BLOCK_SIZE"),
        }
    }
}

/// Table 16 Defines for SHA512 Hash Values
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, TryFromPrimitive, Default)]
#[repr(i32)]
pub enum SHA512 {
    #[default]

    /// Size of digest in octets
    DIGEST_SIZE = 0x40, // Original value: 64

    /// Size of hash block in octets
    BLOCK_SIZE = 0x80 // Original value: 128
}

impl TpmEnum for SHA512 {
    fn get_value(&self) -> u32 {
        *self as u32
    }

}

impl From<SHA512> for u32 {
    fn from(value: SHA512) -> Self {
        value as u32
    }

}

impl From<SHA512> for i32 {
    fn from(value: SHA512) -> Self {
        value as i32
    }

}

impl fmt::Display for SHA512 {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::DIGEST_SIZE => write!(f, "DIGEST_SIZE"),
            Self::BLOCK_SIZE => write!(f, "BLOCK_SIZE"),
        }
    }
}

/// Table 17 Defines for SM3_256 Hash Values
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, TryFromPrimitive, Default)]
#[repr(i32)]
pub enum SM3_256 {
    #[default]

    /// Size of digest in octets
    DIGEST_SIZE = 0x20, // Original value: 32

    /// Size of hash block in octets
    BLOCK_SIZE = 0x40 // Original value: 64
}

impl TpmEnum for SM3_256 {
    fn get_value(&self) -> u32 {
        *self as u32
    }

}

impl From<SM3_256> for u32 {
    fn from(value: SM3_256) -> Self {
        value as u32
    }

}

impl From<SM3_256> for i32 {
    fn from(value: SM3_256) -> Self {
        value as i32
    }

}

impl fmt::Display for SM3_256 {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::DIGEST_SIZE => write!(f, "DIGEST_SIZE"),
            Self::BLOCK_SIZE => write!(f, "BLOCK_SIZE"),
        }
    }
}

/// Table 18 Defines for SHA3_256 Hash Values
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, TryFromPrimitive, Default)]
#[repr(i32)]
pub enum SHA3_256 {
    #[default]

    /// Size of digest in octets
    DIGEST_SIZE = 0x20, // Original value: 32

    /// Size of hash block in octets
    BLOCK_SIZE = 0x88 // Original value: 136
}

impl TpmEnum for SHA3_256 {
    fn get_value(&self) -> u32 {
        *self as u32
    }

}

impl From<SHA3_256> for u32 {
    fn from(value: SHA3_256) -> Self {
        value as u32
    }

}

impl From<SHA3_256> for i32 {
    fn from(value: SHA3_256) -> Self {
        value as i32
    }

}

impl fmt::Display for SHA3_256 {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::DIGEST_SIZE => write!(f, "DIGEST_SIZE"),
            Self::BLOCK_SIZE => write!(f, "BLOCK_SIZE"),
        }
    }
}

/// Table 19 Defines for SHA3_384 Hash Values
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, TryFromPrimitive, Default)]
#[repr(i32)]
pub enum SHA3_384 {
    #[default]

    /// Size of digest in octets
    DIGEST_SIZE = 0x30, // Original value: 48

    /// Size of hash block in octets
    BLOCK_SIZE = 0x68 // Original value: 104
}

impl TpmEnum for SHA3_384 {
    fn get_value(&self) -> u32 {
        *self as u32
    }

}

impl From<SHA3_384> for u32 {
    fn from(value: SHA3_384) -> Self {
        value as u32
    }

}

impl From<SHA3_384> for i32 {
    fn from(value: SHA3_384) -> Self {
        value as i32
    }

}

impl fmt::Display for SHA3_384 {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::DIGEST_SIZE => write!(f, "DIGEST_SIZE"),
            Self::BLOCK_SIZE => write!(f, "BLOCK_SIZE"),
        }
    }
}

/// Table 20 Defines for SHA3_512 Hash Values
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, TryFromPrimitive, Default)]
#[repr(i32)]
pub enum SHA3_512 {
    #[default]

    /// Size of digest in octets
    DIGEST_SIZE = 0x40, // Original value: 64

    /// Size of hash block in octets
    BLOCK_SIZE = 0x48 // Original value: 72
}

impl TpmEnum for SHA3_512 {
    fn get_value(&self) -> u32 {
        *self as u32
    }

}

impl From<SHA3_512> for u32 {
    fn from(value: SHA3_512) -> Self {
        value as u32
    }

}

impl From<SHA3_512> for i32 {
    fn from(value: SHA3_512) -> Self {
        value as i32
    }

}

impl fmt::Display for SHA3_512 {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::DIGEST_SIZE => write!(f, "DIGEST_SIZE"),
            Self::BLOCK_SIZE => write!(f, "BLOCK_SIZE"),
        }
    }
}

/// Table 4 Defines for Logic Values

/// Enum with duplicated values - using struct with constants
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Default)]
pub struct Logic(pub u8);

impl Logic {
    pub const TRUE: Self = Self(0x1); // Original value: 1
    pub const FALSE: Self = Self(0x0); // Original value: 0
    pub const YES: Self = Self(0x1); // Original value: 1
    pub const NO: Self = Self(0x0); // Original value: 0
    pub const SET: Self = Self(0x1); // Original value: 1
    pub const CLEAR: Self = Self(0x0); // Original value: 0

    pub fn try_from(value: i8) -> Result<Self, TpmError> {
        match value {
            1 => Ok(Self::TRUE), // Original value: 1
            0 => Ok(Self::FALSE), // Original value: 0
            _ => Err(TpmError::InvalidEnumValue),
        }

    }

}

impl TpmEnum for Logic {
    fn get_value(&self) -> u32 {
        self.0.into()
    }

}

impl From<Logic> for u32 {
    fn from(value: Logic) -> Self {
        value.0.into()
    }
}

impl From<Logic> for i32 {
    fn from(value: Logic) -> Self {
        value.0 as i32
    }
}

impl fmt::Display for Logic {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self.0 {
            1 => write!(f, "One of <TRUE, YES, SET>"),
            0 => write!(f, "One of <FALSE, NO, CLEAR>"),
            _ => write!(f, "Unknown({:?})", self.0),
        }

    }

}

/// These values are readable with TPM2_GetCapability() (see 6.13 for the format).
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, TryFromPrimitive, Default)]
#[repr(i32)]
pub enum TPM_SPEC {
    #[default]

    /// ASCII 2.0 with null terminator
    FAMILY = 0x322E3000,

    /// The level number for the specification
    LEVEL = 0x0, // Original value: 0

    /// The version number of the spec (001.62 * 100)
    VERSION = 0xA2, // Original value: 162

    /// The year of the version
    YEAR = 0x7E3, // Original value: 2019

    /// The day of the year (December 26)
    DAY_OF_YEAR = 0x168 // Original value: 360
}

impl TpmEnum for TPM_SPEC {
    fn get_value(&self) -> u32 {
        *self as u32
    }

}

impl From<TPM_SPEC> for u32 {
    fn from(value: TPM_SPEC) -> Self {
        value as u32
    }

}

impl From<TPM_SPEC> for i32 {
    fn from(value: TPM_SPEC) -> Self {
        value as i32
    }

}

impl fmt::Display for TPM_SPEC {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::FAMILY => write!(f, "FAMILY"),
            Self::LEVEL => write!(f, "LEVEL"),
            Self::VERSION => write!(f, "VERSION"),
            Self::YEAR => write!(f, "YEAR"),
            Self::DAY_OF_YEAR => write!(f, "DAY_OF_YEAR"),
        }
    }
}

/// This constant value differentiates TPM-generated structures from non-TPM structures.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, TryFromPrimitive, Default)]
#[repr(i32)]
pub enum TPM_GENERATED {
    #[default]

    /// 0xFF TCG (FF 54 43 4716)
    VALUE = 0xFF544347 // Original value: 0xff544347
}

impl TpmEnum for TPM_GENERATED {
    fn get_value(&self) -> u32 {
        *self as u32
    }

}

impl From<TPM_GENERATED> for u32 {
    fn from(value: TPM_GENERATED) -> Self {
        value as u32
    }

}

impl From<TPM_GENERATED> for i32 {
    fn from(value: TPM_GENERATED) -> Self {
        value as i32
    }

}

impl fmt::Display for TPM_GENERATED {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::VALUE => write!(f, "VALUE"),
        }
    }
}

/// Enum with duplicated values - using struct with constants
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Default)]
pub struct TPM_CC(pub u32);

impl TPM_CC {
    /// Compile variable. May decrease based on implementation.
    pub const FIRST: Self = Self(0x11F); // Original value: 0x0000011F
    pub const NV_UndefineSpaceSpecial: Self = Self(0x11F); // Original value: 0x0000011F
    pub const EvictControl: Self = Self(0x120); // Original value: 0x00000120
    pub const HierarchyControl: Self = Self(0x121); // Original value: 0x00000121
    pub const NV_UndefineSpace: Self = Self(0x122); // Original value: 0x00000122
    pub const ChangeEPS: Self = Self(0x124); // Original value: 0x00000124
    pub const ChangePPS: Self = Self(0x125); // Original value: 0x00000125
    pub const Clear: Self = Self(0x126); // Original value: 0x00000126
    pub const ClearControl: Self = Self(0x127); // Original value: 0x00000127
    pub const ClockSet: Self = Self(0x128); // Original value: 0x00000128
    pub const HierarchyChangeAuth: Self = Self(0x129); // Original value: 0x00000129
    pub const NV_DefineSpace: Self = Self(0x12A); // Original value: 0x0000012A
    pub const PCR_Allocate: Self = Self(0x12B); // Original value: 0x0000012B
    pub const PCR_SetAuthPolicy: Self = Self(0x12C); // Original value: 0x0000012C
    pub const PP_Commands: Self = Self(0x12D); // Original value: 0x0000012D
    pub const SetPrimaryPolicy: Self = Self(0x12E); // Original value: 0x0000012E
    pub const FieldUpgradeStart: Self = Self(0x12F); // Original value: 0x0000012F
    pub const ClockRateAdjust: Self = Self(0x130); // Original value: 0x00000130
    pub const CreatePrimary: Self = Self(0x131); // Original value: 0x00000131
    pub const NV_GlobalWriteLock: Self = Self(0x132); // Original value: 0x00000132
    pub const GetCommandAuditDigest: Self = Self(0x133); // Original value: 0x00000133
    pub const NV_Increment: Self = Self(0x134); // Original value: 0x00000134
    pub const NV_SetBits: Self = Self(0x135); // Original value: 0x00000135
    pub const NV_Extend: Self = Self(0x136); // Original value: 0x00000136
    pub const NV_Write: Self = Self(0x137); // Original value: 0x00000137
    pub const NV_WriteLock: Self = Self(0x138); // Original value: 0x00000138
    pub const DictionaryAttackLockReset: Self = Self(0x139); // Original value: 0x00000139
    pub const DictionaryAttackParameters: Self = Self(0x13A); // Original value: 0x0000013A
    pub const NV_ChangeAuth: Self = Self(0x13B); // Original value: 0x0000013B

    /// PCR
    pub const PCR_Event: Self = Self(0x13C); // Original value: 0x0000013C

    /// PCR
    pub const PCR_Reset: Self = Self(0x13D); // Original value: 0x0000013D
    pub const SequenceComplete: Self = Self(0x13E); // Original value: 0x0000013E
    pub const SetAlgorithmSet: Self = Self(0x13F); // Original value: 0x0000013F
    pub const SetCommandCodeAuditStatus: Self = Self(0x140); // Original value: 0x00000140
    pub const FieldUpgradeData: Self = Self(0x141); // Original value: 0x00000141
    pub const IncrementalSelfTest: Self = Self(0x142); // Original value: 0x00000142
    pub const SelfTest: Self = Self(0x143); // Original value: 0x00000143
    pub const Startup: Self = Self(0x144); // Original value: 0x00000144
    pub const Shutdown: Self = Self(0x145); // Original value: 0x00000145
    pub const StirRandom: Self = Self(0x146); // Original value: 0x00000146
    pub const ActivateCredential: Self = Self(0x147); // Original value: 0x00000147
    pub const Certify: Self = Self(0x148); // Original value: 0x00000148

    /// Policy
    pub const PolicyNV: Self = Self(0x149); // Original value: 0x00000149
    pub const CertifyCreation: Self = Self(0x14A); // Original value: 0x0000014A
    pub const Duplicate: Self = Self(0x14B); // Original value: 0x0000014B
    pub const GetTime: Self = Self(0x14C); // Original value: 0x0000014C
    pub const GetSessionAuditDigest: Self = Self(0x14D); // Original value: 0x0000014D
    pub const NV_Read: Self = Self(0x14E); // Original value: 0x0000014E
    pub const NV_ReadLock: Self = Self(0x14F); // Original value: 0x0000014F
    pub const ObjectChangeAuth: Self = Self(0x150); // Original value: 0x00000150

    /// Policy
    pub const PolicySecret: Self = Self(0x151); // Original value: 0x00000151
    pub const Rewrap: Self = Self(0x152); // Original value: 0x00000152
    pub const Create: Self = Self(0x153); // Original value: 0x00000153
    pub const ECDH_ZGen: Self = Self(0x154); // Original value: 0x00000154

    /// See NOTE 1
    pub const HMAC: Self = Self(0x155); // Original value: 0x00000155

    /// See NOTE 1
    pub const MAC: Self = Self(0x155); // Original value: 0x00000155
    pub const Import: Self = Self(0x156); // Original value: 0x00000156
    pub const Load: Self = Self(0x157); // Original value: 0x00000157
    pub const Quote: Self = Self(0x158); // Original value: 0x00000158
    pub const RSA_Decrypt: Self = Self(0x159); // Original value: 0x00000159

    /// See NOTE 1
    pub const HMAC_Start: Self = Self(0x15B); // Original value: 0x0000015B

    /// See NOTE 1
    pub const MAC_Start: Self = Self(0x15B); // Original value: 0x0000015B
    pub const SequenceUpdate: Self = Self(0x15C); // Original value: 0x0000015C
    pub const Sign: Self = Self(0x15D); // Original value: 0x0000015D
    pub const Unseal: Self = Self(0x15E); // Original value: 0x0000015E

    /// Policy
    pub const PolicySigned: Self = Self(0x160); // Original value: 0x00000160

    /// Context
    pub const ContextLoad: Self = Self(0x161); // Original value: 0x00000161

    /// Context
    pub const ContextSave: Self = Self(0x162); // Original value: 0x00000162
    pub const ECDH_KeyGen: Self = Self(0x163); // Original value: 0x00000163
    pub const EncryptDecrypt: Self = Self(0x164); // Original value: 0x00000164

    /// Context
    pub const FlushContext: Self = Self(0x165); // Original value: 0x00000165
    pub const LoadExternal: Self = Self(0x167); // Original value: 0x00000167
    pub const MakeCredential: Self = Self(0x168); // Original value: 0x00000168

    /// NV
    pub const NV_ReadPublic: Self = Self(0x169); // Original value: 0x00000169

    /// Policy
    pub const PolicyAuthorize: Self = Self(0x16A); // Original value: 0x0000016A

    /// Policy
    pub const PolicyAuthValue: Self = Self(0x16B); // Original value: 0x0000016B

    /// Policy
    pub const PolicyCommandCode: Self = Self(0x16C); // Original value: 0x0000016C

    /// Policy
    pub const PolicyCounterTimer: Self = Self(0x16D); // Original value: 0x0000016D

    /// Policy
    pub const PolicyCpHash: Self = Self(0x16E); // Original value: 0x0000016E

    /// Policy
    pub const PolicyLocality: Self = Self(0x16F); // Original value: 0x0000016F

    /// Policy
    pub const PolicyNameHash: Self = Self(0x170); // Original value: 0x00000170

    /// Policy
    pub const PolicyOR: Self = Self(0x171); // Original value: 0x00000171

    /// Policy
    pub const PolicyTicket: Self = Self(0x172); // Original value: 0x00000172
    pub const ReadPublic: Self = Self(0x173); // Original value: 0x00000173
    pub const RSA_Encrypt: Self = Self(0x174); // Original value: 0x00000174
    pub const StartAuthSession: Self = Self(0x176); // Original value: 0x00000176
    pub const VerifySignature: Self = Self(0x177); // Original value: 0x00000177
    pub const ECC_Parameters: Self = Self(0x178); // Original value: 0x00000178
    pub const FirmwareRead: Self = Self(0x179); // Original value: 0x00000179
    pub const GetCapability: Self = Self(0x17A); // Original value: 0x0000017A
    pub const GetRandom: Self = Self(0x17B); // Original value: 0x0000017B
    pub const GetTestResult: Self = Self(0x17C); // Original value: 0x0000017C
    pub const Hash: Self = Self(0x17D); // Original value: 0x0000017D

    /// PCR
    pub const PCR_Read: Self = Self(0x17E); // Original value: 0x0000017E

    /// Policy
    pub const PolicyPCR: Self = Self(0x17F); // Original value: 0x0000017F
    pub const PolicyRestart: Self = Self(0x180); // Original value: 0x00000180
    pub const ReadClock: Self = Self(0x181); // Original value: 0x00000181
    pub const PCR_Extend: Self = Self(0x182); // Original value: 0x00000182
    pub const PCR_SetAuthValue: Self = Self(0x183); // Original value: 0x00000183
    pub const NV_Certify: Self = Self(0x184); // Original value: 0x00000184
    pub const EventSequenceComplete: Self = Self(0x185); // Original value: 0x00000185
    pub const HashSequenceStart: Self = Self(0x186); // Original value: 0x00000186

    /// Policy
    pub const PolicyPhysicalPresence: Self = Self(0x187); // Original value: 0x00000187

    /// Policy
    pub const PolicyDuplicationSelect: Self = Self(0x188); // Original value: 0x00000188

    /// Policy
    pub const PolicyGetDigest: Self = Self(0x189); // Original value: 0x00000189
    pub const TestParms: Self = Self(0x18A); // Original value: 0x0000018A
    pub const Commit: Self = Self(0x18B); // Original value: 0x0000018B

    /// Policy
    pub const PolicyPassword: Self = Self(0x18C); // Original value: 0x0000018C
    pub const ZGen_2Phase: Self = Self(0x18D); // Original value: 0x0000018D
    pub const EC_Ephemeral: Self = Self(0x18E); // Original value: 0x0000018E

    /// Policy
    pub const PolicyNvWritten: Self = Self(0x18F); // Original value: 0x0000018F

    /// Policy
    pub const PolicyTemplate: Self = Self(0x190); // Original value: 0x00000190
    pub const CreateLoaded: Self = Self(0x191); // Original value: 0x00000191

    /// Policy
    pub const PolicyAuthorizeNV: Self = Self(0x192); // Original value: 0x00000192
    pub const EncryptDecrypt2: Self = Self(0x193); // Original value: 0x00000193
    pub const AC_GetCapability: Self = Self(0x194); // Original value: 0x00000194
    pub const AC_Send: Self = Self(0x195); // Original value: 0x00000195

    /// Policy
    pub const Policy_AC_SendSelect: Self = Self(0x196); // Original value: 0x00000196
    pub const CertifyX509: Self = Self(0x197); // Original value: 0x00000197
    pub const ACT_SetTimeout: Self = Self(0x198); // Original value: 0x00000198
    pub const ECC_Encrypt: Self = Self(0x199); // Original value: 0x00000199
    pub const ECC_Decrypt: Self = Self(0x19A); // Original value: 0x0000019A

    /// Compile variable. May increase based on implementation.
    pub const LAST: Self = Self(0x19A); // Original value: 0x0000019A
    pub const CC_VEND: Self = Self(0x20000000);

    /// Used for testing of command dispatch
    pub const Vendor_TCG_Test: Self = Self(0x20000000); // Original value: CC_VEND+0x0000

    pub fn try_from(value: i32) -> Result<Self, TpmError> {
        match value {
            287 => Ok(Self::FIRST), // Original value: 0x0000011F
            288 => Ok(Self::EvictControl), // Original value: 0x00000120
            289 => Ok(Self::HierarchyControl), // Original value: 0x00000121
            290 => Ok(Self::NV_UndefineSpace), // Original value: 0x00000122
            292 => Ok(Self::ChangeEPS), // Original value: 0x00000124
            293 => Ok(Self::ChangePPS), // Original value: 0x00000125
            294 => Ok(Self::Clear), // Original value: 0x00000126
            295 => Ok(Self::ClearControl), // Original value: 0x00000127
            296 => Ok(Self::ClockSet), // Original value: 0x00000128
            297 => Ok(Self::HierarchyChangeAuth), // Original value: 0x00000129
            298 => Ok(Self::NV_DefineSpace), // Original value: 0x0000012A
            299 => Ok(Self::PCR_Allocate), // Original value: 0x0000012B
            300 => Ok(Self::PCR_SetAuthPolicy), // Original value: 0x0000012C
            301 => Ok(Self::PP_Commands), // Original value: 0x0000012D
            302 => Ok(Self::SetPrimaryPolicy), // Original value: 0x0000012E
            303 => Ok(Self::FieldUpgradeStart), // Original value: 0x0000012F
            304 => Ok(Self::ClockRateAdjust), // Original value: 0x00000130
            305 => Ok(Self::CreatePrimary), // Original value: 0x00000131
            306 => Ok(Self::NV_GlobalWriteLock), // Original value: 0x00000132
            307 => Ok(Self::GetCommandAuditDigest), // Original value: 0x00000133
            308 => Ok(Self::NV_Increment), // Original value: 0x00000134
            309 => Ok(Self::NV_SetBits), // Original value: 0x00000135
            310 => Ok(Self::NV_Extend), // Original value: 0x00000136
            311 => Ok(Self::NV_Write), // Original value: 0x00000137
            312 => Ok(Self::NV_WriteLock), // Original value: 0x00000138
            313 => Ok(Self::DictionaryAttackLockReset), // Original value: 0x00000139
            314 => Ok(Self::DictionaryAttackParameters), // Original value: 0x0000013A
            315 => Ok(Self::NV_ChangeAuth), // Original value: 0x0000013B
            316 => Ok(Self::PCR_Event), // Original value: 0x0000013C
            317 => Ok(Self::PCR_Reset), // Original value: 0x0000013D
            318 => Ok(Self::SequenceComplete), // Original value: 0x0000013E
            319 => Ok(Self::SetAlgorithmSet), // Original value: 0x0000013F
            320 => Ok(Self::SetCommandCodeAuditStatus), // Original value: 0x00000140
            321 => Ok(Self::FieldUpgradeData), // Original value: 0x00000141
            322 => Ok(Self::IncrementalSelfTest), // Original value: 0x00000142
            323 => Ok(Self::SelfTest), // Original value: 0x00000143
            324 => Ok(Self::Startup), // Original value: 0x00000144
            325 => Ok(Self::Shutdown), // Original value: 0x00000145
            326 => Ok(Self::StirRandom), // Original value: 0x00000146
            327 => Ok(Self::ActivateCredential), // Original value: 0x00000147
            328 => Ok(Self::Certify), // Original value: 0x00000148
            329 => Ok(Self::PolicyNV), // Original value: 0x00000149
            330 => Ok(Self::CertifyCreation), // Original value: 0x0000014A
            331 => Ok(Self::Duplicate), // Original value: 0x0000014B
            332 => Ok(Self::GetTime), // Original value: 0x0000014C
            333 => Ok(Self::GetSessionAuditDigest), // Original value: 0x0000014D
            334 => Ok(Self::NV_Read), // Original value: 0x0000014E
            335 => Ok(Self::NV_ReadLock), // Original value: 0x0000014F
            336 => Ok(Self::ObjectChangeAuth), // Original value: 0x00000150
            337 => Ok(Self::PolicySecret), // Original value: 0x00000151
            338 => Ok(Self::Rewrap), // Original value: 0x00000152
            339 => Ok(Self::Create), // Original value: 0x00000153
            340 => Ok(Self::ECDH_ZGen), // Original value: 0x00000154
            341 => Ok(Self::HMAC), // Original value: 0x00000155
            342 => Ok(Self::Import), // Original value: 0x00000156
            343 => Ok(Self::Load), // Original value: 0x00000157
            344 => Ok(Self::Quote), // Original value: 0x00000158
            345 => Ok(Self::RSA_Decrypt), // Original value: 0x00000159
            347 => Ok(Self::HMAC_Start), // Original value: 0x0000015B
            348 => Ok(Self::SequenceUpdate), // Original value: 0x0000015C
            349 => Ok(Self::Sign), // Original value: 0x0000015D
            350 => Ok(Self::Unseal), // Original value: 0x0000015E
            352 => Ok(Self::PolicySigned), // Original value: 0x00000160
            353 => Ok(Self::ContextLoad), // Original value: 0x00000161
            354 => Ok(Self::ContextSave), // Original value: 0x00000162
            355 => Ok(Self::ECDH_KeyGen), // Original value: 0x00000163
            356 => Ok(Self::EncryptDecrypt), // Original value: 0x00000164
            357 => Ok(Self::FlushContext), // Original value: 0x00000165
            359 => Ok(Self::LoadExternal), // Original value: 0x00000167
            360 => Ok(Self::MakeCredential), // Original value: 0x00000168
            361 => Ok(Self::NV_ReadPublic), // Original value: 0x00000169
            362 => Ok(Self::PolicyAuthorize), // Original value: 0x0000016A
            363 => Ok(Self::PolicyAuthValue), // Original value: 0x0000016B
            364 => Ok(Self::PolicyCommandCode), // Original value: 0x0000016C
            365 => Ok(Self::PolicyCounterTimer), // Original value: 0x0000016D
            366 => Ok(Self::PolicyCpHash), // Original value: 0x0000016E
            367 => Ok(Self::PolicyLocality), // Original value: 0x0000016F
            368 => Ok(Self::PolicyNameHash), // Original value: 0x00000170
            369 => Ok(Self::PolicyOR), // Original value: 0x00000171
            370 => Ok(Self::PolicyTicket), // Original value: 0x00000172
            371 => Ok(Self::ReadPublic), // Original value: 0x00000173
            372 => Ok(Self::RSA_Encrypt), // Original value: 0x00000174
            374 => Ok(Self::StartAuthSession), // Original value: 0x00000176
            375 => Ok(Self::VerifySignature), // Original value: 0x00000177
            376 => Ok(Self::ECC_Parameters), // Original value: 0x00000178
            377 => Ok(Self::FirmwareRead), // Original value: 0x00000179
            378 => Ok(Self::GetCapability), // Original value: 0x0000017A
            379 => Ok(Self::GetRandom), // Original value: 0x0000017B
            380 => Ok(Self::GetTestResult), // Original value: 0x0000017C
            381 => Ok(Self::Hash), // Original value: 0x0000017D
            382 => Ok(Self::PCR_Read), // Original value: 0x0000017E
            383 => Ok(Self::PolicyPCR), // Original value: 0x0000017F
            384 => Ok(Self::PolicyRestart), // Original value: 0x00000180
            385 => Ok(Self::ReadClock), // Original value: 0x00000181
            386 => Ok(Self::PCR_Extend), // Original value: 0x00000182
            387 => Ok(Self::PCR_SetAuthValue), // Original value: 0x00000183
            388 => Ok(Self::NV_Certify), // Original value: 0x00000184
            389 => Ok(Self::EventSequenceComplete), // Original value: 0x00000185
            390 => Ok(Self::HashSequenceStart), // Original value: 0x00000186
            391 => Ok(Self::PolicyPhysicalPresence), // Original value: 0x00000187
            392 => Ok(Self::PolicyDuplicationSelect), // Original value: 0x00000188
            393 => Ok(Self::PolicyGetDigest), // Original value: 0x00000189
            394 => Ok(Self::TestParms), // Original value: 0x0000018A
            395 => Ok(Self::Commit), // Original value: 0x0000018B
            396 => Ok(Self::PolicyPassword), // Original value: 0x0000018C
            397 => Ok(Self::ZGen_2Phase), // Original value: 0x0000018D
            398 => Ok(Self::EC_Ephemeral), // Original value: 0x0000018E
            399 => Ok(Self::PolicyNvWritten), // Original value: 0x0000018F
            400 => Ok(Self::PolicyTemplate), // Original value: 0x00000190
            401 => Ok(Self::CreateLoaded), // Original value: 0x00000191
            402 => Ok(Self::PolicyAuthorizeNV), // Original value: 0x00000192
            403 => Ok(Self::EncryptDecrypt2), // Original value: 0x00000193
            404 => Ok(Self::AC_GetCapability), // Original value: 0x00000194
            405 => Ok(Self::AC_Send), // Original value: 0x00000195
            406 => Ok(Self::Policy_AC_SendSelect), // Original value: 0x00000196
            407 => Ok(Self::CertifyX509), // Original value: 0x00000197
            408 => Ok(Self::ACT_SetTimeout), // Original value: 0x00000198
            409 => Ok(Self::ECC_Encrypt), // Original value: 0x00000199
            410 => Ok(Self::ECC_Decrypt), // Original value: 0x0000019A
            536870912 => Ok(Self::CC_VEND), // Original value: 0x20000000
            _ => Err(TpmError::InvalidEnumValue),
        }

    }

}

impl TpmEnum for TPM_CC {
    fn get_value(&self) -> u32 {
        self.0.into()
    }

}

impl From<TPM_CC> for u32 {
    fn from(value: TPM_CC) -> Self {
        value.0.into()
    }
}

impl From<TPM_CC> for i32 {
    fn from(value: TPM_CC) -> Self {
        value.0 as i32
    }
}

impl fmt::Display for TPM_CC {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self.0 {
            287 => write!(f, "One of <FIRST, NV_UndefineSpaceSpecial>"),
            288 => write!(f, "EvictControl"),
            289 => write!(f, "HierarchyControl"),
            290 => write!(f, "NV_UndefineSpace"),
            292 => write!(f, "ChangeEPS"),
            293 => write!(f, "ChangePPS"),
            294 => write!(f, "Clear"),
            295 => write!(f, "ClearControl"),
            296 => write!(f, "ClockSet"),
            297 => write!(f, "HierarchyChangeAuth"),
            298 => write!(f, "NV_DefineSpace"),
            299 => write!(f, "PCR_Allocate"),
            300 => write!(f, "PCR_SetAuthPolicy"),
            301 => write!(f, "PP_Commands"),
            302 => write!(f, "SetPrimaryPolicy"),
            303 => write!(f, "FieldUpgradeStart"),
            304 => write!(f, "ClockRateAdjust"),
            305 => write!(f, "CreatePrimary"),
            306 => write!(f, "NV_GlobalWriteLock"),
            307 => write!(f, "GetCommandAuditDigest"),
            308 => write!(f, "NV_Increment"),
            309 => write!(f, "NV_SetBits"),
            310 => write!(f, "NV_Extend"),
            311 => write!(f, "NV_Write"),
            312 => write!(f, "NV_WriteLock"),
            313 => write!(f, "DictionaryAttackLockReset"),
            314 => write!(f, "DictionaryAttackParameters"),
            315 => write!(f, "NV_ChangeAuth"),
            316 => write!(f, "PCR_Event"),
            317 => write!(f, "PCR_Reset"),
            318 => write!(f, "SequenceComplete"),
            319 => write!(f, "SetAlgorithmSet"),
            320 => write!(f, "SetCommandCodeAuditStatus"),
            321 => write!(f, "FieldUpgradeData"),
            322 => write!(f, "IncrementalSelfTest"),
            323 => write!(f, "SelfTest"),
            324 => write!(f, "Startup"),
            325 => write!(f, "Shutdown"),
            326 => write!(f, "StirRandom"),
            327 => write!(f, "ActivateCredential"),
            328 => write!(f, "Certify"),
            329 => write!(f, "PolicyNV"),
            330 => write!(f, "CertifyCreation"),
            331 => write!(f, "Duplicate"),
            332 => write!(f, "GetTime"),
            333 => write!(f, "GetSessionAuditDigest"),
            334 => write!(f, "NV_Read"),
            335 => write!(f, "NV_ReadLock"),
            336 => write!(f, "ObjectChangeAuth"),
            337 => write!(f, "PolicySecret"),
            338 => write!(f, "Rewrap"),
            339 => write!(f, "Create"),
            340 => write!(f, "ECDH_ZGen"),
            341 => write!(f, "One of <HMAC, MAC>"),
            342 => write!(f, "Import"),
            343 => write!(f, "Load"),
            344 => write!(f, "Quote"),
            345 => write!(f, "RSA_Decrypt"),
            347 => write!(f, "One of <HMAC_Start, MAC_Start>"),
            348 => write!(f, "SequenceUpdate"),
            349 => write!(f, "Sign"),
            350 => write!(f, "Unseal"),
            352 => write!(f, "PolicySigned"),
            353 => write!(f, "ContextLoad"),
            354 => write!(f, "ContextSave"),
            355 => write!(f, "ECDH_KeyGen"),
            356 => write!(f, "EncryptDecrypt"),
            357 => write!(f, "FlushContext"),
            359 => write!(f, "LoadExternal"),
            360 => write!(f, "MakeCredential"),
            361 => write!(f, "NV_ReadPublic"),
            362 => write!(f, "PolicyAuthorize"),
            363 => write!(f, "PolicyAuthValue"),
            364 => write!(f, "PolicyCommandCode"),
            365 => write!(f, "PolicyCounterTimer"),
            366 => write!(f, "PolicyCpHash"),
            367 => write!(f, "PolicyLocality"),
            368 => write!(f, "PolicyNameHash"),
            369 => write!(f, "PolicyOR"),
            370 => write!(f, "PolicyTicket"),
            371 => write!(f, "ReadPublic"),
            372 => write!(f, "RSA_Encrypt"),
            374 => write!(f, "StartAuthSession"),
            375 => write!(f, "VerifySignature"),
            376 => write!(f, "ECC_Parameters"),
            377 => write!(f, "FirmwareRead"),
            378 => write!(f, "GetCapability"),
            379 => write!(f, "GetRandom"),
            380 => write!(f, "GetTestResult"),
            381 => write!(f, "Hash"),
            382 => write!(f, "PCR_Read"),
            383 => write!(f, "PolicyPCR"),
            384 => write!(f, "PolicyRestart"),
            385 => write!(f, "ReadClock"),
            386 => write!(f, "PCR_Extend"),
            387 => write!(f, "PCR_SetAuthValue"),
            388 => write!(f, "NV_Certify"),
            389 => write!(f, "EventSequenceComplete"),
            390 => write!(f, "HashSequenceStart"),
            391 => write!(f, "PolicyPhysicalPresence"),
            392 => write!(f, "PolicyDuplicationSelect"),
            393 => write!(f, "PolicyGetDigest"),
            394 => write!(f, "TestParms"),
            395 => write!(f, "Commit"),
            396 => write!(f, "PolicyPassword"),
            397 => write!(f, "ZGen_2Phase"),
            398 => write!(f, "EC_Ephemeral"),
            399 => write!(f, "PolicyNvWritten"),
            400 => write!(f, "PolicyTemplate"),
            401 => write!(f, "CreateLoaded"),
            402 => write!(f, "PolicyAuthorizeNV"),
            403 => write!(f, "EncryptDecrypt2"),
            404 => write!(f, "AC_GetCapability"),
            405 => write!(f, "AC_Send"),
            406 => write!(f, "Policy_AC_SendSelect"),
            407 => write!(f, "CertifyX509"),
            408 => write!(f, "ACT_SetTimeout"),
            409 => write!(f, "ECC_Encrypt"),
            410 => write!(f, "One of <ECC_Decrypt, LAST>"),
            536870912 => write!(f, "One of <CC_VEND, Vendor_TCG_Test>"),
            _ => write!(f, "Unknown({:?})", self.0),
        }

    }

}

/// Architecturally defined constants

/// Enum with duplicated values - using struct with constants
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Default)]
pub struct ImplementationConstants(pub u32);

impl ImplementationConstants {
    pub const Ossl: Self = Self(0x1); // Original value: 1
    pub const Ltc: Self = Self(0x2); // Original value: 2
    pub const Msbn: Self = Self(0x3); // Original value: 3
    pub const Symcrypt: Self = Self(0x4); // Original value: 4
    pub const HASH_COUNT: Self = Self(0x3); // Original value: 3
    pub const MAX_SYM_KEY_BITS: Self = Self(0x100); // Original value: 256
    pub const MAX_SYM_KEY_BYTES: Self = Self(0x20); // Original value: ((MAX_SYM_KEY_BITS + 7) / 8)
    pub const MAX_SYM_BLOCK_SIZE: Self = Self(0x10); // Original value: 16
    pub const MAX_CAP_CC: Self = Self(0x19A); // Original value: TPM_CC::LAST
    pub const MAX_RSA_KEY_BYTES: Self = Self(0x100); // Original value: 256
    pub const MAX_AES_KEY_BYTES: Self = Self(0x20); // Original value: 32
    pub const MAX_ECC_KEY_BYTES: Self = Self(0x30); // Original value: 48
    pub const LABEL_MAX_BUFFER: Self = Self(0x20); // Original value: 32
    pub const _TPM_CAP_SIZE: Self = Self(0x4); // Original value: 0x4 /* sizeof(UINT32) */
    pub const MAX_CAP_DATA: Self = Self(0x3F8); // Original value: (Implementation::MAX_CAP_BUFFER-_TPM_CAP_SIZE-0x4) /* (MAX_CAP_BUFFER-_TPM_CAP_SIZE-sizeof(UINT32)) */
    pub const MAX_CAP_ALGS: Self = Self(0xA9); // Original value: (MAX_CAP_DATA / 0x6) /* (MAX_CAP_DATA / sizeof(TPMS_ALG_PROPERTY)) */
    pub const MAX_CAP_HANDLES: Self = Self(0xFE); // Original value: (MAX_CAP_DATA / 0x4) /* (MAX_CAP_DATA / sizeof(TPM_HANDLE)) */
    pub const MAX_TPM_PROPERTIES: Self = Self(0x7F); // Original value: (MAX_CAP_DATA / 0x8) /* (MAX_CAP_DATA / sizeof(TPMS_TAGGED_PROPERTY)) */
    pub const MAX_PCR_PROPERTIES: Self = Self(0xCB); // Original value: (MAX_CAP_DATA / 0x5) /* (MAX_CAP_DATA / sizeof(TPMS_TAGGED_PCR_SELECT)) */
    pub const MAX_ECC_CURVES: Self = Self(0x1FC); // Original value: (MAX_CAP_DATA / 0x2) /* (MAX_CAP_DATA / sizeof(TPM_ECC_CURVE)) */
    pub const MAX_TAGGED_POLICIES: Self = Self(0xE); // Original value: (MAX_CAP_DATA / 0x46) /* (MAX_CAP_DATA / sizeof(TPMS_TAGGED_POLICY)) */
    pub const MAX_AC_CAPABILITIES: Self = Self(0x7F); // Original value: (MAX_CAP_DATA / 0x8) /* (MAX_CAP_DATA / sizeof(TPMS_AC_OUTPUT)) */
    pub const MAX_ACT_DATA: Self = Self(0x54); // Original value: MAX_CAP_DATA / 0xC /* MAX_CAP_DATA / sizeof(TPMS_ACT_DATA) */

    pub fn try_from(value: i32) -> Result<Self, TpmError> {
        match value {
            1 => Ok(Self::Ossl), // Original value: 1
            2 => Ok(Self::Ltc), // Original value: 2
            3 => Ok(Self::Msbn), // Original value: 3
            4 => Ok(Self::Symcrypt), // Original value: 4
            256 => Ok(Self::MAX_SYM_KEY_BITS), // Original value: 256
            32 => Ok(Self::MAX_SYM_KEY_BYTES), // Original value: ((MAX_SYM_KEY_BITS + 7) / 8)
            16 => Ok(Self::MAX_SYM_BLOCK_SIZE), // Original value: 16
            410 => Ok(Self::MAX_CAP_CC), // Original value: TPM_CC::LAST
            48 => Ok(Self::MAX_ECC_KEY_BYTES), // Original value: 48
            1016 => Ok(Self::MAX_CAP_DATA), // Original value: (Implementation::MAX_CAP_BUFFER-_TPM_CAP_SIZE-0x4) /* (MAX_CAP_BUFFER-_TPM_CAP_SIZE-sizeof(UINT32)) */
            169 => Ok(Self::MAX_CAP_ALGS), // Original value: (MAX_CAP_DATA / 0x6) /* (MAX_CAP_DATA / sizeof(TPMS_ALG_PROPERTY)) */
            254 => Ok(Self::MAX_CAP_HANDLES), // Original value: (MAX_CAP_DATA / 0x4) /* (MAX_CAP_DATA / sizeof(TPM_HANDLE)) */
            127 => Ok(Self::MAX_TPM_PROPERTIES), // Original value: (MAX_CAP_DATA / 0x8) /* (MAX_CAP_DATA / sizeof(TPMS_TAGGED_PROPERTY)) */
            203 => Ok(Self::MAX_PCR_PROPERTIES), // Original value: (MAX_CAP_DATA / 0x5) /* (MAX_CAP_DATA / sizeof(TPMS_TAGGED_PCR_SELECT)) */
            508 => Ok(Self::MAX_ECC_CURVES), // Original value: (MAX_CAP_DATA / 0x2) /* (MAX_CAP_DATA / sizeof(TPM_ECC_CURVE)) */
            14 => Ok(Self::MAX_TAGGED_POLICIES), // Original value: (MAX_CAP_DATA / 0x46) /* (MAX_CAP_DATA / sizeof(TPMS_TAGGED_POLICY)) */
            84 => Ok(Self::MAX_ACT_DATA), // Original value: MAX_CAP_DATA / 0xC /* MAX_CAP_DATA / sizeof(TPMS_ACT_DATA) */
            _ => Err(TpmError::InvalidEnumValue),
        }

    }

}

impl TpmEnum for ImplementationConstants {
    fn get_value(&self) -> u32 {
        self.0.into()
    }

}

impl From<ImplementationConstants> for u32 {
    fn from(value: ImplementationConstants) -> Self {
        value.0.into()
    }
}

impl From<ImplementationConstants> for i32 {
    fn from(value: ImplementationConstants) -> Self {
        value.0 as i32
    }
}

impl fmt::Display for ImplementationConstants {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self.0 {
            1 => write!(f, "Ossl"),
            2 => write!(f, "Ltc"),
            3 => write!(f, "One of <Msbn, HASH_COUNT>"),
            4 => write!(f, "One of <Symcrypt, _TPM_CAP_SIZE>"),
            256 => write!(f, "One of <MAX_SYM_KEY_BITS, MAX_RSA_KEY_BYTES>"),
            32 => write!(f, "One of <MAX_SYM_KEY_BYTES, MAX_AES_KEY_BYTES, LABEL_MAX_BUFFER>"),
            16 => write!(f, "MAX_SYM_BLOCK_SIZE"),
            410 => write!(f, "MAX_CAP_CC"),
            48 => write!(f, "MAX_ECC_KEY_BYTES"),
            1016 => write!(f, "MAX_CAP_DATA"),
            169 => write!(f, "MAX_CAP_ALGS"),
            254 => write!(f, "MAX_CAP_HANDLES"),
            127 => write!(f, "One of <MAX_TPM_PROPERTIES, MAX_AC_CAPABILITIES>"),
            203 => write!(f, "MAX_PCR_PROPERTIES"),
            508 => write!(f, "MAX_ECC_CURVES"),
            14 => write!(f, "MAX_TAGGED_POLICIES"),
            84 => write!(f, "MAX_ACT_DATA"),
            _ => write!(f, "Unknown({:?})", self.0),
        }

    }

}

/// In general, response codes defined in TPM 2.0 Part 2 will be unmarshaling errors and
/// will have the F (format) bit SET. Codes that are unique to TPM 2.0 Part 3 will have
/// the F bit CLEAR but the V (version) attribute will be SET to indicate that it is a TPM
/// 2.0 response code. See Response Code Details in TPM 2.0 Part 1.

/// Enum with duplicated values - using struct with constants
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Default)]
pub struct TPM_RC(pub u32);

impl TPM_RC {
    pub const SUCCESS: Self = Self(0x0); // Original value: 0x000

    /// Defined for compatibility with TPM 1.2
    pub const BAD_TAG: Self = Self(0x1E); // Original value: 0x01E

    /// Set for all format 0 response codes
    pub const RC_VER1: Self = Self(0x100);

    /// TPM not initialized by TPM2_Startup or already initialized
    pub const INITIALIZE: Self = Self(0x100); // Original value: RC_VER1 + 0x000

    /// Commands not being accepted because of a TPM failure
    /// NOTE This may be returned by TPM2_GetTestResult() as the testResult parameter.
    pub const FAILURE: Self = Self(0x101); // Original value: RC_VER1 + 0x001

    /// Improper use of a sequence handle
    pub const SEQUENCE: Self = Self(0x103); // Original value: RC_VER1 + 0x003

    /// Not currently used
    pub const PRIVATE: Self = Self(0x10B); // Original value: RC_VER1 + 0x00B

    /// Not currently used
    pub const HMAC: Self = Self(0x119); // Original value: RC_VER1 + 0x019

    /// The command is disabled
    pub const DISABLED: Self = Self(0x120); // Original value: RC_VER1 + 0x020

    /// Command failed because audit sequence required exclusivity
    pub const EXCLUSIVE: Self = Self(0x121); // Original value: RC_VER1 + 0x021

    /// Authorization handle is not correct for command
    pub const AUTH_TYPE: Self = Self(0x124); // Original value: RC_VER1 + 0x024

    /// Command requires an authorization session for handle and it is not present.
    pub const AUTH_MISSING: Self = Self(0x125); // Original value: RC_VER1 + 0x025

    /// Policy failure in math operation or an invalid authPolicy value
    pub const POLICY: Self = Self(0x126); // Original value: RC_VER1 + 0x026

    /// PCR check fail
    pub const PCR: Self = Self(0x127); // Original value: RC_VER1 + 0x027

    /// PCR have changed since checked.
    pub const PCR_CHANGED: Self = Self(0x128); // Original value: RC_VER1 + 0x028

    /// For all commands other than TPM2_FieldUpgradeData(), this code indicates that the TPM
    /// is in field upgrade mode; for TPM2_FieldUpgradeData(), this code indicates that the
    /// TPM is not in field upgrade mode
    pub const UPGRADE: Self = Self(0x12D); // Original value: RC_VER1 + 0x02D

    /// Context ID counter is at maximum.
    pub const TOO_MANY_CONTEXTS: Self = Self(0x12E); // Original value: RC_VER1 + 0x02E

    /// AuthValue or authPolicy is not available for selected entity.
    pub const AUTH_UNAVAILABLE: Self = Self(0x12F); // Original value: RC_VER1 + 0x02F

    /// A _TPM_Init and Startup(CLEAR) is required before the TPM can resume operation.
    pub const REBOOT: Self = Self(0x130); // Original value: RC_VER1 + 0x030

    /// The protection algorithms (hash and symmetric) are not reasonably balanced. The digest
    /// size of the hash must be larger than the key size of the symmetric algorithm.
    pub const UNBALANCED: Self = Self(0x131); // Original value: RC_VER1 + 0x031

    /// Command commandSize value is inconsistent with contents of the command buffer; either
    /// the size is not the same as the octets loaded by the hardware interface layer or the
    /// value is not large enough to hold a command header
    pub const COMMAND_SIZE: Self = Self(0x142); // Original value: RC_VER1 + 0x042

    /// Command code not supported
    pub const COMMAND_CODE: Self = Self(0x143); // Original value: RC_VER1 + 0x043

    /// The value of authorizationSize is out of range or the number of octets in the
    /// Authorization Area is greater than required
    pub const AUTHSIZE: Self = Self(0x144); // Original value: RC_VER1 + 0x044

    /// Use of an authorization session with a context command or another command that cannot
    /// have an authorization session.
    pub const AUTH_CONTEXT: Self = Self(0x145); // Original value: RC_VER1 + 0x045

    /// NV offset+size is out of range.
    pub const NV_RANGE: Self = Self(0x146); // Original value: RC_VER1 + 0x046

    /// Requested allocation size is larger than allowed.
    pub const NV_SIZE: Self = Self(0x147); // Original value: RC_VER1 + 0x047

    /// NV access locked.
    pub const NV_LOCKED: Self = Self(0x148); // Original value: RC_VER1 + 0x048

    /// NV access authorization fails in command actions (this failure does not affect lockout.action)
    pub const NV_AUTHORIZATION: Self = Self(0x149); // Original value: RC_VER1 + 0x049

    /// An NV Index is used before being initialized or the state saved by
    /// TPM2_Shutdown(STATE) could not be restored
    pub const NV_UNINITIALIZED: Self = Self(0x14A); // Original value: RC_VER1 + 0x04A

    /// Insufficient space for NV allocation
    pub const NV_SPACE: Self = Self(0x14B); // Original value: RC_VER1 + 0x04B

    /// NV Index or persistent object already defined
    pub const NV_DEFINED: Self = Self(0x14C); // Original value: RC_VER1 + 0x04C

    /// Context in TPM2_ContextLoad() is not valid
    pub const BAD_CONTEXT: Self = Self(0x150); // Original value: RC_VER1 + 0x050

    /// CpHash value already set or not correct for use
    pub const CPHASH: Self = Self(0x151); // Original value: RC_VER1 + 0x051

    /// Handle for parent is not a valid parent
    pub const PARENT: Self = Self(0x152); // Original value: RC_VER1 + 0x052

    /// Some function needs testing.
    pub const NEEDS_TEST: Self = Self(0x153); // Original value: RC_VER1 + 0x053

    /// Returned when an internal function cannot process a request due to an unspecified
    /// problem. This code is usually related to invalid parameters that are not properly
    /// filtered by the input unmarshaling code.
    pub const NO_RESULT: Self = Self(0x154); // Original value: RC_VER1 + 0x054

    /// The sensitive area did not unmarshal correctly after decryption this code is used in
    /// lieu of the other unmarshaling errors so that an attacker cannot determine where the
    /// unmarshaling error occurred
    pub const SENSITIVE: Self = Self(0x155); // Original value: RC_VER1 + 0x055

    /// Largest version 1 code that is not a warning
    pub const RC_MAX_FM0: Self = Self(0x17F); // Original value: RC_VER1 + 0x07F

    /// This bit is SET in all format 1 response codes
    /// The codes in this group may have a value added to them to indicate the handle,
    /// session, or parameter to which they apply.
    pub const RC_FMT1: Self = Self(0x80); // Original value: 0x080

    /// Asymmetric algorithm not supported or not correct
    pub const ASYMMETRIC: Self = Self(0x81); // Original value: RC_FMT1 + 0x001

    /// Inconsistent attributes
    pub const ATTRIBUTES: Self = Self(0x82); // Original value: RC_FMT1 + 0x002

    /// Hash algorithm not supported or not appropriate
    pub const HASH: Self = Self(0x83); // Original value: RC_FMT1 + 0x003

    /// Value is out of range or is not correct for the context
    pub const VALUE: Self = Self(0x84); // Original value: RC_FMT1 + 0x004

    /// Hierarchy is not enabled or is not correct for the use
    pub const HIERARCHY: Self = Self(0x85); // Original value: RC_FMT1 + 0x005

    /// Key size is not supported
    pub const KEY_SIZE: Self = Self(0x87); // Original value: RC_FMT1 + 0x007

    /// Mask generation function not supported
    pub const MGF: Self = Self(0x88); // Original value: RC_FMT1 + 0x008

    /// Mode of operation not supported
    pub const MODE: Self = Self(0x89); // Original value: RC_FMT1 + 0x009

    /// The type of the value is not appropriate for the use
    pub const TYPE: Self = Self(0x8A); // Original value: RC_FMT1 + 0x00A

    /// The handle is not correct for the use
    pub const HANDLE: Self = Self(0x8B); // Original value: RC_FMT1 + 0x00B

    /// Unsupported key derivation function or function not appropriate for use
    pub const KDF: Self = Self(0x8C); // Original value: RC_FMT1 + 0x00C

    /// Value was out of allowed range.
    pub const RANGE: Self = Self(0x8D); // Original value: RC_FMT1 + 0x00D

    /// The authorization HMAC check failed and DA counter incremented
    pub const AUTH_FAIL: Self = Self(0x8E); // Original value: RC_FMT1 + 0x00E

    /// Invalid nonce size or nonce value mismatch
    pub const NONCE: Self = Self(0x8F); // Original value: RC_FMT1 + 0x00F

    /// Authorization requires assertion of PP
    pub const PP: Self = Self(0x90); // Original value: RC_FMT1 + 0x010

    /// Unsupported or incompatible scheme
    pub const SCHEME: Self = Self(0x92); // Original value: RC_FMT1 + 0x012

    /// Structure is the wrong size
    pub const SIZE: Self = Self(0x95); // Original value: RC_FMT1 + 0x015

    /// Unsupported symmetric algorithm or key size, or not appropriate for instance
    pub const SYMMETRIC: Self = Self(0x96); // Original value: RC_FMT1 + 0x016

    /// Incorrect structure tag
    pub const TAG: Self = Self(0x97); // Original value: RC_FMT1 + 0x017

    /// Union selector is incorrect
    pub const SELECTOR: Self = Self(0x98); // Original value: RC_FMT1 + 0x018

    /// The TPM was unable to unmarshal a value because there were not enough octets in the
    /// input buffer
    pub const INSUFFICIENT: Self = Self(0x9A); // Original value: RC_FMT1 + 0x01A

    /// The signature is not valid
    pub const SIGNATURE: Self = Self(0x9B); // Original value: RC_FMT1 + 0x01B

    /// Key fields are not compatible with the selected use
    pub const KEY: Self = Self(0x9C); // Original value: RC_FMT1 + 0x01C

    /// A policy check failed
    pub const POLICY_FAIL: Self = Self(0x9D); // Original value: RC_FMT1 + 0x01D

    /// Integrity check failed
    pub const INTEGRITY: Self = Self(0x9F); // Original value: RC_FMT1 + 0x01F

    /// Invalid ticket
    pub const TICKET: Self = Self(0xA0); // Original value: RC_FMT1 + 0x020

    /// Reserved bits not set to zero as required
    pub const RESERVED_BITS: Self = Self(0xA1); // Original value: RC_FMT1 + 0x021

    /// Authorization failure without DA implications
    pub const BAD_AUTH: Self = Self(0xA2); // Original value: RC_FMT1 + 0x022

    /// The policy has expired
    pub const EXPIRED: Self = Self(0xA3); // Original value: RC_FMT1 + 0x023

    /// The commandCode in the policy is not the commandCode of the command or the command
    /// code in a policy command references a command that is not implemented
    pub const POLICY_CC: Self = Self(0xA4); // Original value: RC_FMT1 + 0x024

    /// Public and sensitive portions of an object are not cryptographically bound
    pub const BINDING: Self = Self(0xA5); // Original value: RC_FMT1 + 0x025

    /// Curve not supported
    pub const CURVE: Self = Self(0xA6); // Original value: RC_FMT1 + 0x026

    /// Point is not on the required curve.
    pub const ECC_POINT: Self = Self(0xA7); // Original value: RC_FMT1 + 0x027

    /// Set for warning response codes
    pub const RC_WARN: Self = Self(0x900);

    /// Gap for context ID is too large
    pub const CONTEXT_GAP: Self = Self(0x901); // Original value: RC_WARN + 0x001

    /// Out of memory for object contexts
    pub const OBJECT_MEMORY: Self = Self(0x902); // Original value: RC_WARN + 0x002

    /// Out of memory for session contexts
    pub const SESSION_MEMORY: Self = Self(0x903); // Original value: RC_WARN + 0x003

    /// Out of shared object/session memory or need space for internal operations
    pub const MEMORY: Self = Self(0x904); // Original value: RC_WARN + 0x004

    /// Out of session handles a session must be flushed before a new session may be created
    pub const SESSION_HANDLES: Self = Self(0x905); // Original value: RC_WARN + 0x005

    /// Out of object handles the handle space for objects is depleted and a reboot is required
    /// NOTE 1 This cannot occur on the reference implementation.
    /// NOTE 2 There is no reason why an implementation would implement a design that would
    /// deplete handle space. Platform specifications are encouraged to forbid it.
    pub const OBJECT_HANDLES: Self = Self(0x906); // Original value: RC_WARN + 0x006

    /// Bad locality
    pub const LOCALITY: Self = Self(0x907); // Original value: RC_WARN + 0x007

    /// The TPM has suspended operation on the command; forward progress was made and the
    /// command may be retried
    /// See TPM 2.0 Part 1, Multi-tasking.
    /// NOTE This cannot occur on the reference implementation.
    pub const YIELDED: Self = Self(0x908); // Original value: RC_WARN + 0x008

    /// The command was canceled
    pub const CANCELED: Self = Self(0x909); // Original value: RC_WARN + 0x009

    /// TPM is performing self-tests
    pub const TESTING: Self = Self(0x90A); // Original value: RC_WARN + 0x00A

    /// The 1st handle in the handle area references a transient object or session that is not
    /// loaded
    pub const REFERENCE_H0: Self = Self(0x910); // Original value: RC_WARN + 0x010

    /// The 2nd handle in the handle area references a transient object or session that is not
    /// loaded
    pub const REFERENCE_H1: Self = Self(0x911); // Original value: RC_WARN + 0x011

    /// The 3rd handle in the handle area references a transient object or session that is not
    /// loaded
    pub const REFERENCE_H2: Self = Self(0x912); // Original value: RC_WARN + 0x012

    /// The 4th handle in the handle area references a transient object or session that is not
    /// loaded
    pub const REFERENCE_H3: Self = Self(0x913); // Original value: RC_WARN + 0x013

    /// The 5th handle in the handle area references a transient object or session that is not
    /// loaded
    pub const REFERENCE_H4: Self = Self(0x914); // Original value: RC_WARN + 0x014

    /// The 6th handle in the handle area references a transient object or session that is not
    /// loaded
    pub const REFERENCE_H5: Self = Self(0x915); // Original value: RC_WARN + 0x015

    /// The 7th handle in the handle area references a transient object or session that is not
    /// loaded
    pub const REFERENCE_H6: Self = Self(0x916); // Original value: RC_WARN + 0x016

    /// The 1st authorization session handle references a session that is not loaded
    pub const REFERENCE_S0: Self = Self(0x918); // Original value: RC_WARN + 0x018

    /// The 2nd authorization session handle references a session that is not loaded
    pub const REFERENCE_S1: Self = Self(0x919); // Original value: RC_WARN + 0x019

    /// The 3rd authorization session handle references a session that is not loaded
    pub const REFERENCE_S2: Self = Self(0x91A); // Original value: RC_WARN + 0x01A

    /// The 4th authorization session handle references a session that is not loaded
    pub const REFERENCE_S3: Self = Self(0x91B); // Original value: RC_WARN + 0x01B

    /// The 5th session handle references a session that is not loaded
    pub const REFERENCE_S4: Self = Self(0x91C); // Original value: RC_WARN + 0x01C

    /// The 6th session handle references a session that is not loaded
    pub const REFERENCE_S5: Self = Self(0x91D); // Original value: RC_WARN + 0x01D

    /// The 7th authorization session handle references a session that is not loaded
    pub const REFERENCE_S6: Self = Self(0x91E); // Original value: RC_WARN + 0x01E

    /// The TPM is rate-limiting accesses to prevent wearout of NV
    pub const NV_RATE: Self = Self(0x920); // Original value: RC_WARN + 0x020

    /// Authorizations for objects subject to DA protection are not allowed at this time
    /// because the TPM is in DA lockout mode
    pub const LOCKOUT: Self = Self(0x921); // Original value: RC_WARN + 0x021

    /// The TPM was not able to start the command
    pub const RETRY: Self = Self(0x922); // Original value: RC_WARN + 0x022

    /// The command may require writing of NV and NV is not current accessible
    pub const NV_UNAVAILABLE: Self = Self(0x923); // Original value: RC_WARN + 0x023

    /// This value is reserved and shall not be returned by the TPM
    pub const NOT_USED: Self = Self(0x97F); // Original value: RC_WARN + 0x7F

    /// Add to a handle-related error
    pub const H: Self = Self(0x0); // Original value: 0x000

    /// Add to a parameter-related error
    pub const P: Self = Self(0x40); // Original value: 0x040

    /// Add to a session-related error
    pub const S: Self = Self(0x800);

    /// Add to a parameter-, handle-, or session-related error
    pub const _1: Self = Self(0x100);

    /// Add to a parameter-, handle-, or session-related error
    pub const _2: Self = Self(0x200);

    /// Add to a parameter-, handle-, or session-related error
    pub const _3: Self = Self(0x300);

    /// Add to a parameter-, handle-, or session-related error
    pub const _4: Self = Self(0x400);

    /// Add to a parameter-, handle-, or session-related error
    pub const _5: Self = Self(0x500);

    /// Add to a parameter-, handle-, or session-related error
    pub const _6: Self = Self(0x600);

    /// Add to a parameter-, handle-, or session-related error
    pub const _7: Self = Self(0x700);

    /// Add to a parameter-related error
    pub const _8: Self = Self(0x800);

    /// Add to a parameter-related error
    pub const _9: Self = Self(0x900);

    /// Add to a parameter-related error
    pub const A: Self = Self(0xA00);

    /// Add to a parameter-related error
    pub const B: Self = Self(0xB00);

    /// Add to a parameter-related error
    pub const C: Self = Self(0xC00);

    /// Add to a parameter-related error
    pub const D: Self = Self(0xD00);

    /// Add to a parameter-related error
    pub const E: Self = Self(0xE00);

    /// Add to a parameter-related error
    pub const F: Self = Self(0xF00);

    /// Number mask
    pub const N_MASK: Self = Self(0xF00);

    /// Response buffer returned by the TPM is too short
    pub const TSS_TCP_BAD_HANDSHAKE_RESP: Self = Self(0x40280001);

    /// Too old TCP server version
    pub const TSS_TCP_SERVER_TOO_OLD: Self = Self(0x40280002);

    /// Bad ack from the TCP end point
    pub const TSS_TCP_BAD_ACK: Self = Self(0x40280003);

    /// Wrong length of the response buffer returned by the TPM
    pub const TSS_TCP_BAD_RESP_LEN: Self = Self(0x40280004);

    /// TPM2_Startup returned unexpected response code
    pub const TSS_TCP_UNEXPECTED_STARTUP_RESP: Self = Self(0x40280005);

    /// Invalid size tag in the TPM response TCP packet
    pub const TSS_TCP_INVALID_SIZE_TAG: Self = Self(0x40280006);

    /// TPM over TCP device is not connected
    pub const TSS_TCP_DISCONNECTED: Self = Self(0x40280007);

    /// General TPM command dispatch failure
    pub const TSS_DISPATCH_FAILED: Self = Self(0x40280010);

    /// Sending data to TPM failed
    pub const TSS_SEND_OP_FAILED: Self = Self(0x40280011);

    /// Response buffer returned by the TPM is too short
    pub const TSS_RESP_BUF_TOO_SHORT: Self = Self(0x40280021);

    /// Invalid tag in the response buffer returned by the TPM
    pub const TSS_RESP_BUF_INVALID_SESSION_TAG: Self = Self(0x40280022);

    /// Inconsistent TPM response parameters size
    pub const TSS_RESP_BUF_INVALID_SIZE: Self = Self(0x40280023);

    /// Windows TBS error TPM_E_COMMAND_BLOCKED
    pub const TBS_COMMAND_BLOCKED: Self = Self(0x80280400);

    /// Windows TBS error TPM_E_INVALID_HANDLE
    pub const TBS_INVALID_HANDLE: Self = Self(0x80280401);

    /// Windows TBS error TPM_E_DUPLICATE_VHANDLE
    pub const TBS_DUPLICATE_V_HANDLE: Self = Self(0x80280402);

    /// Windows TBS error TPM_E_EMBEDDED_COMMAND_BLOCKED
    pub const TBS_EMBEDDED_COMMAND_BLOCKED: Self = Self(0x80280403);

    /// Windows TBS error TPM_E_EMBEDDED_COMMAND_UNSUPPORTED
    pub const TBS_EMBEDDED_COMMAND_UNSUPPORTED: Self = Self(0x80280404);

    /// Windows TBS returned success but empty response buffer
    pub const TBS_UNKNOWN_ERROR: Self = Self(0x80284000);

    /// Windows TBS error TBS_E_INTERNAL_ERROR
    pub const TBS_INTERNAL_ERROR: Self = Self(0x80284001);

    /// Windows TBS error TBS_E_BAD_PARAMETER
    pub const TBS_BAD_PARAMETER: Self = Self(0x80284002);

    /// Windows TBS error TBS_E_INVALID_OUTPUT_POINTER
    pub const TBS_INVALID_OUTPUT_POINTER: Self = Self(0x80284003);

    /// Windows TBS error TBS_E_INVALID_CONTEXT
    pub const TBS_INVALID_CONTEXT: Self = Self(0x80284004);

    /// Windows TBS error TBS_E_INSUFFICIENT_BUFFER
    pub const TBS_INSUFFICIENT_BUFFER: Self = Self(0x80284005);

    /// Windows TBS error TBS_E_IOERROR
    pub const TBS_IO_ERROR: Self = Self(0x80284006);

    /// Windows TBS error TBS_E_INVALID_CONTEXT_PARAM
    pub const TBS_INVALID_CONTEXT_PARAM: Self = Self(0x80284007);

    /// Windows TBS error TBS_E_SERVICE_NOT_RUNNING
    pub const TBS_SERVICE_NOT_RUNNING: Self = Self(0x80284008);

    /// Windows TBS error TBS_E_TOO_MANY_TBS_CONTEXTS
    pub const TBS_TOO_MANY_CONTEXTS: Self = Self(0x80284009);

    /// Windows TBS error TBS_E_TOO_MANY_TBS_RESOURCES
    pub const TBS_TOO_MANY_RESOURCES: Self = Self(0x8028400A);

    /// Windows TBS error TBS_E_SERVICE_START_PENDING
    pub const TBS_SERVICE_START_PENDING: Self = Self(0x8028400B);

    /// Windows TBS error TBS_E_PPI_NOT_SUPPORTED
    pub const TBS_PPI_NOT_SUPPORTED: Self = Self(0x8028400C);

    /// Windows TBS error TBS_E_COMMAND_CANCELED
    pub const TBS_COMMAND_CANCELED: Self = Self(0x8028400D);

    /// Windows TBS error TBS_E_BUFFER_TOO_LARGE
    pub const TBS_BUFFER_TOO_LARGE: Self = Self(0x8028400E);

    /// Windows TBS error TBS_E_TPM_NOT_FOUND
    pub const TBS_TPM_NOT_FOUND: Self = Self(0x8028400F);

    /// Windows TBS error TBS_E_SERVICE_DISABLED
    pub const TBS_SERVICE_DISABLED: Self = Self(0x80284010);

    /// Windows TBS error TBS_E_ACCESS_DENIED
    pub const TBS_ACCESS_DENIED: Self = Self(0x80284012);

    /// Windows TBS error TBS_E_PPI_FUNCTION_UNSUPPORTED
    pub const TBS_PPI_FUNCTION_NOT_SUPPORTED: Self = Self(0x80284014);

    /// Windows TBS error TBS_E_OWNERAUTH_NOT_FOUND
    pub const TBS_OWNER_AUTH_NOT_FOUND: Self = Self(0x80284015);

    pub fn try_from(value: i32) -> Result<Self, TpmError> {
        match value {
            0 => Ok(Self::SUCCESS), // Original value: 0x000
            30 => Ok(Self::BAD_TAG), // Original value: 0x01E
            256 => Ok(Self::RC_VER1), // Original value: 0x100
            257 => Ok(Self::FAILURE), // Original value: RC_VER1 + 0x001
            259 => Ok(Self::SEQUENCE), // Original value: RC_VER1 + 0x003
            267 => Ok(Self::PRIVATE), // Original value: RC_VER1 + 0x00B
            281 => Ok(Self::HMAC), // Original value: RC_VER1 + 0x019
            288 => Ok(Self::DISABLED), // Original value: RC_VER1 + 0x020
            289 => Ok(Self::EXCLUSIVE), // Original value: RC_VER1 + 0x021
            292 => Ok(Self::AUTH_TYPE), // Original value: RC_VER1 + 0x024
            293 => Ok(Self::AUTH_MISSING), // Original value: RC_VER1 + 0x025
            294 => Ok(Self::POLICY), // Original value: RC_VER1 + 0x026
            295 => Ok(Self::PCR), // Original value: RC_VER1 + 0x027
            296 => Ok(Self::PCR_CHANGED), // Original value: RC_VER1 + 0x028
            301 => Ok(Self::UPGRADE), // Original value: RC_VER1 + 0x02D
            302 => Ok(Self::TOO_MANY_CONTEXTS), // Original value: RC_VER1 + 0x02E
            303 => Ok(Self::AUTH_UNAVAILABLE), // Original value: RC_VER1 + 0x02F
            304 => Ok(Self::REBOOT), // Original value: RC_VER1 + 0x030
            305 => Ok(Self::UNBALANCED), // Original value: RC_VER1 + 0x031
            322 => Ok(Self::COMMAND_SIZE), // Original value: RC_VER1 + 0x042
            323 => Ok(Self::COMMAND_CODE), // Original value: RC_VER1 + 0x043
            324 => Ok(Self::AUTHSIZE), // Original value: RC_VER1 + 0x044
            325 => Ok(Self::AUTH_CONTEXT), // Original value: RC_VER1 + 0x045
            326 => Ok(Self::NV_RANGE), // Original value: RC_VER1 + 0x046
            327 => Ok(Self::NV_SIZE), // Original value: RC_VER1 + 0x047
            328 => Ok(Self::NV_LOCKED), // Original value: RC_VER1 + 0x048
            329 => Ok(Self::NV_AUTHORIZATION), // Original value: RC_VER1 + 0x049
            330 => Ok(Self::NV_UNINITIALIZED), // Original value: RC_VER1 + 0x04A
            331 => Ok(Self::NV_SPACE), // Original value: RC_VER1 + 0x04B
            332 => Ok(Self::NV_DEFINED), // Original value: RC_VER1 + 0x04C
            336 => Ok(Self::BAD_CONTEXT), // Original value: RC_VER1 + 0x050
            337 => Ok(Self::CPHASH), // Original value: RC_VER1 + 0x051
            338 => Ok(Self::PARENT), // Original value: RC_VER1 + 0x052
            339 => Ok(Self::NEEDS_TEST), // Original value: RC_VER1 + 0x053
            340 => Ok(Self::NO_RESULT), // Original value: RC_VER1 + 0x054
            341 => Ok(Self::SENSITIVE), // Original value: RC_VER1 + 0x055
            383 => Ok(Self::RC_MAX_FM0), // Original value: RC_VER1 + 0x07F
            128 => Ok(Self::RC_FMT1), // Original value: 0x080
            129 => Ok(Self::ASYMMETRIC), // Original value: RC_FMT1 + 0x001
            130 => Ok(Self::ATTRIBUTES), // Original value: RC_FMT1 + 0x002
            131 => Ok(Self::HASH), // Original value: RC_FMT1 + 0x003
            132 => Ok(Self::VALUE), // Original value: RC_FMT1 + 0x004
            133 => Ok(Self::HIERARCHY), // Original value: RC_FMT1 + 0x005
            135 => Ok(Self::KEY_SIZE), // Original value: RC_FMT1 + 0x007
            136 => Ok(Self::MGF), // Original value: RC_FMT1 + 0x008
            137 => Ok(Self::MODE), // Original value: RC_FMT1 + 0x009
            138 => Ok(Self::TYPE), // Original value: RC_FMT1 + 0x00A
            139 => Ok(Self::HANDLE), // Original value: RC_FMT1 + 0x00B
            140 => Ok(Self::KDF), // Original value: RC_FMT1 + 0x00C
            141 => Ok(Self::RANGE), // Original value: RC_FMT1 + 0x00D
            142 => Ok(Self::AUTH_FAIL), // Original value: RC_FMT1 + 0x00E
            143 => Ok(Self::NONCE), // Original value: RC_FMT1 + 0x00F
            144 => Ok(Self::PP), // Original value: RC_FMT1 + 0x010
            146 => Ok(Self::SCHEME), // Original value: RC_FMT1 + 0x012
            149 => Ok(Self::SIZE), // Original value: RC_FMT1 + 0x015
            150 => Ok(Self::SYMMETRIC), // Original value: RC_FMT1 + 0x016
            151 => Ok(Self::TAG), // Original value: RC_FMT1 + 0x017
            152 => Ok(Self::SELECTOR), // Original value: RC_FMT1 + 0x018
            154 => Ok(Self::INSUFFICIENT), // Original value: RC_FMT1 + 0x01A
            155 => Ok(Self::SIGNATURE), // Original value: RC_FMT1 + 0x01B
            156 => Ok(Self::KEY), // Original value: RC_FMT1 + 0x01C
            157 => Ok(Self::POLICY_FAIL), // Original value: RC_FMT1 + 0x01D
            159 => Ok(Self::INTEGRITY), // Original value: RC_FMT1 + 0x01F
            160 => Ok(Self::TICKET), // Original value: RC_FMT1 + 0x020
            161 => Ok(Self::RESERVED_BITS), // Original value: RC_FMT1 + 0x021
            162 => Ok(Self::BAD_AUTH), // Original value: RC_FMT1 + 0x022
            163 => Ok(Self::EXPIRED), // Original value: RC_FMT1 + 0x023
            164 => Ok(Self::POLICY_CC), // Original value: RC_FMT1 + 0x024
            165 => Ok(Self::BINDING), // Original value: RC_FMT1 + 0x025
            166 => Ok(Self::CURVE), // Original value: RC_FMT1 + 0x026
            167 => Ok(Self::ECC_POINT), // Original value: RC_FMT1 + 0x027
            2304 => Ok(Self::RC_WARN), // Original value: 0x900
            2305 => Ok(Self::CONTEXT_GAP), // Original value: RC_WARN + 0x001
            2306 => Ok(Self::OBJECT_MEMORY), // Original value: RC_WARN + 0x002
            2307 => Ok(Self::SESSION_MEMORY), // Original value: RC_WARN + 0x003
            2308 => Ok(Self::MEMORY), // Original value: RC_WARN + 0x004
            2309 => Ok(Self::SESSION_HANDLES), // Original value: RC_WARN + 0x005
            2310 => Ok(Self::OBJECT_HANDLES), // Original value: RC_WARN + 0x006
            2311 => Ok(Self::LOCALITY), // Original value: RC_WARN + 0x007
            2312 => Ok(Self::YIELDED), // Original value: RC_WARN + 0x008
            2313 => Ok(Self::CANCELED), // Original value: RC_WARN + 0x009
            2314 => Ok(Self::TESTING), // Original value: RC_WARN + 0x00A
            2320 => Ok(Self::REFERENCE_H0), // Original value: RC_WARN + 0x010
            2321 => Ok(Self::REFERENCE_H1), // Original value: RC_WARN + 0x011
            2322 => Ok(Self::REFERENCE_H2), // Original value: RC_WARN + 0x012
            2323 => Ok(Self::REFERENCE_H3), // Original value: RC_WARN + 0x013
            2324 => Ok(Self::REFERENCE_H4), // Original value: RC_WARN + 0x014
            2325 => Ok(Self::REFERENCE_H5), // Original value: RC_WARN + 0x015
            2326 => Ok(Self::REFERENCE_H6), // Original value: RC_WARN + 0x016
            2328 => Ok(Self::REFERENCE_S0), // Original value: RC_WARN + 0x018
            2329 => Ok(Self::REFERENCE_S1), // Original value: RC_WARN + 0x019
            2330 => Ok(Self::REFERENCE_S2), // Original value: RC_WARN + 0x01A
            2331 => Ok(Self::REFERENCE_S3), // Original value: RC_WARN + 0x01B
            2332 => Ok(Self::REFERENCE_S4), // Original value: RC_WARN + 0x01C
            2333 => Ok(Self::REFERENCE_S5), // Original value: RC_WARN + 0x01D
            2334 => Ok(Self::REFERENCE_S6), // Original value: RC_WARN + 0x01E
            2336 => Ok(Self::NV_RATE), // Original value: RC_WARN + 0x020
            2337 => Ok(Self::LOCKOUT), // Original value: RC_WARN + 0x021
            2338 => Ok(Self::RETRY), // Original value: RC_WARN + 0x022
            2339 => Ok(Self::NV_UNAVAILABLE), // Original value: RC_WARN + 0x023
            2431 => Ok(Self::NOT_USED), // Original value: RC_WARN + 0x7F
            64 => Ok(Self::P), // Original value: 0x040
            2048 => Ok(Self::S), // Original value: 0x800
            512 => Ok(Self::_2), // Original value: 0x200
            768 => Ok(Self::_3), // Original value: 0x300
            1024 => Ok(Self::_4), // Original value: 0x400
            1280 => Ok(Self::_5), // Original value: 0x500
            1536 => Ok(Self::_6), // Original value: 0x600
            1792 => Ok(Self::_7), // Original value: 0x700
            2560 => Ok(Self::A), // Original value: 0xA00
            2816 => Ok(Self::B), // Original value: 0xB00
            3072 => Ok(Self::C), // Original value: 0xC00
            3328 => Ok(Self::D), // Original value: 0xD00
            3584 => Ok(Self::E), // Original value: 0xE00
            3840 => Ok(Self::F), // Original value: 0xF00
            1076363265 => Ok(Self::TSS_TCP_BAD_HANDSHAKE_RESP), // Original value: 0x40280001
            1076363266 => Ok(Self::TSS_TCP_SERVER_TOO_OLD), // Original value: 0x40280002
            1076363267 => Ok(Self::TSS_TCP_BAD_ACK), // Original value: 0x40280003
            1076363268 => Ok(Self::TSS_TCP_BAD_RESP_LEN), // Original value: 0x40280004
            1076363269 => Ok(Self::TSS_TCP_UNEXPECTED_STARTUP_RESP), // Original value: 0x40280005
            1076363270 => Ok(Self::TSS_TCP_INVALID_SIZE_TAG), // Original value: 0x40280006
            1076363271 => Ok(Self::TSS_TCP_DISCONNECTED), // Original value: 0x40280007
            1076363280 => Ok(Self::TSS_DISPATCH_FAILED), // Original value: 0x40280010
            1076363281 => Ok(Self::TSS_SEND_OP_FAILED), // Original value: 0x40280011
            1076363297 => Ok(Self::TSS_RESP_BUF_TOO_SHORT), // Original value: 0x40280021
            1076363298 => Ok(Self::TSS_RESP_BUF_INVALID_SESSION_TAG), // Original value: 0x40280022
            1076363299 => Ok(Self::TSS_RESP_BUF_INVALID_SIZE), // Original value: 0x40280023
            2150106112 => Ok(Self::TBS_COMMAND_BLOCKED), // Original value: 0x80280400
            2150106113 => Ok(Self::TBS_INVALID_HANDLE), // Original value: 0x80280401
            2150106114 => Ok(Self::TBS_DUPLICATE_V_HANDLE), // Original value: 0x80280402
            2150106115 => Ok(Self::TBS_EMBEDDED_COMMAND_BLOCKED), // Original value: 0x80280403
            2150106116 => Ok(Self::TBS_EMBEDDED_COMMAND_UNSUPPORTED), // Original value: 0x80280404
            2150121472 => Ok(Self::TBS_UNKNOWN_ERROR), // Original value: 0x80284000
            2150121473 => Ok(Self::TBS_INTERNAL_ERROR), // Original value: 0x80284001
            2150121474 => Ok(Self::TBS_BAD_PARAMETER), // Original value: 0x80284002
            2150121475 => Ok(Self::TBS_INVALID_OUTPUT_POINTER), // Original value: 0x80284003
            2150121476 => Ok(Self::TBS_INVALID_CONTEXT), // Original value: 0x80284004
            2150121477 => Ok(Self::TBS_INSUFFICIENT_BUFFER), // Original value: 0x80284005
            2150121478 => Ok(Self::TBS_IO_ERROR), // Original value: 0x80284006
            2150121479 => Ok(Self::TBS_INVALID_CONTEXT_PARAM), // Original value: 0x80284007
            2150121480 => Ok(Self::TBS_SERVICE_NOT_RUNNING), // Original value: 0x80284008
            2150121481 => Ok(Self::TBS_TOO_MANY_CONTEXTS), // Original value: 0x80284009
            2150121482 => Ok(Self::TBS_TOO_MANY_RESOURCES), // Original value: 0x8028400A
            2150121483 => Ok(Self::TBS_SERVICE_START_PENDING), // Original value: 0x8028400B
            2150121484 => Ok(Self::TBS_PPI_NOT_SUPPORTED), // Original value: 0x8028400C
            2150121485 => Ok(Self::TBS_COMMAND_CANCELED), // Original value: 0x8028400D
            2150121486 => Ok(Self::TBS_BUFFER_TOO_LARGE), // Original value: 0x8028400E
            2150121487 => Ok(Self::TBS_TPM_NOT_FOUND), // Original value: 0x8028400F
            2150121488 => Ok(Self::TBS_SERVICE_DISABLED), // Original value: 0x80284010
            2150121490 => Ok(Self::TBS_ACCESS_DENIED), // Original value: 0x80284012
            2150121492 => Ok(Self::TBS_PPI_FUNCTION_NOT_SUPPORTED), // Original value: 0x80284014
            2150121493 => Ok(Self::TBS_OWNER_AUTH_NOT_FOUND), // Original value: 0x80284015
            _ => Err(TpmError::InvalidEnumValue),
        }

    }

}

impl TpmEnum for TPM_RC {
    fn get_value(&self) -> u32 {
        self.0.into()
    }

}

impl From<TPM_RC> for u32 {
    fn from(value: TPM_RC) -> Self {
        value.0.into()
    }
}

impl From<TPM_RC> for i32 {
    fn from(value: TPM_RC) -> Self {
        value.0 as i32
    }
}

impl fmt::Display for TPM_RC {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self.0 {
            0 => write!(f, "One of <SUCCESS, H>"),
            30 => write!(f, "BAD_TAG"),
            256 => write!(f, "One of <RC_VER1, INITIALIZE, _1>"),
            257 => write!(f, "FAILURE"),
            259 => write!(f, "SEQUENCE"),
            267 => write!(f, "PRIVATE"),
            281 => write!(f, "HMAC"),
            288 => write!(f, "DISABLED"),
            289 => write!(f, "EXCLUSIVE"),
            292 => write!(f, "AUTH_TYPE"),
            293 => write!(f, "AUTH_MISSING"),
            294 => write!(f, "POLICY"),
            295 => write!(f, "PCR"),
            296 => write!(f, "PCR_CHANGED"),
            301 => write!(f, "UPGRADE"),
            302 => write!(f, "TOO_MANY_CONTEXTS"),
            303 => write!(f, "AUTH_UNAVAILABLE"),
            304 => write!(f, "REBOOT"),
            305 => write!(f, "UNBALANCED"),
            322 => write!(f, "COMMAND_SIZE"),
            323 => write!(f, "COMMAND_CODE"),
            324 => write!(f, "AUTHSIZE"),
            325 => write!(f, "AUTH_CONTEXT"),
            326 => write!(f, "NV_RANGE"),
            327 => write!(f, "NV_SIZE"),
            328 => write!(f, "NV_LOCKED"),
            329 => write!(f, "NV_AUTHORIZATION"),
            330 => write!(f, "NV_UNINITIALIZED"),
            331 => write!(f, "NV_SPACE"),
            332 => write!(f, "NV_DEFINED"),
            336 => write!(f, "BAD_CONTEXT"),
            337 => write!(f, "CPHASH"),
            338 => write!(f, "PARENT"),
            339 => write!(f, "NEEDS_TEST"),
            340 => write!(f, "NO_RESULT"),
            341 => write!(f, "SENSITIVE"),
            383 => write!(f, "RC_MAX_FM0"),
            128 => write!(f, "RC_FMT1"),
            129 => write!(f, "ASYMMETRIC"),
            130 => write!(f, "ATTRIBUTES"),
            131 => write!(f, "HASH"),
            132 => write!(f, "VALUE"),
            133 => write!(f, "HIERARCHY"),
            135 => write!(f, "KEY_SIZE"),
            136 => write!(f, "MGF"),
            137 => write!(f, "MODE"),
            138 => write!(f, "TYPE"),
            139 => write!(f, "HANDLE"),
            140 => write!(f, "KDF"),
            141 => write!(f, "RANGE"),
            142 => write!(f, "AUTH_FAIL"),
            143 => write!(f, "NONCE"),
            144 => write!(f, "PP"),
            146 => write!(f, "SCHEME"),
            149 => write!(f, "SIZE"),
            150 => write!(f, "SYMMETRIC"),
            151 => write!(f, "TAG"),
            152 => write!(f, "SELECTOR"),
            154 => write!(f, "INSUFFICIENT"),
            155 => write!(f, "SIGNATURE"),
            156 => write!(f, "KEY"),
            157 => write!(f, "POLICY_FAIL"),
            159 => write!(f, "INTEGRITY"),
            160 => write!(f, "TICKET"),
            161 => write!(f, "RESERVED_BITS"),
            162 => write!(f, "BAD_AUTH"),
            163 => write!(f, "EXPIRED"),
            164 => write!(f, "POLICY_CC"),
            165 => write!(f, "BINDING"),
            166 => write!(f, "CURVE"),
            167 => write!(f, "ECC_POINT"),
            2304 => write!(f, "One of <RC_WARN, _9>"),
            2305 => write!(f, "CONTEXT_GAP"),
            2306 => write!(f, "OBJECT_MEMORY"),
            2307 => write!(f, "SESSION_MEMORY"),
            2308 => write!(f, "MEMORY"),
            2309 => write!(f, "SESSION_HANDLES"),
            2310 => write!(f, "OBJECT_HANDLES"),
            2311 => write!(f, "LOCALITY"),
            2312 => write!(f, "YIELDED"),
            2313 => write!(f, "CANCELED"),
            2314 => write!(f, "TESTING"),
            2320 => write!(f, "REFERENCE_H0"),
            2321 => write!(f, "REFERENCE_H1"),
            2322 => write!(f, "REFERENCE_H2"),
            2323 => write!(f, "REFERENCE_H3"),
            2324 => write!(f, "REFERENCE_H4"),
            2325 => write!(f, "REFERENCE_H5"),
            2326 => write!(f, "REFERENCE_H6"),
            2328 => write!(f, "REFERENCE_S0"),
            2329 => write!(f, "REFERENCE_S1"),
            2330 => write!(f, "REFERENCE_S2"),
            2331 => write!(f, "REFERENCE_S3"),
            2332 => write!(f, "REFERENCE_S4"),
            2333 => write!(f, "REFERENCE_S5"),
            2334 => write!(f, "REFERENCE_S6"),
            2336 => write!(f, "NV_RATE"),
            2337 => write!(f, "LOCKOUT"),
            2338 => write!(f, "RETRY"),
            2339 => write!(f, "NV_UNAVAILABLE"),
            2431 => write!(f, "NOT_USED"),
            64 => write!(f, "P"),
            2048 => write!(f, "One of <S, _8>"),
            512 => write!(f, "_2"),
            768 => write!(f, "_3"),
            1024 => write!(f, "_4"),
            1280 => write!(f, "_5"),
            1536 => write!(f, "_6"),
            1792 => write!(f, "_7"),
            2560 => write!(f, "A"),
            2816 => write!(f, "B"),
            3072 => write!(f, "C"),
            3328 => write!(f, "D"),
            3584 => write!(f, "E"),
            3840 => write!(f, "One of <F, N_MASK>"),
            1076363265 => write!(f, "TSS_TCP_BAD_HANDSHAKE_RESP"),
            1076363266 => write!(f, "TSS_TCP_SERVER_TOO_OLD"),
            1076363267 => write!(f, "TSS_TCP_BAD_ACK"),
            1076363268 => write!(f, "TSS_TCP_BAD_RESP_LEN"),
            1076363269 => write!(f, "TSS_TCP_UNEXPECTED_STARTUP_RESP"),
            1076363270 => write!(f, "TSS_TCP_INVALID_SIZE_TAG"),
            1076363271 => write!(f, "TSS_TCP_DISCONNECTED"),
            1076363280 => write!(f, "TSS_DISPATCH_FAILED"),
            1076363281 => write!(f, "TSS_SEND_OP_FAILED"),
            1076363297 => write!(f, "TSS_RESP_BUF_TOO_SHORT"),
            1076363298 => write!(f, "TSS_RESP_BUF_INVALID_SESSION_TAG"),
            1076363299 => write!(f, "TSS_RESP_BUF_INVALID_SIZE"),
            2150106112 => write!(f, "TBS_COMMAND_BLOCKED"),
            2150106113 => write!(f, "TBS_INVALID_HANDLE"),
            2150106114 => write!(f, "TBS_DUPLICATE_V_HANDLE"),
            2150106115 => write!(f, "TBS_EMBEDDED_COMMAND_BLOCKED"),
            2150106116 => write!(f, "TBS_EMBEDDED_COMMAND_UNSUPPORTED"),
            2150121472 => write!(f, "TBS_UNKNOWN_ERROR"),
            2150121473 => write!(f, "TBS_INTERNAL_ERROR"),
            2150121474 => write!(f, "TBS_BAD_PARAMETER"),
            2150121475 => write!(f, "TBS_INVALID_OUTPUT_POINTER"),
            2150121476 => write!(f, "TBS_INVALID_CONTEXT"),
            2150121477 => write!(f, "TBS_INSUFFICIENT_BUFFER"),
            2150121478 => write!(f, "TBS_IO_ERROR"),
            2150121479 => write!(f, "TBS_INVALID_CONTEXT_PARAM"),
            2150121480 => write!(f, "TBS_SERVICE_NOT_RUNNING"),
            2150121481 => write!(f, "TBS_TOO_MANY_CONTEXTS"),
            2150121482 => write!(f, "TBS_TOO_MANY_RESOURCES"),
            2150121483 => write!(f, "TBS_SERVICE_START_PENDING"),
            2150121484 => write!(f, "TBS_PPI_NOT_SUPPORTED"),
            2150121485 => write!(f, "TBS_COMMAND_CANCELED"),
            2150121486 => write!(f, "TBS_BUFFER_TOO_LARGE"),
            2150121487 => write!(f, "TBS_TPM_NOT_FOUND"),
            2150121488 => write!(f, "TBS_SERVICE_DISABLED"),
            2150121490 => write!(f, "TBS_ACCESS_DENIED"),
            2150121492 => write!(f, "TBS_PPI_FUNCTION_NOT_SUPPORTED"),
            2150121493 => write!(f, "TBS_OWNER_AUTH_NOT_FOUND"),
            _ => write!(f, "Unknown({:?})", self.0),
        }

    }

}

/// A TPM_CLOCK_ADJUST value is used to change the rate at which the TPM internal
/// oscillator is divided. A change to the divider will change the rate at which Clock and
/// Time change.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, TryFromPrimitive, Default)]
#[repr(i8)]
pub enum TPM_CLOCK_ADJUST {
    #[default]

    /// Slow the Clock update rate by one coarse adjustment step.
    COARSE_SLOWER = 0xFFFFFFFFFFFFFFFD, // Original value: -3

    /// Slow the Clock update rate by one medium adjustment step.
    MEDIUM_SLOWER = 0xFFFFFFFFFFFFFFFE, // Original value: -2

    /// Slow the Clock update rate by one fine adjustment step.
    FINE_SLOWER = 0xFFFFFFFFFFFFFFFF, // Original value: -1

    /// No change to the Clock update rate.
    NO_CHANGE = 0x0, // Original value: 0

    /// Speed the Clock update rate by one fine adjustment step.
    FINE_FASTER = 0x1, // Original value: 1

    /// Speed the Clock update rate by one medium adjustment step.
    MEDIUM_FASTER = 0x2, // Original value: 2

    /// Speed the Clock update rate by one coarse adjustment step.
    COARSE_FASTER = 0x3 // Original value: 3
}

impl TpmEnum for TPM_CLOCK_ADJUST {
    fn get_value(&self) -> u32 {
        *self as u32
    }

}

impl From<TPM_CLOCK_ADJUST> for u32 {
    fn from(value: TPM_CLOCK_ADJUST) -> Self {
        value as u32
    }

}

impl From<TPM_CLOCK_ADJUST> for i32 {
    fn from(value: TPM_CLOCK_ADJUST) -> Self {
        value as i32
    }

}

impl fmt::Display for TPM_CLOCK_ADJUST {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::COARSE_SLOWER => write!(f, "COARSE_SLOWER"),
            Self::MEDIUM_SLOWER => write!(f, "MEDIUM_SLOWER"),
            Self::FINE_SLOWER => write!(f, "FINE_SLOWER"),
            Self::NO_CHANGE => write!(f, "NO_CHANGE"),
            Self::FINE_FASTER => write!(f, "FINE_FASTER"),
            Self::MEDIUM_FASTER => write!(f, "MEDIUM_FASTER"),
            Self::COARSE_FASTER => write!(f, "COARSE_FASTER"),
        }
    }
}

/// Table 18 Definition of (UINT16) TPM_EO Constants [IN/OUT]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, TryFromPrimitive, Default)]
#[repr(i16)]
pub enum TPM_EO {
    #[default]

    /// A = B
    EQ = 0x0, // Original value: 0x0000

    /// A B
    NEQ = 0x1, // Original value: 0x0001

    /// A ˃ B signed
    SIGNED_GT = 0x2, // Original value: 0x0002

    /// A ˃ B unsigned
    UNSIGNED_GT = 0x3, // Original value: 0x0003

    /// A ˂ B signed
    SIGNED_LT = 0x4, // Original value: 0x0004

    /// A ˂ B unsigned
    UNSIGNED_LT = 0x5, // Original value: 0x0005

    /// A B signed
    SIGNED_GE = 0x6, // Original value: 0x0006

    /// A B unsigned
    UNSIGNED_GE = 0x7, // Original value: 0x0007

    /// A B signed
    SIGNED_LE = 0x8, // Original value: 0x0008

    /// A B unsigned
    UNSIGNED_LE = 0x9, // Original value: 0x0009

    /// All bits SET in B are SET in A. ((A∧B)=B)
    BITSET = 0xA, // Original value: 0x000A

    /// All bits SET in B are CLEAR in A. ((A∧B)=0)
    BITCLEAR = 0xB // Original value: 0x000B
}

impl TpmEnum for TPM_EO {
    fn get_value(&self) -> u32 {
        *self as u32
    }

}

impl From<TPM_EO> for u32 {
    fn from(value: TPM_EO) -> Self {
        value as u32
    }

}

impl From<TPM_EO> for i32 {
    fn from(value: TPM_EO) -> Self {
        value as i32
    }

}

impl fmt::Display for TPM_EO {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::EQ => write!(f, "EQ"),
            Self::NEQ => write!(f, "NEQ"),
            Self::SIGNED_GT => write!(f, "SIGNED_GT"),
            Self::UNSIGNED_GT => write!(f, "UNSIGNED_GT"),
            Self::SIGNED_LT => write!(f, "SIGNED_LT"),
            Self::UNSIGNED_LT => write!(f, "UNSIGNED_LT"),
            Self::SIGNED_GE => write!(f, "SIGNED_GE"),
            Self::UNSIGNED_GE => write!(f, "UNSIGNED_GE"),
            Self::SIGNED_LE => write!(f, "SIGNED_LE"),
            Self::UNSIGNED_LE => write!(f, "UNSIGNED_LE"),
            Self::BITSET => write!(f, "BITSET"),
            Self::BITCLEAR => write!(f, "BITCLEAR"),
        }
    }
}

/// Structure tags are used to disambiguate structures. They are 16-bit values with the
/// most significant bit SET so that they do not overlap TPM_ALG_ID values. A single
/// exception is made for the value associated with TPM_ST_RSP_COMMAND (0x00C4), which has
/// the same value as the TPM_TAG_RSP_COMMAND tag from earlier versions of this
/// specification. This value is used when the TPM is compatible with a previous TPM
/// specification and the TPM cannot determine which family of response code to return
/// because the command tag is not valid.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, TryFromPrimitive, Default)]
#[repr(i16)]
pub enum TPM_ST {
    #[default]

    /// Tag value for a response; used when there is an error in the tag. This is also the
    /// value returned from a TPM 1.2 when an error occurs. This value is used in this
    /// specification because an error in the command tag may prevent determination of the
    /// family. When this tag is used in the response, the response code will be
    /// TPM_RC_BAD_TAG (0 1E16), which has the same numeric value as the TPM 1.2 response code
    /// for TPM_BADTAG.
    /// NOTE In a previously published version of this specification, TPM_RC_BAD_TAG was
    /// incorrectly assigned a value of 0x030 instead of 30 (0x01e). Some implementations my
    /// return the old value instead of the new value.
    RSP_COMMAND = 0xC4, // Original value: 0x00C4

    /// No structure type specified
    NULL = 0x8000, // Original value: 0X8000

    /// Tag value for a command/response for a command defined in this specification;
    /// indicating that the command/response has no attached sessions and no
    /// authorizationSize/parameterSize value is present
    /// If the responseCode from the TPM is not TPM_RC_SUCCESS, then the response tag shall
    /// have this value.
    NO_SESSIONS = 0x8001,

    /// Tag value for a command/response for a command defined in this specification;
    /// indicating that the command/response has one or more attached sessions and the
    /// authorizationSize/parameterSize field is present
    SESSIONS = 0x8002,

    /// Tag for an attestation structure
    ATTEST_NV = 0x8014,

    /// Tag for an attestation structure
    ATTEST_COMMAND_AUDIT = 0x8015,

    /// Tag for an attestation structure
    ATTEST_SESSION_AUDIT = 0x8016,

    /// Tag for an attestation structure
    ATTEST_CERTIFY = 0x8017,

    /// Tag for an attestation structure
    ATTEST_QUOTE = 0x8018,

    /// Tag for an attestation structure
    ATTEST_TIME = 0x8019,

    /// Tag for an attestation structure
    ATTEST_CREATION = 0x801A,

    /// Tag for an attestation structure
    ATTEST_NV_DIGEST = 0x801C,

    /// Tag for a ticket type
    CREATION = 0x8021,

    /// Tag for a ticket type
    VERIFIED = 0x8022,

    /// Tag for a ticket type
    AUTH_SECRET = 0x8023,

    /// Tag for a ticket type
    HASHCHECK = 0x8024,

    /// Tag for a ticket type
    AUTH_SIGNED = 0x8025,

    /// Tag for a structure describing a Field Upgrade Policy
    FU_MANIFEST = 0x8029
}

impl TpmEnum for TPM_ST {
    fn get_value(&self) -> u32 {
        *self as u32
    }

}

impl From<TPM_ST> for u32 {
    fn from(value: TPM_ST) -> Self {
        value as u32
    }

}

impl From<TPM_ST> for i32 {
    fn from(value: TPM_ST) -> Self {
        value as i32
    }

}

impl fmt::Display for TPM_ST {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::RSP_COMMAND => write!(f, "RSP_COMMAND"),
            Self::NULL => write!(f, "NULL"),
            Self::NO_SESSIONS => write!(f, "NO_SESSIONS"),
            Self::SESSIONS => write!(f, "SESSIONS"),
            Self::ATTEST_NV => write!(f, "ATTEST_NV"),
            Self::ATTEST_COMMAND_AUDIT => write!(f, "ATTEST_COMMAND_AUDIT"),
            Self::ATTEST_SESSION_AUDIT => write!(f, "ATTEST_SESSION_AUDIT"),
            Self::ATTEST_CERTIFY => write!(f, "ATTEST_CERTIFY"),
            Self::ATTEST_QUOTE => write!(f, "ATTEST_QUOTE"),
            Self::ATTEST_TIME => write!(f, "ATTEST_TIME"),
            Self::ATTEST_CREATION => write!(f, "ATTEST_CREATION"),
            Self::ATTEST_NV_DIGEST => write!(f, "ATTEST_NV_DIGEST"),
            Self::CREATION => write!(f, "CREATION"),
            Self::VERIFIED => write!(f, "VERIFIED"),
            Self::AUTH_SECRET => write!(f, "AUTH_SECRET"),
            Self::HASHCHECK => write!(f, "HASHCHECK"),
            Self::AUTH_SIGNED => write!(f, "AUTH_SIGNED"),
            Self::FU_MANIFEST => write!(f, "FU_MANIFEST"),
        }
    }
}

/// These values are used in TPM2_Startup() to indicate the shutdown and startup mode. The
/// defined startup sequences are:
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, TryFromPrimitive, Default)]
#[repr(i16)]
pub enum TPM_SU {
    #[default]

    /// On TPM2_Shutdown(), indicates that the TPM should prepare for loss of power and save
    /// state required for an orderly startup (TPM Reset).
    /// on TPM2_Startup(), indicates that the TPM should perform TPM Reset or TPM Restart
    CLEAR = 0x0, // Original value: 0x0000

    /// On TPM2_Shutdown(), indicates that the TPM should prepare for loss of power and save
    /// state required for an orderly startup (TPM Restart or TPM Resume)
    /// on TPM2_Startup(), indicates that the TPM should restore the state saved by
    /// TPM2_Shutdown(TPM_SU_STATE)
    STATE = 0x1 // Original value: 0x0001
}

impl TpmEnum for TPM_SU {
    fn get_value(&self) -> u32 {
        *self as u32
    }

}

impl From<TPM_SU> for u32 {
    fn from(value: TPM_SU) -> Self {
        value as u32
    }

}

impl From<TPM_SU> for i32 {
    fn from(value: TPM_SU) -> Self {
        value as i32
    }

}

impl fmt::Display for TPM_SU {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::CLEAR => write!(f, "CLEAR"),
            Self::STATE => write!(f, "STATE"),
        }
    }
}

/// This type is used in TPM2_StartAuthSession() to indicate the type of the session to be
/// created.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, TryFromPrimitive, Default)]
#[repr(i8)]
pub enum TPM_SE {
    #[default]
    HMAC = 0x0, // Original value: 0x00
    POLICY = 0x1, // Original value: 0x01

    /// The policy session is being used to compute the policyHash and not for command authorization.
    /// This setting modifies some policy commands and prevents session from being used to
    /// authorize a command.
    TRIAL = 0x3 // Original value: 0x03
}

impl TpmEnum for TPM_SE {
    fn get_value(&self) -> u32 {
        *self as u32
    }

}

impl From<TPM_SE> for u32 {
    fn from(value: TPM_SE) -> Self {
        value as u32
    }

}

impl From<TPM_SE> for i32 {
    fn from(value: TPM_SE) -> Self {
        value as i32
    }

}

impl fmt::Display for TPM_SE {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::HMAC => write!(f, "HMAC"),
            Self::POLICY => write!(f, "POLICY"),
            Self::TRIAL => write!(f, "TRIAL"),
        }
    }
}

/// The TPM_CAP values are used in TPM2_GetCapability() to select the type of the value to
/// be returned. The format of the response varies according to the type of the value.

/// Enum with duplicated values - using struct with constants
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Default)]
pub struct TPM_CAP(pub u32);

impl TPM_CAP {
    pub const FIRST: Self = Self(0x0); // Original value: 0x00000000

    /// TPML_ALG_PROPERTY
    pub const ALGS: Self = Self(0x0); // Original value: 0x00000000

    /// TPML_HANDLE
    pub const HANDLES: Self = Self(0x1); // Original value: 0x00000001

    /// TPML_CCA
    pub const COMMANDS: Self = Self(0x2); // Original value: 0x00000002

    /// TPML_CC
    pub const PP_COMMANDS: Self = Self(0x3); // Original value: 0x00000003

    /// TPML_CC
    pub const AUDIT_COMMANDS: Self = Self(0x4); // Original value: 0x00000004

    /// TPML_PCR_SELECTION
    pub const PCRS: Self = Self(0x5); // Original value: 0x00000005

    /// TPML_TAGGED_TPM_PROPERTY
    pub const TPM_PROPERTIES: Self = Self(0x6); // Original value: 0x00000006

    /// TPML_TAGGED_PCR_PROPERTY
    pub const PCR_PROPERTIES: Self = Self(0x7); // Original value: 0x00000007

    /// TPML_ECC_CURVE
    pub const ECC_CURVES: Self = Self(0x8); // Original value: 0x00000008

    /// TPML_TAGGED_POLICY
    pub const AUTH_POLICIES: Self = Self(0x9); // Original value: 0x00000009

    /// TPML_ACT_DATA
    pub const ACT: Self = Self(0xA); // Original value: 0x0000000A
    pub const LAST: Self = Self(0xA); // Original value: 0x0000000A

    /// Manufacturer-specific values
    pub const VENDOR_PROPERTY: Self = Self(0x100); // Original value: 0x00000100

    pub fn try_from(value: i32) -> Result<Self, TpmError> {
        match value {
            0 => Ok(Self::FIRST), // Original value: 0x00000000
            1 => Ok(Self::HANDLES), // Original value: 0x00000001
            2 => Ok(Self::COMMANDS), // Original value: 0x00000002
            3 => Ok(Self::PP_COMMANDS), // Original value: 0x00000003
            4 => Ok(Self::AUDIT_COMMANDS), // Original value: 0x00000004
            5 => Ok(Self::PCRS), // Original value: 0x00000005
            6 => Ok(Self::TPM_PROPERTIES), // Original value: 0x00000006
            7 => Ok(Self::PCR_PROPERTIES), // Original value: 0x00000007
            8 => Ok(Self::ECC_CURVES), // Original value: 0x00000008
            9 => Ok(Self::AUTH_POLICIES), // Original value: 0x00000009
            10 => Ok(Self::ACT), // Original value: 0x0000000A
            256 => Ok(Self::VENDOR_PROPERTY), // Original value: 0x00000100
            _ => Err(TpmError::InvalidEnumValue),
        }

    }

}

impl TpmEnum for TPM_CAP {
    fn get_value(&self) -> u32 {
        self.0.into()
    }

}

impl From<TPM_CAP> for u32 {
    fn from(value: TPM_CAP) -> Self {
        value.0.into()
    }
}

impl From<TPM_CAP> for i32 {
    fn from(value: TPM_CAP) -> Self {
        value.0 as i32
    }
}

impl fmt::Display for TPM_CAP {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self.0 {
            0 => write!(f, "One of <FIRST, ALGS>"),
            1 => write!(f, "HANDLES"),
            2 => write!(f, "COMMANDS"),
            3 => write!(f, "PP_COMMANDS"),
            4 => write!(f, "AUDIT_COMMANDS"),
            5 => write!(f, "PCRS"),
            6 => write!(f, "TPM_PROPERTIES"),
            7 => write!(f, "PCR_PROPERTIES"),
            8 => write!(f, "ECC_CURVES"),
            9 => write!(f, "AUTH_POLICIES"),
            10 => write!(f, "One of <ACT, LAST>"),
            256 => write!(f, "VENDOR_PROPERTY"),
            _ => write!(f, "Unknown({:?})", self.0),
        }

    }

}

/// The TPM_PT constants are used in TPM2_GetCapability(capability =
/// TPM_CAP_TPM_PROPERTIES) to indicate the property being selected or returned.

/// Enum with duplicated values - using struct with constants
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Default)]
pub struct TPM_PT(pub u32);

impl TPM_PT {
    /// Indicates no property type
    pub const NONE: Self = Self(0x0); // Original value: 0x00000000

    /// The number of properties in each group.
    /// NOTE The first group with any properties is group 1 (PT_GROUP * 1). Group 0 is reserved.
    pub const PT_GROUP: Self = Self(0x100); // Original value: 0x00000100

    /// The group of fixed properties returned as TPMS_TAGGED_PROPERTY
    /// The values in this group are only changed due to a firmware change in the TPM.
    pub const PT_FIXED: Self = Self(0x100); // Original value: PT_GROUP * 1

    /// A 4-octet character string containing the TPM Family value (TPM_SPEC_FAMILY)
    pub const FAMILY_INDICATOR: Self = Self(0x100); // Original value: PT_FIXED + 0

    /// The level of the specification
    /// NOTE 1 For this specification, the level is zero.
    /// NOTE 2 The level is on the title page of the specification.
    pub const LEVEL: Self = Self(0x101); // Original value: PT_FIXED + 1

    /// The specification Revision times 100
    /// EXAMPLE Revision 01.01 would have a value of 101.
    /// NOTE The Revision value is on the title page of the specification.
    pub const REVISION: Self = Self(0x102); // Original value: PT_FIXED + 2

    /// The specification day of year using TCG calendar
    /// EXAMPLE November 15, 2010, has a day of year value of 319 (0000013F16).
    /// NOTE The specification date is on the title page of the specification or errata (see 6.1).
    pub const DAY_OF_YEAR: Self = Self(0x103); // Original value: PT_FIXED + 3

    /// The specification year using the CE
    /// EXAMPLE The year 2010 has a value of 000007DA16.
    /// NOTE The specification date is on the title page of the specification or errata (see 6.1).
    pub const YEAR: Self = Self(0x104); // Original value: PT_FIXED + 4

    /// The vendor ID unique to each TPM manufacturer
    pub const MANUFACTURER: Self = Self(0x105); // Original value: PT_FIXED + 5

    /// The first four characters of the vendor ID string
    /// NOTE When the vendor string is fewer than 16 octets, the additional property values do
    /// not have to be present. A vendor string of 4 octets can be represented in one 32-bit
    /// value and no null terminating character is required.
    pub const VENDOR_STRING_1: Self = Self(0x106); // Original value: PT_FIXED + 6

    /// The second four characters of the vendor ID string
    pub const VENDOR_STRING_2: Self = Self(0x107); // Original value: PT_FIXED + 7

    /// The third four characters of the vendor ID string
    pub const VENDOR_STRING_3: Self = Self(0x108); // Original value: PT_FIXED + 8

    /// The fourth four characters of the vendor ID sting
    pub const VENDOR_STRING_4: Self = Self(0x109); // Original value: PT_FIXED + 9

    /// Vendor-defined value indicating the TPM model
    pub const VENDOR_TPM_TYPE: Self = Self(0x10A); // Original value: PT_FIXED + 10

    /// The most-significant 32 bits of a TPM vendor-specific value indicating the version
    /// number of the firmware. See 10.12.2 and 10.12.12.
    pub const FIRMWARE_VERSION_1: Self = Self(0x10B); // Original value: PT_FIXED + 11

    /// The least-significant 32 bits of a TPM vendor-specific value indicating the version
    /// number of the firmware. See 10.12.2 and 10.12.12.
    pub const FIRMWARE_VERSION_2: Self = Self(0x10C); // Original value: PT_FIXED + 12

    /// The maximum size of a parameter (typically, a TPM2B_MAX_BUFFER)
    pub const INPUT_BUFFER: Self = Self(0x10D); // Original value: PT_FIXED + 13

    /// The minimum number of transient objects that can be held in TPM RAM
    /// NOTE This minimum shall be no less than the minimum value required by the
    /// platform-specific specification to which the TPM is built.
    pub const HR_TRANSIENT_MIN: Self = Self(0x10E); // Original value: PT_FIXED + 14

    /// The minimum number of persistent objects that can be held in TPM NV memory
    /// NOTE This minimum shall be no less than the minimum value required by the
    /// platform-specific specification to which the TPM is built.
    pub const HR_PERSISTENT_MIN: Self = Self(0x10F); // Original value: PT_FIXED + 15

    /// The minimum number of authorization sessions that can be held in TPM RAM
    /// NOTE This minimum shall be no less than the minimum value required by the
    /// platform-specific specification to which the TPM is built.
    pub const HR_LOADED_MIN: Self = Self(0x110); // Original value: PT_FIXED + 16

    /// The number of authorization sessions that may be active at a time
    /// A session is active when it has a context associated with its handle. The context may
    /// either be in TPM RAM or be context saved.
    /// NOTE This value shall be no less than the minimum value required by the
    /// platform-specific specification to which the TPM is built.
    pub const ACTIVE_SESSIONS_MAX: Self = Self(0x111); // Original value: PT_FIXED + 17

    /// The number of PCR implemented
    /// NOTE This number is determined by the defined attributes, not the number of PCR that
    /// are populated.
    pub const PCR_COUNT: Self = Self(0x112); // Original value: PT_FIXED + 18

    /// The minimum number of octets in a TPMS_PCR_SELECT.sizeOfSelect
    /// NOTE This value is not determined by the number of PCR implemented but by the number
    /// of PCR required by the platform-specific specification with which the TPM is compliant
    /// or by the implementer if not adhering to a platform-specific specification.
    pub const PCR_SELECT_MIN: Self = Self(0x113); // Original value: PT_FIXED + 19

    /// The maximum allowed difference (unsigned) between the contextID values of two saved
    /// session contexts
    /// This value shall be 2n-1, where n is at least 16.
    pub const CONTEXT_GAP_MAX: Self = Self(0x114); // Original value: PT_FIXED + 20

    /// The maximum number of NV Indexes that are allowed to have the TPM_NT_COUNTER attribute
    /// NOTE 1 It is allowed for this value to be larger than the number of NV Indexes that
    /// can be defined. This would be indicative of a TPM implementation that did not use
    /// different implementation technology for different NV Index types.
    /// NOTE 2 The value zero indicates that there is no fixed maximum. The number of counter
    /// indexes is determined by the available NV memory pool.
    pub const NV_COUNTERS_MAX: Self = Self(0x116); // Original value: PT_FIXED + 22

    /// The maximum size of an NV Index data area
    pub const NV_INDEX_MAX: Self = Self(0x117); // Original value: PT_FIXED + 23

    /// A TPMA_MEMORY indicating the memory management method for the TPM
    pub const MEMORY: Self = Self(0x118); // Original value: PT_FIXED + 24

    /// Interval, in milliseconds, between updates to the copy of TPMS_CLOCK_INFO.clock in NV
    pub const CLOCK_UPDATE: Self = Self(0x119); // Original value: PT_FIXED + 25

    /// The algorithm used for the integrity HMAC on saved contexts and for hashing the fuData
    /// of TPM2_FirmwareRead()
    pub const CONTEXT_HASH: Self = Self(0x11A); // Original value: PT_FIXED + 26

    /// TPM_ALG_ID, the algorithm used for encryption of saved contexts
    pub const CONTEXT_SYM: Self = Self(0x11B); // Original value: PT_FIXED + 27

    /// TPM_KEY_BITS, the size of the key used for encryption of saved contexts
    pub const CONTEXT_SYM_SIZE: Self = Self(0x11C); // Original value: PT_FIXED + 28

    /// The modulus - 1 of the count for NV update of an orderly counter
    /// The returned value is MAX_ORDERLY_COUNT.
    /// This will have a value of 2N 1 where 1 N 32
    /// NOTE 1 An orderly counter is an NV Index with an TPM_NT of TPM_NV_COUNTER and
    /// TPMA_NV_ORDERLY SET.
    /// NOTE 2 When the low-order bits of a counter equal this value, an NV write occurs on
    /// the next increment.
    pub const ORDERLY_COUNT: Self = Self(0x11D); // Original value: PT_FIXED + 29

    /// The maximum value for commandSize in a command
    pub const MAX_COMMAND_SIZE: Self = Self(0x11E); // Original value: PT_FIXED + 30

    /// The maximum value for responseSize in a response
    pub const MAX_RESPONSE_SIZE: Self = Self(0x11F); // Original value: PT_FIXED + 31

    /// The maximum size of a digest that can be produced by the TPM
    pub const MAX_DIGEST: Self = Self(0x120); // Original value: PT_FIXED + 32

    /// The maximum size of an object context that will be returned by TPM2_ContextSave
    pub const MAX_OBJECT_CONTEXT: Self = Self(0x121); // Original value: PT_FIXED + 33

    /// The maximum size of a session context that will be returned by TPM2_ContextSave
    pub const MAX_SESSION_CONTEXT: Self = Self(0x122); // Original value: PT_FIXED + 34

    /// Platform-specific family (a TPM_PS value)(see Table 25)
    /// NOTE The platform-specific values for the TPM_PT_PS parameters are in the relevant
    /// platform-specific specification. In the reference implementation, all of these values
    /// are 0.
    pub const PS_FAMILY_INDICATOR: Self = Self(0x123); // Original value: PT_FIXED + 35

    /// The level of the platform-specific specification
    pub const PS_LEVEL: Self = Self(0x124); // Original value: PT_FIXED + 36

    /// A platform specific value
    pub const PS_REVISION: Self = Self(0x125); // Original value: PT_FIXED + 37

    /// The platform-specific TPM specification day of year using TCG calendar
    /// EXAMPLE November 15, 2010, has a day of year value of 319 (0000013F16).
    pub const PS_DAY_OF_YEAR: Self = Self(0x126); // Original value: PT_FIXED + 38

    /// The platform-specific TPM specification year using the CE
    /// EXAMPLE The year 2010 has a value of 000007DA16.
    pub const PS_YEAR: Self = Self(0x127); // Original value: PT_FIXED + 39

    /// The number of split signing operations supported by the TPM
    pub const SPLIT_MAX: Self = Self(0x128); // Original value: PT_FIXED + 40

    /// Total number of commands implemented in the TPM
    pub const TOTAL_COMMANDS: Self = Self(0x129); // Original value: PT_FIXED + 41

    /// Number of commands from the TPM library that are implemented
    pub const LIBRARY_COMMANDS: Self = Self(0x12A); // Original value: PT_FIXED + 42

    /// Number of vendor commands that are implemented
    pub const VENDOR_COMMANDS: Self = Self(0x12B); // Original value: PT_FIXED + 43

    /// The maximum data size in one NV write, NV read, NV extend, or NV certify command
    pub const NV_BUFFER_MAX: Self = Self(0x12C); // Original value: PT_FIXED + 44

    /// A TPMA_MODES value, indicating that the TPM is designed for these modes.
    pub const MODES: Self = Self(0x12D); // Original value: PT_FIXED + 45

    /// The maximum size of a TPMS_CAPABILITY_DATA structure returned in TPM2_GetCapability().
    pub const MAX_CAP_BUFFER: Self = Self(0x12E); // Original value: PT_FIXED + 46

    /// The group of variable properties returned as TPMS_TAGGED_PROPERTY
    /// The properties in this group change because of a Protected Capability other than a
    /// firmware update. The values are not necessarily persistent across all power transitions.
    pub const PT_VAR: Self = Self(0x200); // Original value: PT_GROUP * 2

    /// TPMA_PERMANENT
    pub const PERMANENT: Self = Self(0x200); // Original value: PT_VAR + 0

    /// TPMA_STARTUP_CLEAR
    pub const STARTUP_CLEAR: Self = Self(0x201); // Original value: PT_VAR + 1

    /// The number of NV Indexes currently defined
    pub const HR_NV_INDEX: Self = Self(0x202); // Original value: PT_VAR + 2

    /// The number of authorization sessions currently loaded into TPM RAM
    pub const HR_LOADED: Self = Self(0x203); // Original value: PT_VAR + 3

    /// The number of additional authorization sessions, of any type, that could be loaded
    /// into TPM RAM
    /// This value is an estimate. If this value is at least 1, then at least one
    /// authorization session of any type may be loaded. Any command that changes the RAM
    /// memory allocation can make this estimate invalid.
    /// NOTE A valid implementation may return 1 even if more than one authorization session
    /// would fit into RAM.
    pub const HR_LOADED_AVAIL: Self = Self(0x204); // Original value: PT_VAR + 4

    /// The number of active authorization sessions currently being tracked by the TPM
    /// This is the sum of the loaded and saved sessions.
    pub const HR_ACTIVE: Self = Self(0x205); // Original value: PT_VAR + 5

    /// The number of additional authorization sessions, of any type, that could be created
    /// This value is an estimate. If this value is at least 1, then at least one
    /// authorization session of any type may be created. Any command that changes the RAM
    /// memory allocation can make this estimate invalid.
    /// NOTE A valid implementation may return 1 even if more than one authorization session
    /// could be created.
    pub const HR_ACTIVE_AVAIL: Self = Self(0x206); // Original value: PT_VAR + 6

    /// Estimate of the number of additional transient objects that could be loaded into TPM RAM
    /// This value is an estimate. If this value is at least 1, then at least one object of
    /// any type may be loaded. Any command that changes the memory allocation can make this
    /// estimate invalid.
    /// NOTE A valid implementation may return 1 even if more than one transient object would
    /// fit into RAM.
    pub const HR_TRANSIENT_AVAIL: Self = Self(0x207); // Original value: PT_VAR + 7

    /// The number of persistent objects currently loaded into TPM NV memory
    pub const HR_PERSISTENT: Self = Self(0x208); // Original value: PT_VAR + 8

    /// The number of additional persistent objects that could be loaded into NV memory
    /// This value is an estimate. If this value is at least 1, then at least one object of
    /// any type may be made persistent. Any command that changes the NV memory allocation can
    /// make this estimate invalid.
    /// NOTE A valid implementation may return 1 even if more than one persistent object would
    /// fit into NV memory.
    pub const HR_PERSISTENT_AVAIL: Self = Self(0x209); // Original value: PT_VAR + 9

    /// The number of defined NV Indexes that have NV the TPM_NT_COUNTER attribute
    pub const NV_COUNTERS: Self = Self(0x20A); // Original value: PT_VAR + 10

    /// The number of additional NV Indexes that can be defined with their TPM_NT of
    /// TPM_NV_COUNTER and the TPMA_NV_ORDERLY attribute SET
    /// This value is an estimate. If this value is at least 1, then at least one NV Index may
    /// be created with a TPM_NT of TPM_NV_COUNTER and the TPMA_NV_ORDERLY attributes. Any
    /// command that changes the NV memory allocation can make this estimate invalid.
    /// NOTE A valid implementation may return 1 even if more than one NV counter could be defined.
    pub const NV_COUNTERS_AVAIL: Self = Self(0x20B); // Original value: PT_VAR + 11

    /// Code that limits the algorithms that may be used with the TPM
    pub const ALGORITHM_SET: Self = Self(0x20C); // Original value: PT_VAR + 12

    /// The number of loaded ECC curves
    pub const LOADED_CURVES: Self = Self(0x20D); // Original value: PT_VAR + 13

    /// The current value of the lockout counter (failedTries)
    pub const LOCKOUT_COUNTER: Self = Self(0x20E); // Original value: PT_VAR + 14

    /// The number of authorization failures before DA lockout is invoked
    pub const MAX_AUTH_FAIL: Self = Self(0x20F); // Original value: PT_VAR + 15

    /// The number of seconds before the value reported by TPM_PT_LOCKOUT_COUNTER is decremented
    pub const LOCKOUT_INTERVAL: Self = Self(0x210); // Original value: PT_VAR + 16

    /// The number of seconds after a lockoutAuth failure before use of lockoutAuth may be
    /// attempted again
    pub const LOCKOUT_RECOVERY: Self = Self(0x211); // Original value: PT_VAR + 17

    /// Number of milliseconds before the TPM will accept another command that will modify NV
    /// This value is an approximation and may go up or down over time.
    pub const NV_WRITE_RECOVERY: Self = Self(0x212); // Original value: PT_VAR + 18

    /// The high-order 32 bits of the command audit counter
    pub const AUDIT_COUNTER_0: Self = Self(0x213); // Original value: PT_VAR + 19

    /// The low-order 32 bits of the command audit counter
    pub const AUDIT_COUNTER_1: Self = Self(0x214); // Original value: PT_VAR + 20

    pub fn try_from(value: i32) -> Result<Self, TpmError> {
        match value {
            0 => Ok(Self::NONE), // Original value: 0x00000000
            256 => Ok(Self::PT_GROUP), // Original value: 0x00000100
            257 => Ok(Self::LEVEL), // Original value: PT_FIXED + 1
            258 => Ok(Self::REVISION), // Original value: PT_FIXED + 2
            259 => Ok(Self::DAY_OF_YEAR), // Original value: PT_FIXED + 3
            260 => Ok(Self::YEAR), // Original value: PT_FIXED + 4
            261 => Ok(Self::MANUFACTURER), // Original value: PT_FIXED + 5
            262 => Ok(Self::VENDOR_STRING_1), // Original value: PT_FIXED + 6
            263 => Ok(Self::VENDOR_STRING_2), // Original value: PT_FIXED + 7
            264 => Ok(Self::VENDOR_STRING_3), // Original value: PT_FIXED + 8
            265 => Ok(Self::VENDOR_STRING_4), // Original value: PT_FIXED + 9
            266 => Ok(Self::VENDOR_TPM_TYPE), // Original value: PT_FIXED + 10
            267 => Ok(Self::FIRMWARE_VERSION_1), // Original value: PT_FIXED + 11
            268 => Ok(Self::FIRMWARE_VERSION_2), // Original value: PT_FIXED + 12
            269 => Ok(Self::INPUT_BUFFER), // Original value: PT_FIXED + 13
            270 => Ok(Self::HR_TRANSIENT_MIN), // Original value: PT_FIXED + 14
            271 => Ok(Self::HR_PERSISTENT_MIN), // Original value: PT_FIXED + 15
            272 => Ok(Self::HR_LOADED_MIN), // Original value: PT_FIXED + 16
            273 => Ok(Self::ACTIVE_SESSIONS_MAX), // Original value: PT_FIXED + 17
            274 => Ok(Self::PCR_COUNT), // Original value: PT_FIXED + 18
            275 => Ok(Self::PCR_SELECT_MIN), // Original value: PT_FIXED + 19
            276 => Ok(Self::CONTEXT_GAP_MAX), // Original value: PT_FIXED + 20
            278 => Ok(Self::NV_COUNTERS_MAX), // Original value: PT_FIXED + 22
            279 => Ok(Self::NV_INDEX_MAX), // Original value: PT_FIXED + 23
            280 => Ok(Self::MEMORY), // Original value: PT_FIXED + 24
            281 => Ok(Self::CLOCK_UPDATE), // Original value: PT_FIXED + 25
            282 => Ok(Self::CONTEXT_HASH), // Original value: PT_FIXED + 26
            283 => Ok(Self::CONTEXT_SYM), // Original value: PT_FIXED + 27
            284 => Ok(Self::CONTEXT_SYM_SIZE), // Original value: PT_FIXED + 28
            285 => Ok(Self::ORDERLY_COUNT), // Original value: PT_FIXED + 29
            286 => Ok(Self::MAX_COMMAND_SIZE), // Original value: PT_FIXED + 30
            287 => Ok(Self::MAX_RESPONSE_SIZE), // Original value: PT_FIXED + 31
            288 => Ok(Self::MAX_DIGEST), // Original value: PT_FIXED + 32
            289 => Ok(Self::MAX_OBJECT_CONTEXT), // Original value: PT_FIXED + 33
            290 => Ok(Self::MAX_SESSION_CONTEXT), // Original value: PT_FIXED + 34
            291 => Ok(Self::PS_FAMILY_INDICATOR), // Original value: PT_FIXED + 35
            292 => Ok(Self::PS_LEVEL), // Original value: PT_FIXED + 36
            293 => Ok(Self::PS_REVISION), // Original value: PT_FIXED + 37
            294 => Ok(Self::PS_DAY_OF_YEAR), // Original value: PT_FIXED + 38
            295 => Ok(Self::PS_YEAR), // Original value: PT_FIXED + 39
            296 => Ok(Self::SPLIT_MAX), // Original value: PT_FIXED + 40
            297 => Ok(Self::TOTAL_COMMANDS), // Original value: PT_FIXED + 41
            298 => Ok(Self::LIBRARY_COMMANDS), // Original value: PT_FIXED + 42
            299 => Ok(Self::VENDOR_COMMANDS), // Original value: PT_FIXED + 43
            300 => Ok(Self::NV_BUFFER_MAX), // Original value: PT_FIXED + 44
            301 => Ok(Self::MODES), // Original value: PT_FIXED + 45
            302 => Ok(Self::MAX_CAP_BUFFER), // Original value: PT_FIXED + 46
            512 => Ok(Self::PT_VAR), // Original value: PT_GROUP * 2
            513 => Ok(Self::STARTUP_CLEAR), // Original value: PT_VAR + 1
            514 => Ok(Self::HR_NV_INDEX), // Original value: PT_VAR + 2
            515 => Ok(Self::HR_LOADED), // Original value: PT_VAR + 3
            516 => Ok(Self::HR_LOADED_AVAIL), // Original value: PT_VAR + 4
            517 => Ok(Self::HR_ACTIVE), // Original value: PT_VAR + 5
            518 => Ok(Self::HR_ACTIVE_AVAIL), // Original value: PT_VAR + 6
            519 => Ok(Self::HR_TRANSIENT_AVAIL), // Original value: PT_VAR + 7
            520 => Ok(Self::HR_PERSISTENT), // Original value: PT_VAR + 8
            521 => Ok(Self::HR_PERSISTENT_AVAIL), // Original value: PT_VAR + 9
            522 => Ok(Self::NV_COUNTERS), // Original value: PT_VAR + 10
            523 => Ok(Self::NV_COUNTERS_AVAIL), // Original value: PT_VAR + 11
            524 => Ok(Self::ALGORITHM_SET), // Original value: PT_VAR + 12
            525 => Ok(Self::LOADED_CURVES), // Original value: PT_VAR + 13
            526 => Ok(Self::LOCKOUT_COUNTER), // Original value: PT_VAR + 14
            527 => Ok(Self::MAX_AUTH_FAIL), // Original value: PT_VAR + 15
            528 => Ok(Self::LOCKOUT_INTERVAL), // Original value: PT_VAR + 16
            529 => Ok(Self::LOCKOUT_RECOVERY), // Original value: PT_VAR + 17
            530 => Ok(Self::NV_WRITE_RECOVERY), // Original value: PT_VAR + 18
            531 => Ok(Self::AUDIT_COUNTER_0), // Original value: PT_VAR + 19
            532 => Ok(Self::AUDIT_COUNTER_1), // Original value: PT_VAR + 20
            _ => Err(TpmError::InvalidEnumValue),
        }

    }

}

impl TpmEnum for TPM_PT {
    fn get_value(&self) -> u32 {
        self.0.into()
    }

}

impl From<TPM_PT> for u32 {
    fn from(value: TPM_PT) -> Self {
        value.0.into()
    }
}

impl From<TPM_PT> for i32 {
    fn from(value: TPM_PT) -> Self {
        value.0 as i32
    }
}

impl fmt::Display for TPM_PT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self.0 {
            0 => write!(f, "NONE"),
            256 => write!(f, "One of <PT_GROUP, PT_FIXED, FAMILY_INDICATOR>"),
            257 => write!(f, "LEVEL"),
            258 => write!(f, "REVISION"),
            259 => write!(f, "DAY_OF_YEAR"),
            260 => write!(f, "YEAR"),
            261 => write!(f, "MANUFACTURER"),
            262 => write!(f, "VENDOR_STRING_1"),
            263 => write!(f, "VENDOR_STRING_2"),
            264 => write!(f, "VENDOR_STRING_3"),
            265 => write!(f, "VENDOR_STRING_4"),
            266 => write!(f, "VENDOR_TPM_TYPE"),
            267 => write!(f, "FIRMWARE_VERSION_1"),
            268 => write!(f, "FIRMWARE_VERSION_2"),
            269 => write!(f, "INPUT_BUFFER"),
            270 => write!(f, "HR_TRANSIENT_MIN"),
            271 => write!(f, "HR_PERSISTENT_MIN"),
            272 => write!(f, "HR_LOADED_MIN"),
            273 => write!(f, "ACTIVE_SESSIONS_MAX"),
            274 => write!(f, "PCR_COUNT"),
            275 => write!(f, "PCR_SELECT_MIN"),
            276 => write!(f, "CONTEXT_GAP_MAX"),
            278 => write!(f, "NV_COUNTERS_MAX"),
            279 => write!(f, "NV_INDEX_MAX"),
            280 => write!(f, "MEMORY"),
            281 => write!(f, "CLOCK_UPDATE"),
            282 => write!(f, "CONTEXT_HASH"),
            283 => write!(f, "CONTEXT_SYM"),
            284 => write!(f, "CONTEXT_SYM_SIZE"),
            285 => write!(f, "ORDERLY_COUNT"),
            286 => write!(f, "MAX_COMMAND_SIZE"),
            287 => write!(f, "MAX_RESPONSE_SIZE"),
            288 => write!(f, "MAX_DIGEST"),
            289 => write!(f, "MAX_OBJECT_CONTEXT"),
            290 => write!(f, "MAX_SESSION_CONTEXT"),
            291 => write!(f, "PS_FAMILY_INDICATOR"),
            292 => write!(f, "PS_LEVEL"),
            293 => write!(f, "PS_REVISION"),
            294 => write!(f, "PS_DAY_OF_YEAR"),
            295 => write!(f, "PS_YEAR"),
            296 => write!(f, "SPLIT_MAX"),
            297 => write!(f, "TOTAL_COMMANDS"),
            298 => write!(f, "LIBRARY_COMMANDS"),
            299 => write!(f, "VENDOR_COMMANDS"),
            300 => write!(f, "NV_BUFFER_MAX"),
            301 => write!(f, "MODES"),
            302 => write!(f, "MAX_CAP_BUFFER"),
            512 => write!(f, "One of <PT_VAR, PERMANENT>"),
            513 => write!(f, "STARTUP_CLEAR"),
            514 => write!(f, "HR_NV_INDEX"),
            515 => write!(f, "HR_LOADED"),
            516 => write!(f, "HR_LOADED_AVAIL"),
            517 => write!(f, "HR_ACTIVE"),
            518 => write!(f, "HR_ACTIVE_AVAIL"),
            519 => write!(f, "HR_TRANSIENT_AVAIL"),
            520 => write!(f, "HR_PERSISTENT"),
            521 => write!(f, "HR_PERSISTENT_AVAIL"),
            522 => write!(f, "NV_COUNTERS"),
            523 => write!(f, "NV_COUNTERS_AVAIL"),
            524 => write!(f, "ALGORITHM_SET"),
            525 => write!(f, "LOADED_CURVES"),
            526 => write!(f, "LOCKOUT_COUNTER"),
            527 => write!(f, "MAX_AUTH_FAIL"),
            528 => write!(f, "LOCKOUT_INTERVAL"),
            529 => write!(f, "LOCKOUT_RECOVERY"),
            530 => write!(f, "NV_WRITE_RECOVERY"),
            531 => write!(f, "AUDIT_COUNTER_0"),
            532 => write!(f, "AUDIT_COUNTER_1"),
            _ => write!(f, "Unknown({:?})", self.0),
        }

    }

}

/// The TPM_PT_PCR constants are used in TPM2_GetCapability() to indicate the property
/// being selected or returned. The PCR properties can be read when capability ==
/// TPM_CAP_PCR_PROPERTIES. If there is no property that corresponds to the value of
/// property, the next higher value is returned, if it exists.

/// Enum with duplicated values - using struct with constants
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Default)]
pub struct TPM_PT_PCR(pub u32);

impl TPM_PT_PCR {
    /// Bottom of the range of TPM_PT_PCR properties
    pub const FIRST: Self = Self(0x0); // Original value: 0x00000000

    /// A SET bit in the TPMS_PCR_SELECT indicates that the PCR is saved and restored by TPM_SU_STATE
    pub const SAVE: Self = Self(0x0); // Original value: 0x00000000

    /// A SET bit in the TPMS_PCR_SELECT indicates that the PCR may be extended from locality 0
    /// This property is only present if a locality other than 0 is implemented.
    pub const EXTEND_L0: Self = Self(0x1); // Original value: 0x00000001

    /// A SET bit in the TPMS_PCR_SELECT indicates that the PCR may be reset by
    /// TPM2_PCR_Reset() from locality 0
    pub const RESET_L0: Self = Self(0x2); // Original value: 0x00000002

    /// A SET bit in the TPMS_PCR_SELECT indicates that the PCR may be extended from locality 1
    /// This property is only present if locality 1 is implemented.
    pub const EXTEND_L1: Self = Self(0x3); // Original value: 0x00000003

    /// A SET bit in the TPMS_PCR_SELECT indicates that the PCR may be reset by
    /// TPM2_PCR_Reset() from locality 1
    /// This property is only present if locality 1 is implemented.
    pub const RESET_L1: Self = Self(0x4); // Original value: 0x00000004

    /// A SET bit in the TPMS_PCR_SELECT indicates that the PCR may be extended from locality 2
    /// This property is only present if localities 1 and 2 are implemented.
    pub const EXTEND_L2: Self = Self(0x5); // Original value: 0x00000005

    /// A SET bit in the TPMS_PCR_SELECT indicates that the PCR may be reset by
    /// TPM2_PCR_Reset() from locality 2
    /// This property is only present if localities 1 and 2 are implemented.
    pub const RESET_L2: Self = Self(0x6); // Original value: 0x00000006

    /// A SET bit in the TPMS_PCR_SELECT indicates that the PCR may be extended from locality 3
    /// This property is only present if localities 1, 2, and 3 are implemented.
    pub const EXTEND_L3: Self = Self(0x7); // Original value: 0x00000007

    /// A SET bit in the TPMS_PCR_SELECT indicates that the PCR may be reset by
    /// TPM2_PCR_Reset() from locality 3
    /// This property is only present if localities 1, 2, and 3 are implemented.
    pub const RESET_L3: Self = Self(0x8); // Original value: 0x00000008

    /// A SET bit in the TPMS_PCR_SELECT indicates that the PCR may be extended from locality 4
    /// This property is only present if localities 1, 2, 3, and 4 are implemented.
    pub const EXTEND_L4: Self = Self(0x9); // Original value: 0x00000009

    /// A SET bit in the TPMS_PCR_SELECT indicates that the PCR may be reset by
    /// TPM2_PCR_Reset() from locality 4
    /// This property is only present if localities 1, 2, 3, and 4 are implemented.
    pub const RESET_L4: Self = Self(0xA); // Original value: 0x0000000A

    /// A SET bit in the TPMS_PCR_SELECT indicates that modifications to this PCR (reset or
    /// Extend) will not increment the pcrUpdateCounter
    pub const NO_INCREMENT: Self = Self(0x11); // Original value: 0x00000011

    /// A SET bit in the TPMS_PCR_SELECT indicates that the PCR is reset by a D-RTM event
    /// These PCR are reset to -1 on TPM2_Startup() and reset to 0 on a _TPM_Hash_End event
    /// following a _TPM_Hash_Start event.
    pub const DRTM_RESET: Self = Self(0x12); // Original value: 0x00000012

    /// A SET bit in the TPMS_PCR_SELECT indicates that the PCR is controlled by policy
    /// This property is only present if the TPM supports policy control of a PCR.
    pub const POLICY: Self = Self(0x13); // Original value: 0x00000013

    /// A SET bit in the TPMS_PCR_SELECT indicates that the PCR is controlled by an
    /// authorization value
    /// This property is only present if the TPM supports authorization control of a PCR.
    pub const AUTH: Self = Self(0x14); // Original value: 0x00000014

    /// Top of the range of TPM_PT_PCR properties of the implementation
    /// If the TPM receives a request for a PCR property with a value larger than this, the
    /// TPM will return a zero length list and set the moreData parameter to NO.
    /// NOTE This is an implementation-specific value. The value shown reflects the reference
    /// code implementation.
    pub const LAST: Self = Self(0x14); // Original value: 0x00000014

    pub fn try_from(value: i32) -> Result<Self, TpmError> {
        match value {
            0 => Ok(Self::FIRST), // Original value: 0x00000000
            1 => Ok(Self::EXTEND_L0), // Original value: 0x00000001
            2 => Ok(Self::RESET_L0), // Original value: 0x00000002
            3 => Ok(Self::EXTEND_L1), // Original value: 0x00000003
            4 => Ok(Self::RESET_L1), // Original value: 0x00000004
            5 => Ok(Self::EXTEND_L2), // Original value: 0x00000005
            6 => Ok(Self::RESET_L2), // Original value: 0x00000006
            7 => Ok(Self::EXTEND_L3), // Original value: 0x00000007
            8 => Ok(Self::RESET_L3), // Original value: 0x00000008
            9 => Ok(Self::EXTEND_L4), // Original value: 0x00000009
            10 => Ok(Self::RESET_L4), // Original value: 0x0000000A
            17 => Ok(Self::NO_INCREMENT), // Original value: 0x00000011
            18 => Ok(Self::DRTM_RESET), // Original value: 0x00000012
            19 => Ok(Self::POLICY), // Original value: 0x00000013
            20 => Ok(Self::AUTH), // Original value: 0x00000014
            _ => Err(TpmError::InvalidEnumValue),
        }

    }

}

impl TpmEnum for TPM_PT_PCR {
    fn get_value(&self) -> u32 {
        self.0.into()
    }

}

impl From<TPM_PT_PCR> for u32 {
    fn from(value: TPM_PT_PCR) -> Self {
        value.0.into()
    }
}

impl From<TPM_PT_PCR> for i32 {
    fn from(value: TPM_PT_PCR) -> Self {
        value.0 as i32
    }
}

impl fmt::Display for TPM_PT_PCR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self.0 {
            0 => write!(f, "One of <FIRST, SAVE>"),
            1 => write!(f, "EXTEND_L0"),
            2 => write!(f, "RESET_L0"),
            3 => write!(f, "EXTEND_L1"),
            4 => write!(f, "RESET_L1"),
            5 => write!(f, "EXTEND_L2"),
            6 => write!(f, "RESET_L2"),
            7 => write!(f, "EXTEND_L3"),
            8 => write!(f, "RESET_L3"),
            9 => write!(f, "EXTEND_L4"),
            10 => write!(f, "RESET_L4"),
            17 => write!(f, "NO_INCREMENT"),
            18 => write!(f, "DRTM_RESET"),
            19 => write!(f, "POLICY"),
            20 => write!(f, "One of <AUTH, LAST>"),
            _ => write!(f, "Unknown({:?})", self.0),
        }

    }

}

/// The platform values in Table 25 are used for the TPM_PT_PS_FAMILY_INDICATOR.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, TryFromPrimitive, Default)]
#[repr(i32)]
pub enum TPM_PS {
    #[default]

    /// Not platform specific
    MAIN = 0x0, // Original value: 0x00000000

    /// PC Client
    PC = 0x1, // Original value: 0x00000001

    /// PDA (includes all mobile devices that are not specifically cell phones)
    PDA = 0x2, // Original value: 0x00000002

    /// Cell Phone
    CELL_PHONE = 0x3, // Original value: 0x00000003

    /// Server WG
    SERVER = 0x4, // Original value: 0x00000004

    /// Peripheral WG
    PERIPHERAL = 0x5, // Original value: 0x00000005

    /// TSS WG (deprecated)
    TSS = 0x6, // Original value: 0x00000006

    /// Storage WG
    STORAGE = 0x7, // Original value: 0x00000007

    /// Authentication WG
    AUTHENTICATION = 0x8, // Original value: 0x00000008

    /// Embedded WG
    EMBEDDED = 0x9, // Original value: 0x00000009

    /// Hardcopy WG
    HARDCOPY = 0xA, // Original value: 0x0000000A

    /// Infrastructure WG (deprecated)
    INFRASTRUCTURE = 0xB, // Original value: 0x0000000B

    /// Virtualization WG
    VIRTUALIZATION = 0xC, // Original value: 0x0000000C

    /// Trusted Network Connect WG (deprecated)
    TNC = 0xD, // Original value: 0x0000000D

    /// Multi-tenant WG (deprecated)
    MULTI_TENANT = 0xE, // Original value: 0x0000000E

    /// Technical Committee (deprecated)
    TC = 0xF // Original value: 0x0000000F
}

impl TpmEnum for TPM_PS {
    fn get_value(&self) -> u32 {
        *self as u32
    }

}

impl From<TPM_PS> for u32 {
    fn from(value: TPM_PS) -> Self {
        value as u32
    }

}

impl From<TPM_PS> for i32 {
    fn from(value: TPM_PS) -> Self {
        value as i32
    }

}

impl fmt::Display for TPM_PS {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::MAIN => write!(f, "MAIN"),
            Self::PC => write!(f, "PC"),
            Self::PDA => write!(f, "PDA"),
            Self::CELL_PHONE => write!(f, "CELL_PHONE"),
            Self::SERVER => write!(f, "SERVER"),
            Self::PERIPHERAL => write!(f, "PERIPHERAL"),
            Self::TSS => write!(f, "TSS"),
            Self::STORAGE => write!(f, "STORAGE"),
            Self::AUTHENTICATION => write!(f, "AUTHENTICATION"),
            Self::EMBEDDED => write!(f, "EMBEDDED"),
            Self::HARDCOPY => write!(f, "HARDCOPY"),
            Self::INFRASTRUCTURE => write!(f, "INFRASTRUCTURE"),
            Self::VIRTUALIZATION => write!(f, "VIRTUALIZATION"),
            Self::TNC => write!(f, "TNC"),
            Self::MULTI_TENANT => write!(f, "MULTI_TENANT"),
            Self::TC => write!(f, "TC"),
        }
    }
}

/// The 32-bit handle space is divided into 256 regions of equal size with 224 values in
/// each. Each of these ranges represents a handle type.

/// Enum with duplicated values - using struct with constants
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Default)]
pub struct TPM_HT(pub u8);

impl TPM_HT {
    /// PCR consecutive numbers, starting at 0, that reference the PCR registers
    /// A platform-specific specification will set the minimum number of PCR and an
    /// implementation may have more.
    pub const PCR: Self = Self(0x0); // Original value: 0x00

    /// NV Index assigned by the caller
    pub const NV_INDEX: Self = Self(0x1); // Original value: 0x01

    /// HMAC Authorization Session assigned by the TPM when the session is created
    pub const HMAC_SESSION: Self = Self(0x2); // Original value: 0x02

    /// Loaded Authorization Session used only in the context of TPM2_GetCapability
    /// This type references both loaded HMAC and loaded policy authorization sessions.
    pub const LOADED_SESSION: Self = Self(0x2); // Original value: 0x02

    /// Policy Authorization Session assigned by the TPM when the session is created
    pub const POLICY_SESSION: Self = Self(0x3); // Original value: 0x03

    /// Saved Authorization Session used only in the context of TPM2_GetCapability
    /// This type references saved authorization session contexts for which the TPM is
    /// maintaining tracking information.
    pub const SAVED_SESSION: Self = Self(0x3); // Original value: 0x03

    /// Permanent Values assigned by this specification in Table 28
    pub const PERMANENT: Self = Self(0x40);

    /// Transient Objects assigned by the TPM when an object is loaded into transient-object
    /// memory or when a persistent object is converted to a transient object
    pub const TRANSIENT: Self = Self(0x80);

    /// Persistent Objects assigned by the TPM when a loaded transient object is made persistent
    pub const PERSISTENT: Self = Self(0x81);

    /// Attached Component handle for an Attached Component.
    pub const AC: Self = Self(0x90);

    pub fn try_from(value: i8) -> Result<Self, TpmError> {
        match value {
            0 => Ok(Self::PCR), // Original value: 0x00
            1 => Ok(Self::NV_INDEX), // Original value: 0x01
            2 => Ok(Self::HMAC_SESSION), // Original value: 0x02
            3 => Ok(Self::POLICY_SESSION), // Original value: 0x03
            64 => Ok(Self::PERMANENT), // Original value: 0x40
            128 => Ok(Self::TRANSIENT), // Original value: 0x80
            129 => Ok(Self::PERSISTENT), // Original value: 0x81
            144 => Ok(Self::AC), // Original value: 0x90
            _ => Err(TpmError::InvalidEnumValue),
        }

    }

}

impl TpmEnum for TPM_HT {
    fn get_value(&self) -> u32 {
        self.0.into()
    }

}

impl From<TPM_HT> for u32 {
    fn from(value: TPM_HT) -> Self {
        value.0.into()
    }
}

impl From<TPM_HT> for i32 {
    fn from(value: TPM_HT) -> Self {
        value.0 as i32
    }
}

impl fmt::Display for TPM_HT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self.0 {
            0 => write!(f, "PCR"),
            1 => write!(f, "NV_INDEX"),
            2 => write!(f, "One of <HMAC_SESSION, LOADED_SESSION>"),
            3 => write!(f, "One of <POLICY_SESSION, SAVED_SESSION>"),
            64 => write!(f, "PERMANENT"),
            128 => write!(f, "TRANSIENT"),
            129 => write!(f, "PERSISTENT"),
            144 => write!(f, "AC"),
            _ => write!(f, "Unknown({:?})", self.0),
        }

    }

}

/// Table 28 lists the architecturally defined handles that cannot be changed. The handles
/// include authorization handles, and special handles.

/// Enum with duplicated values - using struct with constants
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Default)]
pub struct TPM_RH(pub u32);

impl TPM_RH {
    pub const FIRST: Self = Self(0x40000000);

    /// Not used1
    pub const SRK: Self = Self(0x40000000);

    /// Handle references the Storage Primary Seed (SPS), the ownerAuth, and the ownerPolicy
    pub const OWNER: Self = Self(0x40000001);

    /// Not used1
    pub const REVOKE: Self = Self(0x40000002);

    /// Not used1
    pub const TRANSPORT: Self = Self(0x40000003);

    /// Not used1
    pub const OPERATOR: Self = Self(0x40000004);

    /// Not used1
    pub const ADMIN: Self = Self(0x40000005);

    /// Not used1
    pub const EK: Self = Self(0x40000006);

    /// A handle associated with the null hierarchy, an EmptyAuth authValue, and an Empty
    /// Policy authPolicy.
    pub const NULL: Self = Self(0x40000007);

    /// Value reserved to the TPM to indicate a handle location that has not been initialized
    /// or assigned
    pub const UNASSIGNED: Self = Self(0x40000008);

    /// Authorization value used to indicate a password authorization session
    pub const PW: Self = Self(0x40000009);

    /// References the authorization associated with the dictionary attack lockout reset
    pub const LOCKOUT: Self = Self(0x4000000A);

    /// References the Endorsement Primary Seed (EPS), endorsementAuth, and endorsementPolicy
    pub const ENDORSEMENT: Self = Self(0x4000000B);

    /// References the Platform Primary Seed (PPS), platformAuth, and platformPolicy
    pub const PLATFORM: Self = Self(0x4000000C);

    /// For phEnableNV
    pub const PLATFORM_NV: Self = Self(0x4000000D);

    /// Start of a range of authorization values that are vendor-specific. A TPM may support
    /// any of the values in this range as are needed for vendor-specific purposes.
    /// Disabled if ehEnable is CLEAR.
    /// NOTE Any includes none.
    pub const AUTH_00: Self = Self(0x40000010);

    /// End of the range of vendor-specific authorization values.
    pub const AUTH_FF: Self = Self(0x4000010F);

    /// Start of the range of authenticated timers
    pub const ACT_0: Self = Self(0x40000110);

    /// End of the range of authenticated timers
    pub const ACT_F: Self = Self(0x4000011F);

    /// The top of the reserved handle area
    /// This is set to allow TPM2_GetCapability() to know where to stop. It may vary as
    /// implementations add to the permanent handle area.
    pub const LAST: Self = Self(0x4000011F);

    pub fn try_from(value: i32) -> Result<Self, TpmError> {
        match value {
            1073741824 => Ok(Self::FIRST), // Original value: 0x40000000
            1073741825 => Ok(Self::OWNER), // Original value: 0x40000001
            1073741826 => Ok(Self::REVOKE), // Original value: 0x40000002
            1073741827 => Ok(Self::TRANSPORT), // Original value: 0x40000003
            1073741828 => Ok(Self::OPERATOR), // Original value: 0x40000004
            1073741829 => Ok(Self::ADMIN), // Original value: 0x40000005
            1073741830 => Ok(Self::EK), // Original value: 0x40000006
            1073741831 => Ok(Self::NULL), // Original value: 0x40000007
            1073741832 => Ok(Self::UNASSIGNED), // Original value: 0x40000008
            1073741833 => Ok(Self::PW), // Original value: 0x40000009
            1073741834 => Ok(Self::LOCKOUT), // Original value: 0x4000000A
            1073741835 => Ok(Self::ENDORSEMENT), // Original value: 0x4000000B
            1073741836 => Ok(Self::PLATFORM), // Original value: 0x4000000C
            1073741837 => Ok(Self::PLATFORM_NV), // Original value: 0x4000000D
            1073741840 => Ok(Self::AUTH_00), // Original value: 0x40000010
            1073742095 => Ok(Self::AUTH_FF), // Original value: 0x4000010F
            1073742096 => Ok(Self::ACT_0), // Original value: 0x40000110
            1073742111 => Ok(Self::ACT_F), // Original value: 0x4000011F
            _ => Err(TpmError::InvalidEnumValue),
        }

    }

}

impl TpmEnum for TPM_RH {
    fn get_value(&self) -> u32 {
        self.0.into()
    }

}

impl From<TPM_RH> for u32 {
    fn from(value: TPM_RH) -> Self {
        value.0.into()
    }
}

impl From<TPM_RH> for i32 {
    fn from(value: TPM_RH) -> Self {
        value.0 as i32
    }
}

impl fmt::Display for TPM_RH {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self.0 {
            1073741824 => write!(f, "One of <FIRST, SRK>"),
            1073741825 => write!(f, "OWNER"),
            1073741826 => write!(f, "REVOKE"),
            1073741827 => write!(f, "TRANSPORT"),
            1073741828 => write!(f, "OPERATOR"),
            1073741829 => write!(f, "ADMIN"),
            1073741830 => write!(f, "EK"),
            1073741831 => write!(f, "NULL"),
            1073741832 => write!(f, "UNASSIGNED"),
            1073741833 => write!(f, "PW"),
            1073741834 => write!(f, "LOCKOUT"),
            1073741835 => write!(f, "ENDORSEMENT"),
            1073741836 => write!(f, "PLATFORM"),
            1073741837 => write!(f, "PLATFORM_NV"),
            1073741840 => write!(f, "AUTH_00"),
            1073742095 => write!(f, "AUTH_FF"),
            1073742096 => write!(f, "ACT_0"),
            1073742111 => write!(f, "One of <ACT_F, LAST>"),
            _ => write!(f, "Unknown({:?})", self.0),
        }

    }

}

/// This table lists the values of the TPM_NT field of a TPMA_NV. See Table 215 for usage.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, TryFromPrimitive, Default)]
#[repr(i32)]
pub enum TPM_NT {
    #[default]

    /// Ordinary contains data that is opaque to the TPM that can only be modified using TPM2_NV_Write().
    ORDINARY = 0x0,

    /// Counter contains an 8-octet value that is to be used as a counter and can only be
    /// modified with TPM2_NV_Increment()
    COUNTER = 0x1,

    /// Bit Field contains an 8-octet value to be used as a bit field and can only be modified
    /// with TPM2_NV_SetBits().
    BITS = 0x2,

    /// Extend contains a digest-sized value used like a PCR. The Index can only be modified
    /// using TPM2_NV_Extend(). The extend will use the nameAlg of the Index.
    EXTEND = 0x4,

    /// PIN Fail - contains pinCount that increments on a PIN authorization failure and a pinLimit
    PIN_FAIL = 0x8,

    /// PIN Pass - contains pinCount that increments on a PIN authorization success and a pinLimit
    PIN_PASS = 0x9
}

impl TpmEnum for TPM_NT {
    fn get_value(&self) -> u32 {
        *self as u32
    }

}

impl From<TPM_NT> for u32 {
    fn from(value: TPM_NT) -> Self {
        value as u32
    }

}

impl From<TPM_NT> for i32 {
    fn from(value: TPM_NT) -> Self {
        value as i32
    }

}

impl fmt::Display for TPM_NT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::ORDINARY => write!(f, "ORDINARY"),
            Self::COUNTER => write!(f, "COUNTER"),
            Self::BITS => write!(f, "BITS"),
            Self::EXTEND => write!(f, "EXTEND"),
            Self::PIN_FAIL => write!(f, "PIN_FAIL"),
            Self::PIN_PASS => write!(f, "PIN_PASS"),
        }
    }
}

/// These constants are used in TPM2_AC_GetCapability() to indicate the first tagged value
/// returned from an attached component.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, TryFromPrimitive, Default)]
#[repr(i32)]
pub enum TPM_AT {
    #[default]

    /// In a command, a non-specific request for AC information; in a response, indicates that
    /// outputData is not meaningful
    ANY = 0x0, // Original value: 0x00000000

    /// Indicates a TCG defined, device-specific error
    ERROR = 0x1, // Original value: 0x00000001

    /// Indicates the most significant 32 bits of a pairing value for the AC
    PV1 = 0x2, // Original value: 0x00000002

    /// Value added to a TPM_AT to indicate a vendor-specific tag value
    VEND = 0x80000000
}

impl TpmEnum for TPM_AT {
    fn get_value(&self) -> u32 {
        *self as u32
    }

}

impl From<TPM_AT> for u32 {
    fn from(value: TPM_AT) -> Self {
        value as u32
    }

}

impl From<TPM_AT> for i32 {
    fn from(value: TPM_AT) -> Self {
        value as i32
    }

}

impl fmt::Display for TPM_AT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::ANY => write!(f, "ANY"),
            Self::ERROR => write!(f, "ERROR"),
            Self::PV1 => write!(f, "PV1"),
            Self::VEND => write!(f, "VEND"),
        }
    }
}

/// These constants are the TCG-defined error values returned by an AC.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, TryFromPrimitive, Default)]
#[repr(i32)]
pub enum TPM_AE {
    #[default]

    /// In a command, a non-specific request for AC information; in a response, indicates that
    /// outputData is not meaningful
    NONE = 0x0 // Original value: 0x00000000
}

impl TpmEnum for TPM_AE {
    fn get_value(&self) -> u32 {
        *self as u32
    }

}

impl From<TPM_AE> for u32 {
    fn from(value: TPM_AE) -> Self {
        value as u32
    }

}

impl From<TPM_AE> for i32 {
    fn from(value: TPM_AE) -> Self {
        value as i32
    }

}

impl fmt::Display for TPM_AE {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::NONE => write!(f, "NONE"),
        }
    }
}

/// These values are readable with TPM2_GetCapability(). They are the TPM_PT_PS_xxx values.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, TryFromPrimitive, Default)]
#[repr(i32)]
pub enum PLATFORM {
    #[default]
    FAMILY = 0x322E3000, // Original value: TPM_SPEC::FAMILY
    LEVEL = 0x0, // Original value: TPM_SPEC::LEVEL
    VERSION = 0xA2, // Original value: TPM_SPEC::VERSION
    YEAR = 0x7E3, // Original value: TPM_SPEC::YEAR
    DAY_OF_YEAR = 0x168 // Original value: TPM_SPEC::DAY_OF_YEAR
}

impl TpmEnum for PLATFORM {
    fn get_value(&self) -> u32 {
        *self as u32
    }

}

impl From<PLATFORM> for u32 {
    fn from(value: PLATFORM) -> Self {
        value as u32
    }

}

impl From<PLATFORM> for i32 {
    fn from(value: PLATFORM) -> Self {
        value as i32
    }

}

impl fmt::Display for PLATFORM {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::FAMILY => write!(f, "FAMILY"),
            Self::LEVEL => write!(f, "LEVEL"),
            Self::VERSION => write!(f, "VERSION"),
            Self::YEAR => write!(f, "YEAR"),
            Self::DAY_OF_YEAR => write!(f, "DAY_OF_YEAR"),
        }
    }
}

/// This table contains a collection of values used in various parts of the reference
/// code. The values shown are illustrative.

/// Enum with duplicated values - using struct with constants
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Default)]
pub struct Implementation(pub u32);

impl Implementation {
    /// Temporary define
    pub const FIELD_UPGRADE_IMPLEMENTED: Self = Self(0x0); // Original value: Logic::NO

    /// Selection of the library that provides the basic hashing functions.
    pub const HASH_LIB: Self = Self(0x1); // Original value: ImplementationConstants::Ossl

    /// Selection of the library that provides the low-level symmetric cryptography. Choices
    /// are determined by the vendor (See LibSupport.h for implications).
    pub const SYM_LIB: Self = Self(0x1); // Original value: ImplementationConstants::Ossl

    /// Selection of the library that provides the big number math including ECC. Choices are
    /// determined by the vendor (See LibSupport.h for implications).
    pub const MATH_LIB: Self = Self(0x1); // Original value: ImplementationConstants::Ossl

    /// The number of PCR in the TPM
    pub const IMPLEMENTATION_PCR: Self = Self(0x18); // Original value: 24
    pub const PCR_SELECT_MAX: Self = Self(0x3); // Original value: ((IMPLEMENTATION_PCR+7)/8)

    /// The number of PCR required by the relevant platform specification
    pub const PLATFORM_PCR: Self = Self(0x18); // Original value: 24
    pub const PCR_SELECT_MIN: Self = Self(0x3); // Original value: ((PLATFORM_PCR + 7) / 8)

    /// The D-RTM PCR
    /// NOTE This value is not defined when the TPM does not implement D-RTM
    pub const DRTM_PCR: Self = Self(0x11); // Original value: 17

    /// The PCR that will receive the H-CRTM value at TPM2_Startup. This value should not be changed.
    pub const HCRTM_PCR: Self = Self(0x0); // Original value: 0

    /// The number of localities supported by the TPM
    /// This is expected to be either 5 for a PC, or 1 for just about everything else.
    pub const NUM_LOCALITIES: Self = Self(0x5); // Original value: 5

    /// The maximum number of handles in the handle area
    /// This should be produced by the Part 3 parser but is here for now.
    pub const MAX_HANDLE_NUM: Self = Self(0x3); // Original value: 3

    /// The number of simultaneously active sessions that are supported by the TPM implementation
    pub const MAX_ACTIVE_SESSIONS: Self = Self(0x40); // Original value: 64

    /// The number of sessions that the TPM may have in memory
    pub const MAX_LOADED_SESSIONS: Self = Self(0x3); // Original value: 3

    /// This is the current maximum value
    pub const MAX_SESSION_NUM: Self = Self(0x3); // Original value: 3

    /// The number of simultaneously loaded objects that are supported by the TPM; this number
    /// does not include the objects that may be placed in NV memory by TPM2_EvictControl().
    pub const MAX_LOADED_OBJECTS: Self = Self(0x3); // Original value: 3

    /// The minimum number of evict objects supported by the TPM
    pub const MIN_EVICT_OBJECTS: Self = Self(0x2); // Original value: 2

    /// Number of PCR groups that have individual policies
    pub const NUM_POLICY_PCR_GROUP: Self = Self(0x1); // Original value: 1

    /// Number of PCR groups that have individual authorization values
    pub const NUM_AUTHVALUE_PCR_GROUP: Self = Self(0x1); // Original value: 1
    pub const MAX_CONTEXT_SIZE: Self = Self(0x4F0); // Original value: 1264
    pub const MAX_DIGEST_BUFFER: Self = Self(0x400); // Original value: 1024

    /// Maximum data size allowed in an NV Index
    pub const MAX_NV_INDEX_SIZE: Self = Self(0x800); // Original value: 2048

    /// Maximum data size in one NV read or write command
    pub const MAX_NV_BUFFER_SIZE: Self = Self(0x400); // Original value: 1024

    /// Maximum size of a capability buffer
    pub const MAX_CAP_BUFFER: Self = Self(0x400); // Original value: 1024

    /// Size of NV memory in octets
    pub const NV_MEMORY_SIZE: Self = Self(0x4000); // Original value: 16384

    /// The TPM will not allocate a non-counter index if it would prevent allocation of this
    /// number of indices.
    pub const MIN_COUNTER_INDICES: Self = Self(0x8); // Original value: 8
    pub const NUM_STATIC_PCR: Self = Self(0x10); // Original value: 16

    /// Number of algorithms that can be in a list
    pub const MAX_ALG_LIST_SIZE: Self = Self(0x40); // Original value: 64

    /// Size of the Primary Seed in octets
    pub const PRIMARY_SEED_SIZE: Self = Self(0x20); // Original value: 32

    /// Context encryption algorithm
    /// Just use the root so that the macros in GpMacros.h will work correctly.
    pub const CONTEXT_ENCRYPT_ALGORITHM: Self = Self(0x6); // Original value: TPM_ALG_ID::AES

    /// The update interval expressed as a power of 2 seconds
    /// A value of 12 is 4,096 seconds (~68 minutes).
    pub const NV_CLOCK_UPDATE_INTERVAL: Self = Self(0xC); // Original value: 12

    /// Number of PCR groups that allow policy/auth
    pub const NUM_POLICY_PCR: Self = Self(0x1); // Original value: 1

    /// Maximum size of a command
    pub const MAX_COMMAND_SIZE: Self = Self(0x1000); // Original value: 4096

    /// Maximum size of a response
    pub const MAX_RESPONSE_SIZE: Self = Self(0x1000); // Original value: 4096

    /// Number between 1 and 32 inclusive
    pub const ORDERLY_BITS: Self = Self(0x8); // Original value: 8

    /// The maximum number of octets that may be in a sealed blob; 128 is the minimum allowed value
    pub const MAX_SYM_DATA: Self = Self(0x80); // Original value: 128
    pub const MAX_RNG_ENTROPY_SIZE: Self = Self(0x40); // Original value: 64

    /// Number of bytes used for the RAM index space. If this is not large enough, it might
    /// not be possible to allocate orderly indices.
    pub const RAM_INDEX_SPACE: Self = Self(0x200); // Original value: 512

    /// 216 + 1
    pub const RSA_DEFAULT_PUBLIC_EXPONENT: Self = Self(0x10001); // Original value: 0x00010001

    /// Indicates if the TPM_PT_PCR_NO_INCREMENT group is implemented
    pub const ENABLE_PCR_NO_INCREMENT: Self = Self(0x1); // Original value: Logic::YES
    pub const CRT_FORMAT_RSA: Self = Self(0x1); // Original value: Logic::YES
    pub const VENDOR_COMMAND_COUNT: Self = Self(0x0); // Original value: 0

    /// Maximum size of the vendor-specific buffer
    pub const MAX_VENDOR_BUFFER_SIZE: Self = Self(0x400); // Original value: 1024

    /// L value for a derivation. This is the
    /// maximum number of bits allowed from an instantiation of a KDF-DRBG. This is size is OK
    /// because RSA keys are never derived keys
    pub const MAX_DERIVATION_BITS: Self = Self(0x2000); // Original value: 8192
    pub const RSA_MAX_PRIME: Self = Self(0x80); // Original value: (ImplementationConstants::MAX_RSA_KEY_BYTES/2)
    pub const RSA_PRIVATE_SIZE: Self = Self(0x280); // Original value: (RSA_MAX_PRIME * 5)
    pub const SIZE_OF_X509_SERIAL_NUMBER: Self = Self(0x14); // Original value: 20

    /// This is a vendor-specific value so it is in this vendor-speific table. When this is
    /// used, RSA_PRIVATE_SIZE will have been defined
    pub const PRIVATE_VENDOR_SPECIFIC_BYTES: Self = Self(0x280); // Original value: RSA_PRIVATE_SIZE

    pub fn try_from(value: i32) -> Result<Self, TpmError> {
        match value {
            0 => Ok(Self::FIELD_UPGRADE_IMPLEMENTED), // Original value: Logic::NO
            1 => Ok(Self::HASH_LIB), // Original value: ImplementationConstants::Ossl
            24 => Ok(Self::IMPLEMENTATION_PCR), // Original value: 24
            3 => Ok(Self::PCR_SELECT_MAX), // Original value: ((IMPLEMENTATION_PCR+7)/8)
            17 => Ok(Self::DRTM_PCR), // Original value: 17
            5 => Ok(Self::NUM_LOCALITIES), // Original value: 5
            64 => Ok(Self::MAX_ACTIVE_SESSIONS), // Original value: 64
            2 => Ok(Self::MIN_EVICT_OBJECTS), // Original value: 2
            1264 => Ok(Self::MAX_CONTEXT_SIZE), // Original value: 1264
            1024 => Ok(Self::MAX_DIGEST_BUFFER), // Original value: 1024
            2048 => Ok(Self::MAX_NV_INDEX_SIZE), // Original value: 2048
            16384 => Ok(Self::NV_MEMORY_SIZE), // Original value: 16384
            8 => Ok(Self::MIN_COUNTER_INDICES), // Original value: 8
            16 => Ok(Self::NUM_STATIC_PCR), // Original value: 16
            32 => Ok(Self::PRIMARY_SEED_SIZE), // Original value: 32
            6 => Ok(Self::CONTEXT_ENCRYPT_ALGORITHM), // Original value: TPM_ALG_ID::AES
            12 => Ok(Self::NV_CLOCK_UPDATE_INTERVAL), // Original value: 12
            4096 => Ok(Self::MAX_COMMAND_SIZE), // Original value: 4096
            128 => Ok(Self::MAX_SYM_DATA), // Original value: 128
            512 => Ok(Self::RAM_INDEX_SPACE), // Original value: 512
            65537 => Ok(Self::RSA_DEFAULT_PUBLIC_EXPONENT), // Original value: 0x00010001
            8192 => Ok(Self::MAX_DERIVATION_BITS), // Original value: 8192
            640 => Ok(Self::RSA_PRIVATE_SIZE), // Original value: (RSA_MAX_PRIME * 5)
            20 => Ok(Self::SIZE_OF_X509_SERIAL_NUMBER), // Original value: 20
            _ => Err(TpmError::InvalidEnumValue),
        }

    }

}

impl TpmEnum for Implementation {
    fn get_value(&self) -> u32 {
        self.0.into()
    }

}

impl From<Implementation> for u32 {
    fn from(value: Implementation) -> Self {
        value.0.into()
    }
}

impl From<Implementation> for i32 {
    fn from(value: Implementation) -> Self {
        value.0 as i32
    }
}

impl fmt::Display for Implementation {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self.0 {
            0 => write!(f, "One of <FIELD_UPGRADE_IMPLEMENTED, HCRTM_PCR, VENDOR_COMMAND_COUNT>"),
            1 => write!(f, "One of <HASH_LIB, SYM_LIB, MATH_LIB, NUM_POLICY_PCR_GROUP, NUM_AUTHVALUE_PCR_GROUP, NUM_POLICY_PCR, ENABLE_PCR_NO_INCREMENT, CRT_FORMAT_RSA>"),
            24 => write!(f, "One of <IMPLEMENTATION_PCR, PLATFORM_PCR>"),
            3 => write!(f, "One of <PCR_SELECT_MAX, PCR_SELECT_MIN, MAX_HANDLE_NUM, MAX_LOADED_SESSIONS, MAX_SESSION_NUM, MAX_LOADED_OBJECTS>"),
            17 => write!(f, "DRTM_PCR"),
            5 => write!(f, "NUM_LOCALITIES"),
            64 => write!(f, "One of <MAX_ACTIVE_SESSIONS, MAX_ALG_LIST_SIZE, MAX_RNG_ENTROPY_SIZE>"),
            2 => write!(f, "MIN_EVICT_OBJECTS"),
            1264 => write!(f, "MAX_CONTEXT_SIZE"),
            1024 => write!(f, "One of <MAX_DIGEST_BUFFER, MAX_NV_BUFFER_SIZE, MAX_CAP_BUFFER, MAX_VENDOR_BUFFER_SIZE>"),
            2048 => write!(f, "MAX_NV_INDEX_SIZE"),
            16384 => write!(f, "NV_MEMORY_SIZE"),
            8 => write!(f, "One of <MIN_COUNTER_INDICES, ORDERLY_BITS>"),
            16 => write!(f, "NUM_STATIC_PCR"),
            32 => write!(f, "PRIMARY_SEED_SIZE"),
            6 => write!(f, "CONTEXT_ENCRYPT_ALGORITHM"),
            12 => write!(f, "NV_CLOCK_UPDATE_INTERVAL"),
            4096 => write!(f, "One of <MAX_COMMAND_SIZE, MAX_RESPONSE_SIZE>"),
            128 => write!(f, "One of <MAX_SYM_DATA, RSA_MAX_PRIME>"),
            512 => write!(f, "RAM_INDEX_SPACE"),
            65537 => write!(f, "RSA_DEFAULT_PUBLIC_EXPONENT"),
            8192 => write!(f, "MAX_DERIVATION_BITS"),
            640 => write!(f, "One of <RSA_PRIVATE_SIZE, PRIVATE_VENDOR_SPECIFIC_BYTES>"),
            20 => write!(f, "SIZE_OF_X509_SERIAL_NUMBER"),
            _ => write!(f, "Unknown({:?})", self.0),
        }

    }

}

/// The definitions in Table 29 are used to define many of the interface data types.

/// Enum with duplicated values - using struct with constants
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Default)]
pub struct TPM_HC(pub u32);

impl TPM_HC {
    /// To mask off the HR
    pub const HR_HANDLE_MASK: Self = Self(0xFFFFFF); // Original value: 0x00FFFFFF

    /// To mask off the variable part
    pub const HR_RANGE_MASK: Self = Self(0xFF000000);
    pub const HR_SHIFT: Self = Self(0x18); // Original value: 24
    pub const HR_PCR: Self = Self(0x0); // Original value: (TPM_HT::PCR  <<  HR_SHIFT)
    pub const HR_HMAC_SESSION: Self = Self(0x2000000); // Original value: (TPM_HT::HMAC_SESSION  <<  HR_SHIFT)
    pub const HR_POLICY_SESSION: Self = Self(0x3000000); // Original value: (TPM_HT::POLICY_SESSION  <<  HR_SHIFT)
    pub const HR_TRANSIENT: Self = Self(0x80000000); // Original value: (TPM_HT::TRANSIENT  <<  HR_SHIFT)
    pub const HR_PERSISTENT: Self = Self(0x81000000); // Original value: (TPM_HT::PERSISTENT  <<  HR_SHIFT)
    pub const HR_NV_INDEX: Self = Self(0x1000000); // Original value: (TPM_HT::NV_INDEX  <<  HR_SHIFT)
    pub const HR_PERMANENT: Self = Self(0x40000000); // Original value: (TPM_HT::PERMANENT  <<  HR_SHIFT)

    /// First PCR
    pub const PCR_FIRST: Self = Self(0x0); // Original value: (HR_PCR + 0)

    /// Last PCR
    pub const PCR_LAST: Self = Self(0x17); // Original value: (PCR_FIRST + Implementation::IMPLEMENTATION_PCR-1)

    /// First HMAC session
    pub const HMAC_SESSION_FIRST: Self = Self(0x2000000); // Original value: (HR_HMAC_SESSION + 0)

    /// Last HMAC session
    pub const HMAC_SESSION_LAST: Self = Self(0x200003F); // Original value: (HMAC_SESSION_FIRST+Implementation::MAX_ACTIVE_SESSIONS-1)

    /// Used in GetCapability
    pub const LOADED_SESSION_FIRST: Self = Self(0x2000000); // Original value: HMAC_SESSION_FIRST

    /// Used in GetCapability
    pub const LOADED_SESSION_LAST: Self = Self(0x200003F); // Original value: HMAC_SESSION_LAST

    /// First policy session
    pub const POLICY_SESSION_FIRST: Self = Self(0x3000000); // Original value: (HR_POLICY_SESSION + 0)

    /// Last policy session
    pub const POLICY_SESSION_LAST: Self = Self(0x300003F); // Original value: (POLICY_SESSION_FIRST + Implementation::MAX_ACTIVE_SESSIONS-1)

    /// First transient object
    pub const TRANSIENT_FIRST: Self = Self(0x80000000); // Original value: (HR_TRANSIENT + 0)

    /// Used in GetCapability
    pub const ACTIVE_SESSION_FIRST: Self = Self(0x3000000); // Original value: POLICY_SESSION_FIRST

    /// Used in GetCapability
    pub const ACTIVE_SESSION_LAST: Self = Self(0x300003F); // Original value: POLICY_SESSION_LAST

    /// Last transient object
    pub const TRANSIENT_LAST: Self = Self(0x80000002); // Original value: (TRANSIENT_FIRST+Implementation::MAX_LOADED_OBJECTS-1)

    /// First persistent object
    pub const PERSISTENT_FIRST: Self = Self(0x81000000); // Original value: (HR_PERSISTENT + 0)

    /// Last persistent object
    pub const PERSISTENT_LAST: Self = Self(0x81FFFFFF); // Original value: (PERSISTENT_FIRST + 0x00FFFFFF)

    /// First platform persistent object
    pub const PLATFORM_PERSISTENT: Self = Self(0x81800000); // Original value: (PERSISTENT_FIRST + 0x00800000)

    /// First allowed NV Index
    pub const NV_INDEX_FIRST: Self = Self(0x1000000); // Original value: (HR_NV_INDEX + 0)

    /// Last allowed NV Index
    pub const NV_INDEX_LAST: Self = Self(0x1FFFFFF); // Original value: (NV_INDEX_FIRST + 0x00FFFFFF)
    pub const PERMANENT_FIRST: Self = Self(0x40000000); // Original value: TPM_RH::FIRST
    pub const PERMANENT_LAST: Self = Self(0x4000011F); // Original value: TPM_RH::LAST

    /// AC aliased NV Index
    pub const HR_NV_AC: Self = Self(0x1D00000); // Original value: ((TPM_HT::NV_INDEX  <<  HR_SHIFT) + 0xD00000)

    /// First NV Index aliased to Attached Component
    pub const NV_AC_FIRST: Self = Self(0x1D00000); // Original value: (HR_NV_AC + 0)

    /// Last NV Index aliased to Attached Component
    pub const NV_AC_LAST: Self = Self(0x1D0FFFF); // Original value: (HR_NV_AC + 0x0000FFFF)

    /// AC Handle
    pub const HR_AC: Self = Self(0x90000000); // Original value: (TPM_HT::AC  <<  HR_SHIFT)

    /// First Attached Component
    pub const AC_FIRST: Self = Self(0x90000000); // Original value: (HR_AC + 0)

    /// Last Attached Component
    pub const AC_LAST: Self = Self(0x9000FFFF); // Original value: (HR_AC + 0x0000FFFF)

    pub fn try_from(value: i32) -> Result<Self, TpmError> {
        match value {
            16777215 => Ok(Self::HR_HANDLE_MASK), // Original value: 0x00FFFFFF
            4278190080 => Ok(Self::HR_RANGE_MASK), // Original value: 0xFF000000
            24 => Ok(Self::HR_SHIFT), // Original value: 24
            0 => Ok(Self::HR_PCR), // Original value: (TPM_HT::PCR  <<  HR_SHIFT)
            33554432 => Ok(Self::HR_HMAC_SESSION), // Original value: (TPM_HT::HMAC_SESSION  <<  HR_SHIFT)
            50331648 => Ok(Self::HR_POLICY_SESSION), // Original value: (TPM_HT::POLICY_SESSION  <<  HR_SHIFT)
            2147483648 => Ok(Self::HR_TRANSIENT), // Original value: (TPM_HT::TRANSIENT  <<  HR_SHIFT)
            2164260864 => Ok(Self::HR_PERSISTENT), // Original value: (TPM_HT::PERSISTENT  <<  HR_SHIFT)
            16777216 => Ok(Self::HR_NV_INDEX), // Original value: (TPM_HT::NV_INDEX  <<  HR_SHIFT)
            1073741824 => Ok(Self::HR_PERMANENT), // Original value: (TPM_HT::PERMANENT  <<  HR_SHIFT)
            23 => Ok(Self::PCR_LAST), // Original value: (PCR_FIRST + Implementation::IMPLEMENTATION_PCR-1)
            33554495 => Ok(Self::HMAC_SESSION_LAST), // Original value: (HMAC_SESSION_FIRST+Implementation::MAX_ACTIVE_SESSIONS-1)
            50331711 => Ok(Self::POLICY_SESSION_LAST), // Original value: (POLICY_SESSION_FIRST + Implementation::MAX_ACTIVE_SESSIONS-1)
            2147483650 => Ok(Self::TRANSIENT_LAST), // Original value: (TRANSIENT_FIRST+Implementation::MAX_LOADED_OBJECTS-1)
            2181038079 => Ok(Self::PERSISTENT_LAST), // Original value: (PERSISTENT_FIRST + 0x00FFFFFF)
            2172649472 => Ok(Self::PLATFORM_PERSISTENT), // Original value: (PERSISTENT_FIRST + 0x00800000)
            33554431 => Ok(Self::NV_INDEX_LAST), // Original value: (NV_INDEX_FIRST + 0x00FFFFFF)
            1073742111 => Ok(Self::PERMANENT_LAST), // Original value: TPM_RH::LAST
            30408704 => Ok(Self::HR_NV_AC), // Original value: ((TPM_HT::NV_INDEX  <<  HR_SHIFT) + 0xD00000)
            30474239 => Ok(Self::NV_AC_LAST), // Original value: (HR_NV_AC + 0x0000FFFF)
            2415919104 => Ok(Self::HR_AC), // Original value: (TPM_HT::AC  <<  HR_SHIFT)
            2415984639 => Ok(Self::AC_LAST), // Original value: (HR_AC + 0x0000FFFF)
            _ => Err(TpmError::InvalidEnumValue),
        }

    }

}

impl TpmEnum for TPM_HC {
    fn get_value(&self) -> u32 {
        self.0.into()
    }

}

impl From<TPM_HC> for u32 {
    fn from(value: TPM_HC) -> Self {
        value.0.into()
    }
}

impl From<TPM_HC> for i32 {
    fn from(value: TPM_HC) -> Self {
        value.0 as i32
    }
}

impl fmt::Display for TPM_HC {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self.0 {
            16777215 => write!(f, "HR_HANDLE_MASK"),
            4278190080 => write!(f, "HR_RANGE_MASK"),
            24 => write!(f, "HR_SHIFT"),
            0 => write!(f, "One of <HR_PCR, PCR_FIRST>"),
            33554432 => write!(f, "One of <HR_HMAC_SESSION, HMAC_SESSION_FIRST, LOADED_SESSION_FIRST>"),
            50331648 => write!(f, "One of <HR_POLICY_SESSION, POLICY_SESSION_FIRST, ACTIVE_SESSION_FIRST>"),
            2147483648 => write!(f, "One of <HR_TRANSIENT, TRANSIENT_FIRST>"),
            2164260864 => write!(f, "One of <HR_PERSISTENT, PERSISTENT_FIRST>"),
            16777216 => write!(f, "One of <HR_NV_INDEX, NV_INDEX_FIRST>"),
            1073741824 => write!(f, "One of <HR_PERMANENT, PERMANENT_FIRST>"),
            23 => write!(f, "PCR_LAST"),
            33554495 => write!(f, "One of <HMAC_SESSION_LAST, LOADED_SESSION_LAST>"),
            50331711 => write!(f, "One of <POLICY_SESSION_LAST, ACTIVE_SESSION_LAST>"),
            2147483650 => write!(f, "TRANSIENT_LAST"),
            2181038079 => write!(f, "PERSISTENT_LAST"),
            2172649472 => write!(f, "PLATFORM_PERSISTENT"),
            33554431 => write!(f, "NV_INDEX_LAST"),
            1073742111 => write!(f, "PERMANENT_LAST"),
            30408704 => write!(f, "One of <HR_NV_AC, NV_AC_FIRST>"),
            30474239 => write!(f, "NV_AC_LAST"),
            2415919104 => write!(f, "One of <HR_AC, AC_FIRST>"),
            2415984639 => write!(f, "AC_LAST"),
            _ => write!(f, "Unknown({:?})", self.0),
        }

    }

}

/// This structure defines the attributes of an algorithm.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, TryFromPrimitive, Default)]
#[repr(i32)]
pub enum TPMA_ALGORITHM {
    #[default]

    /// SET (1): an asymmetric algorithm with public and private portions
    /// CLEAR (0): not an asymmetric algorithm
    asymmetric = 0x1,

    /// SET (1): a symmetric block cipher
    /// CLEAR (0): not a symmetric block cipher
    symmetric = 0x2,

    /// SET (1): a hash algorithm
    /// CLEAR (0): not a hash algorithm
    hash = 0x4,

    /// SET (1): an algorithm that may be used as an object type
    /// CLEAR (0): an algorithm that is not used as an object type
    object = 0x8,

    /// SET (1): a signing algorithm. The setting of asymmetric, symmetric, and hash will
    /// indicate the type of signing algorithm.
    /// CLEAR (0): not a signing algorithm
    signing = 0x100,

    /// SET (1): an encryption/decryption algorithm. The setting of asymmetric, symmetric, and
    /// hash will indicate the type of encryption/decryption algorithm.
    /// CLEAR (0): not an encryption/decryption algorithm
    encrypting = 0x200,

    /// SET (1): a method such as a key derivative function (KDF)
    /// CLEAR (0): not a method
    method = 0x400
}

impl TpmEnum for TPMA_ALGORITHM {
    fn get_value(&self) -> u32 {
        *self as u32
    }

}

impl From<TPMA_ALGORITHM> for u32 {
    fn from(value: TPMA_ALGORITHM) -> Self {
        value as u32
    }

}

impl From<TPMA_ALGORITHM> for i32 {
    fn from(value: TPMA_ALGORITHM) -> Self {
        value as i32
    }

}

impl fmt::Display for TPMA_ALGORITHM {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::asymmetric => write!(f, "asymmetric"),
            Self::symmetric => write!(f, "symmetric"),
            Self::hash => write!(f, "hash"),
            Self::object => write!(f, "object"),
            Self::signing => write!(f, "signing"),
            Self::encrypting => write!(f, "encrypting"),
            Self::method => write!(f, "method"),
        }
    }
}

impl std::ops::BitOr for TPMA_ALGORITHM {
type Output = Self;
    fn bitor(self, rhs: Self) -> Self::Output {
    unsafe { std::mem::transmute(self as u32 | rhs as u32) }
    }

}

impl From<u32> for TPMA_ALGORITHM {
fn from(value: u32) -> Self {
    unsafe { std::mem::transmute(value) }
    }

}

/// This attribute structure indicates an objects use, its authorization types, and its
/// relationship to other objects.

/// Enum with duplicated values - using struct with constants
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Default)]
pub struct TPMA_OBJECT(pub u32);

impl TPMA_OBJECT {
    /// SET (1): The hierarchy of the object, as indicated by its Qualified Name, may not change.
    /// CLEAR (0): The hierarchy of the object may change as a result of this object or an
    /// ancestor key being duplicated for use in another hierarchy.
    /// NOTE fixedTPM does not indicate that key material resides on a single TPM (see
    /// sensitiveDataOrigin).
    pub const fixedTPM: Self = Self(0x2);

    /// SET (1): Previously saved contexts of this object may not be loaded after Startup(CLEAR).
    /// CLEAR (0): Saved contexts of this object may be used after a Shutdown(STATE) and
    /// subsequent Startup().
    pub const stClear: Self = Self(0x4);

    /// SET (1): The parent of the object may not change.
    /// CLEAR (0): The parent of the object may change as the result of a TPM2_Duplicate() of
    /// the object.
    pub const fixedParent: Self = Self(0x10);

    /// SET (1): Indicates that, when the object was created with TPM2_Create() or
    /// TPM2_CreatePrimary(), the TPM generated all of the sensitive data other than the authValue.
    /// CLEAR (0): A portion of the sensitive data, other than the authValue, was provided by
    /// the caller.
    pub const sensitiveDataOrigin: Self = Self(0x20);

    /// SET (1): Approval of USER role actions with this object may be with an HMAC session or
    /// with a password using the authValue of the object or a policy session.
    /// CLEAR (0): Approval of USER role actions with this object may only be done with a
    /// policy session.
    pub const userWithAuth: Self = Self(0x40);

    /// SET (1): Approval of ADMIN role actions with this object may only be done with a
    /// policy session.
    /// CLEAR (0): Approval of ADMIN role actions with this object may be with an HMAC session
    /// or with a password using the authValue of the object or a policy session.
    pub const adminWithPolicy: Self = Self(0x80);

    /// SET (1): The object is not subject to dictionary attack protections.
    /// CLEAR (0): The object is subject to dictionary attack protections.
    pub const noDA: Self = Self(0x400);

    /// SET (1): If the object is duplicated, then symmetricAlg shall not be TPM_ALG_NULL and
    /// newParentHandle shall not be TPM_RH_NULL.
    /// CLEAR (0): The object may be duplicated without an inner wrapper on the private
    /// portion of the object and the new parent may be TPM_RH_NULL.
    pub const encryptedDuplication: Self = Self(0x800);

    /// SET (1): Key usage is restricted to manipulate structures of known format; the parent
    /// of this key shall have restricted SET.
    /// CLEAR (0): Key usage is not restricted to use on special formats.
    pub const restricted: Self = Self(0x10000);

    /// SET (1): The private portion of the key may be used to decrypt.
    /// CLEAR (0): The private portion of the key may not be used to decrypt.
    pub const decrypt: Self = Self(0x20000);

    /// SET (1): For a symmetric cipher object, the private portion of the key may be used to
    /// encrypt. For other objects, the private portion of the key may be used to sign.
    /// CLEAR (0): The private portion of the key may not be used to sign or encrypt.
    pub const sign: Self = Self(0x40000);

    /// Alias to the sign value.
    pub const encrypt: Self = Self(0x40000);

    /// SET (1): An asymmetric key that may not be used to sign with TPM2_Sign()
    /// CLEAR (0): A key that may be used with TPM2_Sign() if sign is SET
    /// NOTE: This attribute only has significance if sign is SET.
    pub const x509sign: Self = Self(0x80000);

    pub fn try_from(value: i32) -> Result<Self, TpmError> {
        match value {
            2 => Ok(Self::fixedTPM), // Original value: 0x2
            4 => Ok(Self::stClear), // Original value: 0x4
            16 => Ok(Self::fixedParent), // Original value: 0x10
            32 => Ok(Self::sensitiveDataOrigin), // Original value: 0x20
            64 => Ok(Self::userWithAuth), // Original value: 0x40
            128 => Ok(Self::adminWithPolicy), // Original value: 0x80
            1024 => Ok(Self::noDA), // Original value: 0x400
            2048 => Ok(Self::encryptedDuplication), // Original value: 0x800
            65536 => Ok(Self::restricted), // Original value: 0x10000
            131072 => Ok(Self::decrypt), // Original value: 0x20000
            262144 => Ok(Self::sign), // Original value: 0x40000
            524288 => Ok(Self::x509sign), // Original value: 0x80000
            _ => Err(TpmError::InvalidEnumValue),
        }

    }

}

impl TpmEnum for TPMA_OBJECT {
    fn get_value(&self) -> u32 {
        self.0.into()
    }

}

impl From<TPMA_OBJECT> for u32 {
    fn from(value: TPMA_OBJECT) -> Self {
        value.0.into()
    }
}

impl From<TPMA_OBJECT> for i32 {
    fn from(value: TPMA_OBJECT) -> Self {
        value.0 as i32
    }
}

impl fmt::Display for TPMA_OBJECT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self.0 {
            2 => write!(f, "fixedTPM"),
            4 => write!(f, "stClear"),
            16 => write!(f, "fixedParent"),
            32 => write!(f, "sensitiveDataOrigin"),
            64 => write!(f, "userWithAuth"),
            128 => write!(f, "adminWithPolicy"),
            1024 => write!(f, "noDA"),
            2048 => write!(f, "encryptedDuplication"),
            65536 => write!(f, "restricted"),
            131072 => write!(f, "decrypt"),
            262144 => write!(f, "One of <sign, encrypt>"),
            524288 => write!(f, "x509sign"),
            _ => write!(f, "Unknown({:?})", self.0),
        }

    }

}

impl std::ops::BitOr for TPMA_OBJECT {
    type Output = Self;

    fn bitor(self, rhs: Self) -> Self::Output {
        Self(self.0 | rhs.0)
    }

}

impl From<u32> for TPMA_OBJECT {
    fn from(value: u32) -> Self {
        Self(value.into())
    }
}

/// This octet in each session is used to identify the session type, indicate its
/// relationship to any handles in the command, and indicate its use in parameter encryption.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, TryFromPrimitive, Default)]
#[repr(i8)]
pub enum TPMA_SESSION {
    #[default]

    /// SET (1): In a command, this setting indicates that the session is to remain active
    /// after successful completion of the command. In a response, it indicates that the
    /// session is still active. If SET in the command, this attribute shall be SET in the response.
    /// CLEAR (0): In a command, this setting indicates that the TPM should close the session
    /// and flush any related context when the command completes successfully. In a response,
    /// it indicates that the session is closed and the context is no longer active.
    /// This attribute has no meaning for a password authorization and the TPM will allow any
    /// setting of the attribute in the command and SET the attribute in the response.
    /// This attribute will only be CLEAR in one response for a logical session. If the
    /// attribute is CLEAR, the context associated with the session is no longer in use and
    /// the space is available. A session created after another session is ended may have the
    /// same handle but logically is not the same session.
    /// This attribute has no effect if the command does not complete successfully.
    continueSession = 0x1,

    /// SET (1): In a command, this setting indicates that the command should only be executed
    /// if the session is exclusive at the start of the command. In a response, it indicates
    /// that the session is exclusive. This setting is only allowed if the audit attribute is
    /// SET (TPM_RC_ATTRIBUTES).
    /// CLEAR (0): In a command, indicates that the session need not be exclusive at the start
    /// of the command. In a response, indicates that the session is not exclusive.
    auditExclusive = 0x2,

    /// SET (1): In a command, this setting indicates that the audit digest of the session
    /// should be initialized and the exclusive status of the session SET. This setting is
    /// only allowed if the audit attribute is SET (TPM_RC_ATTRIBUTES).
    /// CLEAR (0): In a command, indicates that the audit digest should not be initialized.
    /// This bit is always CLEAR in a response.
    auditReset = 0x4,

    /// SET (1): In a command, this setting indicates that the first parameter in the command
    /// is symmetrically encrypted using the parameter encryption scheme described in TPM 2.0
    /// Part 1. The TPM will decrypt the parameter after performing any HMAC computations and
    /// before unmarshaling the parameter. In a response, the attribute is copied from the
    /// request but has no effect on the response.
    /// CLEAR (0): Session not used for encryption.
    /// For a password authorization, this attribute will be CLEAR in both the command and response.
    /// This attribute may be SET in a session that is not associated with a command handle.
    /// Such a session is provided for purposes of encrypting a parameter and not for authorization.
    /// This attribute may be SET in combination with any other session attributes.
    decrypt = 0x20,

    /// SET (1): In a command, this setting indicates that the TPM should use this session to
    /// encrypt the first parameter in the response. In a response, it indicates that the
    /// attribute was set in the command and that the TPM used the session to encrypt the
    /// first parameter in the response using the parameter encryption scheme described in TPM
    /// 2.0 Part 1.
    /// CLEAR (0): Session not used for encryption.
    /// For a password authorization, this attribute will be CLEAR in both the command and response.
    /// This attribute may be SET in a session that is not associated with a command handle.
    /// Such a session is provided for purposes of encrypting a parameter and not for authorization.
    encrypt = 0x40,

    /// SET (1): In a command or response, this setting indicates that the session is for
    /// audit and that auditExclusive and auditReset have meaning. This session may also be
    /// used for authorization, encryption, or decryption. The encrypted and encrypt fields
    /// may be SET or CLEAR.
    /// CLEAR (0): Session is not used for audit.
    /// If SET in the command, then this attribute will be SET in the response.
    audit = 0x80
}

impl TpmEnum for TPMA_SESSION {
    fn get_value(&self) -> u32 {
        *self as u32
    }

}

impl From<TPMA_SESSION> for u32 {
    fn from(value: TPMA_SESSION) -> Self {
        value as u32
    }

}

impl From<TPMA_SESSION> for i32 {
    fn from(value: TPMA_SESSION) -> Self {
        value as i32
    }

}

impl fmt::Display for TPMA_SESSION {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::continueSession => write!(f, "continueSession"),
            Self::auditExclusive => write!(f, "auditExclusive"),
            Self::auditReset => write!(f, "auditReset"),
            Self::decrypt => write!(f, "decrypt"),
            Self::encrypt => write!(f, "encrypt"),
            Self::audit => write!(f, "audit"),
        }
    }
}

impl std::ops::BitOr for TPMA_SESSION {
type Output = Self;
    fn bitor(self, rhs: Self) -> Self::Output {
    unsafe { std::mem::transmute(self as u8 | rhs as u8) }
    }

}

impl From<u8> for TPMA_SESSION {
fn from(value: u8) -> Self {
    unsafe { std::mem::transmute(value) }
    }

}

/// In a TPMS_CREATION_DATA structure, this structure is used to indicate the locality of
/// the command that created the object. No more than one of the locality attributes shall
/// be set in the creation data.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, TryFromPrimitive, Default)]
#[repr(i8)]
pub enum TPMA_LOCALITY {
    #[default]
    LOC_ZERO = 0x1,
    LOC_ONE = 0x2,
    LOC_TWO = 0x4,
    LOC_THREE = 0x8,
    LOC_FOUR = 0x10,

    /// If any of these bits is set, an extended locality is indicated
    Extended_BIT_MASK = 0xE0,
    Extended_BIT_OFFSET = 0x5, // Original value: 5
    Extended_BIT_LENGTH = 0x3 // Original value: 3
}

impl TpmEnum for TPMA_LOCALITY {
    fn get_value(&self) -> u32 {
        *self as u32
    }

}

impl From<TPMA_LOCALITY> for u32 {
    fn from(value: TPMA_LOCALITY) -> Self {
        value as u32
    }

}

impl From<TPMA_LOCALITY> for i32 {
    fn from(value: TPMA_LOCALITY) -> Self {
        value as i32
    }

}

impl fmt::Display for TPMA_LOCALITY {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::LOC_ZERO => write!(f, "LOC_ZERO"),
            Self::LOC_ONE => write!(f, "LOC_ONE"),
            Self::LOC_TWO => write!(f, "LOC_TWO"),
            Self::LOC_THREE => write!(f, "LOC_THREE"),
            Self::LOC_FOUR => write!(f, "LOC_FOUR"),
            Self::Extended_BIT_MASK => write!(f, "Extended_BIT_MASK"),
            Self::Extended_BIT_OFFSET => write!(f, "Extended_BIT_OFFSET"),
            Self::Extended_BIT_LENGTH => write!(f, "Extended_BIT_LENGTH"),
        }
    }
}

impl std::ops::BitOr for TPMA_LOCALITY {
type Output = Self;
    fn bitor(self, rhs: Self) -> Self::Output {
    unsafe { std::mem::transmute(self as u8 | rhs as u8) }
    }

}

impl From<u8> for TPMA_LOCALITY {
fn from(value: u8) -> Self {
    unsafe { std::mem::transmute(value) }
    }

}

/// The attributes in this structure are persistent and are not changed as a result of
/// _TPM_Init or any TPM2_Startup(). Some of the attributes in this structure may change
/// as the result of specific Protected Capabilities. This structure may be read using
/// TPM2_GetCapability(capability = TPM_CAP_TPM_PROPERTIES, property = TPM_PT_PERMANENT).
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, TryFromPrimitive, Default)]
#[repr(i32)]
pub enum TPMA_PERMANENT {
    #[default]

    /// SET (1): TPM2_HierarchyChangeAuth() with ownerAuth has been executed since the last TPM2_Clear().
    /// CLEAR (0): ownerAuth has not been changed since TPM2_Clear().
    ownerAuthSet = 0x1,

    /// SET (1): TPM2_HierarchyChangeAuth() with endorsementAuth has been executed since the
    /// last TPM2_Clear().
    /// CLEAR (0): endorsementAuth has not been changed since TPM2_Clear().
    endorsementAuthSet = 0x2,

    /// SET (1): TPM2_HierarchyChangeAuth() with lockoutAuth has been executed since the last
    /// TPM2_Clear().
    /// CLEAR (0): lockoutAuth has not been changed since TPM2_Clear().
    lockoutAuthSet = 0x4,

    /// SET (1): TPM2_Clear() is disabled.
    /// CLEAR (0): TPM2_Clear() is enabled.
    /// NOTE See TPM2_ClearControl in TPM 2.0 Part 3 for details on changing this attribute.
    disableClear = 0x100,

    /// SET (1): The TPM is in lockout, when failedTries is equal to maxTries.
    inLockout = 0x200,

    /// SET (1): The EPS was created by the TPM.
    /// CLEAR (0): The EPS was created outside of the TPM using a manufacturer-specific process.
    tpmGeneratedEPS = 0x400
}

impl TpmEnum for TPMA_PERMANENT {
    fn get_value(&self) -> u32 {
        *self as u32
    }

}

impl From<TPMA_PERMANENT> for u32 {
    fn from(value: TPMA_PERMANENT) -> Self {
        value as u32
    }

}

impl From<TPMA_PERMANENT> for i32 {
    fn from(value: TPMA_PERMANENT) -> Self {
        value as i32
    }

}

impl fmt::Display for TPMA_PERMANENT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::ownerAuthSet => write!(f, "ownerAuthSet"),
            Self::endorsementAuthSet => write!(f, "endorsementAuthSet"),
            Self::lockoutAuthSet => write!(f, "lockoutAuthSet"),
            Self::disableClear => write!(f, "disableClear"),
            Self::inLockout => write!(f, "inLockout"),
            Self::tpmGeneratedEPS => write!(f, "tpmGeneratedEPS"),
        }
    }
}

impl std::ops::BitOr for TPMA_PERMANENT {
type Output = Self;
    fn bitor(self, rhs: Self) -> Self::Output {
    unsafe { std::mem::transmute(self as u32 | rhs as u32) }
    }

}

impl From<u32> for TPMA_PERMANENT {
fn from(value: u32) -> Self {
    unsafe { std::mem::transmute(value) }
    }

}

/// This structure may be read using TPM2_GetCapability(capability =
/// TPM_CAP_TPM_PROPERTIES, property = TPM_PT_STARTUP_CLEAR).
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, TryFromPrimitive, Default)]
#[repr(i32)]
pub enum TPMA_STARTUP_CLEAR {
    #[default]

    /// SET (1): The platform hierarchy is enabled and platformAuth or platformPolicy may be
    /// used for authorization.
    /// CLEAR (0): platformAuth and platformPolicy may not be used for authorizations, and
    /// objects in the platform hierarchy, including persistent objects, cannot be used.
    /// NOTE See TPM2_HierarchyControl in TPM 2.0 Part 3 for details on changing this attribute.
    phEnable = 0x1,

    /// SET (1): The Storage hierarchy is enabled and ownerAuth or ownerPolicy may be used for
    /// authorization. NV indices defined using owner authorization are accessible.
    /// CLEAR (0): ownerAuth and ownerPolicy may not be used for authorizations, and objects
    /// in the Storage hierarchy, persistent objects, and NV indices defined using owner
    /// authorization cannot be used.
    /// NOTE See TPM2_HierarchyControl in TPM 2.0 Part 3 for details on changing this attribute.
    shEnable = 0x2,

    /// SET (1): The EPS hierarchy is enabled and Endorsement Authorization may be used to
    /// authorize commands.
    /// CLEAR (0): Endorsement Authorization may not be used for authorizations, and objects
    /// in the endorsement hierarchy, including persistent objects, cannot be used.
    /// NOTE See TPM2_HierarchyControl in TPM 2.0 Part 3 for details on changing this attribute.
    ehEnable = 0x4,

    /// SET (1): NV indices that have TPMA_NV_PLATFORMCREATE SET may be read or written. The
    /// platform can create define and undefine indices.
    /// CLEAR (0): NV indices that have TPMA_NV_PLATFORMCREATE SET may not be read or written
    /// (TPM_RC_HANDLE). The platform cannot define (TPM_RC_HIERARCHY) or undefined
    /// (TPM_RC_HANDLE) indices.
    /// NOTE See TPM2_HierarchyControl in TPM 2.0 Part 3 for details on changing this attribute.
    /// NOTE
    /// read refers to these commands: TPM2_NV_Read, TPM2_NV_ReadPublic, TPM_NV_Certify, TPM2_PolicyNV
    /// write refers to these commands: TPM2_NV_Write, TPM2_NV_Increment, TPM2_NV_Extend, TPM2_NV_SetBits
    /// NOTE The TPM must query the index TPMA_NV_PLATFORMCREATE attribute to determine
    /// whether phEnableNV is applicable. Since the TPM will return TPM_RC_HANDLE if the index
    /// does not exist, it also returns this error code if the index is disabled. Otherwise,
    /// the TPM would leak the existence of an index even when disabled.
    phEnableNV = 0x8,

    /// SET (1): The TPM received a TPM2_Shutdown() and a matching TPM2_Startup().
    /// CLEAR (0): TPM2_Startup(TPM_SU_CLEAR) was not preceded by a TPM2_Shutdown() of any type.
    /// NOTE A shutdown is orderly if the TPM receives a TPM2_Shutdown() of any type followed
    /// by a TPM2_Startup() of any type. However, the TPM will return an error if
    /// TPM2_Startup(TPM_SU_STATE) was not preceded by TPM2_Shutdown(TPM_SU_STATE).
    orderly = 0xFFFFFFFF80000000
}

impl TpmEnum for TPMA_STARTUP_CLEAR {
    fn get_value(&self) -> u32 {
        *self as u32
    }

}

impl From<TPMA_STARTUP_CLEAR> for u32 {
    fn from(value: TPMA_STARTUP_CLEAR) -> Self {
        value as u32
    }

}

impl From<TPMA_STARTUP_CLEAR> for i32 {
    fn from(value: TPMA_STARTUP_CLEAR) -> Self {
        value as i32
    }

}

impl fmt::Display for TPMA_STARTUP_CLEAR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::phEnable => write!(f, "phEnable"),
            Self::shEnable => write!(f, "shEnable"),
            Self::ehEnable => write!(f, "ehEnable"),
            Self::phEnableNV => write!(f, "phEnableNV"),
            Self::orderly => write!(f, "orderly"),
        }
    }
}

impl std::ops::BitOr for TPMA_STARTUP_CLEAR {
type Output = Self;
    fn bitor(self, rhs: Self) -> Self::Output {
    unsafe { std::mem::transmute(self as u32 | rhs as u32) }
    }

}

impl From<u32> for TPMA_STARTUP_CLEAR {
fn from(value: u32) -> Self {
    unsafe { std::mem::transmute(value) }
    }

}

/// This structure of this attribute is used to report the memory management method used
/// by the TPM for transient objects and authorization sessions. This structure may be
/// read using TPM2_GetCapability(capability = TPM_CAP_TPM_PROPERTIES, property = TPM_PT_MEMORY).
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, TryFromPrimitive, Default)]
#[repr(i32)]
pub enum TPMA_MEMORY {
    #[default]

    /// SET (1): indicates that the RAM memory used for authorization session contexts is
    /// shared with the memory used for transient objects
    /// CLEAR (0): indicates that the memory used for authorization sessions is not shared
    /// with memory used for transient objects
    sharedRAM = 0x1,

    /// SET (1): indicates that the NV memory used for persistent objects is shared with the
    /// NV memory used for NV Index values
    /// CLEAR (0): indicates that the persistent objects and NV Index values are allocated
    /// from separate sections of NV
    sharedNV = 0x2,

    /// SET (1): indicates that the TPM copies persistent objects to a transient-object slot
    /// in RAM when the persistent object is referenced in a command. The TRM is required to
    /// make sure that an object slot is available.
    /// CLEAR (0): indicates that the TPM does not use transient-object slots when persistent
    /// objects are referenced
    objectCopiedToRam = 0x4
}

impl TpmEnum for TPMA_MEMORY {
    fn get_value(&self) -> u32 {
        *self as u32
    }

}

impl From<TPMA_MEMORY> for u32 {
    fn from(value: TPMA_MEMORY) -> Self {
        value as u32
    }

}

impl From<TPMA_MEMORY> for i32 {
    fn from(value: TPMA_MEMORY) -> Self {
        value as i32
    }

}

impl fmt::Display for TPMA_MEMORY {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::sharedRAM => write!(f, "sharedRAM"),
            Self::sharedNV => write!(f, "sharedNV"),
            Self::objectCopiedToRam => write!(f, "objectCopiedToRam"),
        }
    }
}

impl std::ops::BitOr for TPMA_MEMORY {
type Output = Self;
    fn bitor(self, rhs: Self) -> Self::Output {
    unsafe { std::mem::transmute(self as u32 | rhs as u32) }
    }

}

impl From<u32> for TPMA_MEMORY {
fn from(value: u32) -> Self {
    unsafe { std::mem::transmute(value) }
    }

}

/// This structure defines the attributes of a command from a context management
/// perspective. The fields of the structure indicate to the TPM Resource Manager (TRM)
/// the number of resources required by a command and how the command affects the TPMs resources.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, TryFromPrimitive, Default)]
#[repr(i32)]
pub enum TPMA_CC {
    #[default]

    /// Indicates the command being selected
    commandIndex_BIT_MASK = 0xFFFF,
    commandIndex_BIT_OFFSET = 0x0, // Original value: 0
    commandIndex_BIT_LENGTH = 0x10, // Original value: 16

    /// SET (1): indicates that the command may write to NV
    /// CLEAR (0): indicates that the command does not write to NV
    nv = 0x400000,

    /// SET (1): This command could flush any number of loaded contexts.
    /// CLEAR (0): no additional changes other than indicated by the flushed attribute
    extensive = 0x800000,

    /// SET (1): The context associated with any transient handle in the command will be
    /// flushed when this command completes.
    /// CLEAR (0): No context is flushed as a side effect of this command.
    flushed = 0x1000000,

    /// Indicates the number of the handles in the handle area for this command
    cHandles_BIT_MASK = 0xE000000,
    cHandles_BIT_OFFSET = 0x19, // Original value: 25
    cHandles_BIT_LENGTH = 0x3, // Original value: 3

    /// SET (1): indicates the presence of the handle area in the response
    rHandle = 0x10000000,

    /// SET (1): indicates that the command is vendor-specific
    /// CLEAR (0): indicates that the command is defined in a version of this specification
    V = 0x20000000,

    /// Allocated for software; shall be zero
    Res_BIT_MASK = 0xFFFFFFFFC0000000,
    Res_BIT_OFFSET = 0x1E, // Original value: 30
    Res_BIT_LENGTH = 0x2 // Original value: 2
}

impl TpmEnum for TPMA_CC {
    fn get_value(&self) -> u32 {
        *self as u32
    }

}

impl From<TPMA_CC> for u32 {
    fn from(value: TPMA_CC) -> Self {
        value as u32
    }

}

impl From<TPMA_CC> for i32 {
    fn from(value: TPMA_CC) -> Self {
        value as i32
    }

}

impl fmt::Display for TPMA_CC {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::commandIndex_BIT_MASK => write!(f, "commandIndex_BIT_MASK"),
            Self::commandIndex_BIT_OFFSET => write!(f, "commandIndex_BIT_OFFSET"),
            Self::commandIndex_BIT_LENGTH => write!(f, "commandIndex_BIT_LENGTH"),
            Self::nv => write!(f, "nv"),
            Self::extensive => write!(f, "extensive"),
            Self::flushed => write!(f, "flushed"),
            Self::cHandles_BIT_MASK => write!(f, "cHandles_BIT_MASK"),
            Self::cHandles_BIT_OFFSET => write!(f, "cHandles_BIT_OFFSET"),
            Self::cHandles_BIT_LENGTH => write!(f, "cHandles_BIT_LENGTH"),
            Self::rHandle => write!(f, "rHandle"),
            Self::V => write!(f, "V"),
            Self::Res_BIT_MASK => write!(f, "Res_BIT_MASK"),
            Self::Res_BIT_OFFSET => write!(f, "Res_BIT_OFFSET"),
            Self::Res_BIT_LENGTH => write!(f, "Res_BIT_LENGTH"),
        }
    }
}

impl std::ops::BitOr for TPMA_CC {
type Output = Self;
    fn bitor(self, rhs: Self) -> Self::Output {
    unsafe { std::mem::transmute(self as u32 | rhs as u32) }
    }

}

impl From<u32> for TPMA_CC {
fn from(value: u32) -> Self {
    unsafe { std::mem::transmute(value) }
    }

}

/// This structure of this attribute is used to report that the TPM is designed for these
/// modes. This structure may be read using TPM2_GetCapability(capability =
/// TPM_CAP_TPM_PROPERTIES, property = TPM_PT_MODES).
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, TryFromPrimitive, Default)]
#[repr(i32)]
pub enum TPMA_MODES {
    #[default]

    /// SET (1): indicates that the TPM is designed to comply with all of the FIPS 140-2
    /// requirements at Level 1 or higher.
    FIPS_140_2 = 0x1
}

impl TpmEnum for TPMA_MODES {
    fn get_value(&self) -> u32 {
        *self as u32
    }

}

impl From<TPMA_MODES> for u32 {
    fn from(value: TPMA_MODES) -> Self {
        value as u32
    }

}

impl From<TPMA_MODES> for i32 {
    fn from(value: TPMA_MODES) -> Self {
        value as i32
    }

}

impl fmt::Display for TPMA_MODES {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::FIPS_140_2 => write!(f, "FIPS_140_2"),
        }
    }
}

impl std::ops::BitOr for TPMA_MODES {
type Output = Self;
    fn bitor(self, rhs: Self) -> Self::Output {
    unsafe { std::mem::transmute(self as u32 | rhs as u32) }
    }

}

impl From<u32> for TPMA_MODES {
fn from(value: u32) -> Self {
    unsafe { std::mem::transmute(value) }
    }

}

/// These attributes are as specified in clause 4.2.1.3. of RFC 5280 Internet X.509 Public
/// Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile. For
/// TPM2_CertifyX509, when a caller provides a DER encoded Key Usage in
/// partialCertificate, the TPM will validate that the key to be certified meets the
/// requirements of Key Usage.

/// Enum with duplicated values - using struct with constants
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Default)]
pub struct TPMA_X509_KEY_USAGE(pub u32);

impl TPMA_X509_KEY_USAGE {
    /// Attributes.Decrypt SET
    pub const decipherOnly: Self = Self(0x800000);

    /// Attributes.Decrypt SET
    pub const encipherOnly: Self = Self(0x1000000);

    /// Attributes.sign SET
    pub const cRLSign: Self = Self(0x2000000);

    /// Attributes.sign SET
    pub const keyCertSign: Self = Self(0x4000000);

    /// Attributes.Decrypt SET
    pub const keyAgreement: Self = Self(0x8000000);

    /// Attributes.Decrypt SET
    pub const dataEncipherment: Self = Self(0x10000000);

    /// Asymmetric key with decrypt and restricted SET key has the attributes of a parent key
    pub const keyEncipherment: Self = Self(0x20000000);

    /// FixedTPM SET in Subject Key (objectHandle)
    pub const nonrepudiation: Self = Self(0x40000000);

    /// Alias to the nonrepudiation value.
    pub const contentCommitment: Self = Self(0x40000000);

    /// Sign SET in Subject Key (objectHandle)
    pub const digitalSignature: Self = Self(0xFFFFFFFF80000000);

    pub fn try_from(value: i32) -> Result<Self, TpmError> {
        match value {
            8388608 => Ok(Self::decipherOnly), // Original value: 0x800000
            16777216 => Ok(Self::encipherOnly), // Original value: 0x1000000
            33554432 => Ok(Self::cRLSign), // Original value: 0x2000000
            67108864 => Ok(Self::keyCertSign), // Original value: 0x4000000
            134217728 => Ok(Self::keyAgreement), // Original value: 0x8000000
            268435456 => Ok(Self::dataEncipherment), // Original value: 0x10000000
            536870912 => Ok(Self::keyEncipherment), // Original value: 0x20000000
            1073741824 => Ok(Self::nonrepudiation), // Original value: 0x40000000
            18446744071562067968 => Ok(Self::digitalSignature), // Original value: 0xFFFFFFFF80000000
            _ => Err(TpmError::InvalidEnumValue),
        }

    }

}

impl TpmEnum for TPMA_X509_KEY_USAGE {
    fn get_value(&self) -> u32 {
        self.0.into()
    }

}

impl From<TPMA_X509_KEY_USAGE> for u32 {
    fn from(value: TPMA_X509_KEY_USAGE) -> Self {
        value.0.into()
    }
}

impl From<TPMA_X509_KEY_USAGE> for i32 {
    fn from(value: TPMA_X509_KEY_USAGE) -> Self {
        value.0 as i32
    }
}

impl fmt::Display for TPMA_X509_KEY_USAGE {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self.0 {
            8388608 => write!(f, "decipherOnly"),
            16777216 => write!(f, "encipherOnly"),
            33554432 => write!(f, "cRLSign"),
            67108864 => write!(f, "keyCertSign"),
            134217728 => write!(f, "keyAgreement"),
            268435456 => write!(f, "dataEncipherment"),
            536870912 => write!(f, "keyEncipherment"),
            1073741824 => write!(f, "One of <nonrepudiation, contentCommitment>"),
            18446744071562067968 => write!(f, "digitalSignature"),
            _ => write!(f, "Unknown({:?})", self.0),
        }

    }

}

impl std::ops::BitOr for TPMA_X509_KEY_USAGE {
    type Output = Self;

    fn bitor(self, rhs: Self) -> Self::Output {
        Self(self.0 | rhs.0)
    }

}

impl From<u32> for TPMA_X509_KEY_USAGE {
    fn from(value: u32) -> Self {
        Self(value.into())
    }
}

/// This attribute is used to report the ACT state. This attribute may be read using
/// TPM2_GetCapability(capability = TPM_CAP_ACT, property = TPM_RH_ACT_x where x is the
/// ACT number (0-F)). The signaled value must be preserved across TPM Resume or if the
/// TPM has not lost power. The signaled value may be preserved over a power cycle of a TPM.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, TryFromPrimitive, Default)]
#[repr(i32)]
pub enum TPMA_ACT {
    #[default]

    /// SET (1): The ACT has signaled
    /// CLEAR (0): The ACT has not signaled
    signaled = 0x1,

    /// Preserves the state of signaled, depending on the power cycle
    preserveSignaled = 0x2
}

impl TpmEnum for TPMA_ACT {
    fn get_value(&self) -> u32 {
        *self as u32
    }

}

impl From<TPMA_ACT> for u32 {
    fn from(value: TPMA_ACT) -> Self {
        value as u32
    }

}

impl From<TPMA_ACT> for i32 {
    fn from(value: TPMA_ACT) -> Self {
        value as i32
    }

}

impl fmt::Display for TPMA_ACT {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::signaled => write!(f, "signaled"),
            Self::preserveSignaled => write!(f, "preserveSignaled"),
        }
    }
}

impl std::ops::BitOr for TPMA_ACT {
type Output = Self;
    fn bitor(self, rhs: Self) -> Self::Output {
    unsafe { std::mem::transmute(self as u32 | rhs as u32) }
    }

}

impl From<u32> for TPMA_ACT {
fn from(value: u32) -> Self {
    unsafe { std::mem::transmute(value) }
    }

}

/// A TPM_NV_INDEX is used to reference a defined location in NV memory. The format of the
/// Index is changed from TPM 1.2 in order to include the Index in the reserved handle
/// space. Handles in this range use the digest of the public area of the Index as the
/// Name of the entity in authorization computations

/// Enum with duplicated values - using struct with constants
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Default)]
pub struct TPM_NV_INDEX(pub u32);

impl TPM_NV_INDEX {
    /// The Index of the NV location
    pub const index_BIT_MASK: Self = Self(0xFFFFFF);
    pub const index_BIT_OFFSET: Self = Self(0x0); // Original value: 0
    pub const index_BIT_LENGTH: Self = Self(0x18); // Original value: 24

    /// Constant value of TPM_HT_NV_INDEX indicating the NV Index range
    pub const RhNv_BIT_MASK: Self = Self(0xFFFFFFFFFF000000);
    pub const RhNv_BIT_OFFSET: Self = Self(0x18); // Original value: 24
    pub const RhNv_BIT_LENGTH: Self = Self(0x8); // Original value: 8

    pub fn try_from(value: i32) -> Result<Self, TpmError> {
        match value {
            16777215 => Ok(Self::index_BIT_MASK), // Original value: 0xFFFFFF
            0 => Ok(Self::index_BIT_OFFSET), // Original value: 0
            24 => Ok(Self::index_BIT_LENGTH), // Original value: 24
            18446744073692774400 => Ok(Self::RhNv_BIT_MASK), // Original value: 0xFFFFFFFFFF000000
            8 => Ok(Self::RhNv_BIT_LENGTH), // Original value: 8
            _ => Err(TpmError::InvalidEnumValue),
        }

    }

}

impl TpmEnum for TPM_NV_INDEX {
    fn get_value(&self) -> u32 {
        self.0.into()
    }

}

impl From<TPM_NV_INDEX> for u32 {
    fn from(value: TPM_NV_INDEX) -> Self {
        value.0.into()
    }
}

impl From<TPM_NV_INDEX> for i32 {
    fn from(value: TPM_NV_INDEX) -> Self {
        value.0 as i32
    }
}

impl fmt::Display for TPM_NV_INDEX {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self.0 {
            16777215 => write!(f, "index_BIT_MASK"),
            0 => write!(f, "index_BIT_OFFSET"),
            24 => write!(f, "One of <index_BIT_LENGTH, RhNv_BIT_OFFSET>"),
            18446744073692774400 => write!(f, "RhNv_BIT_MASK"),
            8 => write!(f, "RhNv_BIT_LENGTH"),
            _ => write!(f, "Unknown({:?})", self.0),
        }

    }

}

impl std::ops::BitOr for TPM_NV_INDEX {
    type Output = Self;

    fn bitor(self, rhs: Self) -> Self::Output {
        Self(self.0 | rhs.0)
    }

}

impl From<u32> for TPM_NV_INDEX {
    fn from(value: u32) -> Self {
        Self(value.into())
    }
}

/// This structure allows the TPM to keep track of the data and permissions to manipulate
/// an NV Index.

/// Enum with duplicated values - using struct with constants
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Default)]
pub struct TPMA_NV(pub u32);

impl TPMA_NV {
    /// SET (1): The Index data can be written if Platform Authorization is provided.
    /// CLEAR (0): Writing of the Index data cannot be authorized with Platform Authorization.
    pub const PPWRITE: Self = Self(0x1);

    /// SET (1): The Index data can be written if Owner Authorization is provided.
    /// CLEAR (0): Writing of the Index data cannot be authorized with Owner Authorization.
    pub const OWNERWRITE: Self = Self(0x2);

    /// SET (1): Authorizations to change the Index contents that require USER role may be
    /// provided with an HMAC session or password.
    /// CLEAR (0): Authorizations to change the Index contents that require USER role may not
    /// be provided with an HMAC session or password.
    pub const AUTHWRITE: Self = Self(0x4);

    /// SET (1): Authorizations to change the Index contents that require USER role may be
    /// provided with a policy session.
    /// CLEAR (0): Authorizations to change the Index contents that require USER role may not
    /// be provided with a policy session.
    /// NOTE TPM2_NV_ChangeAuth() always requires that authorization be provided in a policy session.
    pub const POLICYWRITE: Self = Self(0x8);

    /// Ordinary contains data that is opaque to the TPM that can only be modified using TPM2_NV_Write().
    pub const ORDINARY: Self = Self(0x0);

    /// Counter contains an 8-octet value that is to be used as a counter and can only be
    /// modified with TPM2_NV_Increment()
    pub const COUNTER: Self = Self(0x10);

    /// Bit Field contains an 8-octet value to be used as a bit field and can only be modified
    /// with TPM2_NV_SetBits().
    pub const BITS: Self = Self(0x20);

    /// Extend contains a digest-sized value used like a PCR. The Index can only be modified
    /// using TPM2_NV_Extend(). The extend will use the nameAlg of the Index.
    pub const EXTEND: Self = Self(0x40);

    /// PIN Fail - contains pinCount that increments on a PIN authorization failure and a pinLimit
    pub const PIN_FAIL: Self = Self(0x80);

    /// PIN Pass - contains pinCount that increments on a PIN authorization success and a pinLimit
    pub const PIN_PASS: Self = Self(0x90);

    /// The type of the index.
    /// NOTE A TPM is not required to support all TPM_NT values
    pub const TpmNt_BIT_MASK: Self = Self(0xF0);
    pub const TpmNt_BIT_OFFSET: Self = Self(0x4); // Original value: 4
    pub const TpmNt_BIT_LENGTH: Self = Self(0x4); // Original value: 4

    /// SET (1): Index may not be deleted unless the authPolicy is satisfied using
    /// TPM2_NV_UndefineSpaceSpecial().
    /// CLEAR (0): Index may be deleted with proper platform or owner authorization using
    /// TPM2_NV_UndefineSpace().
    /// NOTE An Index with this attribute and a policy that cannot be satisfied (e.g., an
    /// Empty Policy) cannot be deleted.
    pub const POLICY_DELETE: Self = Self(0x400);

    /// SET (1): Index cannot be written.
    /// CLEAR (0): Index can be written.
    pub const WRITELOCKED: Self = Self(0x800);

    /// SET (1): A partial write of the Index data is not allowed. The write size shall match
    /// the defined space size.
    /// CLEAR (0): Partial writes are allowed. This setting is required if the .dataSize of
    /// the Index is larger than NV_MAX_BUFFER_SIZE for the implementation.
    pub const WRITEALL: Self = Self(0x1000);

    /// SET (1): TPM2_NV_WriteLock() may be used to prevent further writes to this location.
    /// CLEAR (0): TPM2_NV_WriteLock() does not block subsequent writes if
    /// TPMA_NV_WRITE_STCLEAR is also CLEAR.
    pub const WRITEDEFINE: Self = Self(0x2000);

    /// SET (1): TPM2_NV_WriteLock() may be used to prevent further writes to this location
    /// until the next TPM Reset or TPM Restart.
    /// CLEAR (0): TPM2_NV_WriteLock() does not block subsequent writes if TPMA_NV_WRITEDEFINE
    /// is also CLEAR.
    pub const WRITE_STCLEAR: Self = Self(0x4000);

    /// SET (1): If TPM2_NV_GlobalWriteLock() is successful, TPMA_NV_WRITELOCKED is set.
    /// CLEAR (0): TPM2_NV_GlobalWriteLock() has no effect on the writing of the data at this Index.
    pub const GLOBALLOCK: Self = Self(0x8000);

    /// SET (1): The Index data can be read if Platform Authorization is provided.
    /// CLEAR (0): Reading of the Index data cannot be authorized with Platform Authorization.
    pub const PPREAD: Self = Self(0x10000);

    /// SET (1): The Index data can be read if Owner Authorization is provided.
    /// CLEAR (0): Reading of the Index data cannot be authorized with Owner Authorization.
    pub const OWNERREAD: Self = Self(0x20000);

    /// SET (1): The Index data may be read if the authValue is provided.
    /// CLEAR (0): Reading of the Index data cannot be authorized with the Index authValue.
    pub const AUTHREAD: Self = Self(0x40000);

    /// SET (1): The Index data may be read if the authPolicy is satisfied.
    /// CLEAR (0): Reading of the Index data cannot be authorized with the Index authPolicy.
    pub const POLICYREAD: Self = Self(0x80000);

    /// SET (1): Authorization failures of the Index do not affect the DA logic and
    /// authorization of the Index is not blocked when the TPM is in Lockout mode.
    /// CLEAR (0): Authorization failures of the Index will increment the authorization
    /// failure counter and authorizations of this Index are not allowed when the TPM is in
    /// Lockout mode.
    pub const NO_DA: Self = Self(0x2000000);

    /// SET (1): NV Index state is only required to be saved when the TPM performs an orderly
    /// shutdown (TPM2_Shutdown()).
    /// CLEAR (0): NV Index state is required to be persistent after the command to update the
    /// Index completes successfully (that is, the NV update is synchronous with the update command).
    pub const ORDERLY: Self = Self(0x4000000);

    /// SET (1): TPMA_NV_WRITTEN for the Index is CLEAR by TPM Reset or TPM Restart.
    /// CLEAR (0): TPMA_NV_WRITTEN is not changed by TPM Restart.
    /// NOTE This attribute may only be SET if TPM_NT is not TPM_NT_COUNTER.
    pub const CLEAR_STCLEAR: Self = Self(0x8000000);

    /// SET (1): Reads of the Index are blocked until the next TPM Reset or TPM Restart.
    /// CLEAR (0): Reads of the Index are allowed if proper authorization is provided.
    pub const READLOCKED: Self = Self(0x10000000);

    /// SET (1): Index has been written.
    /// CLEAR (0): Index has not been written.
    pub const WRITTEN: Self = Self(0x20000000);

    /// SET (1): This Index may be undefined with Platform Authorization but not with Owner
    /// Authorization.
    /// CLEAR (0): This Index may be undefined using Owner Authorization but not with Platform
    /// Authorization.
    /// The TPM will validate that this attribute is SET when the Index is defined using
    /// Platform Authorization and will validate that this attribute is CLEAR when the Index
    /// is defined using Owner Authorization.
    pub const PLATFORMCREATE: Self = Self(0x40000000);

    /// SET (1): TPM2_NV_ReadLock() may be used to SET TPMA_NV_READLOCKED for this Index.
    /// CLEAR (0): TPM2_NV_ReadLock() has no effect on this Index.
    pub const READ_STCLEAR: Self = Self(0xFFFFFFFF80000000);

    pub fn try_from(value: i32) -> Result<Self, TpmError> {
        match value {
            1 => Ok(Self::PPWRITE), // Original value: 0x1
            2 => Ok(Self::OWNERWRITE), // Original value: 0x2
            4 => Ok(Self::AUTHWRITE), // Original value: 0x4
            8 => Ok(Self::POLICYWRITE), // Original value: 0x8
            0 => Ok(Self::ORDINARY), // Original value: 0x0
            16 => Ok(Self::COUNTER), // Original value: 0x10
            32 => Ok(Self::BITS), // Original value: 0x20
            64 => Ok(Self::EXTEND), // Original value: 0x40
            128 => Ok(Self::PIN_FAIL), // Original value: 0x80
            144 => Ok(Self::PIN_PASS), // Original value: 0x90
            240 => Ok(Self::TpmNt_BIT_MASK), // Original value: 0xF0
            1024 => Ok(Self::POLICY_DELETE), // Original value: 0x400
            2048 => Ok(Self::WRITELOCKED), // Original value: 0x800
            4096 => Ok(Self::WRITEALL), // Original value: 0x1000
            8192 => Ok(Self::WRITEDEFINE), // Original value: 0x2000
            16384 => Ok(Self::WRITE_STCLEAR), // Original value: 0x4000
            32768 => Ok(Self::GLOBALLOCK), // Original value: 0x8000
            65536 => Ok(Self::PPREAD), // Original value: 0x10000
            131072 => Ok(Self::OWNERREAD), // Original value: 0x20000
            262144 => Ok(Self::AUTHREAD), // Original value: 0x40000
            524288 => Ok(Self::POLICYREAD), // Original value: 0x80000
            33554432 => Ok(Self::NO_DA), // Original value: 0x2000000
            67108864 => Ok(Self::ORDERLY), // Original value: 0x4000000
            134217728 => Ok(Self::CLEAR_STCLEAR), // Original value: 0x8000000
            268435456 => Ok(Self::READLOCKED), // Original value: 0x10000000
            536870912 => Ok(Self::WRITTEN), // Original value: 0x20000000
            1073741824 => Ok(Self::PLATFORMCREATE), // Original value: 0x40000000
            18446744071562067968 => Ok(Self::READ_STCLEAR), // Original value: 0xFFFFFFFF80000000
            _ => Err(TpmError::InvalidEnumValue),
        }

    }

}

impl TpmEnum for TPMA_NV {
    fn get_value(&self) -> u32 {
        self.0.into()
    }

}

impl From<TPMA_NV> for u32 {
    fn from(value: TPMA_NV) -> Self {
        value.0.into()
    }
}

impl From<TPMA_NV> for i32 {
    fn from(value: TPMA_NV) -> Self {
        value.0 as i32
    }
}

impl fmt::Display for TPMA_NV {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self.0 {
            1 => write!(f, "PPWRITE"),
            2 => write!(f, "OWNERWRITE"),
            4 => write!(f, "One of <AUTHWRITE, TpmNt_BIT_OFFSET, TpmNt_BIT_LENGTH>"),
            8 => write!(f, "POLICYWRITE"),
            0 => write!(f, "ORDINARY"),
            16 => write!(f, "COUNTER"),
            32 => write!(f, "BITS"),
            64 => write!(f, "EXTEND"),
            128 => write!(f, "PIN_FAIL"),
            144 => write!(f, "PIN_PASS"),
            240 => write!(f, "TpmNt_BIT_MASK"),
            1024 => write!(f, "POLICY_DELETE"),
            2048 => write!(f, "WRITELOCKED"),
            4096 => write!(f, "WRITEALL"),
            8192 => write!(f, "WRITEDEFINE"),
            16384 => write!(f, "WRITE_STCLEAR"),
            32768 => write!(f, "GLOBALLOCK"),
            65536 => write!(f, "PPREAD"),
            131072 => write!(f, "OWNERREAD"),
            262144 => write!(f, "AUTHREAD"),
            524288 => write!(f, "POLICYREAD"),
            33554432 => write!(f, "NO_DA"),
            67108864 => write!(f, "ORDERLY"),
            134217728 => write!(f, "CLEAR_STCLEAR"),
            268435456 => write!(f, "READLOCKED"),
            536870912 => write!(f, "WRITTEN"),
            1073741824 => write!(f, "PLATFORMCREATE"),
            18446744071562067968 => write!(f, "READ_STCLEAR"),
            _ => write!(f, "Unknown({:?})", self.0),
        }

    }

}

impl std::ops::BitOr for TPMA_NV {
    type Output = Self;

    fn bitor(self, rhs: Self) -> Self::Output {
        Self(self.0 | rhs.0)
    }

}

impl From<u32> for TPMA_NV {
    fn from(value: u32) -> Self {
        Self(value.into())
    }
}

/// Table 119 Definition of TPMU_CAPABILITIES Union [OUT]
/// One of: TPML_ALG_PROPERTY, TPML_HANDLE, TPML_CCA, TPML_CC, TPML_PCR_SELECTION,
/// TPML_TAGGED_TPM_PROPERTY, TPML_TAGGED_PCR_PROPERTY, TPML_ECC_CURVE,
/// TPML_TAGGED_POLICY, TPML_ACT_DATA.
pub enum TPMU_CAPABILITIES {
    algorithms(TPML_ALG_PROPERTY),
    handles(TPML_HANDLE),
    command(TPML_CCA),
    ppCommands(TPML_CC),
    auditCommands(TPML_CC),
    assignedPCR(TPML_PCR_SELECTION),
    tpmProperties(TPML_TAGGED_TPM_PROPERTY),
    pcrProperties(TPML_TAGGED_PCR_PROPERTY),
    eccCurves(TPML_ECC_CURVE),
    authPolicies(TPML_TAGGED_POLICY),
    actData(TPML_ACT_DATA),
}

/// Union selector type
impl TPMU_CAPABILITIES {
    pub fn GetUnionSelector(&self) -> Option<TPM_CAP> {
        match self {
            Self::algorithms(_) => TPML_ALG_PROPERTY::GetUnionSelector(),
            Self::handles(_) => TPML_HANDLE::GetUnionSelector(),
            Self::command(_) => TPML_CCA::GetUnionSelector(),
            Self::ppCommands(_) => TPML_CC::GetUnionSelector(),
            Self::auditCommands(_) => TPML_CC::GetUnionSelector(),
            Self::assignedPCR(_) => TPML_PCR_SELECTION::GetUnionSelector(),
            Self::tpmProperties(_) => TPML_TAGGED_TPM_PROPERTY::GetUnionSelector(),
            Self::pcrProperties(_) => TPML_TAGGED_PCR_PROPERTY::GetUnionSelector(),
            Self::eccCurves(_) => TPML_ECC_CURVE::GetUnionSelector(),
            Self::authPolicies(_) => TPML_TAGGED_POLICY::GetUnionSelector(),
            Self::actData(_) => TPML_ACT_DATA::GetUnionSelector(),
        }
    }

    fn create(selector: TPM_CAP) -> Result<Option<Self>, TpmError> {
        match selector {
            TPM_CAP::ALGS => Ok(Some(Self::algorithms(TPML_ALG_PROPERTY::default()))),
            TPM_CAP::HANDLES => Ok(Some(Self::handles(TPML_HANDLE::default()))),
            TPM_CAP::COMMANDS => Ok(Some(Self::command(TPML_CCA::default()))),
            TPM_CAP::PP_COMMANDS => Ok(Some(Self::ppCommands(TPML_CC::default()))),
            TPM_CAP::AUDIT_COMMANDS => Ok(Some(Self::auditCommands(TPML_CC::default()))),
            TPM_CAP::PCRS => Ok(Some(Self::assignedPCR(TPML_PCR_SELECTION::default()))),
            TPM_CAP::TPM_PROPERTIES => Ok(Some(Self::tpmProperties(TPML_TAGGED_TPM_PROPERTY::default()))),
            TPM_CAP::PCR_PROPERTIES => Ok(Some(Self::pcrProperties(TPML_TAGGED_PCR_PROPERTY::default()))),
            TPM_CAP::ECC_CURVES => Ok(Some(Self::eccCurves(TPML_ECC_CURVE::default()))),
            TPM_CAP::AUTH_POLICIES => Ok(Some(Self::authPolicies(TPML_TAGGED_POLICY::default()))),
            TPM_CAP::ACT => Ok(Some(Self::actData(TPML_ACT_DATA::default()))),
            _ => Err(TpmError::InvalidUnion),
        }
    }
}

impl fmt::Debug for TPMU_CAPABILITIES {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::algorithms(inner) => write!(f, "TPMU_CAPABILITIES::algorithms({:?})", inner),
            Self::handles(inner) => write!(f, "TPMU_CAPABILITIES::handles({:?})", inner),
            Self::command(inner) => write!(f, "TPMU_CAPABILITIES::command({:?})", inner),
            Self::ppCommands(inner) => write!(f, "TPMU_CAPABILITIES::ppCommands({:?})", inner),
            Self::auditCommands(inner) => write!(f, "TPMU_CAPABILITIES::auditCommands({:?})", inner),
            Self::assignedPCR(inner) => write!(f, "TPMU_CAPABILITIES::assignedPCR({:?})", inner),
            Self::tpmProperties(inner) => write!(f, "TPMU_CAPABILITIES::tpmProperties({:?})", inner),
            Self::pcrProperties(inner) => write!(f, "TPMU_CAPABILITIES::pcrProperties({:?})", inner),
            Self::eccCurves(inner) => write!(f, "TPMU_CAPABILITIES::eccCurves({:?})", inner),
            Self::authPolicies(inner) => write!(f, "TPMU_CAPABILITIES::authPolicies({:?})", inner),
            Self::actData(inner) => write!(f, "TPMU_CAPABILITIES::actData({:?})", inner),
        }
    }
}
impl TpmStructure for TPMU_CAPABILITIES {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        match self {
            Self::algorithms(inner) => inner.serialize(buffer),
            Self::handles(inner) => inner.serialize(buffer),
            Self::command(inner) => inner.serialize(buffer),
            Self::ppCommands(inner) => inner.serialize(buffer),
            Self::auditCommands(inner) => inner.serialize(buffer),
            Self::assignedPCR(inner) => inner.serialize(buffer),
            Self::tpmProperties(inner) => inner.serialize(buffer),
            Self::pcrProperties(inner) => inner.serialize(buffer),
            Self::eccCurves(inner) => inner.serialize(buffer),
            Self::authPolicies(inner) => inner.serialize(buffer),
            Self::actData(inner) => inner.serialize(buffer),
        }
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        match self {
            Self::algorithms(inner) => inner.deserialize(buffer),
            Self::handles(inner) => inner.deserialize(buffer),
            Self::command(inner) => inner.deserialize(buffer),
            Self::ppCommands(inner) => inner.deserialize(buffer),
            Self::auditCommands(inner) => inner.deserialize(buffer),
            Self::assignedPCR(inner) => inner.deserialize(buffer),
            Self::tpmProperties(inner) => inner.deserialize(buffer),
            Self::pcrProperties(inner) => inner.deserialize(buffer),
            Self::eccCurves(inner) => inner.deserialize(buffer),
            Self::authPolicies(inner) => inner.deserialize(buffer),
            Self::actData(inner) => inner.deserialize(buffer),
        }
    }

    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        match self {
            Self::algorithms(inner) => inner.toTpm(buffer),
            Self::handles(inner) => inner.toTpm(buffer),
            Self::command(inner) => inner.toTpm(buffer),
            Self::ppCommands(inner) => inner.toTpm(buffer),
            Self::auditCommands(inner) => inner.toTpm(buffer),
            Self::assignedPCR(inner) => inner.toTpm(buffer),
            Self::tpmProperties(inner) => inner.toTpm(buffer),
            Self::pcrProperties(inner) => inner.toTpm(buffer),
            Self::eccCurves(inner) => inner.toTpm(buffer),
            Self::authPolicies(inner) => inner.toTpm(buffer),
            Self::actData(inner) => inner.toTpm(buffer),
        }
    }

    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        match self {
            Self::algorithms(inner) => inner.initFromTpm(buffer),
            Self::handles(inner) => inner.initFromTpm(buffer),
            Self::command(inner) => inner.initFromTpm(buffer),
            Self::ppCommands(inner) => inner.initFromTpm(buffer),
            Self::auditCommands(inner) => inner.initFromTpm(buffer),
            Self::assignedPCR(inner) => inner.initFromTpm(buffer),
            Self::tpmProperties(inner) => inner.initFromTpm(buffer),
            Self::pcrProperties(inner) => inner.initFromTpm(buffer),
            Self::eccCurves(inner) => inner.initFromTpm(buffer),
            Self::authPolicies(inner) => inner.initFromTpm(buffer),
            Self::actData(inner) => inner.initFromTpm(buffer),
        }
    }

    fn fromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        match self {
            Self::algorithms(inner) => inner.fromTpm(buffer),
            Self::handles(inner) => inner.fromTpm(buffer),
            Self::command(inner) => inner.fromTpm(buffer),
            Self::ppCommands(inner) => inner.fromTpm(buffer),
            Self::auditCommands(inner) => inner.fromTpm(buffer),
            Self::assignedPCR(inner) => inner.fromTpm(buffer),
            Self::tpmProperties(inner) => inner.fromTpm(buffer),
            Self::pcrProperties(inner) => inner.fromTpm(buffer),
            Self::eccCurves(inner) => inner.fromTpm(buffer),
            Self::authPolicies(inner) => inner.fromTpm(buffer),
            Self::actData(inner) => inner.fromTpm(buffer),
        }
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        match self {
            Self::algorithms(inner) => inner.fromBytes(buffer),
            Self::handles(inner) => inner.fromBytes(buffer),
            Self::command(inner) => inner.fromBytes(buffer),
            Self::ppCommands(inner) => inner.fromBytes(buffer),
            Self::auditCommands(inner) => inner.fromBytes(buffer),
            Self::assignedPCR(inner) => inner.fromBytes(buffer),
            Self::tpmProperties(inner) => inner.fromBytes(buffer),
            Self::pcrProperties(inner) => inner.fromBytes(buffer),
            Self::eccCurves(inner) => inner.fromBytes(buffer),
            Self::authPolicies(inner) => inner.fromBytes(buffer),
            Self::actData(inner) => inner.fromBytes(buffer),
        }
    }

}

/// Table 132 Definition of TPMU_ATTEST Union [OUT]
/// One of: TPMS_CERTIFY_INFO, TPMS_CREATION_INFO, TPMS_QUOTE_INFO,
/// TPMS_COMMAND_AUDIT_INFO, TPMS_SESSION_AUDIT_INFO, TPMS_TIME_ATTEST_INFO,
/// TPMS_NV_CERTIFY_INFO, TPMS_NV_DIGEST_CERTIFY_INFO.
pub enum TPMU_ATTEST {
    certify(TPMS_CERTIFY_INFO),
    creation(TPMS_CREATION_INFO),
    quote(TPMS_QUOTE_INFO),
    commandAudit(TPMS_COMMAND_AUDIT_INFO),
    sessionAudit(TPMS_SESSION_AUDIT_INFO),
    time(TPMS_TIME_ATTEST_INFO),
    nv(TPMS_NV_CERTIFY_INFO),
    nvDigest(TPMS_NV_DIGEST_CERTIFY_INFO),
}

/// Union selector type
impl TPMU_ATTEST {
    pub fn GetUnionSelector(&self) -> Option<TPM_ST> {
        match self {
            Self::certify(_) => TPMS_CERTIFY_INFO::GetUnionSelector(),
            Self::creation(_) => TPMS_CREATION_INFO::GetUnionSelector(),
            Self::quote(_) => TPMS_QUOTE_INFO::GetUnionSelector(),
            Self::commandAudit(_) => TPMS_COMMAND_AUDIT_INFO::GetUnionSelector(),
            Self::sessionAudit(_) => TPMS_SESSION_AUDIT_INFO::GetUnionSelector(),
            Self::time(_) => TPMS_TIME_ATTEST_INFO::GetUnionSelector(),
            Self::nv(_) => TPMS_NV_CERTIFY_INFO::GetUnionSelector(),
            Self::nvDigest(_) => TPMS_NV_DIGEST_CERTIFY_INFO::GetUnionSelector(),
        }
    }

    fn create(selector: TPM_ST) -> Result<Option<Self>, TpmError> {
        match selector {
            TPM_ST::ATTEST_CERTIFY => Ok(Some(Self::certify(TPMS_CERTIFY_INFO::default()))),
            TPM_ST::ATTEST_CREATION => Ok(Some(Self::creation(TPMS_CREATION_INFO::default()))),
            TPM_ST::ATTEST_QUOTE => Ok(Some(Self::quote(TPMS_QUOTE_INFO::default()))),
            TPM_ST::ATTEST_COMMAND_AUDIT => Ok(Some(Self::commandAudit(TPMS_COMMAND_AUDIT_INFO::default()))),
            TPM_ST::ATTEST_SESSION_AUDIT => Ok(Some(Self::sessionAudit(TPMS_SESSION_AUDIT_INFO::default()))),
            TPM_ST::ATTEST_TIME => Ok(Some(Self::time(TPMS_TIME_ATTEST_INFO::default()))),
            TPM_ST::ATTEST_NV => Ok(Some(Self::nv(TPMS_NV_CERTIFY_INFO::default()))),
            TPM_ST::ATTEST_NV_DIGEST => Ok(Some(Self::nvDigest(TPMS_NV_DIGEST_CERTIFY_INFO::default()))),
            _ => Err(TpmError::InvalidUnion),
        }
    }
}

impl fmt::Debug for TPMU_ATTEST {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::certify(inner) => write!(f, "TPMU_ATTEST::certify({:?})", inner),
            Self::creation(inner) => write!(f, "TPMU_ATTEST::creation({:?})", inner),
            Self::quote(inner) => write!(f, "TPMU_ATTEST::quote({:?})", inner),
            Self::commandAudit(inner) => write!(f, "TPMU_ATTEST::commandAudit({:?})", inner),
            Self::sessionAudit(inner) => write!(f, "TPMU_ATTEST::sessionAudit({:?})", inner),
            Self::time(inner) => write!(f, "TPMU_ATTEST::time({:?})", inner),
            Self::nv(inner) => write!(f, "TPMU_ATTEST::nv({:?})", inner),
            Self::nvDigest(inner) => write!(f, "TPMU_ATTEST::nvDigest({:?})", inner),
        }
    }
}
impl TpmStructure for TPMU_ATTEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        match self {
            Self::certify(inner) => inner.serialize(buffer),
            Self::creation(inner) => inner.serialize(buffer),
            Self::quote(inner) => inner.serialize(buffer),
            Self::commandAudit(inner) => inner.serialize(buffer),
            Self::sessionAudit(inner) => inner.serialize(buffer),
            Self::time(inner) => inner.serialize(buffer),
            Self::nv(inner) => inner.serialize(buffer),
            Self::nvDigest(inner) => inner.serialize(buffer),
        }
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        match self {
            Self::certify(inner) => inner.deserialize(buffer),
            Self::creation(inner) => inner.deserialize(buffer),
            Self::quote(inner) => inner.deserialize(buffer),
            Self::commandAudit(inner) => inner.deserialize(buffer),
            Self::sessionAudit(inner) => inner.deserialize(buffer),
            Self::time(inner) => inner.deserialize(buffer),
            Self::nv(inner) => inner.deserialize(buffer),
            Self::nvDigest(inner) => inner.deserialize(buffer),
        }
    }

    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        match self {
            Self::certify(inner) => inner.toTpm(buffer),
            Self::creation(inner) => inner.toTpm(buffer),
            Self::quote(inner) => inner.toTpm(buffer),
            Self::commandAudit(inner) => inner.toTpm(buffer),
            Self::sessionAudit(inner) => inner.toTpm(buffer),
            Self::time(inner) => inner.toTpm(buffer),
            Self::nv(inner) => inner.toTpm(buffer),
            Self::nvDigest(inner) => inner.toTpm(buffer),
        }
    }

    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        match self {
            Self::certify(inner) => inner.initFromTpm(buffer),
            Self::creation(inner) => inner.initFromTpm(buffer),
            Self::quote(inner) => inner.initFromTpm(buffer),
            Self::commandAudit(inner) => inner.initFromTpm(buffer),
            Self::sessionAudit(inner) => inner.initFromTpm(buffer),
            Self::time(inner) => inner.initFromTpm(buffer),
            Self::nv(inner) => inner.initFromTpm(buffer),
            Self::nvDigest(inner) => inner.initFromTpm(buffer),
        }
    }

    fn fromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        match self {
            Self::certify(inner) => inner.fromTpm(buffer),
            Self::creation(inner) => inner.fromTpm(buffer),
            Self::quote(inner) => inner.fromTpm(buffer),
            Self::commandAudit(inner) => inner.fromTpm(buffer),
            Self::sessionAudit(inner) => inner.fromTpm(buffer),
            Self::time(inner) => inner.fromTpm(buffer),
            Self::nv(inner) => inner.fromTpm(buffer),
            Self::nvDigest(inner) => inner.fromTpm(buffer),
        }
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        match self {
            Self::certify(inner) => inner.fromBytes(buffer),
            Self::creation(inner) => inner.fromBytes(buffer),
            Self::quote(inner) => inner.fromBytes(buffer),
            Self::commandAudit(inner) => inner.fromBytes(buffer),
            Self::sessionAudit(inner) => inner.fromBytes(buffer),
            Self::time(inner) => inner.fromBytes(buffer),
            Self::nv(inner) => inner.fromBytes(buffer),
            Self::nvDigest(inner) => inner.fromBytes(buffer),
        }
    }

}

/// This union allows additional parameters to be added for a symmetric cipher. Currently,
/// no additional parameters are required for any of the symmetric algorithms.
/// One of: TPMS_TDES_SYM_DETAILS, TPMS_AES_SYM_DETAILS, TPMS_SM4_SYM_DETAILS,
/// TPMS_CAMELLIA_SYM_DETAILS, TPMS_ANY_SYM_DETAILS, TPMS_XOR_SYM_DETAILS, TPMS_NULL_SYM_DETAILS.
pub enum TPMU_SYM_DETAILS {
    tdes(TPMS_TDES_SYM_DETAILS),
    aes(TPMS_AES_SYM_DETAILS),
    sm4(TPMS_SM4_SYM_DETAILS),
    camellia(TPMS_CAMELLIA_SYM_DETAILS),
    sym(TPMS_ANY_SYM_DETAILS),
    xor(TPMS_XOR_SYM_DETAILS),
    null(TPMS_NULL_SYM_DETAILS),
}

/// Union selector type
impl TPMU_SYM_DETAILS {
    pub fn GetUnionSelector(&self) -> Option<TPM_ALG_ID> {
        match self {
            Self::tdes(_) => TPMS_TDES_SYM_DETAILS::GetUnionSelector(),
            Self::aes(_) => TPMS_AES_SYM_DETAILS::GetUnionSelector(),
            Self::sm4(_) => TPMS_SM4_SYM_DETAILS::GetUnionSelector(),
            Self::camellia(_) => TPMS_CAMELLIA_SYM_DETAILS::GetUnionSelector(),
            Self::sym(_) => TPMS_ANY_SYM_DETAILS::GetUnionSelector(),
            Self::xor(_) => TPMS_XOR_SYM_DETAILS::GetUnionSelector(),
            Self::null(_) => TPMS_NULL_SYM_DETAILS::GetUnionSelector(),
        }
    }

    fn create(selector: TPM_ALG_ID) -> Result<Option<Self>, TpmError> {
        match selector {
            TPM_ALG_ID::TDES => Ok(Some(Self::tdes(TPMS_TDES_SYM_DETAILS::default()))),
            TPM_ALG_ID::AES => Ok(Some(Self::aes(TPMS_AES_SYM_DETAILS::default()))),
            TPM_ALG_ID::SM4 => Ok(Some(Self::sm4(TPMS_SM4_SYM_DETAILS::default()))),
            TPM_ALG_ID::CAMELLIA => Ok(Some(Self::camellia(TPMS_CAMELLIA_SYM_DETAILS::default()))),
            TPM_ALG_ID::ANY => Ok(Some(Self::sym(TPMS_ANY_SYM_DETAILS::default()))),
            TPM_ALG_ID::XOR => Ok(Some(Self::xor(TPMS_XOR_SYM_DETAILS::default()))),
            TPM_ALG_ID::NULL => Ok(Some(Self::null(TPMS_NULL_SYM_DETAILS::default()))),
            _ => Err(TpmError::InvalidUnion),
        }
    }
}

impl fmt::Debug for TPMU_SYM_DETAILS {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::tdes(inner) => write!(f, "TPMU_SYM_DETAILS::tdes({:?})", inner),
            Self::aes(inner) => write!(f, "TPMU_SYM_DETAILS::aes({:?})", inner),
            Self::sm4(inner) => write!(f, "TPMU_SYM_DETAILS::sm4({:?})", inner),
            Self::camellia(inner) => write!(f, "TPMU_SYM_DETAILS::camellia({:?})", inner),
            Self::sym(inner) => write!(f, "TPMU_SYM_DETAILS::sym({:?})", inner),
            Self::xor(inner) => write!(f, "TPMU_SYM_DETAILS::xor({:?})", inner),
            Self::null(inner) => write!(f, "TPMU_SYM_DETAILS::null({:?})", inner),
        }
    }
}
impl TpmStructure for TPMU_SYM_DETAILS {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        match self {
            Self::tdes(inner) => inner.serialize(buffer),
            Self::aes(inner) => inner.serialize(buffer),
            Self::sm4(inner) => inner.serialize(buffer),
            Self::camellia(inner) => inner.serialize(buffer),
            Self::sym(inner) => inner.serialize(buffer),
            Self::xor(inner) => inner.serialize(buffer),
            Self::null(inner) => inner.serialize(buffer),
        }
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        match self {
            Self::tdes(inner) => inner.deserialize(buffer),
            Self::aes(inner) => inner.deserialize(buffer),
            Self::sm4(inner) => inner.deserialize(buffer),
            Self::camellia(inner) => inner.deserialize(buffer),
            Self::sym(inner) => inner.deserialize(buffer),
            Self::xor(inner) => inner.deserialize(buffer),
            Self::null(inner) => inner.deserialize(buffer),
        }
    }

    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        match self {
            Self::tdes(inner) => inner.toTpm(buffer),
            Self::aes(inner) => inner.toTpm(buffer),
            Self::sm4(inner) => inner.toTpm(buffer),
            Self::camellia(inner) => inner.toTpm(buffer),
            Self::sym(inner) => inner.toTpm(buffer),
            Self::xor(inner) => inner.toTpm(buffer),
            Self::null(inner) => inner.toTpm(buffer),
        }
    }

    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        match self {
            Self::tdes(inner) => inner.initFromTpm(buffer),
            Self::aes(inner) => inner.initFromTpm(buffer),
            Self::sm4(inner) => inner.initFromTpm(buffer),
            Self::camellia(inner) => inner.initFromTpm(buffer),
            Self::sym(inner) => inner.initFromTpm(buffer),
            Self::xor(inner) => inner.initFromTpm(buffer),
            Self::null(inner) => inner.initFromTpm(buffer),
        }
    }

    fn fromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        match self {
            Self::tdes(inner) => inner.fromTpm(buffer),
            Self::aes(inner) => inner.fromTpm(buffer),
            Self::sm4(inner) => inner.fromTpm(buffer),
            Self::camellia(inner) => inner.fromTpm(buffer),
            Self::sym(inner) => inner.fromTpm(buffer),
            Self::xor(inner) => inner.fromTpm(buffer),
            Self::null(inner) => inner.fromTpm(buffer),
        }
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        match self {
            Self::tdes(inner) => inner.fromBytes(buffer),
            Self::aes(inner) => inner.fromBytes(buffer),
            Self::sm4(inner) => inner.fromBytes(buffer),
            Self::camellia(inner) => inner.fromBytes(buffer),
            Self::sym(inner) => inner.fromBytes(buffer),
            Self::xor(inner) => inner.fromBytes(buffer),
            Self::null(inner) => inner.fromBytes(buffer),
        }
    }

}

/// This structure allows a TPM2B_SENSITIVE_CREATE structure to carry either a
/// TPM2B_SENSITVE_DATA or a TPM2B_DERIVE structure. The contents of the union are
/// determined by context. When an object is being derived, the derivation values are present.
/// One of: u8, TPMS_DERIVE.
pub enum TPMU_SENSITIVE_CREATE {
    create,
    derive(TPMS_DERIVE),
}

/// Union selector type
impl TPMU_SENSITIVE_CREATE {
    pub fn GetUnionSelector(&self) -> Option<TPM_ALG_ID> {
        match self {
            Self::create => None, 
            Self::derive(_) => TPMS_DERIVE::GetUnionSelector(),
        }
    }

    fn create(selector: TPM_ALG_ID) -> Result<Option<Self>, TpmError> {
        match selector {
            TPM_ALG_ID::ANY => Ok(None),
            TPM_ALG_ID::ANY2 => Ok(Some(Self::derive(TPMS_DERIVE::default()))),
            _ => Err(TpmError::InvalidUnion),
        }
    }
}

impl fmt::Debug for TPMU_SENSITIVE_CREATE {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::create => write!(f, "TPMU_SENSITIVE_CREATE::create"),
            Self::derive(inner) => write!(f, "TPMU_SENSITIVE_CREATE::derive({:?})", inner),
        }
    }
}
impl TpmStructure for TPMU_SENSITIVE_CREATE {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        match self {
            Self::create => Ok(()),
            Self::derive(inner) => inner.serialize(buffer),
        }
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        match self {
            Self::create => Ok(()),
            Self::derive(inner) => inner.deserialize(buffer),
        }
    }

    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        match self {
            Self::create => Ok(()),
            Self::derive(inner) => inner.toTpm(buffer),
        }
    }

    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        match self {
            Self::create => Ok(()),
            Self::derive(inner) => inner.initFromTpm(buffer),
        }
    }

    fn fromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        match self {
            Self::create => Ok(()),
            Self::derive(inner) => inner.fromTpm(buffer),
        }
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        match self {
            Self::create => Ok(()),
            Self::derive(inner) => inner.fromBytes(buffer),
        }
    }

}

/// Table 157 Definition of TPMU_SCHEME_KEYEDHASH Union [IN/OUT]
/// One of: TPMS_SCHEME_HMAC, TPMS_SCHEME_XOR, TPMS_NULL_SCHEME_KEYEDHASH.
pub enum TPMU_SCHEME_KEYEDHASH {
    hmac(TPMS_SCHEME_HMAC),
    xor(TPMS_SCHEME_XOR),
    null(TPMS_NULL_SCHEME_KEYEDHASH),
}

/// Union selector type
impl TPMU_SCHEME_KEYEDHASH {
    pub fn GetUnionSelector(&self) -> Option<TPM_ALG_ID> {
        match self {
            Self::hmac(_) => TPMS_SCHEME_HMAC::GetUnionSelector(),
            Self::xor(_) => TPMS_SCHEME_XOR::GetUnionSelector(),
            Self::null(_) => TPMS_NULL_SCHEME_KEYEDHASH::GetUnionSelector(),
        }
    }

    fn create(selector: TPM_ALG_ID) -> Result<Option<Self>, TpmError> {
        match selector {
            TPM_ALG_ID::HMAC => Ok(Some(Self::hmac(TPMS_SCHEME_HMAC::default()))),
            TPM_ALG_ID::XOR => Ok(Some(Self::xor(TPMS_SCHEME_XOR::default()))),
            TPM_ALG_ID::NULL => Ok(Some(Self::null(TPMS_NULL_SCHEME_KEYEDHASH::default()))),
            _ => Err(TpmError::InvalidUnion),
        }
    }
}

impl fmt::Debug for TPMU_SCHEME_KEYEDHASH {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::hmac(inner) => write!(f, "TPMU_SCHEME_KEYEDHASH::hmac({:?})", inner),
            Self::xor(inner) => write!(f, "TPMU_SCHEME_KEYEDHASH::xor({:?})", inner),
            Self::null(inner) => write!(f, "TPMU_SCHEME_KEYEDHASH::null({:?})", inner),
        }
    }
}
impl TpmStructure for TPMU_SCHEME_KEYEDHASH {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        match self {
            Self::hmac(inner) => inner.serialize(buffer),
            Self::xor(inner) => inner.serialize(buffer),
            Self::null(inner) => inner.serialize(buffer),
        }
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        match self {
            Self::hmac(inner) => inner.deserialize(buffer),
            Self::xor(inner) => inner.deserialize(buffer),
            Self::null(inner) => inner.deserialize(buffer),
        }
    }

    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        match self {
            Self::hmac(inner) => inner.toTpm(buffer),
            Self::xor(inner) => inner.toTpm(buffer),
            Self::null(inner) => inner.toTpm(buffer),
        }
    }

    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        match self {
            Self::hmac(inner) => inner.initFromTpm(buffer),
            Self::xor(inner) => inner.initFromTpm(buffer),
            Self::null(inner) => inner.initFromTpm(buffer),
        }
    }

    fn fromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        match self {
            Self::hmac(inner) => inner.fromTpm(buffer),
            Self::xor(inner) => inner.fromTpm(buffer),
            Self::null(inner) => inner.fromTpm(buffer),
        }
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        match self {
            Self::hmac(inner) => inner.fromBytes(buffer),
            Self::xor(inner) => inner.fromBytes(buffer),
            Self::null(inner) => inner.fromBytes(buffer),
        }
    }

}

/// This is the union of all of the signature schemes.
/// One of: TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA,
/// TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR,
/// TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME.
pub enum TPMU_SIG_SCHEME {
    rsassa(TPMS_SIG_SCHEME_RSASSA),
    rsapss(TPMS_SIG_SCHEME_RSAPSS),
    ecdsa(TPMS_SIG_SCHEME_ECDSA),
    ecdaa(TPMS_SIG_SCHEME_ECDAA),
    sm2(TPMS_SIG_SCHEME_SM2),
    ecschnorr(TPMS_SIG_SCHEME_ECSCHNORR),
    hmac(TPMS_SCHEME_HMAC),
    any(TPMS_SCHEME_HASH),
    null(TPMS_NULL_SIG_SCHEME),
}

/// Union selector type
impl TPMU_SIG_SCHEME {
    pub fn GetUnionSelector(&self) -> Option<TPM_ALG_ID> {
        match self {
            Self::rsassa(_) => TPMS_SIG_SCHEME_RSASSA::GetUnionSelector(),
            Self::rsapss(_) => TPMS_SIG_SCHEME_RSAPSS::GetUnionSelector(),
            Self::ecdsa(_) => TPMS_SIG_SCHEME_ECDSA::GetUnionSelector(),
            Self::ecdaa(_) => TPMS_SIG_SCHEME_ECDAA::GetUnionSelector(),
            Self::sm2(_) => TPMS_SIG_SCHEME_SM2::GetUnionSelector(),
            Self::ecschnorr(_) => TPMS_SIG_SCHEME_ECSCHNORR::GetUnionSelector(),
            Self::hmac(_) => TPMS_SCHEME_HMAC::GetUnionSelector(),
            Self::any(_) => TPMS_SCHEME_HASH::GetUnionSelector(),
            Self::null(_) => TPMS_NULL_SIG_SCHEME::GetUnionSelector(),
        }
    }

    fn create(selector: TPM_ALG_ID) -> Result<Option<Self>, TpmError> {
        match selector {
            TPM_ALG_ID::RSASSA => Ok(Some(Self::rsassa(TPMS_SIG_SCHEME_RSASSA::default()))),
            TPM_ALG_ID::RSAPSS => Ok(Some(Self::rsapss(TPMS_SIG_SCHEME_RSAPSS::default()))),
            TPM_ALG_ID::ECDSA => Ok(Some(Self::ecdsa(TPMS_SIG_SCHEME_ECDSA::default()))),
            TPM_ALG_ID::ECDAA => Ok(Some(Self::ecdaa(TPMS_SIG_SCHEME_ECDAA::default()))),
            TPM_ALG_ID::SM2 => Ok(Some(Self::sm2(TPMS_SIG_SCHEME_SM2::default()))),
            TPM_ALG_ID::ECSCHNORR => Ok(Some(Self::ecschnorr(TPMS_SIG_SCHEME_ECSCHNORR::default()))),
            TPM_ALG_ID::HMAC => Ok(Some(Self::hmac(TPMS_SCHEME_HMAC::default()))),
            TPM_ALG_ID::ANY => Ok(Some(Self::any(TPMS_SCHEME_HASH::default()))),
            TPM_ALG_ID::NULL => Ok(Some(Self::null(TPMS_NULL_SIG_SCHEME::default()))),
            _ => Err(TpmError::InvalidUnion),
        }
    }
}

impl fmt::Debug for TPMU_SIG_SCHEME {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::rsassa(inner) => write!(f, "TPMU_SIG_SCHEME::rsassa({:?})", inner),
            Self::rsapss(inner) => write!(f, "TPMU_SIG_SCHEME::rsapss({:?})", inner),
            Self::ecdsa(inner) => write!(f, "TPMU_SIG_SCHEME::ecdsa({:?})", inner),
            Self::ecdaa(inner) => write!(f, "TPMU_SIG_SCHEME::ecdaa({:?})", inner),
            Self::sm2(inner) => write!(f, "TPMU_SIG_SCHEME::sm2({:?})", inner),
            Self::ecschnorr(inner) => write!(f, "TPMU_SIG_SCHEME::ecschnorr({:?})", inner),
            Self::hmac(inner) => write!(f, "TPMU_SIG_SCHEME::hmac({:?})", inner),
            Self::any(inner) => write!(f, "TPMU_SIG_SCHEME::any({:?})", inner),
            Self::null(inner) => write!(f, "TPMU_SIG_SCHEME::null({:?})", inner),
        }
    }
}
impl TpmStructure for TPMU_SIG_SCHEME {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        match self {
            Self::rsassa(inner) => inner.serialize(buffer),
            Self::rsapss(inner) => inner.serialize(buffer),
            Self::ecdsa(inner) => inner.serialize(buffer),
            Self::ecdaa(inner) => inner.serialize(buffer),
            Self::sm2(inner) => inner.serialize(buffer),
            Self::ecschnorr(inner) => inner.serialize(buffer),
            Self::hmac(inner) => inner.serialize(buffer),
            Self::any(inner) => inner.serialize(buffer),
            Self::null(inner) => inner.serialize(buffer),
        }
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        match self {
            Self::rsassa(inner) => inner.deserialize(buffer),
            Self::rsapss(inner) => inner.deserialize(buffer),
            Self::ecdsa(inner) => inner.deserialize(buffer),
            Self::ecdaa(inner) => inner.deserialize(buffer),
            Self::sm2(inner) => inner.deserialize(buffer),
            Self::ecschnorr(inner) => inner.deserialize(buffer),
            Self::hmac(inner) => inner.deserialize(buffer),
            Self::any(inner) => inner.deserialize(buffer),
            Self::null(inner) => inner.deserialize(buffer),
        }
    }

    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        match self {
            Self::rsassa(inner) => inner.toTpm(buffer),
            Self::rsapss(inner) => inner.toTpm(buffer),
            Self::ecdsa(inner) => inner.toTpm(buffer),
            Self::ecdaa(inner) => inner.toTpm(buffer),
            Self::sm2(inner) => inner.toTpm(buffer),
            Self::ecschnorr(inner) => inner.toTpm(buffer),
            Self::hmac(inner) => inner.toTpm(buffer),
            Self::any(inner) => inner.toTpm(buffer),
            Self::null(inner) => inner.toTpm(buffer),
        }
    }

    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        match self {
            Self::rsassa(inner) => inner.initFromTpm(buffer),
            Self::rsapss(inner) => inner.initFromTpm(buffer),
            Self::ecdsa(inner) => inner.initFromTpm(buffer),
            Self::ecdaa(inner) => inner.initFromTpm(buffer),
            Self::sm2(inner) => inner.initFromTpm(buffer),
            Self::ecschnorr(inner) => inner.initFromTpm(buffer),
            Self::hmac(inner) => inner.initFromTpm(buffer),
            Self::any(inner) => inner.initFromTpm(buffer),
            Self::null(inner) => inner.initFromTpm(buffer),
        }
    }

    fn fromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        match self {
            Self::rsassa(inner) => inner.fromTpm(buffer),
            Self::rsapss(inner) => inner.fromTpm(buffer),
            Self::ecdsa(inner) => inner.fromTpm(buffer),
            Self::ecdaa(inner) => inner.fromTpm(buffer),
            Self::sm2(inner) => inner.fromTpm(buffer),
            Self::ecschnorr(inner) => inner.fromTpm(buffer),
            Self::hmac(inner) => inner.fromTpm(buffer),
            Self::any(inner) => inner.fromTpm(buffer),
            Self::null(inner) => inner.fromTpm(buffer),
        }
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        match self {
            Self::rsassa(inner) => inner.fromBytes(buffer),
            Self::rsapss(inner) => inner.fromBytes(buffer),
            Self::ecdsa(inner) => inner.fromBytes(buffer),
            Self::ecdaa(inner) => inner.fromBytes(buffer),
            Self::sm2(inner) => inner.fromBytes(buffer),
            Self::ecschnorr(inner) => inner.fromBytes(buffer),
            Self::hmac(inner) => inner.fromBytes(buffer),
            Self::any(inner) => inner.fromBytes(buffer),
            Self::null(inner) => inner.fromBytes(buffer),
        }
    }

}

/// Table 166 Definition of TPMU_KDF_SCHEME Union [IN/OUT]
/// One of: TPMS_KDF_SCHEME_MGF1, TPMS_KDF_SCHEME_KDF1_SP800_56A, TPMS_KDF_SCHEME_KDF2,
/// TPMS_KDF_SCHEME_KDF1_SP800_108, TPMS_SCHEME_HASH, TPMS_NULL_KDF_SCHEME.
pub enum TPMU_KDF_SCHEME {
    mgf1(TPMS_KDF_SCHEME_MGF1),
    kdf1_sp800_56a(TPMS_KDF_SCHEME_KDF1_SP800_56A),
    kdf2(TPMS_KDF_SCHEME_KDF2),
    kdf1_sp800_108(TPMS_KDF_SCHEME_KDF1_SP800_108),
    anyKdf(TPMS_SCHEME_HASH),
    null(TPMS_NULL_KDF_SCHEME),
}

/// Union selector type
impl TPMU_KDF_SCHEME {
    pub fn GetUnionSelector(&self) -> Option<TPM_ALG_ID> {
        match self {
            Self::mgf1(_) => TPMS_KDF_SCHEME_MGF1::GetUnionSelector(),
            Self::kdf1_sp800_56a(_) => TPMS_KDF_SCHEME_KDF1_SP800_56A::GetUnionSelector(),
            Self::kdf2(_) => TPMS_KDF_SCHEME_KDF2::GetUnionSelector(),
            Self::kdf1_sp800_108(_) => TPMS_KDF_SCHEME_KDF1_SP800_108::GetUnionSelector(),
            Self::anyKdf(_) => TPMS_SCHEME_HASH::GetUnionSelector(),
            Self::null(_) => TPMS_NULL_KDF_SCHEME::GetUnionSelector(),
        }
    }

    fn create(selector: TPM_ALG_ID) -> Result<Option<Self>, TpmError> {
        match selector {
            TPM_ALG_ID::MGF1 => Ok(Some(Self::mgf1(TPMS_KDF_SCHEME_MGF1::default()))),
            TPM_ALG_ID::KDF1_SP800_56A => Ok(Some(Self::kdf1_sp800_56a(TPMS_KDF_SCHEME_KDF1_SP800_56A::default()))),
            TPM_ALG_ID::KDF2 => Ok(Some(Self::kdf2(TPMS_KDF_SCHEME_KDF2::default()))),
            TPM_ALG_ID::KDF1_SP800_108 => Ok(Some(Self::kdf1_sp800_108(TPMS_KDF_SCHEME_KDF1_SP800_108::default()))),
            TPM_ALG_ID::ANY => Ok(Some(Self::anyKdf(TPMS_SCHEME_HASH::default()))),
            TPM_ALG_ID::NULL => Ok(Some(Self::null(TPMS_NULL_KDF_SCHEME::default()))),
            _ => Err(TpmError::InvalidUnion),
        }
    }
}

impl fmt::Debug for TPMU_KDF_SCHEME {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::mgf1(inner) => write!(f, "TPMU_KDF_SCHEME::mgf1({:?})", inner),
            Self::kdf1_sp800_56a(inner) => write!(f, "TPMU_KDF_SCHEME::kdf1_sp800_56a({:?})", inner),
            Self::kdf2(inner) => write!(f, "TPMU_KDF_SCHEME::kdf2({:?})", inner),
            Self::kdf1_sp800_108(inner) => write!(f, "TPMU_KDF_SCHEME::kdf1_sp800_108({:?})", inner),
            Self::anyKdf(inner) => write!(f, "TPMU_KDF_SCHEME::anyKdf({:?})", inner),
            Self::null(inner) => write!(f, "TPMU_KDF_SCHEME::null({:?})", inner),
        }
    }
}
impl TpmStructure for TPMU_KDF_SCHEME {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        match self {
            Self::mgf1(inner) => inner.serialize(buffer),
            Self::kdf1_sp800_56a(inner) => inner.serialize(buffer),
            Self::kdf2(inner) => inner.serialize(buffer),
            Self::kdf1_sp800_108(inner) => inner.serialize(buffer),
            Self::anyKdf(inner) => inner.serialize(buffer),
            Self::null(inner) => inner.serialize(buffer),
        }
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        match self {
            Self::mgf1(inner) => inner.deserialize(buffer),
            Self::kdf1_sp800_56a(inner) => inner.deserialize(buffer),
            Self::kdf2(inner) => inner.deserialize(buffer),
            Self::kdf1_sp800_108(inner) => inner.deserialize(buffer),
            Self::anyKdf(inner) => inner.deserialize(buffer),
            Self::null(inner) => inner.deserialize(buffer),
        }
    }

    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        match self {
            Self::mgf1(inner) => inner.toTpm(buffer),
            Self::kdf1_sp800_56a(inner) => inner.toTpm(buffer),
            Self::kdf2(inner) => inner.toTpm(buffer),
            Self::kdf1_sp800_108(inner) => inner.toTpm(buffer),
            Self::anyKdf(inner) => inner.toTpm(buffer),
            Self::null(inner) => inner.toTpm(buffer),
        }
    }

    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        match self {
            Self::mgf1(inner) => inner.initFromTpm(buffer),
            Self::kdf1_sp800_56a(inner) => inner.initFromTpm(buffer),
            Self::kdf2(inner) => inner.initFromTpm(buffer),
            Self::kdf1_sp800_108(inner) => inner.initFromTpm(buffer),
            Self::anyKdf(inner) => inner.initFromTpm(buffer),
            Self::null(inner) => inner.initFromTpm(buffer),
        }
    }

    fn fromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        match self {
            Self::mgf1(inner) => inner.fromTpm(buffer),
            Self::kdf1_sp800_56a(inner) => inner.fromTpm(buffer),
            Self::kdf2(inner) => inner.fromTpm(buffer),
            Self::kdf1_sp800_108(inner) => inner.fromTpm(buffer),
            Self::anyKdf(inner) => inner.fromTpm(buffer),
            Self::null(inner) => inner.fromTpm(buffer),
        }
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        match self {
            Self::mgf1(inner) => inner.fromBytes(buffer),
            Self::kdf1_sp800_56a(inner) => inner.fromBytes(buffer),
            Self::kdf2(inner) => inner.fromBytes(buffer),
            Self::kdf1_sp800_108(inner) => inner.fromBytes(buffer),
            Self::anyKdf(inner) => inner.fromBytes(buffer),
            Self::null(inner) => inner.fromBytes(buffer),
        }
    }

}

/// This union of all asymmetric schemes is used in each of the asymmetric scheme
/// structures. The actual scheme structure is defined by the interface type used for the
/// selector (TPMI_ALG_ASYM_SCHEME).
/// One of: TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA,
/// TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA,
/// TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES,
/// TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME.
pub enum TPMU_ASYM_SCHEME {
    ecdh(TPMS_KEY_SCHEME_ECDH),
    ecmqv(TPMS_KEY_SCHEME_ECMQV),
    rsassa(TPMS_SIG_SCHEME_RSASSA),
    rsapss(TPMS_SIG_SCHEME_RSAPSS),
    ecdsa(TPMS_SIG_SCHEME_ECDSA),
    ecdaa(TPMS_SIG_SCHEME_ECDAA),
    sm2(TPMS_SIG_SCHEME_SM2),
    ecschnorr(TPMS_SIG_SCHEME_ECSCHNORR),
    rsaes(TPMS_ENC_SCHEME_RSAES),
    oaep(TPMS_ENC_SCHEME_OAEP),
    anySig(TPMS_SCHEME_HASH),
    null(TPMS_NULL_ASYM_SCHEME),
}

/// Union selector type
impl TPMU_ASYM_SCHEME {
    pub fn GetUnionSelector(&self) -> Option<TPM_ALG_ID> {
        match self {
            Self::ecdh(_) => TPMS_KEY_SCHEME_ECDH::GetUnionSelector(),
            Self::ecmqv(_) => TPMS_KEY_SCHEME_ECMQV::GetUnionSelector(),
            Self::rsassa(_) => TPMS_SIG_SCHEME_RSASSA::GetUnionSelector(),
            Self::rsapss(_) => TPMS_SIG_SCHEME_RSAPSS::GetUnionSelector(),
            Self::ecdsa(_) => TPMS_SIG_SCHEME_ECDSA::GetUnionSelector(),
            Self::ecdaa(_) => TPMS_SIG_SCHEME_ECDAA::GetUnionSelector(),
            Self::sm2(_) => TPMS_SIG_SCHEME_SM2::GetUnionSelector(),
            Self::ecschnorr(_) => TPMS_SIG_SCHEME_ECSCHNORR::GetUnionSelector(),
            Self::rsaes(_) => TPMS_ENC_SCHEME_RSAES::GetUnionSelector(),
            Self::oaep(_) => TPMS_ENC_SCHEME_OAEP::GetUnionSelector(),
            Self::anySig(_) => TPMS_SCHEME_HASH::GetUnionSelector(),
            Self::null(_) => TPMS_NULL_ASYM_SCHEME::GetUnionSelector(),
        }
    }

    fn create(selector: TPM_ALG_ID) -> Result<Option<Self>, TpmError> {
        match selector {
            TPM_ALG_ID::ECDH => Ok(Some(Self::ecdh(TPMS_KEY_SCHEME_ECDH::default()))),
            TPM_ALG_ID::ECMQV => Ok(Some(Self::ecmqv(TPMS_KEY_SCHEME_ECMQV::default()))),
            TPM_ALG_ID::RSASSA => Ok(Some(Self::rsassa(TPMS_SIG_SCHEME_RSASSA::default()))),
            TPM_ALG_ID::RSAPSS => Ok(Some(Self::rsapss(TPMS_SIG_SCHEME_RSAPSS::default()))),
            TPM_ALG_ID::ECDSA => Ok(Some(Self::ecdsa(TPMS_SIG_SCHEME_ECDSA::default()))),
            TPM_ALG_ID::ECDAA => Ok(Some(Self::ecdaa(TPMS_SIG_SCHEME_ECDAA::default()))),
            TPM_ALG_ID::SM2 => Ok(Some(Self::sm2(TPMS_SIG_SCHEME_SM2::default()))),
            TPM_ALG_ID::ECSCHNORR => Ok(Some(Self::ecschnorr(TPMS_SIG_SCHEME_ECSCHNORR::default()))),
            TPM_ALG_ID::RSAES => Ok(Some(Self::rsaes(TPMS_ENC_SCHEME_RSAES::default()))),
            TPM_ALG_ID::OAEP => Ok(Some(Self::oaep(TPMS_ENC_SCHEME_OAEP::default()))),
            TPM_ALG_ID::ANY => Ok(Some(Self::anySig(TPMS_SCHEME_HASH::default()))),
            TPM_ALG_ID::NULL => Ok(Some(Self::null(TPMS_NULL_ASYM_SCHEME::default()))),
            _ => Err(TpmError::InvalidUnion),
        }
    }
}

impl fmt::Debug for TPMU_ASYM_SCHEME {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::ecdh(inner) => write!(f, "TPMU_ASYM_SCHEME::ecdh({:?})", inner),
            Self::ecmqv(inner) => write!(f, "TPMU_ASYM_SCHEME::ecmqv({:?})", inner),
            Self::rsassa(inner) => write!(f, "TPMU_ASYM_SCHEME::rsassa({:?})", inner),
            Self::rsapss(inner) => write!(f, "TPMU_ASYM_SCHEME::rsapss({:?})", inner),
            Self::ecdsa(inner) => write!(f, "TPMU_ASYM_SCHEME::ecdsa({:?})", inner),
            Self::ecdaa(inner) => write!(f, "TPMU_ASYM_SCHEME::ecdaa({:?})", inner),
            Self::sm2(inner) => write!(f, "TPMU_ASYM_SCHEME::sm2({:?})", inner),
            Self::ecschnorr(inner) => write!(f, "TPMU_ASYM_SCHEME::ecschnorr({:?})", inner),
            Self::rsaes(inner) => write!(f, "TPMU_ASYM_SCHEME::rsaes({:?})", inner),
            Self::oaep(inner) => write!(f, "TPMU_ASYM_SCHEME::oaep({:?})", inner),
            Self::anySig(inner) => write!(f, "TPMU_ASYM_SCHEME::anySig({:?})", inner),
            Self::null(inner) => write!(f, "TPMU_ASYM_SCHEME::null({:?})", inner),
        }
    }
}
impl TpmStructure for TPMU_ASYM_SCHEME {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        match self {
            Self::ecdh(inner) => inner.serialize(buffer),
            Self::ecmqv(inner) => inner.serialize(buffer),
            Self::rsassa(inner) => inner.serialize(buffer),
            Self::rsapss(inner) => inner.serialize(buffer),
            Self::ecdsa(inner) => inner.serialize(buffer),
            Self::ecdaa(inner) => inner.serialize(buffer),
            Self::sm2(inner) => inner.serialize(buffer),
            Self::ecschnorr(inner) => inner.serialize(buffer),
            Self::rsaes(inner) => inner.serialize(buffer),
            Self::oaep(inner) => inner.serialize(buffer),
            Self::anySig(inner) => inner.serialize(buffer),
            Self::null(inner) => inner.serialize(buffer),
        }
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        match self {
            Self::ecdh(inner) => inner.deserialize(buffer),
            Self::ecmqv(inner) => inner.deserialize(buffer),
            Self::rsassa(inner) => inner.deserialize(buffer),
            Self::rsapss(inner) => inner.deserialize(buffer),
            Self::ecdsa(inner) => inner.deserialize(buffer),
            Self::ecdaa(inner) => inner.deserialize(buffer),
            Self::sm2(inner) => inner.deserialize(buffer),
            Self::ecschnorr(inner) => inner.deserialize(buffer),
            Self::rsaes(inner) => inner.deserialize(buffer),
            Self::oaep(inner) => inner.deserialize(buffer),
            Self::anySig(inner) => inner.deserialize(buffer),
            Self::null(inner) => inner.deserialize(buffer),
        }
    }

    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        match self {
            Self::ecdh(inner) => inner.toTpm(buffer),
            Self::ecmqv(inner) => inner.toTpm(buffer),
            Self::rsassa(inner) => inner.toTpm(buffer),
            Self::rsapss(inner) => inner.toTpm(buffer),
            Self::ecdsa(inner) => inner.toTpm(buffer),
            Self::ecdaa(inner) => inner.toTpm(buffer),
            Self::sm2(inner) => inner.toTpm(buffer),
            Self::ecschnorr(inner) => inner.toTpm(buffer),
            Self::rsaes(inner) => inner.toTpm(buffer),
            Self::oaep(inner) => inner.toTpm(buffer),
            Self::anySig(inner) => inner.toTpm(buffer),
            Self::null(inner) => inner.toTpm(buffer),
        }
    }

    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        match self {
            Self::ecdh(inner) => inner.initFromTpm(buffer),
            Self::ecmqv(inner) => inner.initFromTpm(buffer),
            Self::rsassa(inner) => inner.initFromTpm(buffer),
            Self::rsapss(inner) => inner.initFromTpm(buffer),
            Self::ecdsa(inner) => inner.initFromTpm(buffer),
            Self::ecdaa(inner) => inner.initFromTpm(buffer),
            Self::sm2(inner) => inner.initFromTpm(buffer),
            Self::ecschnorr(inner) => inner.initFromTpm(buffer),
            Self::rsaes(inner) => inner.initFromTpm(buffer),
            Self::oaep(inner) => inner.initFromTpm(buffer),
            Self::anySig(inner) => inner.initFromTpm(buffer),
            Self::null(inner) => inner.initFromTpm(buffer),
        }
    }

    fn fromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        match self {
            Self::ecdh(inner) => inner.fromTpm(buffer),
            Self::ecmqv(inner) => inner.fromTpm(buffer),
            Self::rsassa(inner) => inner.fromTpm(buffer),
            Self::rsapss(inner) => inner.fromTpm(buffer),
            Self::ecdsa(inner) => inner.fromTpm(buffer),
            Self::ecdaa(inner) => inner.fromTpm(buffer),
            Self::sm2(inner) => inner.fromTpm(buffer),
            Self::ecschnorr(inner) => inner.fromTpm(buffer),
            Self::rsaes(inner) => inner.fromTpm(buffer),
            Self::oaep(inner) => inner.fromTpm(buffer),
            Self::anySig(inner) => inner.fromTpm(buffer),
            Self::null(inner) => inner.fromTpm(buffer),
        }
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        match self {
            Self::ecdh(inner) => inner.fromBytes(buffer),
            Self::ecmqv(inner) => inner.fromBytes(buffer),
            Self::rsassa(inner) => inner.fromBytes(buffer),
            Self::rsapss(inner) => inner.fromBytes(buffer),
            Self::ecdsa(inner) => inner.fromBytes(buffer),
            Self::ecdaa(inner) => inner.fromBytes(buffer),
            Self::sm2(inner) => inner.fromBytes(buffer),
            Self::ecschnorr(inner) => inner.fromBytes(buffer),
            Self::rsaes(inner) => inner.fromBytes(buffer),
            Self::oaep(inner) => inner.fromBytes(buffer),
            Self::anySig(inner) => inner.fromBytes(buffer),
            Self::null(inner) => inner.fromBytes(buffer),
        }
    }

}

/// A TPMU_SIGNATURE_COMPOSITE is a union of the various signatures that are supported by
/// a particular TPM implementation. The union allows substitution of any signature
/// algorithm wherever a signature is required in a structure.
/// One of: TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA,
/// TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TPMT_HA,
/// TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE.
pub enum TPMU_SIGNATURE {
    rsassa(TPMS_SIGNATURE_RSASSA),
    rsapss(TPMS_SIGNATURE_RSAPSS),
    ecdsa(TPMS_SIGNATURE_ECDSA),
    ecdaa(TPMS_SIGNATURE_ECDAA),
    sm2(TPMS_SIGNATURE_SM2),
    ecschnorr(TPMS_SIGNATURE_ECSCHNORR),
    hmac(TPMT_HA),
    any(TPMS_SCHEME_HASH),
    null(TPMS_NULL_SIGNATURE),
}

/// Union selector type
impl TPMU_SIGNATURE {
    pub fn GetUnionSelector(&self) -> Option<TPM_ALG_ID> {
        match self {
            Self::rsassa(_) => TPMS_SIGNATURE_RSASSA::GetUnionSelector(),
            Self::rsapss(_) => TPMS_SIGNATURE_RSAPSS::GetUnionSelector(),
            Self::ecdsa(_) => TPMS_SIGNATURE_ECDSA::GetUnionSelector(),
            Self::ecdaa(_) => TPMS_SIGNATURE_ECDAA::GetUnionSelector(),
            Self::sm2(_) => TPMS_SIGNATURE_SM2::GetUnionSelector(),
            Self::ecschnorr(_) => TPMS_SIGNATURE_ECSCHNORR::GetUnionSelector(),
            Self::hmac(_) => TPMT_HA::GetUnionSelector(),
            Self::any(_) => TPMS_SCHEME_HASH::GetUnionSelector(),
            Self::null(_) => TPMS_NULL_SIGNATURE::GetUnionSelector(),
        }
    }

    fn create(selector: TPM_ALG_ID) -> Result<Option<Self>, TpmError> {
        match selector {
            TPM_ALG_ID::RSASSA => Ok(Some(Self::rsassa(TPMS_SIGNATURE_RSASSA::default()))),
            TPM_ALG_ID::RSAPSS => Ok(Some(Self::rsapss(TPMS_SIGNATURE_RSAPSS::default()))),
            TPM_ALG_ID::ECDSA => Ok(Some(Self::ecdsa(TPMS_SIGNATURE_ECDSA::default()))),
            TPM_ALG_ID::ECDAA => Ok(Some(Self::ecdaa(TPMS_SIGNATURE_ECDAA::default()))),
            TPM_ALG_ID::SM2 => Ok(Some(Self::sm2(TPMS_SIGNATURE_SM2::default()))),
            TPM_ALG_ID::ECSCHNORR => Ok(Some(Self::ecschnorr(TPMS_SIGNATURE_ECSCHNORR::default()))),
            TPM_ALG_ID::HMAC => Ok(Some(Self::hmac(TPMT_HA::default()))),
            TPM_ALG_ID::ANY => Ok(Some(Self::any(TPMS_SCHEME_HASH::default()))),
            TPM_ALG_ID::NULL => Ok(Some(Self::null(TPMS_NULL_SIGNATURE::default()))),
            _ => Err(TpmError::InvalidUnion),
        }
    }
}

impl fmt::Debug for TPMU_SIGNATURE {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::rsassa(inner) => write!(f, "TPMU_SIGNATURE::rsassa({:?})", inner),
            Self::rsapss(inner) => write!(f, "TPMU_SIGNATURE::rsapss({:?})", inner),
            Self::ecdsa(inner) => write!(f, "TPMU_SIGNATURE::ecdsa({:?})", inner),
            Self::ecdaa(inner) => write!(f, "TPMU_SIGNATURE::ecdaa({:?})", inner),
            Self::sm2(inner) => write!(f, "TPMU_SIGNATURE::sm2({:?})", inner),
            Self::ecschnorr(inner) => write!(f, "TPMU_SIGNATURE::ecschnorr({:?})", inner),
            Self::hmac(inner) => write!(f, "TPMU_SIGNATURE::hmac({:?})", inner),
            Self::any(inner) => write!(f, "TPMU_SIGNATURE::any({:?})", inner),
            Self::null(inner) => write!(f, "TPMU_SIGNATURE::null({:?})", inner),
        }
    }
}
impl TpmStructure for TPMU_SIGNATURE {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        match self {
            Self::rsassa(inner) => inner.serialize(buffer),
            Self::rsapss(inner) => inner.serialize(buffer),
            Self::ecdsa(inner) => inner.serialize(buffer),
            Self::ecdaa(inner) => inner.serialize(buffer),
            Self::sm2(inner) => inner.serialize(buffer),
            Self::ecschnorr(inner) => inner.serialize(buffer),
            Self::hmac(inner) => inner.serialize(buffer),
            Self::any(inner) => inner.serialize(buffer),
            Self::null(inner) => inner.serialize(buffer),
        }
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        match self {
            Self::rsassa(inner) => inner.deserialize(buffer),
            Self::rsapss(inner) => inner.deserialize(buffer),
            Self::ecdsa(inner) => inner.deserialize(buffer),
            Self::ecdaa(inner) => inner.deserialize(buffer),
            Self::sm2(inner) => inner.deserialize(buffer),
            Self::ecschnorr(inner) => inner.deserialize(buffer),
            Self::hmac(inner) => inner.deserialize(buffer),
            Self::any(inner) => inner.deserialize(buffer),
            Self::null(inner) => inner.deserialize(buffer),
        }
    }

    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        match self {
            Self::rsassa(inner) => inner.toTpm(buffer),
            Self::rsapss(inner) => inner.toTpm(buffer),
            Self::ecdsa(inner) => inner.toTpm(buffer),
            Self::ecdaa(inner) => inner.toTpm(buffer),
            Self::sm2(inner) => inner.toTpm(buffer),
            Self::ecschnorr(inner) => inner.toTpm(buffer),
            Self::hmac(inner) => inner.toTpm(buffer),
            Self::any(inner) => inner.toTpm(buffer),
            Self::null(inner) => inner.toTpm(buffer),
        }
    }

    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        match self {
            Self::rsassa(inner) => inner.initFromTpm(buffer),
            Self::rsapss(inner) => inner.initFromTpm(buffer),
            Self::ecdsa(inner) => inner.initFromTpm(buffer),
            Self::ecdaa(inner) => inner.initFromTpm(buffer),
            Self::sm2(inner) => inner.initFromTpm(buffer),
            Self::ecschnorr(inner) => inner.initFromTpm(buffer),
            Self::hmac(inner) => inner.initFromTpm(buffer),
            Self::any(inner) => inner.initFromTpm(buffer),
            Self::null(inner) => inner.initFromTpm(buffer),
        }
    }

    fn fromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        match self {
            Self::rsassa(inner) => inner.fromTpm(buffer),
            Self::rsapss(inner) => inner.fromTpm(buffer),
            Self::ecdsa(inner) => inner.fromTpm(buffer),
            Self::ecdaa(inner) => inner.fromTpm(buffer),
            Self::sm2(inner) => inner.fromTpm(buffer),
            Self::ecschnorr(inner) => inner.fromTpm(buffer),
            Self::hmac(inner) => inner.fromTpm(buffer),
            Self::any(inner) => inner.fromTpm(buffer),
            Self::null(inner) => inner.fromTpm(buffer),
        }
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        match self {
            Self::rsassa(inner) => inner.fromBytes(buffer),
            Self::rsapss(inner) => inner.fromBytes(buffer),
            Self::ecdsa(inner) => inner.fromBytes(buffer),
            Self::ecdaa(inner) => inner.fromBytes(buffer),
            Self::sm2(inner) => inner.fromBytes(buffer),
            Self::ecschnorr(inner) => inner.fromBytes(buffer),
            Self::hmac(inner) => inner.fromBytes(buffer),
            Self::any(inner) => inner.fromBytes(buffer),
            Self::null(inner) => inner.fromBytes(buffer),
        }
    }

}

/// This is the union of all values allowed in in the unique field of a TPMT_PUBLIC.
/// One of: TPM2B_DIGEST_KEYEDHASH, TPM2B_DIGEST_SYMCIPHER, TPM2B_PUBLIC_KEY_RSA,
/// TPMS_ECC_POINT, TPMS_DERIVE.
pub enum TPMU_PUBLIC_ID {
    keyedHash(TPM2B_DIGEST_KEYEDHASH),
    sym(TPM2B_DIGEST_SYMCIPHER),
    rsa(TPM2B_PUBLIC_KEY_RSA),
    ecc(TPMS_ECC_POINT),
    derive(TPMS_DERIVE),
}

/// Union selector type
impl TPMU_PUBLIC_ID {
    pub fn GetUnionSelector(&self) -> Option<TPM_ALG_ID> {
        match self {
            Self::keyedHash(_) => TPM2B_DIGEST_KEYEDHASH::GetUnionSelector(),
            Self::sym(_) => TPM2B_DIGEST_SYMCIPHER::GetUnionSelector(),
            Self::rsa(_) => TPM2B_PUBLIC_KEY_RSA::GetUnionSelector(),
            Self::ecc(_) => TPMS_ECC_POINT::GetUnionSelector(),
            Self::derive(_) => TPMS_DERIVE::GetUnionSelector(),
        }
    }

    fn create(selector: TPM_ALG_ID) -> Result<Option<Self>, TpmError> {
        match selector {
            TPM_ALG_ID::KEYEDHASH => Ok(Some(Self::keyedHash(TPM2B_DIGEST_KEYEDHASH::default()))),
            TPM_ALG_ID::SYMCIPHER => Ok(Some(Self::sym(TPM2B_DIGEST_SYMCIPHER::default()))),
            TPM_ALG_ID::RSA => Ok(Some(Self::rsa(TPM2B_PUBLIC_KEY_RSA::default()))),
            TPM_ALG_ID::ECC => Ok(Some(Self::ecc(TPMS_ECC_POINT::default()))),
            TPM_ALG_ID::ANY => Ok(Some(Self::derive(TPMS_DERIVE::default()))),
            _ => Err(TpmError::InvalidUnion),
        }
    }
}

impl fmt::Debug for TPMU_PUBLIC_ID {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::keyedHash(inner) => write!(f, "TPMU_PUBLIC_ID::keyedHash({:?})", inner),
            Self::sym(inner) => write!(f, "TPMU_PUBLIC_ID::sym({:?})", inner),
            Self::rsa(inner) => write!(f, "TPMU_PUBLIC_ID::rsa({:?})", inner),
            Self::ecc(inner) => write!(f, "TPMU_PUBLIC_ID::ecc({:?})", inner),
            Self::derive(inner) => write!(f, "TPMU_PUBLIC_ID::derive({:?})", inner),
        }
    }
}
impl TpmStructure for TPMU_PUBLIC_ID {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        match self {
            Self::keyedHash(inner) => inner.serialize(buffer),
            Self::sym(inner) => inner.serialize(buffer),
            Self::rsa(inner) => inner.serialize(buffer),
            Self::ecc(inner) => inner.serialize(buffer),
            Self::derive(inner) => inner.serialize(buffer),
        }
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        match self {
            Self::keyedHash(inner) => inner.deserialize(buffer),
            Self::sym(inner) => inner.deserialize(buffer),
            Self::rsa(inner) => inner.deserialize(buffer),
            Self::ecc(inner) => inner.deserialize(buffer),
            Self::derive(inner) => inner.deserialize(buffer),
        }
    }

    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        match self {
            Self::keyedHash(inner) => inner.toTpm(buffer),
            Self::sym(inner) => inner.toTpm(buffer),
            Self::rsa(inner) => inner.toTpm(buffer),
            Self::ecc(inner) => inner.toTpm(buffer),
            Self::derive(inner) => inner.toTpm(buffer),
        }
    }

    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        match self {
            Self::keyedHash(inner) => inner.initFromTpm(buffer),
            Self::sym(inner) => inner.initFromTpm(buffer),
            Self::rsa(inner) => inner.initFromTpm(buffer),
            Self::ecc(inner) => inner.initFromTpm(buffer),
            Self::derive(inner) => inner.initFromTpm(buffer),
        }
    }

    fn fromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        match self {
            Self::keyedHash(inner) => inner.fromTpm(buffer),
            Self::sym(inner) => inner.fromTpm(buffer),
            Self::rsa(inner) => inner.fromTpm(buffer),
            Self::ecc(inner) => inner.fromTpm(buffer),
            Self::derive(inner) => inner.fromTpm(buffer),
        }
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        match self {
            Self::keyedHash(inner) => inner.fromBytes(buffer),
            Self::sym(inner) => inner.fromBytes(buffer),
            Self::rsa(inner) => inner.fromBytes(buffer),
            Self::ecc(inner) => inner.fromBytes(buffer),
            Self::derive(inner) => inner.fromBytes(buffer),
        }
    }

}

/// Table 199 defines the possible parameter definition structures that may be contained
/// in the public portion of a key. If the Object can be a parent, the first field must be
/// a TPMT_SYM_DEF_OBJECT. See 11.1.7.
/// One of: TPMS_KEYEDHASH_PARMS, TPMS_SYMCIPHER_PARMS, TPMS_RSA_PARMS, TPMS_ECC_PARMS,
/// TPMS_ASYM_PARMS.
pub enum TPMU_PUBLIC_PARMS {
    keyedHashDetail(TPMS_KEYEDHASH_PARMS),
    symDetail(TPMS_SYMCIPHER_PARMS),
    rsaDetail(TPMS_RSA_PARMS),
    eccDetail(TPMS_ECC_PARMS),
    asymDetail(TPMS_ASYM_PARMS),
}

/// Union selector type
impl TPMU_PUBLIC_PARMS {
    pub fn GetUnionSelector(&self) -> Option<TPM_ALG_ID> {
        match self {
            Self::keyedHashDetail(_) => TPMS_KEYEDHASH_PARMS::GetUnionSelector(),
            Self::symDetail(_) => TPMS_SYMCIPHER_PARMS::GetUnionSelector(),
            Self::rsaDetail(_) => TPMS_RSA_PARMS::GetUnionSelector(),
            Self::eccDetail(_) => TPMS_ECC_PARMS::GetUnionSelector(),
            Self::asymDetail(_) => TPMS_ASYM_PARMS::GetUnionSelector(),
        }
    }

    fn create(selector: TPM_ALG_ID) -> Result<Option<Self>, TpmError> {
        match selector {
            TPM_ALG_ID::KEYEDHASH => Ok(Some(Self::keyedHashDetail(TPMS_KEYEDHASH_PARMS::default()))),
            TPM_ALG_ID::SYMCIPHER => Ok(Some(Self::symDetail(TPMS_SYMCIPHER_PARMS::default()))),
            TPM_ALG_ID::RSA => Ok(Some(Self::rsaDetail(TPMS_RSA_PARMS::default()))),
            TPM_ALG_ID::ECC => Ok(Some(Self::eccDetail(TPMS_ECC_PARMS::default()))),
            TPM_ALG_ID::ANY => Ok(Some(Self::asymDetail(TPMS_ASYM_PARMS::default()))),
            _ => Err(TpmError::InvalidUnion),
        }
    }
}

impl fmt::Debug for TPMU_PUBLIC_PARMS {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::keyedHashDetail(inner) => write!(f, "TPMU_PUBLIC_PARMS::keyedHashDetail({:?})", inner),
            Self::symDetail(inner) => write!(f, "TPMU_PUBLIC_PARMS::symDetail({:?})", inner),
            Self::rsaDetail(inner) => write!(f, "TPMU_PUBLIC_PARMS::rsaDetail({:?})", inner),
            Self::eccDetail(inner) => write!(f, "TPMU_PUBLIC_PARMS::eccDetail({:?})", inner),
            Self::asymDetail(inner) => write!(f, "TPMU_PUBLIC_PARMS::asymDetail({:?})", inner),
        }
    }
}
impl TpmStructure for TPMU_PUBLIC_PARMS {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        match self {
            Self::keyedHashDetail(inner) => inner.serialize(buffer),
            Self::symDetail(inner) => inner.serialize(buffer),
            Self::rsaDetail(inner) => inner.serialize(buffer),
            Self::eccDetail(inner) => inner.serialize(buffer),
            Self::asymDetail(inner) => inner.serialize(buffer),
        }
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        match self {
            Self::keyedHashDetail(inner) => inner.deserialize(buffer),
            Self::symDetail(inner) => inner.deserialize(buffer),
            Self::rsaDetail(inner) => inner.deserialize(buffer),
            Self::eccDetail(inner) => inner.deserialize(buffer),
            Self::asymDetail(inner) => inner.deserialize(buffer),
        }
    }

    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        match self {
            Self::keyedHashDetail(inner) => inner.toTpm(buffer),
            Self::symDetail(inner) => inner.toTpm(buffer),
            Self::rsaDetail(inner) => inner.toTpm(buffer),
            Self::eccDetail(inner) => inner.toTpm(buffer),
            Self::asymDetail(inner) => inner.toTpm(buffer),
        }
    }

    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        match self {
            Self::keyedHashDetail(inner) => inner.initFromTpm(buffer),
            Self::symDetail(inner) => inner.initFromTpm(buffer),
            Self::rsaDetail(inner) => inner.initFromTpm(buffer),
            Self::eccDetail(inner) => inner.initFromTpm(buffer),
            Self::asymDetail(inner) => inner.initFromTpm(buffer),
        }
    }

    fn fromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        match self {
            Self::keyedHashDetail(inner) => inner.fromTpm(buffer),
            Self::symDetail(inner) => inner.fromTpm(buffer),
            Self::rsaDetail(inner) => inner.fromTpm(buffer),
            Self::eccDetail(inner) => inner.fromTpm(buffer),
            Self::asymDetail(inner) => inner.fromTpm(buffer),
        }
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        match self {
            Self::keyedHashDetail(inner) => inner.fromBytes(buffer),
            Self::symDetail(inner) => inner.fromBytes(buffer),
            Self::rsaDetail(inner) => inner.fromBytes(buffer),
            Self::eccDetail(inner) => inner.fromBytes(buffer),
            Self::asymDetail(inner) => inner.fromBytes(buffer),
        }
    }

}

/// Table 205 Definition of TPMU_SENSITIVE_COMPOSITE Union [IN/OUT]
/// One of: TPM2B_PRIVATE_KEY_RSA, TPM2B_ECC_PARAMETER, TPM2B_SENSITIVE_DATA,
/// TPM2B_SYM_KEY, TPM2B_PRIVATE_VENDOR_SPECIFIC.
pub enum TPMU_SENSITIVE_COMPOSITE {
    rsa(TPM2B_PRIVATE_KEY_RSA),
    ecc(TPM2B_ECC_PARAMETER),
    bits(TPM2B_SENSITIVE_DATA),
    sym(TPM2B_SYM_KEY),
    any(TPM2B_PRIVATE_VENDOR_SPECIFIC),
}

/// Union selector type
impl TPMU_SENSITIVE_COMPOSITE {
    pub fn GetUnionSelector(&self) -> Option<TPM_ALG_ID> {
        match self {
            Self::rsa(_) => TPM2B_PRIVATE_KEY_RSA::GetUnionSelector(),
            Self::ecc(_) => TPM2B_ECC_PARAMETER::GetUnionSelector(),
            Self::bits(_) => TPM2B_SENSITIVE_DATA::GetUnionSelector(),
            Self::sym(_) => TPM2B_SYM_KEY::GetUnionSelector(),
            Self::any(_) => TPM2B_PRIVATE_VENDOR_SPECIFIC::GetUnionSelector(),
        }
    }

    fn create(selector: TPM_ALG_ID) -> Result<Option<Self>, TpmError> {
        match selector {
            TPM_ALG_ID::RSA => Ok(Some(Self::rsa(TPM2B_PRIVATE_KEY_RSA::default()))),
            TPM_ALG_ID::ECC => Ok(Some(Self::ecc(TPM2B_ECC_PARAMETER::default()))),
            TPM_ALG_ID::KEYEDHASH => Ok(Some(Self::bits(TPM2B_SENSITIVE_DATA::default()))),
            TPM_ALG_ID::SYMCIPHER => Ok(Some(Self::sym(TPM2B_SYM_KEY::default()))),
            TPM_ALG_ID::ANY => Ok(Some(Self::any(TPM2B_PRIVATE_VENDOR_SPECIFIC::default()))),
            _ => Err(TpmError::InvalidUnion),
        }
    }
}

impl fmt::Debug for TPMU_SENSITIVE_COMPOSITE {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::rsa(inner) => write!(f, "TPMU_SENSITIVE_COMPOSITE::rsa({:?})", inner),
            Self::ecc(inner) => write!(f, "TPMU_SENSITIVE_COMPOSITE::ecc({:?})", inner),
            Self::bits(inner) => write!(f, "TPMU_SENSITIVE_COMPOSITE::bits({:?})", inner),
            Self::sym(inner) => write!(f, "TPMU_SENSITIVE_COMPOSITE::sym({:?})", inner),
            Self::any(inner) => write!(f, "TPMU_SENSITIVE_COMPOSITE::any({:?})", inner),
        }
    }
}
impl TpmStructure for TPMU_SENSITIVE_COMPOSITE {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        match self {
            Self::rsa(inner) => inner.serialize(buffer),
            Self::ecc(inner) => inner.serialize(buffer),
            Self::bits(inner) => inner.serialize(buffer),
            Self::sym(inner) => inner.serialize(buffer),
            Self::any(inner) => inner.serialize(buffer),
        }
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        match self {
            Self::rsa(inner) => inner.deserialize(buffer),
            Self::ecc(inner) => inner.deserialize(buffer),
            Self::bits(inner) => inner.deserialize(buffer),
            Self::sym(inner) => inner.deserialize(buffer),
            Self::any(inner) => inner.deserialize(buffer),
        }
    }

    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        match self {
            Self::rsa(inner) => inner.toTpm(buffer),
            Self::ecc(inner) => inner.toTpm(buffer),
            Self::bits(inner) => inner.toTpm(buffer),
            Self::sym(inner) => inner.toTpm(buffer),
            Self::any(inner) => inner.toTpm(buffer),
        }
    }

    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        match self {
            Self::rsa(inner) => inner.initFromTpm(buffer),
            Self::ecc(inner) => inner.initFromTpm(buffer),
            Self::bits(inner) => inner.initFromTpm(buffer),
            Self::sym(inner) => inner.initFromTpm(buffer),
            Self::any(inner) => inner.initFromTpm(buffer),
        }
    }

    fn fromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        match self {
            Self::rsa(inner) => inner.fromTpm(buffer),
            Self::ecc(inner) => inner.fromTpm(buffer),
            Self::bits(inner) => inner.fromTpm(buffer),
            Self::sym(inner) => inner.fromTpm(buffer),
            Self::any(inner) => inner.fromTpm(buffer),
        }
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        match self {
            Self::rsa(inner) => inner.fromBytes(buffer),
            Self::ecc(inner) => inner.fromBytes(buffer),
            Self::bits(inner) => inner.fromBytes(buffer),
            Self::sym(inner) => inner.fromBytes(buffer),
            Self::any(inner) => inner.fromBytes(buffer),
        }
    }

}

/// Handle of a loaded TPM key or other object [TSS]
#[derive(Debug, Default)]
pub struct TPM_HANDLE {
    /// Handle value
    pub handle: u32,
}

impl TPM_HANDLE {
    /// Creates a new instance with the specified values
    pub fn new(
        handle: u32,
        ) -> Self {
        Self {
            handle,
        }
    }

}

impl TpmStructure for TPM_HANDLE {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM_HANDLE>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeInt(self.handle);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.handle = buf.readInt();
        Ok(())
    }

}

/// Base class for empty union elements.
/// An empty union element does not contain any data to marshal.
/// This data structure can be used in place of any other union
/// initialized with its own empty element.
#[derive(Debug, Default)]
pub struct TPMS_NULL_UNION {
}

impl TPMS_NULL_UNION {
    fn GetUnionSelector() -> Option<TPM_ALG_ID> {
        Some(TPM_ALG_ID::NULL)
    }
}

impl TpmStructure for TPMS_NULL_UNION {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMS_NULL_UNION>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        Ok(())
    }

}

/// This structure is used as a placeholder. In some cases, a union will have a selector
/// value with no data to unmarshal when that type is selected. Rather than leave the
/// entry empty, TPMS_EMPTY may be selected.
#[derive(Debug, Default)]
pub struct TPMS_EMPTY {
}

impl TPMS_EMPTY {
    fn GetUnionSelector() -> Option<TPM_ALG_ID> {
        Some(TPM_ALG_ID::RSAES)
    }
}

impl TpmStructure for TPMS_EMPTY {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMS_EMPTY>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        Ok(())
    }

}

/// This structure is a return value for a TPM2_GetCapability() that reads the installed algorithms.
#[derive(Debug, Default)]
pub struct TPMS_ALGORITHM_DESCRIPTION {
    /// An algorithm
    pub alg: TPM_ALG_ID,

    /// The attributes of the algorithm
    pub attributes: TPMA_ALGORITHM,
}

impl TPMS_ALGORITHM_DESCRIPTION {
    /// Creates a new instance with the specified values
    pub fn new(
        alg: TPM_ALG_ID,
        attributes: TPMA_ALGORITHM,
        ) -> Self {
        Self {
            alg,
            attributes,
        }
    }

}

impl TpmStructure for TPMS_ALGORITHM_DESCRIPTION {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMS_ALGORITHM_DESCRIPTION>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeShort(self.alg);
        buf.writeInt(self.attributes);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.alg = buf.readShort();
        self.attributes = buf.readInt();
        Ok(())
    }

}

/// Table 80 shows the basic hash-agile structure used in this specification. To handle
/// hash agility, this structure uses the hashAlg parameter to indicate the algorithm used
/// to compute the digest and, by implication, the size of the digest.
#[derive(Debug, Default)]
pub struct TPMT_HA {
    /// Selector of the hash contained in the digest that implies the size of the digest
    /// NOTE The leading + on the type indicates that this structure should pass an indication
    /// to the unmarshaling function for TPMI_ALG_HASH so that TPM_ALG_NULL will be allowed if
    /// a use of a TPMT_HA allows TPM_ALG_NULL.
    pub hashAlg: TPM_ALG_ID,

    /// Hash value
    pub digest: Vec<u8>,
}

impl TPMT_HA {
    /// Creates a new instance with the specified values
    pub fn new(
        hashAlg: TPM_ALG_ID,
        digest: Vec<u8>,
        ) -> Self {
        Self {
            hashAlg,
            digest,
        }
    }

    fn GetUnionSelector() -> Option<TPM_ALG_ID> {
        Some(TPM_ALG_ID::HMAC)
    }
}

impl TpmStructure for TPMT_HA {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMT_HA>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeShort(self.hashAlg);
        buf.writeByteBuf(self.digest);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.hashAlg = buf.readShort();
        self.digest = buf.readByteBuf(Crypto::digestSize(self.hashAlg));
        Ok(())
    }

}

/// This structure is used for a sized buffer that cannot be larger than the largest
/// digest produced by any hash algorithm implemented on the TPM.
#[derive(Debug, Default)]
pub struct TPM2B_DIGEST {
    /// The buffer area that can be no larger than a digest
    pub buffer: Vec<u8>,
}

impl TPM2B_DIGEST {
    /// Creates a new instance with the specified values
    pub fn new(
        buffer: Vec<u8>,
        ) -> Self {
        Self {
            buffer,
        }
    }

    fn GetUnionSelector() -> Option<TPM_ALG_ID> {
        Some(TPM_ALG_ID::KEYEDHASH)
    }
}

impl TpmStructure for TPM2B_DIGEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2B_DIGEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.buffer);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.buffer = buf.readSizedByteBuf();
        Ok(())
    }

}

/// This structure is used for a data buffer that is required to be no larger than the
/// size of the Name of an object.
#[derive(Debug, Default)]
pub struct TPM2B_DATA {
    pub buffer: Vec<u8>,
}

impl TPM2B_DATA {
    /// Creates a new instance with the specified values
    pub fn new(
        buffer: Vec<u8>,
        ) -> Self {
        Self {
            buffer,
        }
    }

}

impl TpmStructure for TPM2B_DATA {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2B_DATA>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.buffer);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.buffer = buf.readSizedByteBuf();
        Ok(())
    }

}

/// Table 83 Definition of Types for TPM2B_NONCE
pub type TPM2B_NONCE = TPM2B_DIGEST;

/// This structure is used for an authorization value and limits an authValue to being no
/// larger than the largest digest produced by a TPM. In order to ensure consistency
/// within an object, the authValue may be no larger than the size of the digest produced
/// by the objects nameAlg. This ensures that any TPM that can load the object will be
/// able to handle the authValue of the object.
pub type TPM2B_AUTH = TPM2B_DIGEST;

/// This type is a sized buffer that can hold an operand for a comparison with an NV Index
/// location. The maximum size of the operand is implementation dependent but a TPM is
/// required to support an operand size that is at least as big as the digest produced by
/// any of the hash algorithms implemented on the TPM.
pub type TPM2B_OPERAND = TPM2B_DIGEST;

/// This type is a sized buffer that can hold event data.
#[derive(Debug, Default)]
pub struct TPM2B_EVENT {
    /// The operand
    pub buffer: Vec<u8>,
}

impl TPM2B_EVENT {
    /// Creates a new instance with the specified values
    pub fn new(
        buffer: Vec<u8>,
        ) -> Self {
        Self {
            buffer,
        }
    }

}

impl TpmStructure for TPM2B_EVENT {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2B_EVENT>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.buffer);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.buffer = buf.readSizedByteBuf();
        Ok(())
    }

}

/// This type is a sized buffer that can hold a maximally sized buffer for commands that
/// use a large data buffer such as TPM2_Hash(), TPM2_SequenceUpdate(), or TPM2_FieldUpgradeData().
#[derive(Debug, Default)]
pub struct TPM2B_MAX_BUFFER {
    /// The operand
    pub buffer: Vec<u8>,
}

impl TPM2B_MAX_BUFFER {
    /// Creates a new instance with the specified values
    pub fn new(
        buffer: Vec<u8>,
        ) -> Self {
        Self {
            buffer,
        }
    }

}

impl TpmStructure for TPM2B_MAX_BUFFER {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2B_MAX_BUFFER>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.buffer);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.buffer = buf.readSizedByteBuf();
        Ok(())
    }

}

/// This type is a sized buffer that can hold a maximally sized buffer for NV data
/// commands such as TPM2_NV_Read(), TPM2_NV_Write(), and TPM2_NV_Certify().
#[derive(Debug, Default)]
pub struct TPM2B_MAX_NV_BUFFER {
    /// The operand
    /// NOTE MAX_NV_BUFFER_SIZE is TPM-dependent
    pub buffer: Vec<u8>,
}

impl TPM2B_MAX_NV_BUFFER {
    /// Creates a new instance with the specified values
    pub fn new(
        buffer: Vec<u8>,
        ) -> Self {
        Self {
            buffer,
        }
    }

}

impl TpmStructure for TPM2B_MAX_NV_BUFFER {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2B_MAX_NV_BUFFER>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.buffer);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.buffer = buf.readSizedByteBuf();
        Ok(())
    }

}

/// This TPM-dependent structure is used to provide the timeout value for an
/// authorization. The size shall be 8 or less.
#[derive(Debug, Default)]
pub struct TPM2B_TIMEOUT {
    /// The timeout value
    pub buffer: Vec<u8>,
}

impl TPM2B_TIMEOUT {
    /// Creates a new instance with the specified values
    pub fn new(
        buffer: Vec<u8>,
        ) -> Self {
        Self {
            buffer,
        }
    }

}

impl TpmStructure for TPM2B_TIMEOUT {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2B_TIMEOUT>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.buffer);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.buffer = buf.readSizedByteBuf();
        Ok(())
    }

}

/// This structure is used for passing an initial value for a symmetric block cipher to or
/// from the TPM. The size is set to be the largest block size of any implemented
/// symmetric cipher implemented on the TPM.
#[derive(Debug, Default)]
pub struct TPM2B_IV {
    /// The IV value
    pub buffer: Vec<u8>,
}

impl TPM2B_IV {
    /// Creates a new instance with the specified values
    pub fn new(
        buffer: Vec<u8>,
        ) -> Self {
        Self {
            buffer,
        }
    }

}

impl TpmStructure for TPM2B_IV {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2B_IV>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.buffer);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.buffer = buf.readSizedByteBuf();
        Ok(())
    }

}

/// This buffer holds a Name for any entity type.
#[derive(Debug, Default)]
pub struct TPM2B_NAME {
    /// The Name structure
    pub name: Vec<u8>,
}

impl TPM2B_NAME {
    /// Creates a new instance with the specified values
    pub fn new(
        name: Vec<u8>,
        ) -> Self {
        Self {
            name,
        }
    }

}

impl TpmStructure for TPM2B_NAME {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2B_NAME>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.name);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.name = buf.readSizedByteBuf();
        Ok(())
    }

}

/// This structure provides a standard method of specifying a list of PCR.
#[derive(Debug, Default)]
pub struct TPMS_PCR_SELECT {
    /// The bit map of selected PCR
    pub pcrSelect: Vec<u8>,
}

impl TPMS_PCR_SELECT {
    /// Creates a new instance with the specified values
    pub fn new(
        pcrSelect: Vec<u8>,
        ) -> Self {
        Self {
            pcrSelect,
        }
    }

}

impl TpmStructure for TPMS_PCR_SELECT {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMS_PCR_SELECT>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.pcrSelect, 1);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.pcrSelect = buf.readSizedByteBuf(1);
        Ok(())
    }

}

/// Table 94 Definition of TPMS_PCR_SELECTION Structure
#[derive(Debug, Default)]
pub struct TPMS_PCR_SELECTION {
    /// The hash algorithm associated with the selection
    pub hash: TPM_ALG_ID,

    /// The bit map of selected PCR
    pub pcrSelect: Vec<u8>,
}

impl TPMS_PCR_SELECTION {
    /// Creates a new instance with the specified values
    pub fn new(
        hash: TPM_ALG_ID,
        pcrSelect: Vec<u8>,
        ) -> Self {
        Self {
            hash,
            pcrSelect,
        }
    }

}

impl TpmStructure for TPMS_PCR_SELECTION {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMS_PCR_SELECTION>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeShort(self.hash);
        buf.writeSizedByteBuf(self.pcrSelect, 1);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.hash = buf.readShort();
        self.pcrSelect = buf.readSizedByteBuf(1);
        Ok(())
    }

}

/// This ticket is produced by TPM2_Create() or TPM2_CreatePrimary(). It is used to bind
/// the creation data to the object to which it applies. The ticket is computed by
#[derive(Debug, Default)]
pub struct TPMT_TK_CREATION {
    /// The hierarchy containing name
    pub hierarchy: TPM_HANDLE,

    /// This shall be the HMAC produced using a proof value of hierarchy.
    pub digest: Vec<u8>,
}

impl TPMT_TK_CREATION {
    /// Creates a new instance with the specified values
    pub fn new(
        hierarchy: TPM_HANDLE,
        digest: Vec<u8>,
        ) -> Self {
        Self {
            hierarchy,
            digest,
        }
    }

}

impl TpmStructure for TPMT_TK_CREATION {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMT_TK_CREATION>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeShort(TPM_ST::CREATION);
        self.hierarchy.toTpm(buf);
        buf.writeSizedByteBuf(self.digest);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        buf.readShort();
        self.hierarchy.initFromTpm(buf);
        self.digest = buf.readSizedByteBuf();
        Ok(())
    }

}

/// This ticket is produced by TPM2_VerifySignature(). This formulation is used for
/// multiple ticket uses. The ticket provides evidence that the TPM has validated that a
/// digest was signed by a key with the Name of keyName. The ticket is computed by
#[derive(Debug, Default)]
pub struct TPMT_TK_VERIFIED {
    /// The hierarchy containing keyName
    pub hierarchy: TPM_HANDLE,

    /// This shall be the HMAC produced using a proof value of hierarchy.
    pub digest: Vec<u8>,
}

impl TPMT_TK_VERIFIED {
    /// Creates a new instance with the specified values
    pub fn new(
        hierarchy: TPM_HANDLE,
        digest: Vec<u8>,
        ) -> Self {
        Self {
            hierarchy,
            digest,
        }
    }

}

impl TpmStructure for TPMT_TK_VERIFIED {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMT_TK_VERIFIED>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeShort(TPM_ST::VERIFIED);
        self.hierarchy.toTpm(buf);
        buf.writeSizedByteBuf(self.digest);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        buf.readShort();
        self.hierarchy.initFromTpm(buf);
        self.digest = buf.readSizedByteBuf();
        Ok(())
    }

}

/// This ticket is produced by TPM2_PolicySigned() and TPM2_PolicySecret() when the
/// authorization has an expiration time. If nonceTPM was provided in the policy command,
/// the ticket is computed by
#[derive(Debug, Default)]
pub struct TPMT_TK_AUTH {
    /// Ticket structure tag
    pub tag: TPM_ST,

    /// The hierarchy of the object used to produce the ticket
    pub hierarchy: TPM_HANDLE,

    /// This shall be the HMAC produced using a proof value of hierarchy.
    pub digest: Vec<u8>,
}

impl TPMT_TK_AUTH {
    /// Creates a new instance with the specified values
    pub fn new(
        tag: TPM_ST,
        hierarchy: TPM_HANDLE,
        digest: Vec<u8>,
        ) -> Self {
        Self {
            tag,
            hierarchy,
            digest,
        }
    }

}

impl TpmStructure for TPMT_TK_AUTH {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMT_TK_AUTH>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeShort(self.tag);
        self.hierarchy.toTpm(buf);
        buf.writeSizedByteBuf(self.digest);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.tag = buf.readShort();
        self.hierarchy.initFromTpm(buf);
        self.digest = buf.readSizedByteBuf();
        Ok(())
    }

}

/// This ticket is produced by TPM2_SequenceComplete() or TPM2_Hash() when the message
/// that was digested did not start with TPM_GENERATED_VALUE. The ticket is computed by
#[derive(Debug, Default)]
pub struct TPMT_TK_HASHCHECK {
    /// The hierarchy
    pub hierarchy: TPM_HANDLE,

    /// This shall be the HMAC produced using a proof value of hierarchy.
    pub digest: Vec<u8>,
}

impl TPMT_TK_HASHCHECK {
    /// Creates a new instance with the specified values
    pub fn new(
        hierarchy: TPM_HANDLE,
        digest: Vec<u8>,
        ) -> Self {
        Self {
            hierarchy,
            digest,
        }
    }

}

impl TpmStructure for TPMT_TK_HASHCHECK {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMT_TK_HASHCHECK>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeShort(TPM_ST::HASHCHECK);
        self.hierarchy.toTpm(buf);
        buf.writeSizedByteBuf(self.digest);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        buf.readShort();
        self.hierarchy.initFromTpm(buf);
        self.digest = buf.readSizedByteBuf();
        Ok(())
    }

}

/// This structure is used to report the properties of an algorithm identifier. It is
/// returned in response to a TPM2_GetCapability() with capability = TPM_CAP_ALG.
#[derive(Debug, Default)]
pub struct TPMS_ALG_PROPERTY {
    /// An algorithm identifier
    pub alg: TPM_ALG_ID,

    /// The attributes of the algorithm
    pub algProperties: TPMA_ALGORITHM,
}

impl TPMS_ALG_PROPERTY {
    /// Creates a new instance with the specified values
    pub fn new(
        alg: TPM_ALG_ID,
        algProperties: TPMA_ALGORITHM,
        ) -> Self {
        Self {
            alg,
            algProperties,
        }
    }

}

impl TpmStructure for TPMS_ALG_PROPERTY {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMS_ALG_PROPERTY>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeShort(self.alg);
        buf.writeInt(self.algProperties);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.alg = buf.readShort();
        self.algProperties = buf.readInt();
        Ok(())
    }

}

/// This structure is used to report the properties that are UINT32 values. It is returned
/// in response to a TPM2_GetCapability().
#[derive(Debug, Default)]
pub struct TPMS_TAGGED_PROPERTY {
    /// A property identifier
    pub property: TPM_PT,

    /// The value of the property
    pub value: u32,
}

impl TPMS_TAGGED_PROPERTY {
    /// Creates a new instance with the specified values
    pub fn new(
        property: TPM_PT,
        value: u32,
        ) -> Self {
        Self {
            property,
            value,
        }
    }

}

impl TpmStructure for TPMS_TAGGED_PROPERTY {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMS_TAGGED_PROPERTY>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeInt(self.property);
        buf.writeInt(self.value);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.property = buf.readInt();
        self.value = buf.readInt();
        Ok(())
    }

}

/// This structure is used in TPM2_GetCapability() to return the attributes of the PCR.
#[derive(Debug, Default)]
pub struct TPMS_TAGGED_PCR_SELECT {
    /// The property identifier
    pub tag: TPM_PT_PCR,

    /// The bit map of PCR with the identified property
    pub pcrSelect: Vec<u8>,
}

impl TPMS_TAGGED_PCR_SELECT {
    /// Creates a new instance with the specified values
    pub fn new(
        tag: TPM_PT_PCR,
        pcrSelect: Vec<u8>,
        ) -> Self {
        Self {
            tag,
            pcrSelect,
        }
    }

}

impl TpmStructure for TPMS_TAGGED_PCR_SELECT {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMS_TAGGED_PCR_SELECT>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeInt(self.tag);
        buf.writeSizedByteBuf(self.pcrSelect, 1);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.tag = buf.readInt();
        self.pcrSelect = buf.readSizedByteBuf(1);
        Ok(())
    }

}

/// This structure is used in TPM2_GetCapability() to return the policy associated with a
/// permanent handle.
#[derive(Debug, Default)]
pub struct TPMS_TAGGED_POLICY {
    /// A permanent handle
    pub handle: TPM_HANDLE,

    /// The policy algorithm and hash
    pub policyHash: TPMT_HA,
}

impl TPMS_TAGGED_POLICY {
    /// Creates a new instance with the specified values
    pub fn new(
        handle: TPM_HANDLE,
        policyHash: TPMT_HA,
        ) -> Self {
        Self {
            handle,
            policyHash,
        }
    }

}

impl TpmStructure for TPMS_TAGGED_POLICY {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMS_TAGGED_POLICY>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.handle.toTpm(buf);
        self.policyHash.toTpm(buf);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.handle.initFromTpm(buf);
        self.policyHash.initFromTpm(buf);
        Ok(())
    }

}

/// This structure is used in TPM2_GetCapability() to return the ACT data.
#[derive(Debug, Default)]
pub struct TPMS_ACT_DATA {
    /// A permanent handle
    pub handle: TPM_HANDLE,

    /// The current timeout of the ACT
    pub timeout: u32,

    /// The state of the ACT
    pub attributes: TPMA_ACT,
}

impl TPMS_ACT_DATA {
    /// Creates a new instance with the specified values
    pub fn new(
        handle: TPM_HANDLE,
        timeout: u32,
        attributes: TPMA_ACT,
        ) -> Self {
        Self {
            handle,
            timeout,
            attributes,
        }
    }

}

impl TpmStructure for TPMS_ACT_DATA {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMS_ACT_DATA>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.handle.toTpm(buf);
        buf.writeInt(self.timeout);
        buf.writeInt(self.attributes);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.handle.initFromTpm(buf);
        self.timeout = buf.readInt();
        self.attributes = buf.readInt();
        Ok(())
    }

}

/// A list of command codes may be input to the TPM or returned by the TPM depending on
/// the command.
#[derive(Debug, Default)]
pub struct TPML_CC {
    /// A list of command codes
    /// The maximum only applies to a command code list in a command. The response size is
    /// limited only by the size of the parameter buffer.
    pub commandCodes: Vec<TPM_CC>,
}

impl TPML_CC {
    /// Creates a new instance with the specified values
    pub fn new(
        commandCodes: Vec<TPM_CC>,
        ) -> Self {
        Self {
            commandCodes,
        }
    }

    fn GetUnionSelector() -> Option<TPM_CAP> {
        Some(TPM_CAP::PP_COMMANDS)
    }
}

impl TpmStructure for TPML_CC {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPML_CC>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeValArr(self.commandCodes, 4);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        buf.readValArr(self.commandCodes, 4);
        Ok(())
    }

}

/// This list is only used in TPM2_GetCapability(capability = TPM_CAP_COMMANDS).
#[derive(Debug, Default)]
pub struct TPML_CCA {
    /// A list of command codes attributes
    pub commandAttributes: Vec<TPMA_CC>,
}

impl TPML_CCA {
    /// Creates a new instance with the specified values
    pub fn new(
        commandAttributes: Vec<TPMA_CC>,
        ) -> Self {
        Self {
            commandAttributes,
        }
    }

    fn GetUnionSelector() -> Option<TPM_CAP> {
        Some(TPM_CAP::COMMANDS)
    }
}

impl TpmStructure for TPML_CCA {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPML_CCA>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeValArr(self.commandAttributes, 4);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        buf.readValArr(self.commandAttributes, 4);
        Ok(())
    }

}

/// This list is returned by TPM2_IncrementalSelfTest().
#[derive(Debug, Default)]
pub struct TPML_ALG {
    /// A list of algorithm IDs
    /// The maximum only applies to an algorithm list in a command. The response size is
    /// limited only by the size of the parameter buffer.
    pub algorithms: Vec<TPM_ALG_ID>,
}

impl TPML_ALG {
    /// Creates a new instance with the specified values
    pub fn new(
        algorithms: Vec<TPM_ALG_ID>,
        ) -> Self {
        Self {
            algorithms,
        }
    }

}

impl TpmStructure for TPML_ALG {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPML_ALG>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeValArr(self.algorithms, 2);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        buf.readValArr(self.algorithms, 2);
        Ok(())
    }

}

/// This structure is used when the TPM returns a list of loaded handles when the
/// capability in TPM2_GetCapability() is TPM_CAP_HANDLE.
#[derive(Debug, Default)]
pub struct TPML_HANDLE {
    /// An array of handles
    pub handle: Vec<TPM_HANDLE>,
}

impl TPML_HANDLE {
    /// Creates a new instance with the specified values
    pub fn new(
        handle: Vec<TPM_HANDLE>,
        ) -> Self {
        Self {
            handle,
        }
    }

    fn GetUnionSelector() -> Option<TPM_CAP> {
        Some(TPM_CAP::HANDLES)
    }
}

impl TpmStructure for TPML_HANDLE {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPML_HANDLE>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeObjArr(self.handle);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        buf.readObjArr(self.handle);
        Ok(())
    }

}

/// This list is used to convey a list of digest values. This type is used in
/// TPM2_PolicyOR() and in TPM2_PCR_Read().
#[derive(Debug, Default)]
pub struct TPML_DIGEST {
    /// A list of digests
    /// For TPM2_PolicyOR(), all digests will have been computed using the digest of the
    /// policy session. For TPM2_PCR_Read(), each digest will be the size of the digest for
    /// the bank containing the PCR.
    pub digests: Vec<TPM2B_DIGEST>,
}

impl TPML_DIGEST {
    /// Creates a new instance with the specified values
    pub fn new(
        digests: Vec<TPM2B_DIGEST>,
        ) -> Self {
        Self {
            digests,
        }
    }

}

impl TpmStructure for TPML_DIGEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPML_DIGEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeObjArr(self.digests);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        buf.readObjArr(self.digests);
        Ok(())
    }

}

/// This list is used to convey a list of digest values. This type is returned by
/// TPM2_PCR_Event() and TPM2_EventSequenceComplete() and is an input for TPM2_PCR_Extend().
#[derive(Debug, Default)]
pub struct TPML_DIGEST_VALUES {
    /// A list of tagged digests
    pub digests: Vec<TPMT_HA>,
}

impl TPML_DIGEST_VALUES {
    /// Creates a new instance with the specified values
    pub fn new(
        digests: Vec<TPMT_HA>,
        ) -> Self {
        Self {
            digests,
        }
    }

}

impl TpmStructure for TPML_DIGEST_VALUES {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPML_DIGEST_VALUES>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeObjArr(self.digests);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        buf.readObjArr(self.digests);
        Ok(())
    }

}

/// This list is used to indicate the PCR that are included in a selection when more than
/// one PCR value may be selected.
#[derive(Debug, Default)]
pub struct TPML_PCR_SELECTION {
    /// List of selections
    pub pcrSelections: Vec<TPMS_PCR_SELECTION>,
}

impl TPML_PCR_SELECTION {
    /// Creates a new instance with the specified values
    pub fn new(
        pcrSelections: Vec<TPMS_PCR_SELECTION>,
        ) -> Self {
        Self {
            pcrSelections,
        }
    }

    fn GetUnionSelector() -> Option<TPM_CAP> {
        Some(TPM_CAP::PCRS)
    }
}

impl TpmStructure for TPML_PCR_SELECTION {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPML_PCR_SELECTION>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeObjArr(self.pcrSelections);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        buf.readObjArr(self.pcrSelections);
        Ok(())
    }

}

/// This list is used to report on a list of algorithm attributes. It is returned in a
/// TPM2_GetCapability().
#[derive(Debug, Default)]
pub struct TPML_ALG_PROPERTY {
    /// List of properties
    pub algProperties: Vec<TPMS_ALG_PROPERTY>,
}

impl TPML_ALG_PROPERTY {
    /// Creates a new instance with the specified values
    pub fn new(
        algProperties: Vec<TPMS_ALG_PROPERTY>,
        ) -> Self {
        Self {
            algProperties,
        }
    }

    fn GetUnionSelector() -> Option<TPM_CAP> {
        Some(TPM_CAP::ALGS)
    }
}

impl TpmStructure for TPML_ALG_PROPERTY {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPML_ALG_PROPERTY>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeObjArr(self.algProperties);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        buf.readObjArr(self.algProperties);
        Ok(())
    }

}

/// This list is used to report on a list of properties that are TPMS_TAGGED_PROPERTY
/// values. It is returned by a TPM2_GetCapability().
#[derive(Debug, Default)]
pub struct TPML_TAGGED_TPM_PROPERTY {
    /// An array of tagged properties
    pub tpmProperty: Vec<TPMS_TAGGED_PROPERTY>,
}

impl TPML_TAGGED_TPM_PROPERTY {
    /// Creates a new instance with the specified values
    pub fn new(
        tpmProperty: Vec<TPMS_TAGGED_PROPERTY>,
        ) -> Self {
        Self {
            tpmProperty,
        }
    }

    fn GetUnionSelector() -> Option<TPM_CAP> {
        Some(TPM_CAP::TPM_PROPERTIES)
    }
}

impl TpmStructure for TPML_TAGGED_TPM_PROPERTY {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPML_TAGGED_TPM_PROPERTY>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeObjArr(self.tpmProperty);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        buf.readObjArr(self.tpmProperty);
        Ok(())
    }

}

/// This list is used to report on a list of properties that are TPMS_PCR_SELECT values.
/// It is returned by a TPM2_GetCapability().
#[derive(Debug, Default)]
pub struct TPML_TAGGED_PCR_PROPERTY {
    /// A tagged PCR selection
    pub pcrProperty: Vec<TPMS_TAGGED_PCR_SELECT>,
}

impl TPML_TAGGED_PCR_PROPERTY {
    /// Creates a new instance with the specified values
    pub fn new(
        pcrProperty: Vec<TPMS_TAGGED_PCR_SELECT>,
        ) -> Self {
        Self {
            pcrProperty,
        }
    }

    fn GetUnionSelector() -> Option<TPM_CAP> {
        Some(TPM_CAP::PCR_PROPERTIES)
    }
}

impl TpmStructure for TPML_TAGGED_PCR_PROPERTY {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPML_TAGGED_PCR_PROPERTY>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeObjArr(self.pcrProperty);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        buf.readObjArr(self.pcrProperty);
        Ok(())
    }

}

/// This list is used to report the ECC curve ID values supported by the TPM. It is
/// returned by a TPM2_GetCapability().
#[derive(Debug, Default)]
pub struct TPML_ECC_CURVE {
    /// Array of ECC curve identifiers
    pub eccCurves: Vec<TPM_ECC_CURVE>,
}

impl TPML_ECC_CURVE {
    /// Creates a new instance with the specified values
    pub fn new(
        eccCurves: Vec<TPM_ECC_CURVE>,
        ) -> Self {
        Self {
            eccCurves,
        }
    }

    fn GetUnionSelector() -> Option<TPM_CAP> {
        Some(TPM_CAP::ECC_CURVES)
    }
}

impl TpmStructure for TPML_ECC_CURVE {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPML_ECC_CURVE>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeValArr(self.eccCurves, 2);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        buf.readValArr(self.eccCurves, 2);
        Ok(())
    }

}

/// This list is used to report the authorization policy values for permanent handles.
/// This is list may be generated by TPM2_GetCapabiltiy(). A permanent handle that cannot
/// have a policy is not included in the list.
#[derive(Debug, Default)]
pub struct TPML_TAGGED_POLICY {
    /// Array of tagged policies
    pub policies: Vec<TPMS_TAGGED_POLICY>,
}

impl TPML_TAGGED_POLICY {
    /// Creates a new instance with the specified values
    pub fn new(
        policies: Vec<TPMS_TAGGED_POLICY>,
        ) -> Self {
        Self {
            policies,
        }
    }

    fn GetUnionSelector() -> Option<TPM_CAP> {
        Some(TPM_CAP::AUTH_POLICIES)
    }
}

impl TpmStructure for TPML_TAGGED_POLICY {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPML_TAGGED_POLICY>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeObjArr(self.policies);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        buf.readObjArr(self.policies);
        Ok(())
    }

}

/// This list is used to report the timeout and state for the ACT. This list may be
/// generated by TPM2_GetCapabilty(). Only implemented ACT are present in the list
#[derive(Debug, Default)]
pub struct TPML_ACT_DATA {
    /// Array of ACT data
    pub actData: Vec<TPMS_ACT_DATA>,
}

impl TPML_ACT_DATA {
    /// Creates a new instance with the specified values
    pub fn new(
        actData: Vec<TPMS_ACT_DATA>,
        ) -> Self {
        Self {
            actData,
        }
    }

    fn GetUnionSelector() -> Option<TPM_CAP> {
        Some(TPM_CAP::ACT)
    }
}

impl TpmStructure for TPML_ACT_DATA {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPML_ACT_DATA>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeObjArr(self.actData);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        buf.readObjArr(self.actData);
        Ok(())
    }

}

/// This data area is returned in response to a TPM2_GetCapability().
#[derive(Debug, Default)]
pub struct TPMS_CAPABILITY_DATA {
    /// The capability

    /// The capability data
    /// One of: TPML_ALG_PROPERTY, TPML_HANDLE, TPML_CCA, TPML_CC, TPML_PCR_SELECTION,
    /// TPML_TAGGED_TPM_PROPERTY, TPML_TAGGED_PCR_PROPERTY, TPML_ECC_CURVE,
    /// TPML_TAGGED_POLICY, TPML_ACT_DATA.
    pub data: Option<TPMU_CAPABILITIES>,
}

impl TPMS_CAPABILITY_DATA {
    /// Creates a new instance with the specified values
    pub fn new(
        data: Option<TPMU_CAPABILITIES>,
        ) -> Self {
        Self {
            data,
        }
    }

}

impl TpmStructure for TPMS_CAPABILITY_DATA {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMS_CAPABILITY_DATA>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        if (self.data.is_none()) { return Ok(()) };
        buf.writeInt(self.data.unwrap().GetUnionSelector().unwrap());
        self.data.unwrap().toTpm(buf);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        let r#capability: TPM_CAP = buf.readInt();
        self.data = TPMU_CAPABILITIES::create(r#capability)?;
        self.data.unwrap().initFromTpm(buf);
        Ok(())
    }

}

/// This structure is used in each of the attestation commands.
#[derive(Debug, Default)]
pub struct TPMS_CLOCK_INFO {
    /// Time value in milliseconds that advances while the TPM is powered
    /// NOTE The interpretation of the time-origin (clock=0) is out of the scope of this
    /// specification, although Coordinated Universal Time (UTC) is expected to be a common
    /// convention. This structure element is used to report on the TPM's Clock value.
    /// This value is reset to zero when the Storage Primary Seed is changed (TPM2_Clear()).
    /// This value may be advanced by TPM2_ClockSet().
    pub clock: u64,

    /// Number of occurrences of TPM Reset since the last TPM2_Clear()
    pub resetCount: u32,

    /// Number of times that TPM2_Shutdown() or _TPM_Hash_Start have occurred since the last
    /// TPM Reset or TPM2_Clear().
    pub restartCount: u32,

    /// No value of Clock greater than the current value of Clock has been previously reported
    /// by the TPM. Set to YES on TPM2_Clear().
    pub safe: u8,
}

impl TPMS_CLOCK_INFO {
    /// Creates a new instance with the specified values
    pub fn new(
        clock: u64,
        resetCount: u32,
        restartCount: u32,
        safe: u8,
        ) -> Self {
        Self {
            clock,
            resetCount,
            restartCount,
            safe,
        }
    }

}

impl TpmStructure for TPMS_CLOCK_INFO {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMS_CLOCK_INFO>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeInt64(self.clock);
        buf.writeInt(self.resetCount);
        buf.writeInt(self.restartCount);
        buf.writeByte(self.safe);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.clock = buf.readInt64();
        self.resetCount = buf.readInt();
        self.restartCount = buf.readInt();
        self.safe = buf.readByte();
        Ok(())
    }

}

/// This structure is used in, e.g., the TPM2_GetTime() attestation and TPM2_ReadClock().
#[derive(Debug, Default)]
pub struct TPMS_TIME_INFO {
    /// Time in milliseconds since the TIme circuit was last reset
    /// This structure element is used to report on the TPM's Time value.
    pub time: u64,

    /// A structure containing the clock information
    pub clockInfo: TPMS_CLOCK_INFO,
}

impl TPMS_TIME_INFO {
    /// Creates a new instance with the specified values
    pub fn new(
        time: u64,
        clockInfo: TPMS_CLOCK_INFO,
        ) -> Self {
        Self {
            time,
            clockInfo,
        }
    }

}

impl TpmStructure for TPMS_TIME_INFO {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMS_TIME_INFO>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeInt64(self.time);
        self.clockInfo.toTpm(buf);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.time = buf.readInt64();
        self.clockInfo.initFromTpm(buf);
        Ok(())
    }

}

/// This structure is used when the TPM performs TPM2_GetTime.
#[derive(Debug, Default)]
pub struct TPMS_TIME_ATTEST_INFO {
    /// The Time, Clock, resetCount, restartCount, and Safe indicator
    pub time: TPMS_TIME_INFO,

    /// A TPM vendor-specific value indicating the version number of the firmware
    pub firmwareVersion: u64,
}

impl TPMS_TIME_ATTEST_INFO {
    /// Creates a new instance with the specified values
    pub fn new(
        time: TPMS_TIME_INFO,
        firmwareVersion: u64,
        ) -> Self {
        Self {
            time,
            firmwareVersion,
        }
    }

    fn GetUnionSelector() -> Option<TPM_ST> {
        Some(TPM_ST::ATTEST_TIME)
    }
}

impl TpmStructure for TPMS_TIME_ATTEST_INFO {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMS_TIME_ATTEST_INFO>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.time.toTpm(buf);
        buf.writeInt64(self.firmwareVersion);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.time.initFromTpm(buf);
        self.firmwareVersion = buf.readInt64();
        Ok(())
    }

}

/// This is the attested data for TPM2_Certify().
#[derive(Debug, Default)]
pub struct TPMS_CERTIFY_INFO {
    /// Name of the certified object
    pub name: Vec<u8>,

    /// Qualified Name of the certified object
    pub qualifiedName: Vec<u8>,
}

impl TPMS_CERTIFY_INFO {
    /// Creates a new instance with the specified values
    pub fn new(
        name: Vec<u8>,
        qualifiedName: Vec<u8>,
        ) -> Self {
        Self {
            name,
            qualifiedName,
        }
    }

    fn GetUnionSelector() -> Option<TPM_ST> {
        Some(TPM_ST::ATTEST_CERTIFY)
    }
}

impl TpmStructure for TPMS_CERTIFY_INFO {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMS_CERTIFY_INFO>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.name);
        buf.writeSizedByteBuf(self.qualifiedName);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.name = buf.readSizedByteBuf();
        self.qualifiedName = buf.readSizedByteBuf();
        Ok(())
    }

}

/// This is the attested data for TPM2_Quote().
#[derive(Debug, Default)]
pub struct TPMS_QUOTE_INFO {
    /// Information on algID, PCR selected and digest
    pub pcrSelect: Vec<TPMS_PCR_SELECTION>,

    /// Digest of the selected PCR using the hash of the signing key
    pub pcrDigest: Vec<u8>,
}

impl TPMS_QUOTE_INFO {
    /// Creates a new instance with the specified values
    pub fn new(
        pcrSelect: Vec<TPMS_PCR_SELECTION>,
        pcrDigest: Vec<u8>,
        ) -> Self {
        Self {
            pcrSelect,
            pcrDigest,
        }
    }

    fn GetUnionSelector() -> Option<TPM_ST> {
        Some(TPM_ST::ATTEST_QUOTE)
    }
}

impl TpmStructure for TPMS_QUOTE_INFO {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMS_QUOTE_INFO>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeObjArr(self.pcrSelect);
        buf.writeSizedByteBuf(self.pcrDigest);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        buf.readObjArr(self.pcrSelect);
        self.pcrDigest = buf.readSizedByteBuf();
        Ok(())
    }

}

/// This is the attested data for TPM2_GetCommandAuditDigest().
#[derive(Debug, Default)]
pub struct TPMS_COMMAND_AUDIT_INFO {
    /// The monotonic audit counter
    pub auditCounter: u64,

    /// Hash algorithm used for the command audit
    pub digestAlg: TPM_ALG_ID,

    /// The current value of the audit digest
    pub auditDigest: Vec<u8>,

    /// Digest of the command codes being audited using digestAlg
    pub commandDigest: Vec<u8>,
}

impl TPMS_COMMAND_AUDIT_INFO {
    /// Creates a new instance with the specified values
    pub fn new(
        auditCounter: u64,
        digestAlg: TPM_ALG_ID,
        auditDigest: Vec<u8>,
        commandDigest: Vec<u8>,
        ) -> Self {
        Self {
            auditCounter,
            digestAlg,
            auditDigest,
            commandDigest,
        }
    }

    fn GetUnionSelector() -> Option<TPM_ST> {
        Some(TPM_ST::ATTEST_COMMAND_AUDIT)
    }
}

impl TpmStructure for TPMS_COMMAND_AUDIT_INFO {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMS_COMMAND_AUDIT_INFO>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeInt64(self.auditCounter);
        buf.writeShort(self.digestAlg);
        buf.writeSizedByteBuf(self.auditDigest);
        buf.writeSizedByteBuf(self.commandDigest);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.auditCounter = buf.readInt64();
        self.digestAlg = buf.readShort();
        self.auditDigest = buf.readSizedByteBuf();
        self.commandDigest = buf.readSizedByteBuf();
        Ok(())
    }

}

/// This is the attested data for TPM2_GetSessionAuditDigest().
#[derive(Debug, Default)]
pub struct TPMS_SESSION_AUDIT_INFO {
    /// Current exclusive status of the session
    /// TRUE if all of the commands recorded in the sessionDigest were executed without any
    /// intervening TPM command that did not use this audit session
    pub exclusiveSession: u8,

    /// The current value of the session audit digest
    pub sessionDigest: Vec<u8>,
}

impl TPMS_SESSION_AUDIT_INFO {
    /// Creates a new instance with the specified values
    pub fn new(
        exclusiveSession: u8,
        sessionDigest: Vec<u8>,
        ) -> Self {
        Self {
            exclusiveSession,
            sessionDigest,
        }
    }

    fn GetUnionSelector() -> Option<TPM_ST> {
        Some(TPM_ST::ATTEST_SESSION_AUDIT)
    }
}

impl TpmStructure for TPMS_SESSION_AUDIT_INFO {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMS_SESSION_AUDIT_INFO>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeByte(self.exclusiveSession);
        buf.writeSizedByteBuf(self.sessionDigest);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.exclusiveSession = buf.readByte();
        self.sessionDigest = buf.readSizedByteBuf();
        Ok(())
    }

}

/// This is the attested data for TPM2_CertifyCreation().
#[derive(Debug, Default)]
pub struct TPMS_CREATION_INFO {
    /// Name of the object
    pub objectName: Vec<u8>,

    /// CreationHash
    pub creationHash: Vec<u8>,
}

impl TPMS_CREATION_INFO {
    /// Creates a new instance with the specified values
    pub fn new(
        objectName: Vec<u8>,
        creationHash: Vec<u8>,
        ) -> Self {
        Self {
            objectName,
            creationHash,
        }
    }

    fn GetUnionSelector() -> Option<TPM_ST> {
        Some(TPM_ST::ATTEST_CREATION)
    }
}

impl TpmStructure for TPMS_CREATION_INFO {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMS_CREATION_INFO>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.objectName);
        buf.writeSizedByteBuf(self.creationHash);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.objectName = buf.readSizedByteBuf();
        self.creationHash = buf.readSizedByteBuf();
        Ok(())
    }

}

/// This structure contains the Name and contents of the selected NV Index that is
/// certified by TPM2_NV_Certify().
#[derive(Debug, Default)]
pub struct TPMS_NV_CERTIFY_INFO {
    /// Name of the NV Index
    pub indexName: Vec<u8>,

    /// The offset parameter of TPM2_NV_Certify()
    pub offset: u16,

    /// Contents of the NV Index
    pub nvContents: Vec<u8>,
}

impl TPMS_NV_CERTIFY_INFO {
    /// Creates a new instance with the specified values
    pub fn new(
        indexName: Vec<u8>,
        offset: u16,
        nvContents: Vec<u8>,
        ) -> Self {
        Self {
            indexName,
            offset,
            nvContents,
        }
    }

    fn GetUnionSelector() -> Option<TPM_ST> {
        Some(TPM_ST::ATTEST_NV)
    }
}

impl TpmStructure for TPMS_NV_CERTIFY_INFO {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMS_NV_CERTIFY_INFO>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.indexName);
        buf.writeShort(self.offset);
        buf.writeSizedByteBuf(self.nvContents);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.indexName = buf.readSizedByteBuf();
        self.offset = buf.readShort();
        self.nvContents = buf.readSizedByteBuf();
        Ok(())
    }

}

/// This structure contains the Name and hash of the contents of the selected NV Index
/// that is certified by TPM2_NV_Certify(). The data is hashed using hash of the signing scheme.
#[derive(Debug, Default)]
pub struct TPMS_NV_DIGEST_CERTIFY_INFO {
    /// Name of the NV Index
    pub indexName: Vec<u8>,

    /// Hash of the contents of the index
    pub nvDigest: Vec<u8>,
}

impl TPMS_NV_DIGEST_CERTIFY_INFO {
    /// Creates a new instance with the specified values
    pub fn new(
        indexName: Vec<u8>,
        nvDigest: Vec<u8>,
        ) -> Self {
        Self {
            indexName,
            nvDigest,
        }
    }

    fn GetUnionSelector() -> Option<TPM_ST> {
        Some(TPM_ST::ATTEST_NV_DIGEST)
    }
}

impl TpmStructure for TPMS_NV_DIGEST_CERTIFY_INFO {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMS_NV_DIGEST_CERTIFY_INFO>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.indexName);
        buf.writeSizedByteBuf(self.nvDigest);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.indexName = buf.readSizedByteBuf();
        self.nvDigest = buf.readSizedByteBuf();
        Ok(())
    }

}

/// This structure is used on each TPM-generated signed structure. The signature is over
/// this structure.
#[derive(Debug, Default)]
pub struct TPMS_ATTEST {
    /// The indication that this structure was created by a TPM (always TPM_GENERATED_VALUE)
    pub magic: TPM_GENERATED,

    /// Type of the attestation structure

    /// Qualified Name of the signing key
    pub qualifiedSigner: Vec<u8>,

    /// External information supplied by caller
    /// NOTE A TPM2B_DATA structure provides room for a digest and a method indicator to
    /// indicate the components of the digest. The definition of this method indicator is
    /// outside the scope of this specification.
    pub extraData: Vec<u8>,

    /// Clock, resetCount, restartCount, and Safe
    pub clockInfo: TPMS_CLOCK_INFO,

    /// TPM-vendor-specific value identifying the version number of the firmware
    pub firmwareVersion: u64,

    /// The type-specific attestation information
    /// One of: TPMS_CERTIFY_INFO, TPMS_CREATION_INFO, TPMS_QUOTE_INFO,
    /// TPMS_COMMAND_AUDIT_INFO, TPMS_SESSION_AUDIT_INFO, TPMS_TIME_ATTEST_INFO,
    /// TPMS_NV_CERTIFY_INFO, TPMS_NV_DIGEST_CERTIFY_INFO.
    pub attested: Option<TPMU_ATTEST>,
}

impl TPMS_ATTEST {
    /// Creates a new instance with the specified values
    pub fn new(
        magic: TPM_GENERATED,
        qualifiedSigner: Vec<u8>,
        extraData: Vec<u8>,
        clockInfo: TPMS_CLOCK_INFO,
        firmwareVersion: u64,
        attested: Option<TPMU_ATTEST>,
        ) -> Self {
        Self {
            magic,
            qualifiedSigner,
            extraData,
            clockInfo,
            firmwareVersion,
            attested,
        }
    }

}

impl TpmStructure for TPMS_ATTEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMS_ATTEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeInt(self.magic);
        buf.writeShort(self.attested.unwrap().GetUnionSelector().unwrap());
        buf.writeSizedByteBuf(self.qualifiedSigner);
        buf.writeSizedByteBuf(self.extraData);
        self.clockInfo.toTpm(buf);
        buf.writeInt64(self.firmwareVersion);
        self.attested.unwrap().toTpm(buf);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.magic = buf.readInt();
        let r#type: TPM_ST = buf.readShort();
        self.qualifiedSigner = buf.readSizedByteBuf();
        self.extraData = buf.readSizedByteBuf();
        self.clockInfo.initFromTpm(buf);
        self.firmwareVersion = buf.readInt64();
        self.attested = TPMU_ATTEST::create(r#type)?;
        self.attested.unwrap().initFromTpm(buf);
        Ok(())
    }

}

/// This sized buffer to contain the signed structure. The attestationData is the signed
/// portion of the structure. The size parameter is not signed.
#[derive(Debug, Default)]
pub struct TPM2B_ATTEST {
    /// The signed structure
    pub attestationData: TPMS_ATTEST,
}

impl TPM2B_ATTEST {
    /// Creates a new instance with the specified values
    pub fn new(
        attestationData: TPMS_ATTEST,
        ) -> Self {
        Self {
            attestationData,
        }
    }

}

impl TpmStructure for TPM2B_ATTEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2B_ATTEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedObj(self.attestationData);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        buf.readSizedObj(self.attestationData);
        Ok(())
    }

}

/// This is the format used for each of the authorizations in the session area of a command.
#[derive(Debug, Default)]
pub struct TPMS_AUTH_COMMAND {
    /// The session handle
    pub sessionHandle: TPM_HANDLE,

    /// The session nonce, may be the Empty Buffer
    pub nonce: Vec<u8>,

    /// The session attributes
    pub sessionAttributes: TPMA_SESSION,

    /// Either an HMAC, a password, or an EmptyAuth
    pub hmac: Vec<u8>,
}

impl TPMS_AUTH_COMMAND {
    /// Creates a new instance with the specified values
    pub fn new(
        sessionHandle: TPM_HANDLE,
        nonce: Vec<u8>,
        sessionAttributes: TPMA_SESSION,
        hmac: Vec<u8>,
        ) -> Self {
        Self {
            sessionHandle,
            nonce,
            sessionAttributes,
            hmac,
        }
    }

}

impl TpmStructure for TPMS_AUTH_COMMAND {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMS_AUTH_COMMAND>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.sessionHandle.toTpm(buf);
        buf.writeSizedByteBuf(self.nonce);
        buf.writeByte(self.sessionAttributes);
        buf.writeSizedByteBuf(self.hmac);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.sessionHandle.initFromTpm(buf);
        self.nonce = buf.readSizedByteBuf();
        self.sessionAttributes = buf.readByte();
        self.hmac = buf.readSizedByteBuf();
        Ok(())
    }

}

/// This is the format for each of the authorizations in the session area of the response.
/// If the TPM returns TPM_RC_SUCCESS, then the session area of the response contains the
/// same number of authorizations as the command and the authorizations are in the same order.
#[derive(Debug, Default)]
pub struct TPMS_AUTH_RESPONSE {
    /// The session nonce, may be the Empty Buffer
    pub nonce: Vec<u8>,

    /// The session attributes
    pub sessionAttributes: TPMA_SESSION,

    /// Either an HMAC or an EmptyAuth
    pub hmac: Vec<u8>,
}

impl TPMS_AUTH_RESPONSE {
    /// Creates a new instance with the specified values
    pub fn new(
        nonce: Vec<u8>,
        sessionAttributes: TPMA_SESSION,
        hmac: Vec<u8>,
        ) -> Self {
        Self {
            nonce,
            sessionAttributes,
            hmac,
        }
    }

}

impl TpmStructure for TPMS_AUTH_RESPONSE {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMS_AUTH_RESPONSE>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.nonce);
        buf.writeByte(self.sessionAttributes);
        buf.writeSizedByteBuf(self.hmac);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.nonce = buf.readSizedByteBuf();
        self.sessionAttributes = buf.readByte();
        self.hmac = buf.readSizedByteBuf();
        Ok(())
    }

}

/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_TDES for the union TPMU_SYM_DETAILS
#[derive(Debug, Default)]
pub struct TPMS_TDES_SYM_DETAILS {
}

impl TPMS_TDES_SYM_DETAILS {
    fn GetUnionSelector() -> Option<TPM_ALG_ID> {
        Some(TPM_ALG_ID::TDES)
    }
}

impl TpmStructure for TPMS_TDES_SYM_DETAILS {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMS_TDES_SYM_DETAILS>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        Ok(())
    }

}

/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_AES for the union TPMU_SYM_DETAILS
#[derive(Debug, Default)]
pub struct TPMS_AES_SYM_DETAILS {
}

impl TPMS_AES_SYM_DETAILS {
    fn GetUnionSelector() -> Option<TPM_ALG_ID> {
        Some(TPM_ALG_ID::AES)
    }
}

impl TpmStructure for TPMS_AES_SYM_DETAILS {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMS_AES_SYM_DETAILS>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        Ok(())
    }

}

/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_SM4 for the union TPMU_SYM_DETAILS
#[derive(Debug, Default)]
pub struct TPMS_SM4_SYM_DETAILS {
}

impl TPMS_SM4_SYM_DETAILS {
    fn GetUnionSelector() -> Option<TPM_ALG_ID> {
        Some(TPM_ALG_ID::SM4)
    }
}

impl TpmStructure for TPMS_SM4_SYM_DETAILS {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMS_SM4_SYM_DETAILS>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        Ok(())
    }

}

/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_CAMELLIA for the union TPMU_SYM_DETAILS
#[derive(Debug, Default)]
pub struct TPMS_CAMELLIA_SYM_DETAILS {
}

impl TPMS_CAMELLIA_SYM_DETAILS {
    fn GetUnionSelector() -> Option<TPM_ALG_ID> {
        Some(TPM_ALG_ID::CAMELLIA)
    }
}

impl TpmStructure for TPMS_CAMELLIA_SYM_DETAILS {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMS_CAMELLIA_SYM_DETAILS>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        Ok(())
    }

}

/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_ANY for the union TPMU_SYM_DETAILS
#[derive(Debug, Default)]
pub struct TPMS_ANY_SYM_DETAILS {
}

impl TPMS_ANY_SYM_DETAILS {
    fn GetUnionSelector() -> Option<TPM_ALG_ID> {
        Some(TPM_ALG_ID::ANY)
    }
}

impl TpmStructure for TPMS_ANY_SYM_DETAILS {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMS_ANY_SYM_DETAILS>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        Ok(())
    }

}

/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_XOR for the union TPMU_SYM_DETAILS
#[derive(Debug, Default)]
pub struct TPMS_XOR_SYM_DETAILS {
}

impl TPMS_XOR_SYM_DETAILS {
    fn GetUnionSelector() -> Option<TPM_ALG_ID> {
        Some(TPM_ALG_ID::XOR)
    }
}

impl TpmStructure for TPMS_XOR_SYM_DETAILS {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMS_XOR_SYM_DETAILS>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        Ok(())
    }

}

/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TPMU_SYM_DETAILS
#[derive(Debug, Default)]
pub struct TPMS_NULL_SYM_DETAILS {
}

impl TPMS_NULL_SYM_DETAILS {
    fn GetUnionSelector() -> Option<TPM_ALG_ID> {
        Some(TPM_ALG_ID::NULL)
    }
}

impl TpmStructure for TPMS_NULL_SYM_DETAILS {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMS_NULL_SYM_DETAILS>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        Ok(())
    }

}

/// The TPMT_SYM_DEF structure is used to select an algorithm to be used for parameter
/// encryption in those cases when different symmetric algorithms may be selected.
#[derive(Debug, Default)]
pub struct TPMT_SYM_DEF {
    /// Indicates a symmetric algorithm
    pub algorithm: TPM_ALG_ID,

    /// A supported key size
    pub keyBits: u16,

    /// The mode for the key
    pub mode: TPM_ALG_ID,
}

impl TPMT_SYM_DEF {
    /// Creates a new instance with the specified values
    pub fn new(
        algorithm: TPM_ALG_ID,
        keyBits: u16,
        mode: TPM_ALG_ID,
        ) -> Self {
        Self {
            algorithm,
            keyBits,
            mode,
        }
    }

}

impl TpmStructure for TPMT_SYM_DEF {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMT_SYM_DEF>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeShort(self.algorithm);
        if (self.algorithm == TPM_ALG_ID::NULL) { return Ok(()) };
        buf.writeShort(self.keyBits);
        buf.writeShort(self.mode);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.algorithm = buf.readShort();
        if (self.algorithm == TPM_ALG_ID::NULL) { return Ok(()) };
        self.keyBits = buf.readShort();
        self.mode = buf.readShort();
        Ok(())
    }

}

/// This structure is used when different symmetric block cipher (not XOR) algorithms may
/// be selected. If the Object can be an ordinary parent (not a derivation parent), this
/// must be the first field in the Object's parameter (see 12.2.3.7) field.
#[derive(Debug, Default)]
pub struct TPMT_SYM_DEF_OBJECT {
    /// Selects a symmetric block cipher
    /// When used in the parameter area of a parent object, this shall be a supported block
    /// cipher and not TPM_ALG_NULL
    pub algorithm: TPM_ALG_ID,

    /// The key size
    pub keyBits: u16,

    /// Default mode
    /// When used in the parameter area of a parent object, this shall be TPM_ALG_CFB.
    pub mode: TPM_ALG_ID,
}

impl TPMT_SYM_DEF_OBJECT {
    /// Creates a new instance with the specified values
    pub fn new(
        algorithm: TPM_ALG_ID,
        keyBits: u16,
        mode: TPM_ALG_ID,
        ) -> Self {
        Self {
            algorithm,
            keyBits,
            mode,
        }
    }

}

impl TpmStructure for TPMT_SYM_DEF_OBJECT {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMT_SYM_DEF_OBJECT>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeShort(self.algorithm);
        if (self.algorithm == TPM_ALG_ID::NULL) { return Ok(()) };
        buf.writeShort(self.keyBits);
        buf.writeShort(self.mode);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.algorithm = buf.readShort();
        if (self.algorithm == TPM_ALG_ID::NULL) { return Ok(()) };
        self.keyBits = buf.readShort();
        self.mode = buf.readShort();
        Ok(())
    }

}

/// This structure is used to hold a symmetric key in the sensitive area of an asymmetric object.
#[derive(Debug, Default)]
pub struct TPM2B_SYM_KEY {
    /// The key
    pub buffer: Vec<u8>,
}

impl TPM2B_SYM_KEY {
    /// Creates a new instance with the specified values
    pub fn new(
        buffer: Vec<u8>,
        ) -> Self {
        Self {
            buffer,
        }
    }

    fn GetUnionSelector() -> Option<TPM_ALG_ID> {
        Some(TPM_ALG_ID::SYMCIPHER)
    }
}

impl TpmStructure for TPM2B_SYM_KEY {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2B_SYM_KEY>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.buffer);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.buffer = buf.readSizedByteBuf();
        Ok(())
    }

}

/// This structure contains the parameters for a symmetric block cipher object.
#[derive(Debug, Default)]
pub struct TPMS_SYMCIPHER_PARMS {
    /// A symmetric block cipher
    pub sym: TPMT_SYM_DEF_OBJECT,
}

impl TPMS_SYMCIPHER_PARMS {
    /// Creates a new instance with the specified values
    pub fn new(
        sym: TPMT_SYM_DEF_OBJECT,
        ) -> Self {
        Self {
            sym,
        }
    }

    fn GetUnionSelector() -> Option<TPM_ALG_ID> {
        Some(TPM_ALG_ID::SYMCIPHER)
    }
}

impl TpmStructure for TPMS_SYMCIPHER_PARMS {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMS_SYMCIPHER_PARMS>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.sym.toTpm(buf);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.sym.initFromTpm(buf);
        Ok(())
    }

}

/// This buffer holds a label or context value. For interoperability and backwards
/// compatibility, LABEL_MAX_BUFFER is the minimum of the largest digest on the device and
/// the largest ECC parameter (MAX_ECC_KEY_BYTES) but no more than 32 bytes.
#[derive(Debug, Default)]
pub struct TPM2B_LABEL {
    /// Symmetric data for a created object or the label and context for a derived object
    pub buffer: Vec<u8>,
}

impl TPM2B_LABEL {
    /// Creates a new instance with the specified values
    pub fn new(
        buffer: Vec<u8>,
        ) -> Self {
        Self {
            buffer,
        }
    }

}

impl TpmStructure for TPM2B_LABEL {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2B_LABEL>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.buffer);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.buffer = buf.readSizedByteBuf();
        Ok(())
    }

}

/// This structure contains the label and context fields for a derived object. These
/// values are used in the derivation KDF. The values in the unique field of inPublic area
/// template take precedence over the values in the inSensitive parameter.
#[derive(Debug, Default)]
pub struct TPMS_DERIVE {
    pub label: Vec<u8>,
    pub context: Vec<u8>,
}

impl TPMS_DERIVE {
    /// Creates a new instance with the specified values
    pub fn new(
        label: Vec<u8>,
        context: Vec<u8>,
        ) -> Self {
        Self {
            label,
            context,
        }
    }

    fn GetUnionSelector() -> Option<TPM_ALG_ID> {
        Some(TPM_ALG_ID::ANY2)
    }
}

impl TpmStructure for TPMS_DERIVE {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMS_DERIVE>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.label);
        buf.writeSizedByteBuf(self.context);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.label = buf.readSizedByteBuf();
        self.context = buf.readSizedByteBuf();
        Ok(())
    }

}

/// Table 147 Definition of TPM2B_DERIVE Structure
#[derive(Debug, Default)]
pub struct TPM2B_DERIVE {
    /// Symmetric data for a created object or the label and context for a derived object
    pub buffer: TPMS_DERIVE,
}

impl TPM2B_DERIVE {
    /// Creates a new instance with the specified values
    pub fn new(
        buffer: TPMS_DERIVE,
        ) -> Self {
        Self {
            buffer,
        }
    }

}

impl TpmStructure for TPM2B_DERIVE {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2B_DERIVE>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedObj(self.buffer);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        buf.readSizedObj(self.buffer);
        Ok(())
    }

}

/// This buffer wraps the TPMU_SENSITIVE_CREATE structure.
#[derive(Debug, Default)]
pub struct TPM2B_SENSITIVE_DATA {
    /// Symmetric data for a created object or the label and context for a derived object
    pub buffer: Vec<u8>,
}

impl TPM2B_SENSITIVE_DATA {
    /// Creates a new instance with the specified values
    pub fn new(
        buffer: Vec<u8>,
        ) -> Self {
        Self {
            buffer,
        }
    }

    fn GetUnionSelector() -> Option<TPM_ALG_ID> {
        Some(TPM_ALG_ID::KEYEDHASH)
    }
}

impl TpmStructure for TPM2B_SENSITIVE_DATA {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2B_SENSITIVE_DATA>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.buffer);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.buffer = buf.readSizedByteBuf();
        Ok(())
    }

}

/// This structure defines the values to be placed in the sensitive area of a created
/// object. This structure is only used within a TPM2B_SENSITIVE_CREATE structure.
#[derive(Debug, Default)]
pub struct TPMS_SENSITIVE_CREATE {
    /// The USER auth secret value
    pub userAuth: Vec<u8>,

    /// Data to be sealed, a key, or derivation values
    pub data: Vec<u8>,
}

impl TPMS_SENSITIVE_CREATE {
    /// Creates a new instance with the specified values
    pub fn new(
        userAuth: Vec<u8>,
        data: Vec<u8>,
        ) -> Self {
        Self {
            userAuth,
            data,
        }
    }

}

impl TpmStructure for TPMS_SENSITIVE_CREATE {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMS_SENSITIVE_CREATE>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.userAuth);
        buf.writeSizedByteBuf(self.data);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.userAuth = buf.readSizedByteBuf();
        self.data = buf.readSizedByteBuf();
        Ok(())
    }

}

/// This structure contains the sensitive creation data in a sized buffer. This structure
/// is defined so that both the userAuth and data values of the TPMS_SENSITIVE_CREATE may
/// be passed as a single parameter for parameter encryption purposes.
#[derive(Debug, Default)]
pub struct TPM2B_SENSITIVE_CREATE {
    /// Data to be sealed or a symmetric key value.
    pub sensitive: TPMS_SENSITIVE_CREATE,
}

impl TPM2B_SENSITIVE_CREATE {
    /// Creates a new instance with the specified values
    pub fn new(
        sensitive: TPMS_SENSITIVE_CREATE,
        ) -> Self {
        Self {
            sensitive,
        }
    }

}

impl TpmStructure for TPM2B_SENSITIVE_CREATE {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2B_SENSITIVE_CREATE>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedObj(self.sensitive);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        buf.readSizedObj(self.sensitive);
        Ok(())
    }

}

/// This structure is the scheme data for schemes that only require a hash to complete
/// their definition.
#[derive(Debug, Default)]
pub struct TPMS_SCHEME_HASH {
    /// The hash algorithm used to digest the message
    pub hashAlg: TPM_ALG_ID,
}

impl TPMS_SCHEME_HASH {
    /// Creates a new instance with the specified values
    pub fn new(
        hashAlg: TPM_ALG_ID,
        ) -> Self {
        Self {
            hashAlg,
        }
    }

    fn GetUnionSelector() -> Option<TPM_ALG_ID> {
        Some(TPM_ALG_ID::HMAC)
    }
}

impl TpmStructure for TPMS_SCHEME_HASH {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMS_SCHEME_HASH>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeShort(self.hashAlg);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.hashAlg = buf.readShort();
        Ok(())
    }

}

/// This definition is for split signing schemes that require a commit count.
#[derive(Debug, Default)]
pub struct TPMS_SCHEME_ECDAA {
    /// The hash algorithm used to digest the message
    pub hashAlg: TPM_ALG_ID,

    /// The counter value that is used between TPM2_Commit() and the sign operation
    pub count: u16,
}

impl TPMS_SCHEME_ECDAA {
    /// Creates a new instance with the specified values
    pub fn new(
        hashAlg: TPM_ALG_ID,
        count: u16,
        ) -> Self {
        Self {
            hashAlg,
            count,
        }
    }

    fn GetUnionSelector() -> Option<TPM_ALG_ID> {
        Some(TPM_ALG_ID::ECDAA)
    }
}

impl TpmStructure for TPMS_SCHEME_ECDAA {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMS_SCHEME_ECDAA>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeShort(self.hashAlg);
        buf.writeShort(self.count);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.hashAlg = buf.readShort();
        self.count = buf.readShort();
        Ok(())
    }

}

/// Table 155 Definition of Types for HMAC_SIG_SCHEME
#[derive(Debug, Default)]
pub struct TPMS_SCHEME_HMAC {
}

impl TPMS_SCHEME_HMAC {
    fn GetUnionSelector() -> Option<TPM_ALG_ID> {
        Some(TPM_ALG_ID::HMAC)
    }
}

impl TpmStructure for TPMS_SCHEME_HMAC {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMS_SCHEME_HMAC>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        Ok(())
    }

}

/// This structure is for the XOR encryption scheme.
#[derive(Debug, Default)]
pub struct TPMS_SCHEME_XOR {
    /// The hash algorithm used to digest the message
    pub hashAlg: TPM_ALG_ID,

    /// The key derivation function
    pub kdf: TPM_ALG_ID,
}

impl TPMS_SCHEME_XOR {
    /// Creates a new instance with the specified values
    pub fn new(
        hashAlg: TPM_ALG_ID,
        kdf: TPM_ALG_ID,
        ) -> Self {
        Self {
            hashAlg,
            kdf,
        }
    }

    fn GetUnionSelector() -> Option<TPM_ALG_ID> {
        Some(TPM_ALG_ID::XOR)
    }
}

impl TpmStructure for TPMS_SCHEME_XOR {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMS_SCHEME_XOR>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeShort(self.hashAlg);
        buf.writeShort(self.kdf);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.hashAlg = buf.readShort();
        self.kdf = buf.readShort();
        Ok(())
    }

}

/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TPMU_SCHEME_KEYEDHASH
#[derive(Debug, Default)]
pub struct TPMS_NULL_SCHEME_KEYEDHASH {
}

impl TPMS_NULL_SCHEME_KEYEDHASH {
    fn GetUnionSelector() -> Option<TPM_ALG_ID> {
        Some(TPM_ALG_ID::NULL)
    }
}

impl TpmStructure for TPMS_NULL_SCHEME_KEYEDHASH {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMS_NULL_SCHEME_KEYEDHASH>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        Ok(())
    }

}

/// This structure is used for a hash signing object.
#[derive(Debug, Default)]
pub struct TPMT_KEYEDHASH_SCHEME {
    /// Selects the scheme

    /// The scheme parameters
    /// One of: TPMS_SCHEME_HMAC, TPMS_SCHEME_XOR, TPMS_NULL_SCHEME_KEYEDHASH.
    pub details: Option<TPMU_SCHEME_KEYEDHASH>,
}

impl TPMT_KEYEDHASH_SCHEME {
    /// Creates a new instance with the specified values
    pub fn new(
        details: Option<TPMU_SCHEME_KEYEDHASH>,
        ) -> Self {
        Self {
            details,
        }
    }

}

impl TpmStructure for TPMT_KEYEDHASH_SCHEME {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMT_KEYEDHASH_SCHEME>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        if (self.details.is_none()) { return Ok(()) };
        buf.writeShort(self.details.unwrap().GetUnionSelector().unwrap());
        self.details.unwrap().toTpm(buf);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        let r#scheme: TPM_ALG_ID = buf.readShort();
        self.details = TPMU_SCHEME_KEYEDHASH::create(r#scheme)?;
        self.details.unwrap().initFromTpm(buf);
        Ok(())
    }

}

/// These are the RSA schemes that only need a hash algorithm as a scheme parameter.
#[derive(Debug, Default)]
pub struct TPMS_SIG_SCHEME_RSASSA {
}

impl TPMS_SIG_SCHEME_RSASSA {
    fn GetUnionSelector() -> Option<TPM_ALG_ID> {
        Some(TPM_ALG_ID::RSASSA)
    }
}

impl TpmStructure for TPMS_SIG_SCHEME_RSASSA {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMS_SIG_SCHEME_RSASSA>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        Ok(())
    }

}

/// These are the RSA schemes that only need a hash algorithm as a scheme parameter.
#[derive(Debug, Default)]
pub struct TPMS_SIG_SCHEME_RSAPSS {
}

impl TPMS_SIG_SCHEME_RSAPSS {
    fn GetUnionSelector() -> Option<TPM_ALG_ID> {
        Some(TPM_ALG_ID::RSAPSS)
    }
}

impl TpmStructure for TPMS_SIG_SCHEME_RSAPSS {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMS_SIG_SCHEME_RSAPSS>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        Ok(())
    }

}

/// Most of the ECC signature schemes only require a hash algorithm to complete the
/// definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a
/// count value so they are typed to be TPMS_SCHEME_ECDAA.
#[derive(Debug, Default)]
pub struct TPMS_SIG_SCHEME_ECDSA {
}

impl TPMS_SIG_SCHEME_ECDSA {
    fn GetUnionSelector() -> Option<TPM_ALG_ID> {
        Some(TPM_ALG_ID::ECDSA)
    }
}

impl TpmStructure for TPMS_SIG_SCHEME_ECDSA {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMS_SIG_SCHEME_ECDSA>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        Ok(())
    }

}

/// Most of the ECC signature schemes only require a hash algorithm to complete the
/// definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a
/// count value so they are typed to be TPMS_SCHEME_ECDAA.
#[derive(Debug, Default)]
pub struct TPMS_SIG_SCHEME_SM2 {
}

impl TPMS_SIG_SCHEME_SM2 {
    fn GetUnionSelector() -> Option<TPM_ALG_ID> {
        Some(TPM_ALG_ID::SM2)
    }
}

impl TpmStructure for TPMS_SIG_SCHEME_SM2 {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMS_SIG_SCHEME_SM2>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        Ok(())
    }

}

/// Most of the ECC signature schemes only require a hash algorithm to complete the
/// definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a
/// count value so they are typed to be TPMS_SCHEME_ECDAA.
#[derive(Debug, Default)]
pub struct TPMS_SIG_SCHEME_ECSCHNORR {
}

impl TPMS_SIG_SCHEME_ECSCHNORR {
    fn GetUnionSelector() -> Option<TPM_ALG_ID> {
        Some(TPM_ALG_ID::ECSCHNORR)
    }
}

impl TpmStructure for TPMS_SIG_SCHEME_ECSCHNORR {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMS_SIG_SCHEME_ECSCHNORR>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        Ok(())
    }

}

/// Most of the ECC signature schemes only require a hash algorithm to complete the
/// definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a
/// count value so they are typed to be TPMS_SCHEME_ECDAA.
#[derive(Debug, Default)]
pub struct TPMS_SIG_SCHEME_ECDAA {
}

impl TPMS_SIG_SCHEME_ECDAA {
    fn GetUnionSelector() -> Option<TPM_ALG_ID> {
        Some(TPM_ALG_ID::ECDAA)
    }
}

impl TpmStructure for TPMS_SIG_SCHEME_ECDAA {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMS_SIG_SCHEME_ECDAA>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        Ok(())
    }

}

/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TPMU_SIG_SCHEME
#[derive(Debug, Default)]
pub struct TPMS_NULL_SIG_SCHEME {
}

impl TPMS_NULL_SIG_SCHEME {
    fn GetUnionSelector() -> Option<TPM_ALG_ID> {
        Some(TPM_ALG_ID::NULL)
    }
}

impl TpmStructure for TPMS_NULL_SIG_SCHEME {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMS_NULL_SIG_SCHEME>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        Ok(())
    }

}

/// Table 162 Definition of TPMT_SIG_SCHEME Structure
#[derive(Debug, Default)]
pub struct TPMT_SIG_SCHEME {
    /// Scheme selector

    /// Scheme parameters
    /// One of: TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA,
    /// TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR,
    /// TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME.
    pub details: Option<TPMU_SIG_SCHEME>,
}

impl TPMT_SIG_SCHEME {
    /// Creates a new instance with the specified values
    pub fn new(
        details: Option<TPMU_SIG_SCHEME>,
        ) -> Self {
        Self {
            details,
        }
    }

}

impl TpmStructure for TPMT_SIG_SCHEME {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMT_SIG_SCHEME>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        if (self.details.is_none()) { return Ok(()) };
        buf.writeShort(self.details.unwrap().GetUnionSelector().unwrap());
        self.details.unwrap().toTpm(buf);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        let r#scheme: TPM_ALG_ID = buf.readShort();
        self.details = TPMU_SIG_SCHEME::create(r#scheme)?;
        self.details.unwrap().initFromTpm(buf);
        Ok(())
    }

}

/// These are the RSA encryption schemes that only need a hash algorithm as a controlling parameter.
#[derive(Debug, Default)]
pub struct TPMS_ENC_SCHEME_OAEP {
}

impl TPMS_ENC_SCHEME_OAEP {
    fn GetUnionSelector() -> Option<TPM_ALG_ID> {
        Some(TPM_ALG_ID::OAEP)
    }
}

impl TpmStructure for TPMS_ENC_SCHEME_OAEP {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMS_ENC_SCHEME_OAEP>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        Ok(())
    }

}

/// These are the RSA encryption schemes that only need a hash algorithm as a controlling parameter.
#[derive(Debug, Default)]
pub struct TPMS_ENC_SCHEME_RSAES {
}

impl TPMS_ENC_SCHEME_RSAES {
    fn GetUnionSelector() -> Option<TPM_ALG_ID> {
        Some(TPM_ALG_ID::RSAES)
    }
}

impl TpmStructure for TPMS_ENC_SCHEME_RSAES {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMS_ENC_SCHEME_RSAES>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        Ok(())
    }

}

/// These are the ECC schemes that only need a hash algorithm as a controlling parameter.
#[derive(Debug, Default)]
pub struct TPMS_KEY_SCHEME_ECDH {
}

impl TPMS_KEY_SCHEME_ECDH {
    fn GetUnionSelector() -> Option<TPM_ALG_ID> {
        Some(TPM_ALG_ID::ECDH)
    }
}

impl TpmStructure for TPMS_KEY_SCHEME_ECDH {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMS_KEY_SCHEME_ECDH>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        Ok(())
    }

}

/// These are the ECC schemes that only need a hash algorithm as a controlling parameter.
#[derive(Debug, Default)]
pub struct TPMS_KEY_SCHEME_ECMQV {
}

impl TPMS_KEY_SCHEME_ECMQV {
    fn GetUnionSelector() -> Option<TPM_ALG_ID> {
        Some(TPM_ALG_ID::ECMQV)
    }
}

impl TpmStructure for TPMS_KEY_SCHEME_ECMQV {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMS_KEY_SCHEME_ECMQV>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        Ok(())
    }

}

/// These structures are used to define the key derivation for symmetric secret sharing
/// using asymmetric methods. A secret sharing scheme is required in any asymmetric key
/// with the decrypt attribute SET.
#[derive(Debug, Default)]
pub struct TPMS_KDF_SCHEME_MGF1 {
}

impl TPMS_KDF_SCHEME_MGF1 {
    fn GetUnionSelector() -> Option<TPM_ALG_ID> {
        Some(TPM_ALG_ID::MGF1)
    }
}

impl TpmStructure for TPMS_KDF_SCHEME_MGF1 {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMS_KDF_SCHEME_MGF1>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        Ok(())
    }

}

/// These structures are used to define the key derivation for symmetric secret sharing
/// using asymmetric methods. A secret sharing scheme is required in any asymmetric key
/// with the decrypt attribute SET.
#[derive(Debug, Default)]
pub struct TPMS_KDF_SCHEME_KDF1_SP800_56A {
}

impl TPMS_KDF_SCHEME_KDF1_SP800_56A {
    fn GetUnionSelector() -> Option<TPM_ALG_ID> {
        Some(TPM_ALG_ID::KDF1_SP800_56A)
    }
}

impl TpmStructure for TPMS_KDF_SCHEME_KDF1_SP800_56A {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMS_KDF_SCHEME_KDF1_SP800_56A>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        Ok(())
    }

}

/// These structures are used to define the key derivation for symmetric secret sharing
/// using asymmetric methods. A secret sharing scheme is required in any asymmetric key
/// with the decrypt attribute SET.
#[derive(Debug, Default)]
pub struct TPMS_KDF_SCHEME_KDF2 {
}

impl TPMS_KDF_SCHEME_KDF2 {
    fn GetUnionSelector() -> Option<TPM_ALG_ID> {
        Some(TPM_ALG_ID::KDF2)
    }
}

impl TpmStructure for TPMS_KDF_SCHEME_KDF2 {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMS_KDF_SCHEME_KDF2>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        Ok(())
    }

}

/// These structures are used to define the key derivation for symmetric secret sharing
/// using asymmetric methods. A secret sharing scheme is required in any asymmetric key
/// with the decrypt attribute SET.
#[derive(Debug, Default)]
pub struct TPMS_KDF_SCHEME_KDF1_SP800_108 {
}

impl TPMS_KDF_SCHEME_KDF1_SP800_108 {
    fn GetUnionSelector() -> Option<TPM_ALG_ID> {
        Some(TPM_ALG_ID::KDF1_SP800_108)
    }
}

impl TpmStructure for TPMS_KDF_SCHEME_KDF1_SP800_108 {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMS_KDF_SCHEME_KDF1_SP800_108>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        Ok(())
    }

}

/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TPMU_KDF_SCHEME
#[derive(Debug, Default)]
pub struct TPMS_NULL_KDF_SCHEME {
}

impl TPMS_NULL_KDF_SCHEME {
    fn GetUnionSelector() -> Option<TPM_ALG_ID> {
        Some(TPM_ALG_ID::NULL)
    }
}

impl TpmStructure for TPMS_NULL_KDF_SCHEME {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMS_NULL_KDF_SCHEME>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        Ok(())
    }

}

/// Table 167 Definition of TPMT_KDF_SCHEME Structure
#[derive(Debug, Default)]
pub struct TPMT_KDF_SCHEME {
    /// Scheme selector

    /// Scheme parameters
    /// One of: TPMS_KDF_SCHEME_MGF1, TPMS_KDF_SCHEME_KDF1_SP800_56A, TPMS_KDF_SCHEME_KDF2,
    /// TPMS_KDF_SCHEME_KDF1_SP800_108, TPMS_SCHEME_HASH, TPMS_NULL_KDF_SCHEME.
    pub details: Option<TPMU_KDF_SCHEME>,
}

impl TPMT_KDF_SCHEME {
    /// Creates a new instance with the specified values
    pub fn new(
        details: Option<TPMU_KDF_SCHEME>,
        ) -> Self {
        Self {
            details,
        }
    }

}

impl TpmStructure for TPMT_KDF_SCHEME {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMT_KDF_SCHEME>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        if (self.details.is_none()) { return Ok(()) };
        buf.writeShort(self.details.unwrap().GetUnionSelector().unwrap());
        self.details.unwrap().toTpm(buf);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        let r#scheme: TPM_ALG_ID = buf.readShort();
        self.details = TPMU_KDF_SCHEME::create(r#scheme)?;
        self.details.unwrap().initFromTpm(buf);
        Ok(())
    }

}

/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TPMU_ASYM_SCHEME
#[derive(Debug, Default)]
pub struct TPMS_NULL_ASYM_SCHEME {
}

impl TPMS_NULL_ASYM_SCHEME {
    fn GetUnionSelector() -> Option<TPM_ALG_ID> {
        Some(TPM_ALG_ID::NULL)
    }
}

impl TpmStructure for TPMS_NULL_ASYM_SCHEME {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMS_NULL_ASYM_SCHEME>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        Ok(())
    }

}

/// This structure is defined to allow overlay of all of the schemes for any asymmetric
/// object. This structure is not sent on the interface. It is defined so that common
/// functions may operate on any similar scheme structure.
#[derive(Debug, Default)]
pub struct TPMT_ASYM_SCHEME {
    /// Scheme selector

    /// Scheme parameters
    /// One of: TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA,
    /// TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA,
    /// TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES,
    /// TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME.
    pub details: Option<TPMU_ASYM_SCHEME>,
}

impl TPMT_ASYM_SCHEME {
    /// Creates a new instance with the specified values
    pub fn new(
        details: Option<TPMU_ASYM_SCHEME>,
        ) -> Self {
        Self {
            details,
        }
    }

}

impl TpmStructure for TPMT_ASYM_SCHEME {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMT_ASYM_SCHEME>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        if (self.details.is_none()) { return Ok(()) };
        buf.writeShort(self.details.unwrap().GetUnionSelector().unwrap());
        self.details.unwrap().toTpm(buf);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        let r#scheme: TPM_ALG_ID = buf.readShort();
        self.details = TPMU_ASYM_SCHEME::create(r#scheme)?;
        self.details.unwrap().initFromTpm(buf);
        Ok(())
    }

}

/// Table 172 Definition of {RSA} TPMT_RSA_SCHEME Structure
#[derive(Debug, Default)]
pub struct TPMT_RSA_SCHEME {
    /// Scheme selector

    /// Scheme parameters
    /// One of: TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA,
    /// TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA,
    /// TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES,
    /// TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME.
    pub details: Option<TPMU_ASYM_SCHEME>,
}

impl TPMT_RSA_SCHEME {
    /// Creates a new instance with the specified values
    pub fn new(
        details: Option<TPMU_ASYM_SCHEME>,
        ) -> Self {
        Self {
            details,
        }
    }

}

impl TpmStructure for TPMT_RSA_SCHEME {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMT_RSA_SCHEME>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        if (self.details.is_none()) { return Ok(()) };
        buf.writeShort(self.details.unwrap().GetUnionSelector().unwrap());
        self.details.unwrap().toTpm(buf);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        let r#scheme: TPM_ALG_ID = buf.readShort();
        self.details = TPMU_ASYM_SCHEME::create(r#scheme)?;
        self.details.unwrap().initFromTpm(buf);
        Ok(())
    }

}

/// Table 174 Definition of {RSA} TPMT_RSA_DECRYPT Structure
#[derive(Debug, Default)]
pub struct TPMT_RSA_DECRYPT {
    /// Scheme selector

    /// Scheme parameters
    /// One of: TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA,
    /// TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA,
    /// TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES,
    /// TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME.
    pub details: Option<TPMU_ASYM_SCHEME>,
}

impl TPMT_RSA_DECRYPT {
    /// Creates a new instance with the specified values
    pub fn new(
        details: Option<TPMU_ASYM_SCHEME>,
        ) -> Self {
        Self {
            details,
        }
    }

}

impl TpmStructure for TPMT_RSA_DECRYPT {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMT_RSA_DECRYPT>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        if (self.details.is_none()) { return Ok(()) };
        buf.writeShort(self.details.unwrap().GetUnionSelector().unwrap());
        self.details.unwrap().toTpm(buf);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        let r#scheme: TPM_ALG_ID = buf.readShort();
        self.details = TPMU_ASYM_SCHEME::create(r#scheme)?;
        self.details.unwrap().initFromTpm(buf);
        Ok(())
    }

}

/// This sized buffer holds the largest RSA public key supported by the TPM.
#[derive(Debug, Default)]
pub struct TPM2B_PUBLIC_KEY_RSA {
    /// Value
    pub buffer: Vec<u8>,
}

impl TPM2B_PUBLIC_KEY_RSA {
    /// Creates a new instance with the specified values
    pub fn new(
        buffer: Vec<u8>,
        ) -> Self {
        Self {
            buffer,
        }
    }

    fn GetUnionSelector() -> Option<TPM_ALG_ID> {
        Some(TPM_ALG_ID::RSA)
    }
}

impl TpmStructure for TPM2B_PUBLIC_KEY_RSA {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2B_PUBLIC_KEY_RSA>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.buffer);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.buffer = buf.readSizedByteBuf();
        Ok(())
    }

}

/// This sized buffer holds the largest RSA prime number supported by the TPM.
#[derive(Debug, Default)]
pub struct TPM2B_PRIVATE_KEY_RSA {
    pub buffer: Vec<u8>,
}

impl TPM2B_PRIVATE_KEY_RSA {
    /// Creates a new instance with the specified values
    pub fn new(
        buffer: Vec<u8>,
        ) -> Self {
        Self {
            buffer,
        }
    }

    fn GetUnionSelector() -> Option<TPM_ALG_ID> {
        Some(TPM_ALG_ID::RSA)
    }
}

impl TpmStructure for TPM2B_PRIVATE_KEY_RSA {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2B_PRIVATE_KEY_RSA>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.buffer);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.buffer = buf.readSizedByteBuf();
        Ok(())
    }

}

/// This sized buffer holds the largest ECC parameter (coordinate) supported by the TPM.
#[derive(Debug, Default)]
pub struct TPM2B_ECC_PARAMETER {
    /// The parameter data
    pub buffer: Vec<u8>,
}

impl TPM2B_ECC_PARAMETER {
    /// Creates a new instance with the specified values
    pub fn new(
        buffer: Vec<u8>,
        ) -> Self {
        Self {
            buffer,
        }
    }

    fn GetUnionSelector() -> Option<TPM_ALG_ID> {
        Some(TPM_ALG_ID::ECC)
    }
}

impl TpmStructure for TPM2B_ECC_PARAMETER {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2B_ECC_PARAMETER>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.buffer);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.buffer = buf.readSizedByteBuf();
        Ok(())
    }

}

/// This structure holds two ECC coordinates that, together, make up an ECC point.
#[derive(Debug, Default)]
pub struct TPMS_ECC_POINT {
    /// X coordinate
    pub x: Vec<u8>,

    /// Y coordinate
    pub y: Vec<u8>,
}

impl TPMS_ECC_POINT {
    /// Creates a new instance with the specified values
    pub fn new(
        x: Vec<u8>,
        y: Vec<u8>,
        ) -> Self {
        Self {
            x,
            y,
        }
    }

    fn GetUnionSelector() -> Option<TPM_ALG_ID> {
        Some(TPM_ALG_ID::ECC)
    }
}

impl TpmStructure for TPMS_ECC_POINT {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMS_ECC_POINT>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.x);
        buf.writeSizedByteBuf(self.y);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.x = buf.readSizedByteBuf();
        self.y = buf.readSizedByteBuf();
        Ok(())
    }

}

/// This structure is defined to allow a point to be a single sized parameter so that it
/// may be encrypted.
#[derive(Debug, Default)]
pub struct TPM2B_ECC_POINT {
    /// Coordinates
    pub point: TPMS_ECC_POINT,
}

impl TPM2B_ECC_POINT {
    /// Creates a new instance with the specified values
    pub fn new(
        point: TPMS_ECC_POINT,
        ) -> Self {
        Self {
            point,
        }
    }

}

impl TpmStructure for TPM2B_ECC_POINT {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2B_ECC_POINT>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedObj(self.point);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        buf.readSizedObj(self.point);
        Ok(())
    }

}

/// Table 183 Definition of (TPMT_SIG_SCHEME) {ECC} TPMT_ECC_SCHEME Structure
#[derive(Debug, Default)]
pub struct TPMT_ECC_SCHEME {
    /// Scheme selector

    /// Scheme parameters
    /// One of: TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA,
    /// TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA,
    /// TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES,
    /// TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME.
    pub details: Option<TPMU_ASYM_SCHEME>,
}

impl TPMT_ECC_SCHEME {
    /// Creates a new instance with the specified values
    pub fn new(
        details: Option<TPMU_ASYM_SCHEME>,
        ) -> Self {
        Self {
            details,
        }
    }

}

impl TpmStructure for TPMT_ECC_SCHEME {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMT_ECC_SCHEME>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        if (self.details.is_none()) { return Ok(()) };
        buf.writeShort(self.details.unwrap().GetUnionSelector().unwrap());
        self.details.unwrap().toTpm(buf);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        let r#scheme: TPM_ALG_ID = buf.readShort();
        self.details = TPMU_ASYM_SCHEME::create(r#scheme)?;
        self.details.unwrap().initFromTpm(buf);
        Ok(())
    }

}

/// This structure is used to report on the curve parameters of an ECC curve. It is
/// returned by TPM2_ECC_Parameters().
#[derive(Debug, Default)]
pub struct TPMS_ALGORITHM_DETAIL_ECC {
    /// Identifier for the curve
    pub curveID: TPM_ECC_CURVE,

    /// Size in bits of the key
    pub keySize: u16,

    /// Scheme selector

    /// If not TPM_ALG_NULL, the required KDF and hash algorithm used in secret sharing operations
    /// One of: TPMS_KDF_SCHEME_MGF1, TPMS_KDF_SCHEME_KDF1_SP800_56A, TPMS_KDF_SCHEME_KDF2,
    /// TPMS_KDF_SCHEME_KDF1_SP800_108, TPMS_SCHEME_HASH, TPMS_NULL_KDF_SCHEME.
    pub kdf: Option<TPMU_KDF_SCHEME>,

    /// Scheme selector

    /// If not TPM_ALG_NULL, this is the mandatory signature scheme that is required to be
    /// used with this curve.
    /// One of: TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA,
    /// TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA,
    /// TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES,
    /// TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME.
    pub sign: Option<TPMU_ASYM_SCHEME>,

    /// Fp (the modulus)
    pub p: Vec<u8>,

    /// Coefficient of the linear term in the curve equation
    pub a: Vec<u8>,

    /// Constant term for curve equation
    pub b: Vec<u8>,

    /// X coordinate of base point G
    pub gX: Vec<u8>,

    /// Y coordinate of base point G
    pub gY: Vec<u8>,

    /// Order of G
    pub n: Vec<u8>,

    /// Cofactor (a size of zero indicates a cofactor of 1)
    pub h: Vec<u8>,
}

impl TPMS_ALGORITHM_DETAIL_ECC {
    /// Creates a new instance with the specified values
    pub fn new(
        curveID: TPM_ECC_CURVE,
        keySize: u16,
        kdf: Option<TPMU_KDF_SCHEME>,
        sign: Option<TPMU_ASYM_SCHEME>,
        p: Vec<u8>,
        a: Vec<u8>,
        b: Vec<u8>,
        gX: Vec<u8>,
        gY: Vec<u8>,
        n: Vec<u8>,
        h: Vec<u8>,
        ) -> Self {
        Self {
            curveID,
            keySize,
            kdf,
            sign,
            p,
            a,
            b,
            gX,
            gY,
            n,
            h,
        }
    }

}

impl TpmStructure for TPMS_ALGORITHM_DETAIL_ECC {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMS_ALGORITHM_DETAIL_ECC>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeShort(self.curveID);
        buf.writeShort(self.keySize);
        buf.writeShort(self.kdf.unwrap().GetUnionSelector().unwrap());
        self.kdf.unwrap().toTpm(buf);
        buf.writeShort(self.sign.unwrap().GetUnionSelector().unwrap());
        self.sign.unwrap().toTpm(buf);
        buf.writeSizedByteBuf(self.p);
        buf.writeSizedByteBuf(self.a);
        buf.writeSizedByteBuf(self.b);
        buf.writeSizedByteBuf(self.gX);
        buf.writeSizedByteBuf(self.gY);
        buf.writeSizedByteBuf(self.n);
        buf.writeSizedByteBuf(self.h);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.curveID = buf.readShort();
        self.keySize = buf.readShort();
        let r#kdfScheme: TPM_ALG_ID = buf.readShort();
        self.kdf = TPMU_KDF_SCHEME::create(r#kdfScheme)?;
        self.kdf.unwrap().initFromTpm(buf);
        let r#signScheme: TPM_ALG_ID = buf.readShort();
        self.sign = TPMU_ASYM_SCHEME::create(r#signScheme)?;
        self.sign.unwrap().initFromTpm(buf);
        self.p = buf.readSizedByteBuf();
        self.a = buf.readSizedByteBuf();
        self.b = buf.readSizedByteBuf();
        self.gX = buf.readSizedByteBuf();
        self.gY = buf.readSizedByteBuf();
        self.n = buf.readSizedByteBuf();
        self.h = buf.readSizedByteBuf();
        Ok(())
    }

}

/// Table 185 Definition of {RSA} TPMS_SIGNATURE_RSA Structure
#[derive(Debug, Default)]
pub struct TPMS_SIGNATURE_RSA {
    /// The hash algorithm used to digest the message
    /// TPM_ALG_NULL is not allowed.
    pub hash: TPM_ALG_ID,

    /// The signature is the size of a public key.
    pub sig: Vec<u8>,
}

impl TPMS_SIGNATURE_RSA {
    /// Creates a new instance with the specified values
    pub fn new(
        hash: TPM_ALG_ID,
        sig: Vec<u8>,
        ) -> Self {
        Self {
            hash,
            sig,
        }
    }

    fn GetUnionSelector() -> Option<TPM_ALG_ID> {
        Some(TPM_ALG_ID::RSASSA)
    }
}

impl TpmStructure for TPMS_SIGNATURE_RSA {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMS_SIGNATURE_RSA>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeShort(self.hash);
        buf.writeSizedByteBuf(self.sig);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.hash = buf.readShort();
        self.sig = buf.readSizedByteBuf();
        Ok(())
    }

}

/// Table 185 Definition of {RSA} TPMS_SIGNATURE_RSA Structure
#[derive(Debug, Default)]
pub struct TPMS_SIGNATURE_RSASSA {
}

impl TPMS_SIGNATURE_RSASSA {
    fn GetUnionSelector() -> Option<TPM_ALG_ID> {
        Some(TPM_ALG_ID::RSASSA)
    }
}

impl TpmStructure for TPMS_SIGNATURE_RSASSA {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMS_SIGNATURE_RSASSA>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        Ok(())
    }

}

/// Table 185 Definition of {RSA} TPMS_SIGNATURE_RSA Structure
#[derive(Debug, Default)]
pub struct TPMS_SIGNATURE_RSAPSS {
}

impl TPMS_SIGNATURE_RSAPSS {
    fn GetUnionSelector() -> Option<TPM_ALG_ID> {
        Some(TPM_ALG_ID::RSAPSS)
    }
}

impl TpmStructure for TPMS_SIGNATURE_RSAPSS {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMS_SIGNATURE_RSAPSS>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        Ok(())
    }

}

/// Table 187 Definition of {ECC} TPMS_SIGNATURE_ECC Structure
#[derive(Debug, Default)]
pub struct TPMS_SIGNATURE_ECC {
    /// The hash algorithm used in the signature process
    /// TPM_ALG_NULL is not allowed.
    pub hash: TPM_ALG_ID,
    pub signatureR: Vec<u8>,
    pub signatureS: Vec<u8>,
}

impl TPMS_SIGNATURE_ECC {
    /// Creates a new instance with the specified values
    pub fn new(
        hash: TPM_ALG_ID,
        signatureR: Vec<u8>,
        signatureS: Vec<u8>,
        ) -> Self {
        Self {
            hash,
            signatureR,
            signatureS,
        }
    }

    fn GetUnionSelector() -> Option<TPM_ALG_ID> {
        Some(TPM_ALG_ID::ECDSA)
    }
}

impl TpmStructure for TPMS_SIGNATURE_ECC {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMS_SIGNATURE_ECC>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeShort(self.hash);
        buf.writeSizedByteBuf(self.signatureR);
        buf.writeSizedByteBuf(self.signatureS);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.hash = buf.readShort();
        self.signatureR = buf.readSizedByteBuf();
        self.signatureS = buf.readSizedByteBuf();
        Ok(())
    }

}

/// Table 187 Definition of {ECC} TPMS_SIGNATURE_ECC Structure
#[derive(Debug, Default)]
pub struct TPMS_SIGNATURE_ECDSA {
}

impl TPMS_SIGNATURE_ECDSA {
    fn GetUnionSelector() -> Option<TPM_ALG_ID> {
        Some(TPM_ALG_ID::ECDSA)
    }
}

impl TpmStructure for TPMS_SIGNATURE_ECDSA {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMS_SIGNATURE_ECDSA>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        Ok(())
    }

}

/// Table 187 Definition of {ECC} TPMS_SIGNATURE_ECC Structure
#[derive(Debug, Default)]
pub struct TPMS_SIGNATURE_ECDAA {
}

impl TPMS_SIGNATURE_ECDAA {
    fn GetUnionSelector() -> Option<TPM_ALG_ID> {
        Some(TPM_ALG_ID::ECDAA)
    }
}

impl TpmStructure for TPMS_SIGNATURE_ECDAA {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMS_SIGNATURE_ECDAA>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        Ok(())
    }

}

/// Table 187 Definition of {ECC} TPMS_SIGNATURE_ECC Structure
#[derive(Debug, Default)]
pub struct TPMS_SIGNATURE_SM2 {
}

impl TPMS_SIGNATURE_SM2 {
    fn GetUnionSelector() -> Option<TPM_ALG_ID> {
        Some(TPM_ALG_ID::SM2)
    }
}

impl TpmStructure for TPMS_SIGNATURE_SM2 {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMS_SIGNATURE_SM2>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        Ok(())
    }

}

/// Table 187 Definition of {ECC} TPMS_SIGNATURE_ECC Structure
#[derive(Debug, Default)]
pub struct TPMS_SIGNATURE_ECSCHNORR {
}

impl TPMS_SIGNATURE_ECSCHNORR {
    fn GetUnionSelector() -> Option<TPM_ALG_ID> {
        Some(TPM_ALG_ID::ECSCHNORR)
    }
}

impl TpmStructure for TPMS_SIGNATURE_ECSCHNORR {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMS_SIGNATURE_ECSCHNORR>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        Ok(())
    }

}

/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TPMU_SIGNATURE
#[derive(Debug, Default)]
pub struct TPMS_NULL_SIGNATURE {
}

impl TPMS_NULL_SIGNATURE {
    fn GetUnionSelector() -> Option<TPM_ALG_ID> {
        Some(TPM_ALG_ID::NULL)
    }
}

impl TpmStructure for TPMS_NULL_SIGNATURE {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMS_NULL_SIGNATURE>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        Ok(())
    }

}

/// Table 190 shows the basic algorithm-agile structure when a symmetric or asymmetric
/// signature is indicated. The sigAlg parameter indicates the algorithm used for the
/// signature. This structure is output from commands such as the attestation commands and
/// TPM2_Sign, and is an input to commands such as TPM2_VerifySignature(),
/// TPM2_PolicySigned(), and TPM2_FieldUpgradeStart().
#[derive(Debug, Default)]
pub struct TPMT_SIGNATURE {
    /// Selector of the algorithm used to construct the signature

    /// This shall be the actual signature information.
    /// One of: TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA,
    /// TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TPMT_HA,
    /// TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE.
    pub signature: Option<TPMU_SIGNATURE>,
}

impl TPMT_SIGNATURE {
    /// Creates a new instance with the specified values
    pub fn new(
        signature: Option<TPMU_SIGNATURE>,
        ) -> Self {
        Self {
            signature,
        }
    }

}

impl TpmStructure for TPMT_SIGNATURE {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMT_SIGNATURE>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        if (self.signature.is_none()) { return Ok(()) };
        buf.writeShort(self.signature.unwrap().GetUnionSelector().unwrap());
        self.signature.unwrap().toTpm(buf);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        let r#sigAlg: TPM_ALG_ID = buf.readShort();
        self.signature = TPMU_SIGNATURE::create(r#sigAlg)?;
        self.signature.unwrap().initFromTpm(buf);
        Ok(())
    }

}

/// Table 192 Definition of TPM2B_ENCRYPTED_SECRET Structure
#[derive(Debug, Default)]
pub struct TPM2B_ENCRYPTED_SECRET {
    /// Secret
    pub secret: Vec<u8>,
}

impl TPM2B_ENCRYPTED_SECRET {
    /// Creates a new instance with the specified values
    pub fn new(
        secret: Vec<u8>,
        ) -> Self {
        Self {
            secret,
        }
    }

}

impl TpmStructure for TPM2B_ENCRYPTED_SECRET {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2B_ENCRYPTED_SECRET>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.secret);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.secret = buf.readSizedByteBuf();
        Ok(())
    }

}

/// This structure describes the parameters that would appear in the public area of a
/// KEYEDHASH object.
#[derive(Debug, Default)]
pub struct TPMS_KEYEDHASH_PARMS {
    /// Selects the scheme

    /// Indicates the signing method used for a keyedHash signing object. This field also
    /// determines the size of the data field for a data object created with TPM2_Create() or
    /// TPM2_CreatePrimary().
    /// One of: TPMS_SCHEME_HMAC, TPMS_SCHEME_XOR, TPMS_NULL_SCHEME_KEYEDHASH.
    pub scheme: Option<TPMU_SCHEME_KEYEDHASH>,
}

impl TPMS_KEYEDHASH_PARMS {
    /// Creates a new instance with the specified values
    pub fn new(
        scheme: Option<TPMU_SCHEME_KEYEDHASH>,
        ) -> Self {
        Self {
            scheme,
        }
    }

    fn GetUnionSelector() -> Option<TPM_ALG_ID> {
        Some(TPM_ALG_ID::KEYEDHASH)
    }
}

impl TpmStructure for TPMS_KEYEDHASH_PARMS {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMS_KEYEDHASH_PARMS>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        if (self.scheme.is_none()) { return Ok(()) };
        buf.writeShort(self.scheme.unwrap().GetUnionSelector().unwrap());
        self.scheme.unwrap().toTpm(buf);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        let r#schemeScheme: TPM_ALG_ID = buf.readShort();
        self.scheme = TPMU_SCHEME_KEYEDHASH::create(r#schemeScheme)?;
        self.scheme.unwrap().initFromTpm(buf);
        Ok(())
    }

}

/// This structure contains the common public area parameters for an asymmetric key. The
/// first two parameters of the parameter definition structures of an asymmetric key shall
/// have the same two first components.
#[derive(Debug, Default)]
pub struct TPMS_ASYM_PARMS {
    /// The companion symmetric algorithm for a restricted decryption key and shall be set to
    /// a supported symmetric algorithm
    /// This field is optional for keys that are not decryption keys and shall be set to
    /// TPM_ALG_NULL if not used.
    pub symmetric: TPMT_SYM_DEF_OBJECT,

    /// Scheme selector

    /// For a key with the sign attribute SET, a valid signing scheme for the key type
    /// for a key with the decrypt attribute SET, a valid key exchange protocol
    /// for a key with sign and decrypt attributes, shall be TPM_ALG_NULL
    /// One of: TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA,
    /// TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA,
    /// TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES,
    /// TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME.
    pub scheme: Option<TPMU_ASYM_SCHEME>,
}

impl TPMS_ASYM_PARMS {
    /// Creates a new instance with the specified values
    pub fn new(
        symmetric: TPMT_SYM_DEF_OBJECT,
        scheme: Option<TPMU_ASYM_SCHEME>,
        ) -> Self {
        Self {
            symmetric,
            scheme,
        }
    }

    fn GetUnionSelector() -> Option<TPM_ALG_ID> {
        Some(TPM_ALG_ID::ANY)
    }
}

impl TpmStructure for TPMS_ASYM_PARMS {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMS_ASYM_PARMS>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.symmetric.toTpm(buf);
        buf.writeShort(self.scheme.unwrap().GetUnionSelector().unwrap());
        self.scheme.unwrap().toTpm(buf);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.symmetric.initFromTpm(buf);
        let r#schemeScheme: TPM_ALG_ID = buf.readShort();
        self.scheme = TPMU_ASYM_SCHEME::create(r#schemeScheme)?;
        self.scheme.unwrap().initFromTpm(buf);
        Ok(())
    }

}

/// A TPM compatible with this specification and supporting RSA shall support two primes
/// and an exponent of zero. An exponent of zero indicates that the exponent is the
/// default of 216 + 1. Support for other values is optional. Use of other exponents in
/// duplicated keys is not recommended because the resulting keys would not be
/// interoperable with other TPMs.
#[derive(Debug, Default)]
pub struct TPMS_RSA_PARMS {
    /// For a restricted decryption key, shall be set to a supported symmetric algorithm, key
    /// size, and mode.
    /// if the key is not a restricted decryption key, this field shall be set to TPM_ALG_NULL.
    pub symmetric: TPMT_SYM_DEF_OBJECT,

    /// Scheme selector

    /// Scheme.scheme shall be:
    /// for an unrestricted signing key, either TPM_ALG_RSAPSS TPM_ALG_RSASSA or TPM_ALG_NULL
    /// for a restricted signing key, either TPM_ALG_RSAPSS or TPM_ALG_RSASSA
    /// for an unrestricted decryption key, TPM_ALG_RSAES, TPM_ALG_OAEP, or TPM_ALG_NULL
    /// unless the object also has the sign attribute
    /// for a restricted decryption key, TPM_ALG_NULL
    /// NOTE When both sign and decrypt are SET, restricted shall be CLEAR and scheme shall be
    /// TPM_ALG_NULL.
    /// One of: TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA,
    /// TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA,
    /// TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES,
    /// TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME.
    pub scheme: Option<TPMU_ASYM_SCHEME>,

    /// Number of bits in the public modulus
    pub keyBits: u16,

    /// The public exponent
    /// A prime number greater than 2.
    pub exponent: u32,
}

impl TPMS_RSA_PARMS {
    /// Creates a new instance with the specified values
    pub fn new(
        symmetric: TPMT_SYM_DEF_OBJECT,
        scheme: Option<TPMU_ASYM_SCHEME>,
        keyBits: u16,
        exponent: u32,
        ) -> Self {
        Self {
            symmetric,
            scheme,
            keyBits,
            exponent,
        }
    }

    fn GetUnionSelector() -> Option<TPM_ALG_ID> {
        Some(TPM_ALG_ID::RSA)
    }
}

impl TpmStructure for TPMS_RSA_PARMS {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMS_RSA_PARMS>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.symmetric.toTpm(buf);
        buf.writeShort(self.scheme.unwrap().GetUnionSelector().unwrap());
        self.scheme.unwrap().toTpm(buf);
        buf.writeShort(self.keyBits);
        buf.writeInt(self.exponent);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.symmetric.initFromTpm(buf);
        let r#schemeScheme: TPM_ALG_ID = buf.readShort();
        self.scheme = TPMU_ASYM_SCHEME::create(r#schemeScheme)?;
        self.scheme.unwrap().initFromTpm(buf);
        self.keyBits = buf.readShort();
        self.exponent = buf.readInt();
        Ok(())
    }

}

/// This structure contains the parameters for prime modulus ECC.
#[derive(Debug, Default)]
pub struct TPMS_ECC_PARMS {
    /// For a restricted decryption key, shall be set to a supported symmetric algorithm, key
    /// size. and mode.
    /// if the key is not a restricted decryption key, this field shall be set to TPM_ALG_NULL.
    pub symmetric: TPMT_SYM_DEF_OBJECT,

    /// Scheme selector

    /// If the sign attribute of the key is SET, then this shall be a valid signing scheme.
    /// NOTE If the sign parameter in curveID indicates a mandatory scheme, then this field
    /// shall have the same value.
    /// If the decrypt attribute of the key is SET, then this shall be a valid key exchange
    /// scheme or TPM_ALG_NULL.
    /// If the key is a Storage Key, then this field shall be TPM_ALG_NULL.
    /// One of: TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA,
    /// TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA,
    /// TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES,
    /// TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME.
    pub scheme: Option<TPMU_ASYM_SCHEME>,

    /// ECC curve ID
    pub curveID: TPM_ECC_CURVE,

    /// Scheme selector

    /// An optional key derivation scheme for generating a symmetric key from a Z value
    /// If the kdf parameter associated with curveID is not TPM_ALG_NULL then this is required
    /// to be NULL.
    /// NOTE There are currently no commands where this parameter has effect and, in the
    /// reference code, this field needs to be set to TPM_ALG_NULL.
    /// One of: TPMS_KDF_SCHEME_MGF1, TPMS_KDF_SCHEME_KDF1_SP800_56A, TPMS_KDF_SCHEME_KDF2,
    /// TPMS_KDF_SCHEME_KDF1_SP800_108, TPMS_SCHEME_HASH, TPMS_NULL_KDF_SCHEME.
    pub kdf: Option<TPMU_KDF_SCHEME>,
}

impl TPMS_ECC_PARMS {
    /// Creates a new instance with the specified values
    pub fn new(
        symmetric: TPMT_SYM_DEF_OBJECT,
        scheme: Option<TPMU_ASYM_SCHEME>,
        curveID: TPM_ECC_CURVE,
        kdf: Option<TPMU_KDF_SCHEME>,
        ) -> Self {
        Self {
            symmetric,
            scheme,
            curveID,
            kdf,
        }
    }

    fn GetUnionSelector() -> Option<TPM_ALG_ID> {
        Some(TPM_ALG_ID::ECC)
    }
}

impl TpmStructure for TPMS_ECC_PARMS {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMS_ECC_PARMS>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.symmetric.toTpm(buf);
        buf.writeShort(self.scheme.unwrap().GetUnionSelector().unwrap());
        self.scheme.unwrap().toTpm(buf);
        buf.writeShort(self.curveID);
        buf.writeShort(self.kdf.unwrap().GetUnionSelector().unwrap());
        self.kdf.unwrap().toTpm(buf);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.symmetric.initFromTpm(buf);
        let r#schemeScheme: TPM_ALG_ID = buf.readShort();
        self.scheme = TPMU_ASYM_SCHEME::create(r#schemeScheme)?;
        self.scheme.unwrap().initFromTpm(buf);
        self.curveID = buf.readShort();
        let r#kdfScheme: TPM_ALG_ID = buf.readShort();
        self.kdf = TPMU_KDF_SCHEME::create(r#kdfScheme)?;
        self.kdf.unwrap().initFromTpm(buf);
        Ok(())
    }

}

/// This structure is used in TPM2_TestParms() to validate that a set of algorithm
/// parameters is supported by the TPM.
#[derive(Debug, Default)]
pub struct TPMT_PUBLIC_PARMS {
    /// The algorithm to be tested

    /// The algorithm details
    /// One of: TPMS_KEYEDHASH_PARMS, TPMS_SYMCIPHER_PARMS, TPMS_RSA_PARMS, TPMS_ECC_PARMS,
    /// TPMS_ASYM_PARMS.
    pub parameters: Option<TPMU_PUBLIC_PARMS>,
}

impl TPMT_PUBLIC_PARMS {
    /// Creates a new instance with the specified values
    pub fn new(
        parameters: Option<TPMU_PUBLIC_PARMS>,
        ) -> Self {
        Self {
            parameters,
        }
    }

}

impl TpmStructure for TPMT_PUBLIC_PARMS {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMT_PUBLIC_PARMS>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        if (self.parameters.is_none()) { return Ok(()) };
        buf.writeShort(self.parameters.unwrap().GetUnionSelector().unwrap());
        self.parameters.unwrap().toTpm(buf);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        let r#type: TPM_ALG_ID = buf.readShort();
        self.parameters = TPMU_PUBLIC_PARMS::create(r#type)?;
        self.parameters.unwrap().initFromTpm(buf);
        Ok(())
    }

}

/// Table 201 defines the public area structure. The Name of the object is nameAlg
/// concatenated with the digest of this structure using nameAlg.
#[derive(Debug, Default)]
pub struct TPMT_PUBLIC {
    /// Algorithm associated with this object

    /// Algorithm used for computing the Name of the object
    /// NOTE The "+" indicates that the instance of a TPMT_PUBLIC may have a "+" to indicate
    /// that the nameAlg may be TPM_ALG_NULL.
    pub nameAlg: TPM_ALG_ID,

    /// Attributes that, along with type, determine the manipulations of this object
    pub objectAttributes: TPMA_OBJECT,

    /// Optional policy for using this key
    /// The policy is computed using the nameAlg of the object.
    /// NOTE Shall be the Empty Policy if no authorization policy is present.
    pub authPolicy: Vec<u8>,

    /// The algorithm or structure details
    /// One of: TPMS_KEYEDHASH_PARMS, TPMS_SYMCIPHER_PARMS, TPMS_RSA_PARMS, TPMS_ECC_PARMS,
    /// TPMS_ASYM_PARMS.
    pub parameters: Option<TPMU_PUBLIC_PARMS>,

    /// The unique identifier of the structure
    /// For an asymmetric key, this would be the public key.
    /// One of: TPM2B_DIGEST_KEYEDHASH, TPM2B_DIGEST_SYMCIPHER, TPM2B_PUBLIC_KEY_RSA,
    /// TPMS_ECC_POINT, TPMS_DERIVE.
    pub unique: Option<TPMU_PUBLIC_ID>,
}

impl TPMT_PUBLIC {
    /// Creates a new instance with the specified values
    pub fn new(
        nameAlg: TPM_ALG_ID,
        objectAttributes: TPMA_OBJECT,
        authPolicy: Vec<u8>,
        parameters: Option<TPMU_PUBLIC_PARMS>,
        unique: Option<TPMU_PUBLIC_ID>,
        ) -> Self {
        Self {
            nameAlg,
            objectAttributes,
            authPolicy,
            parameters,
            unique,
        }
    }

}

impl TpmStructure for TPMT_PUBLIC {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMT_PUBLIC>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        if (self.parameters.is_none()) { return Ok(()) };
        buf.writeShort(self.parameters.unwrap().GetUnionSelector().unwrap());
        buf.writeShort(self.nameAlg);
        buf.writeInt(self.objectAttributes);
        buf.writeSizedByteBuf(self.authPolicy);
        self.parameters.unwrap().toTpm(buf);
        self.unique.unwrap().toTpm(buf);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        let r#type: TPM_ALG_ID = buf.readShort();
        self.nameAlg = buf.readShort();
        self.objectAttributes = buf.readInt();
        self.authPolicy = buf.readSizedByteBuf();
        self.parameters = TPMU_PUBLIC_PARMS::create(r#type)?;
        self.parameters.unwrap().initFromTpm(buf);
        self.unique = TPMU_PUBLIC_ID::create(r#type)?;
        self.unique.unwrap().initFromTpm(buf);
        Ok(())
    }

}

/// This sized buffer is used to embed a TPMT_PUBLIC in a load command and in any response
/// that returns a public area.
#[derive(Debug, Default)]
pub struct TPM2B_PUBLIC {
    /// The public area
    /// NOTE The + indicates that the caller may specify that use of TPM_ALG_NULL is allowed
    /// for nameAlg.
    pub publicArea: TPMT_PUBLIC,
}

impl TPM2B_PUBLIC {
    /// Creates a new instance with the specified values
    pub fn new(
        publicArea: TPMT_PUBLIC,
        ) -> Self {
        Self {
            publicArea,
        }
    }

}

impl TpmStructure for TPM2B_PUBLIC {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2B_PUBLIC>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedObj(self.publicArea);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        buf.readSizedObj(self.publicArea);
        Ok(())
    }

}

/// This sized buffer is used to embed a TPMT_TEMPLATE for TPM2_CreateLoaded().
#[derive(Debug, Default)]
pub struct TPM2B_TEMPLATE {
    /// The public area
    pub buffer: Vec<u8>,
}

impl TPM2B_TEMPLATE {
    /// Creates a new instance with the specified values
    pub fn new(
        buffer: Vec<u8>,
        ) -> Self {
        Self {
            buffer,
        }
    }

}

impl TpmStructure for TPM2B_TEMPLATE {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2B_TEMPLATE>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.buffer);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.buffer = buf.readSizedByteBuf();
        Ok(())
    }

}

/// This structure is defined for coding purposes. For IO to the TPM, the sensitive
/// portion of the key will be in a canonical form. For an RSA key, this will be one of
/// the prime factors of the public modulus. After loading, it is typical that other
/// values will be computed so that computations using the private key will not need to
/// start with just one prime factor. This structure can be used to store the results of
/// such vendor-specific calculations.
#[derive(Debug, Default)]
pub struct TPM2B_PRIVATE_VENDOR_SPECIFIC {
    pub buffer: Vec<u8>,
}

impl TPM2B_PRIVATE_VENDOR_SPECIFIC {
    /// Creates a new instance with the specified values
    pub fn new(
        buffer: Vec<u8>,
        ) -> Self {
        Self {
            buffer,
        }
    }

    fn GetUnionSelector() -> Option<TPM_ALG_ID> {
        Some(TPM_ALG_ID::ANY)
    }
}

impl TpmStructure for TPM2B_PRIVATE_VENDOR_SPECIFIC {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2B_PRIVATE_VENDOR_SPECIFIC>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.buffer);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.buffer = buf.readSizedByteBuf();
        Ok(())
    }

}

/// AuthValue shall not be larger than the size of the digest produced by the nameAlg of
/// the object. seedValue shall be the size of the digest produced by the nameAlg of the object.
#[derive(Debug, Default)]
pub struct TPMT_SENSITIVE {
    /// Identifier for the sensitive area
    /// This shall be the same as the type parameter of the associated public area.

    /// User authorization data
    /// The authValue may be a zero-length string.
    pub authValue: Vec<u8>,

    /// For a parent object, the optional protection seed; for other objects, the obfuscation value
    pub seedValue: Vec<u8>,

    /// The type-specific private data
    /// One of: TPM2B_PRIVATE_KEY_RSA, TPM2B_ECC_PARAMETER, TPM2B_SENSITIVE_DATA,
    /// TPM2B_SYM_KEY, TPM2B_PRIVATE_VENDOR_SPECIFIC.
    pub sensitive: Option<TPMU_SENSITIVE_COMPOSITE>,
}

impl TPMT_SENSITIVE {
    /// Creates a new instance with the specified values
    pub fn new(
        authValue: Vec<u8>,
        seedValue: Vec<u8>,
        sensitive: Option<TPMU_SENSITIVE_COMPOSITE>,
        ) -> Self {
        Self {
            authValue,
            seedValue,
            sensitive,
        }
    }

}

impl TpmStructure for TPMT_SENSITIVE {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMT_SENSITIVE>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        if (self.sensitive.is_none()) { return Ok(()) };
        buf.writeShort(self.sensitive.unwrap().GetUnionSelector().unwrap());
        buf.writeSizedByteBuf(self.authValue);
        buf.writeSizedByteBuf(self.seedValue);
        self.sensitive.unwrap().toTpm(buf);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        let r#sensitiveType: TPM_ALG_ID = buf.readShort();
        self.authValue = buf.readSizedByteBuf();
        self.seedValue = buf.readSizedByteBuf();
        self.sensitive = TPMU_SENSITIVE_COMPOSITE::create(r#sensitiveType)?;
        self.sensitive.unwrap().initFromTpm(buf);
        Ok(())
    }

}

/// The TPM2B_SENSITIVE structure is used as a parameter in TPM2_LoadExternal(). It is an
/// unencrypted sensitive area but it may be encrypted using parameter encryption.
#[derive(Debug, Default)]
pub struct TPM2B_SENSITIVE {
    /// An unencrypted sensitive area
    pub sensitiveArea: TPMT_SENSITIVE,
}

impl TPM2B_SENSITIVE {
    /// Creates a new instance with the specified values
    pub fn new(
        sensitiveArea: TPMT_SENSITIVE,
        ) -> Self {
        Self {
            sensitiveArea,
        }
    }

}

impl TpmStructure for TPM2B_SENSITIVE {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2B_SENSITIVE>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedObj(self.sensitiveArea);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        buf.readSizedObj(self.sensitiveArea);
        Ok(())
    }

}

/// This structure is defined to size the contents of a TPM2B_PRIVATE. This structure is
/// not directly marshaled or unmarshaled.
#[derive(Debug, Default)]
pub struct _PRIVATE {
    pub integrityOuter: Vec<u8>,

    /// Could also be a TPM2B_IV
    pub integrityInner: Vec<u8>,

    /// The sensitive area
    pub sensitive: TPMT_SENSITIVE,
}

impl _PRIVATE {
    /// Creates a new instance with the specified values
    pub fn new(
        integrityOuter: Vec<u8>,
        integrityInner: Vec<u8>,
        sensitive: TPMT_SENSITIVE,
        ) -> Self {
        Self {
            integrityOuter,
            integrityInner,
            sensitive,
        }
    }

}

impl TpmStructure for _PRIVATE {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<_PRIVATE>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.integrityOuter);
        buf.writeSizedByteBuf(self.integrityInner);
        buf.writeSizedObj(self.sensitive);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.integrityOuter = buf.readSizedByteBuf();
        self.integrityInner = buf.readSizedByteBuf();
        buf.readSizedObj(self.sensitive);
        Ok(())
    }

}

/// The TPM2B_PRIVATE structure is used as a parameter in multiple commands that create,
/// load, and modify the sensitive area of an object.
#[derive(Debug, Default)]
pub struct TPM2B_PRIVATE {
    /// An encrypted private area
    pub buffer: Vec<u8>,
}

impl TPM2B_PRIVATE {
    /// Creates a new instance with the specified values
    pub fn new(
        buffer: Vec<u8>,
        ) -> Self {
        Self {
            buffer,
        }
    }

}

impl TpmStructure for TPM2B_PRIVATE {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2B_PRIVATE>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.buffer);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.buffer = buf.readSizedByteBuf();
        Ok(())
    }

}

/// This structure is used for sizing the TPM2B_ID_OBJECT.
#[derive(Debug, Default)]
pub struct TPMS_ID_OBJECT {
    /// HMAC using the nameAlg of the storage key on the target TPM
    pub integrityHMAC: Vec<u8>,

    /// Credential protector information returned if name matches the referenced object
    /// All of the encIdentity is encrypted, including the size field.
    /// NOTE The TPM is not required to check that the size is not larger than the digest of
    /// the nameAlg. However, if the size is larger, the ID object may not be usable on a TPM
    /// that has no digest larger than produced by nameAlg.
    pub encIdentity: Vec<u8>,
}

impl TPMS_ID_OBJECT {
    /// Creates a new instance with the specified values
    pub fn new(
        integrityHMAC: Vec<u8>,
        encIdentity: Vec<u8>,
        ) -> Self {
        Self {
            integrityHMAC,
            encIdentity,
        }
    }

}

impl TpmStructure for TPMS_ID_OBJECT {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMS_ID_OBJECT>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.integrityHMAC);
        buf.writeByteBuf(self.encIdentity);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.integrityHMAC = buf.readSizedByteBuf();
        self.encIdentity = buf.readByteBuf(buf.getCurStuctRemainingSize());
        Ok(())
    }

}

/// This structure is an output from TPM2_MakeCredential() and is an input to
/// TPM2_ActivateCredential().
#[derive(Debug, Default)]
pub struct TPM2B_ID_OBJECT {
    /// An encrypted credential area
    pub credential: TPMS_ID_OBJECT,
}

impl TPM2B_ID_OBJECT {
    /// Creates a new instance with the specified values
    pub fn new(
        credential: TPMS_ID_OBJECT,
        ) -> Self {
        Self {
            credential,
        }
    }

}

impl TpmStructure for TPM2B_ID_OBJECT {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2B_ID_OBJECT>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedObj(self.credential);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        buf.readSizedObj(self.credential);
        Ok(())
    }

}

/// This is the data that can be written to and read from a TPM_NT_PIN_PASS or
/// TPM_NT_PIN_FAIL non-volatile index. pinCount is the most significant octets. pinLimit
/// is the least significant octets.
#[derive(Debug, Default)]
pub struct TPMS_NV_PIN_COUNTER_PARAMETERS {
    /// This counter shows the current number of successful authValue authorization attempts
    /// to access a TPM_NT_PIN_PASS index or the current number of unsuccessful authValue
    /// authorization attempts to access a TPM_NT_PIN_FAIL index.
    pub pinCount: u32,

    /// This threshold is the value of pinCount at which the authValue authorization of the
    /// host TPM_NT_PIN_PASS or TPM_NT_PIN_FAIL index is locked out.
    pub pinLimit: u32,
}

impl TPMS_NV_PIN_COUNTER_PARAMETERS {
    /// Creates a new instance with the specified values
    pub fn new(
        pinCount: u32,
        pinLimit: u32,
        ) -> Self {
        Self {
            pinCount,
            pinLimit,
        }
    }

}

impl TpmStructure for TPMS_NV_PIN_COUNTER_PARAMETERS {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMS_NV_PIN_COUNTER_PARAMETERS>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeInt(self.pinCount);
        buf.writeInt(self.pinLimit);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.pinCount = buf.readInt();
        self.pinLimit = buf.readInt();
        Ok(())
    }

}

/// This structure describes an NV Index.
#[derive(Debug, Default)]
pub struct TPMS_NV_PUBLIC {
    /// The handle of the data area
    pub nvIndex: TPM_HANDLE,

    /// Hash algorithm used to compute the name of the Index and used for the authPolicy. For
    /// an extend index, the hash algorithm used for the extend.
    pub nameAlg: TPM_ALG_ID,

    /// The Index attributes
    pub attributes: TPMA_NV,

    /// Optional access policy for the Index
    /// The policy is computed using the nameAlg
    /// NOTE Shall be the Empty Policy if no authorization policy is present.
    pub authPolicy: Vec<u8>,

    /// The size of the data area
    /// The maximum size is implementation-dependent. The minimum maximum size is platform-specific.
    pub dataSize: u16,
}

impl TPMS_NV_PUBLIC {
    /// Creates a new instance with the specified values
    pub fn new(
        nvIndex: TPM_HANDLE,
        nameAlg: TPM_ALG_ID,
        attributes: TPMA_NV,
        authPolicy: Vec<u8>,
        dataSize: u16,
        ) -> Self {
        Self {
            nvIndex,
            nameAlg,
            attributes,
            authPolicy,
            dataSize,
        }
    }

}

impl TpmStructure for TPMS_NV_PUBLIC {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMS_NV_PUBLIC>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.nvIndex.toTpm(buf);
        buf.writeShort(self.nameAlg);
        buf.writeInt(self.attributes);
        buf.writeSizedByteBuf(self.authPolicy);
        buf.writeShort(self.dataSize);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.nvIndex.initFromTpm(buf);
        self.nameAlg = buf.readShort();
        self.attributes = buf.readInt();
        self.authPolicy = buf.readSizedByteBuf();
        self.dataSize = buf.readShort();
        Ok(())
    }

}

/// This structure is used when a TPMS_NV_PUBLIC is sent on the TPM interface.
#[derive(Debug, Default)]
pub struct TPM2B_NV_PUBLIC {
    /// The public area
    pub nvPublic: TPMS_NV_PUBLIC,
}

impl TPM2B_NV_PUBLIC {
    /// Creates a new instance with the specified values
    pub fn new(
        nvPublic: TPMS_NV_PUBLIC,
        ) -> Self {
        Self {
            nvPublic,
        }
    }

}

impl TpmStructure for TPM2B_NV_PUBLIC {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2B_NV_PUBLIC>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedObj(self.nvPublic);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        buf.readSizedObj(self.nvPublic);
        Ok(())
    }

}

/// This structure holds the object or session context data. When saved, the full
/// structure is encrypted.
#[derive(Debug, Default)]
pub struct TPM2B_CONTEXT_SENSITIVE {
    /// The sensitive data
    pub buffer: Vec<u8>,
}

impl TPM2B_CONTEXT_SENSITIVE {
    /// Creates a new instance with the specified values
    pub fn new(
        buffer: Vec<u8>,
        ) -> Self {
        Self {
            buffer,
        }
    }

}

impl TpmStructure for TPM2B_CONTEXT_SENSITIVE {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2B_CONTEXT_SENSITIVE>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.buffer);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.buffer = buf.readSizedByteBuf();
        Ok(())
    }

}

/// This structure holds the integrity value and the encrypted data for a context.
#[derive(Debug, Default)]
pub struct TPMS_CONTEXT_DATA {
    /// The integrity value
    pub integrity: Vec<u8>,

    /// The sensitive area
    pub encrypted: Vec<u8>,
}

impl TPMS_CONTEXT_DATA {
    /// Creates a new instance with the specified values
    pub fn new(
        integrity: Vec<u8>,
        encrypted: Vec<u8>,
        ) -> Self {
        Self {
            integrity,
            encrypted,
        }
    }

}

impl TpmStructure for TPMS_CONTEXT_DATA {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMS_CONTEXT_DATA>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.integrity);
        buf.writeByteBuf(self.encrypted);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.integrity = buf.readSizedByteBuf();
        self.encrypted = buf.readByteBuf(buf.getCurStuctRemainingSize());
        Ok(())
    }

}

/// This structure is used in a TPMS_CONTEXT.
#[derive(Debug, Default)]
pub struct TPM2B_CONTEXT_DATA {
    pub buffer: TPMS_CONTEXT_DATA,
}

impl TPM2B_CONTEXT_DATA {
    /// Creates a new instance with the specified values
    pub fn new(
        buffer: TPMS_CONTEXT_DATA,
        ) -> Self {
        Self {
            buffer,
        }
    }

}

impl TpmStructure for TPM2B_CONTEXT_DATA {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2B_CONTEXT_DATA>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedObj(self.buffer);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        buf.readSizedObj(self.buffer);
        Ok(())
    }

}

/// This structure is used in TPM2_ContextLoad() and TPM2_ContextSave(). If the values of
/// the TPMS_CONTEXT structure in TPM2_ContextLoad() are not the same as the values when
/// the context was saved (TPM2_ContextSave()), then the TPM shall not load the context.
#[derive(Debug, Default)]
pub struct TPMS_CONTEXT {
    /// The sequence number of the context
    /// NOTE Transient object contexts and session contexts used different counters.
    pub sequence: u64,

    /// A handle indicating if the context is a session, object, or sequence object (see Table
    /// 222 Context Handle Values
    pub savedHandle: TPM_HANDLE,

    /// The hierarchy of the context
    pub hierarchy: TPM_HANDLE,

    /// The context data and integrity HMAC
    pub contextBlob: TPMS_CONTEXT_DATA,
}

impl TPMS_CONTEXT {
    /// Creates a new instance with the specified values
    pub fn new(
        sequence: u64,
        savedHandle: TPM_HANDLE,
        hierarchy: TPM_HANDLE,
        contextBlob: TPMS_CONTEXT_DATA,
        ) -> Self {
        Self {
            sequence,
            savedHandle,
            hierarchy,
            contextBlob,
        }
    }

}

impl TpmStructure for TPMS_CONTEXT {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMS_CONTEXT>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeInt64(self.sequence);
        self.savedHandle.toTpm(buf);
        self.hierarchy.toTpm(buf);
        buf.writeSizedObj(self.contextBlob);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.sequence = buf.readInt64();
        self.savedHandle.initFromTpm(buf);
        self.hierarchy.initFromTpm(buf);
        buf.readSizedObj(self.contextBlob);
        Ok(())
    }

}

/// This structure provides information relating to the creation environment for the
/// object. The creation data includes the parent Name, parent Qualified Name, and the
/// digest of selected PCR. These values represent the environment in which the object was
/// created. Creation data allows a relying party to determine if an object was created
/// when some appropriate protections were present.
#[derive(Debug, Default)]
pub struct TPMS_CREATION_DATA {
    /// List indicating the PCR included in pcrDigest
    pub pcrSelect: Vec<TPMS_PCR_SELECTION>,

    /// Digest of the selected PCR using nameAlg of the object for which this structure is
    /// being created
    /// pcrDigest.size shall be zero if the pcrSelect list is empty.
    pub pcrDigest: Vec<u8>,

    /// The locality at which the object was created
    pub locality: TPMA_LOCALITY,

    /// NameAlg of the parent
    pub parentNameAlg: TPM_ALG_ID,

    /// Name of the parent at time of creation
    /// The size will match digest size associated with parentNameAlg unless it is
    /// TPM_ALG_NULL, in which case the size will be 4 and parentName will be the hierarchy handle.
    pub parentName: Vec<u8>,

    /// Qualified Name of the parent at the time of creation
    /// Size is the same as parentName.
    pub parentQualifiedName: Vec<u8>,

    /// Association with additional information added by the key creator
    /// This will be the contents of the outsideInfo parameter in TPM2_Create() or TPM2_CreatePrimary().
    pub outsideInfo: Vec<u8>,
}

impl TPMS_CREATION_DATA {
    /// Creates a new instance with the specified values
    pub fn new(
        pcrSelect: Vec<TPMS_PCR_SELECTION>,
        pcrDigest: Vec<u8>,
        locality: TPMA_LOCALITY,
        parentNameAlg: TPM_ALG_ID,
        parentName: Vec<u8>,
        parentQualifiedName: Vec<u8>,
        outsideInfo: Vec<u8>,
        ) -> Self {
        Self {
            pcrSelect,
            pcrDigest,
            locality,
            parentNameAlg,
            parentName,
            parentQualifiedName,
            outsideInfo,
        }
    }

}

impl TpmStructure for TPMS_CREATION_DATA {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMS_CREATION_DATA>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeObjArr(self.pcrSelect);
        buf.writeSizedByteBuf(self.pcrDigest);
        buf.writeByte(self.locality);
        buf.writeShort(self.parentNameAlg);
        buf.writeSizedByteBuf(self.parentName);
        buf.writeSizedByteBuf(self.parentQualifiedName);
        buf.writeSizedByteBuf(self.outsideInfo);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        buf.readObjArr(self.pcrSelect);
        self.pcrDigest = buf.readSizedByteBuf();
        self.locality = buf.readByte();
        self.parentNameAlg = buf.readShort();
        self.parentName = buf.readSizedByteBuf();
        self.parentQualifiedName = buf.readSizedByteBuf();
        self.outsideInfo = buf.readSizedByteBuf();
        Ok(())
    }

}

/// This structure is created by TPM2_Create() and TPM2_CreatePrimary(). It is never
/// entered into the TPM and never has a size of zero.
#[derive(Debug, Default)]
pub struct TPM2B_CREATION_DATA {
    pub creationData: TPMS_CREATION_DATA,
}

impl TPM2B_CREATION_DATA {
    /// Creates a new instance with the specified values
    pub fn new(
        creationData: TPMS_CREATION_DATA,
        ) -> Self {
        Self {
            creationData,
        }
    }

}

impl TpmStructure for TPM2B_CREATION_DATA {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2B_CREATION_DATA>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedObj(self.creationData);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        buf.readSizedObj(self.creationData);
        Ok(())
    }

}

/// TPMS_AC_OUTPUT is used to return information about an AC. The tag structure parameter
/// indicates the type of the data value.
#[derive(Debug, Default)]
pub struct TPMS_AC_OUTPUT {
    /// Tag indicating the contents of data
    pub tag: TPM_AT,

    /// The data returned from the AC
    pub data: u32,
}

impl TPMS_AC_OUTPUT {
    /// Creates a new instance with the specified values
    pub fn new(
        tag: TPM_AT,
        data: u32,
        ) -> Self {
        Self {
            tag,
            data,
        }
    }

}

impl TpmStructure for TPMS_AC_OUTPUT {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPMS_AC_OUTPUT>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeInt(self.tag);
        buf.writeInt(self.data);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.tag = buf.readInt();
        self.data = buf.readInt();
        Ok(())
    }

}

/// This list is only used in TPM2_AC_GetCapability().
#[derive(Debug, Default)]
pub struct TPML_AC_CAPABILITIES {
    /// A list of AC values
    pub acCapabilities: Vec<TPMS_AC_OUTPUT>,
}

impl TPML_AC_CAPABILITIES {
    /// Creates a new instance with the specified values
    pub fn new(
        acCapabilities: Vec<TPMS_AC_OUTPUT>,
        ) -> Self {
        Self {
            acCapabilities,
        }
    }

}

impl TpmStructure for TPML_AC_CAPABILITIES {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPML_AC_CAPABILITIES>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeObjArr(self.acCapabilities);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        buf.readObjArr(self.acCapabilities);
        Ok(())
    }

}

/// TPM2_Startup() is always preceded by _TPM_Init, which is the physical indication that
/// TPM initialization is necessary because of a system-wide reset. TPM2_Startup() is only
/// valid after _TPM_Init. Additional TPM2_Startup() commands are not allowed after it has
/// completed successfully. If a TPM requires TPM2_Startup() and another command is
/// received, or if the TPM receives TPM2_Startup() when it is not required, the TPM shall
/// return TPM_RC_INITIALIZE.
#[derive(Debug, Default)]
pub struct TPM2_Startup_REQUEST {
    /// TPM_SU_CLEAR or TPM_SU_STATE
    pub startupType: TPM_SU,
}

impl TPM2_Startup_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        startupType: TPM_SU,
        ) -> Self {
        Self {
            startupType,
        }
    }

}

impl TpmStructure for TPM2_Startup_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_Startup_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeShort(self.startupType);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.startupType = buf.readShort();
        Ok(())
    }

}

/// This command is used to prepare the TPM for a power cycle. The shutdownType parameter
/// indicates how the subsequent TPM2_Startup() will be processed.
#[derive(Debug, Default)]
pub struct TPM2_Shutdown_REQUEST {
    /// TPM_SU_CLEAR or TPM_SU_STATE
    pub shutdownType: TPM_SU,
}

impl TPM2_Shutdown_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        shutdownType: TPM_SU,
        ) -> Self {
        Self {
            shutdownType,
        }
    }

}

impl TpmStructure for TPM2_Shutdown_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_Shutdown_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeShort(self.shutdownType);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.shutdownType = buf.readShort();
        Ok(())
    }

}

/// This command causes the TPM to perform a test of its capabilities. If the fullTest is
/// YES, the TPM will test all functions. If fullTest = NO, the TPM will only test those
/// functions that have not previously been tested.
#[derive(Debug, Default)]
pub struct TPM2_SelfTest_REQUEST {
    /// YES if full test to be performed
    /// NO if only test of untested functions required
    pub fullTest: u8,
}

impl TPM2_SelfTest_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        fullTest: u8,
        ) -> Self {
        Self {
            fullTest,
        }
    }

}

impl TpmStructure for TPM2_SelfTest_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_SelfTest_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeByte(self.fullTest);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.fullTest = buf.readByte();
        Ok(())
    }

}

/// This command causes the TPM to perform a test of the selected algorithms.
#[derive(Debug, Default)]
pub struct TPM2_IncrementalSelfTest_REQUEST {
    /// List of algorithms that should be tested
    pub toTest: Vec<TPM_ALG_ID>,
}

impl TPM2_IncrementalSelfTest_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        toTest: Vec<TPM_ALG_ID>,
        ) -> Self {
        Self {
            toTest,
        }
    }

}

impl TpmStructure for TPM2_IncrementalSelfTest_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_IncrementalSelfTest_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeValArr(self.toTest, 2);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        buf.readValArr(self.toTest, 2);
        Ok(())
    }

}

/// This command causes the TPM to perform a test of the selected algorithms.
#[derive(Debug, Default)]
pub struct IncrementalSelfTestResponse {
    /// List of algorithms that need testing
    pub toDoList: Vec<TPM_ALG_ID>,
}

impl IncrementalSelfTestResponse {
}

impl TpmStructure for IncrementalSelfTestResponse {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<IncrementalSelfTestResponse>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeValArr(self.toDoList, 2);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        buf.readValArr(self.toDoList, 2);
        Ok(())
    }

}

/// This command returns manufacturer-specific information regarding the results of a
/// self-test and an indication of the test status.
#[derive(Debug, Default)]
pub struct TPM2_GetTestResult_REQUEST {
}

impl TPM2_GetTestResult_REQUEST {
}

impl TpmStructure for TPM2_GetTestResult_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_GetTestResult_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        Ok(())
    }

}

/// This command returns manufacturer-specific information regarding the results of a
/// self-test and an indication of the test status.
#[derive(Debug, Default)]
pub struct GetTestResultResponse {
    /// Test result data
    /// contains manufacturer-specific information
    pub outData: Vec<u8>,
    pub testResult: TPM_RC,
}

impl GetTestResultResponse {
}

impl TpmStructure for GetTestResultResponse {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<GetTestResultResponse>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.outData);
        buf.writeInt(self.testResult);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.outData = buf.readSizedByteBuf();
        self.testResult = buf.readInt();
        Ok(())
    }

}

/// This command is used to start an authorization session using alternative methods of
/// establishing the session key (sessionKey). The session key is then used to derive
/// values used for authorization and for encrypting parameters.
#[derive(Debug, Default)]
pub struct TPM2_StartAuthSession_REQUEST {
    /// Handle of a loaded decrypt key used to encrypt salt
    /// may be TPM_RH_NULL
    /// Auth Index: None
    pub tpmKey: TPM_HANDLE,

    /// Entity providing the authValue
    /// may be TPM_RH_NULL
    /// Auth Index: None
    pub bind: TPM_HANDLE,

    /// Initial nonceCaller, sets nonceTPM size for the session
    /// shall be at least 16 octets
    pub nonceCaller: Vec<u8>,

    /// Value encrypted according to the type of tpmKey
    /// If tpmKey is TPM_RH_NULL, this shall be the Empty Buffer.
    pub encryptedSalt: Vec<u8>,

    /// Indicates the type of the session; simple HMAC or policy (including a trial policy)
    pub sessionType: TPM_SE,

    /// The algorithm and key size for parameter encryption
    /// may select TPM_ALG_NULL
    pub symmetric: TPMT_SYM_DEF,

    /// Hash algorithm to use for the session
    /// Shall be a hash algorithm supported by the TPM and not TPM_ALG_NULL
    pub authHash: TPM_ALG_ID,
}

impl TPM2_StartAuthSession_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        tpmKey: TPM_HANDLE,
        bind: TPM_HANDLE,
        nonceCaller: Vec<u8>,
        encryptedSalt: Vec<u8>,
        sessionType: TPM_SE,
        symmetric: TPMT_SYM_DEF,
        authHash: TPM_ALG_ID,
        ) -> Self {
        Self {
            tpmKey,
            bind,
            nonceCaller,
            encryptedSalt,
            sessionType,
            symmetric,
            authHash,
        }
    }

}

impl TpmStructure for TPM2_StartAuthSession_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_StartAuthSession_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.nonceCaller);
        buf.writeSizedByteBuf(self.encryptedSalt);
        buf.writeByte(self.sessionType);
        self.symmetric.toTpm(buf);
        buf.writeShort(self.authHash);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.nonceCaller = buf.readSizedByteBuf();
        self.encryptedSalt = buf.readSizedByteBuf();
        self.sessionType = buf.readByte();
        self.symmetric.initFromTpm(buf);
        self.authHash = buf.readShort();
        Ok(())
    }

}

/// This command is used to start an authorization session using alternative methods of
/// establishing the session key (sessionKey). The session key is then used to derive
/// values used for authorization and for encrypting parameters.
#[derive(Debug, Default)]
pub struct StartAuthSessionResponse {
    /// Handle for the newly created session
    pub handle: TPM_HANDLE,

    /// The initial nonce from the TPM, used in the computation of the sessionKey
    pub nonceTPM: Vec<u8>,
}

impl StartAuthSessionResponse {
}

impl TpmStructure for StartAuthSessionResponse {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<StartAuthSessionResponse>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.nonceTPM);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.nonceTPM = buf.readSizedByteBuf();
        Ok(())
    }

}

/// This command allows a policy authorization session to be returned to its initial
/// state. This command is used after the TPM returns TPM_RC_PCR_CHANGED. That response
/// code indicates that a policy will fail because the PCR have changed after
/// TPM2_PolicyPCR() was executed. Restarting the session allows the authorizations to be
/// replayed because the session restarts with the same nonceTPM. If the PCR are valid for
/// the policy, the policy may then succeed.
#[derive(Debug, Default)]
pub struct TPM2_PolicyRestart_REQUEST {
    /// The handle for the policy session
    pub sessionHandle: TPM_HANDLE,
}

impl TPM2_PolicyRestart_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        sessionHandle: TPM_HANDLE,
        ) -> Self {
        Self {
            sessionHandle,
        }
    }

}

impl TpmStructure for TPM2_PolicyRestart_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_PolicyRestart_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        Ok(())
    }

}

/// This command is used to create an object that can be loaded into a TPM using
/// TPM2_Load(). If the command completes successfully, the TPM will create the new object
/// and return the objects creation data (creationData), its public area (outPublic), and
/// its encrypted sensitive area (outPrivate). Preservation of the returned data is the
/// responsibility of the caller. The object will need to be loaded (TPM2_Load()) before
/// it may be used. The only difference between the inPublic TPMT_PUBLIC template and the
/// outPublic TPMT_PUBLIC object is in the unique field.
#[derive(Debug, Default)]
pub struct TPM2_Create_REQUEST {
    /// Handle of parent for new object
    /// Auth Index: 1
    /// Auth Role: USER
    pub parentHandle: TPM_HANDLE,

    /// The sensitive data
    pub inSensitive: TPMS_SENSITIVE_CREATE,

    /// The public template
    pub inPublic: TPMT_PUBLIC,

    /// Data that will be included in the creation data for this object to provide permanent,
    /// verifiable linkage between this object and some object owner data
    pub outsideInfo: Vec<u8>,

    /// PCR that will be used in creation data
    pub creationPCR: Vec<TPMS_PCR_SELECTION>,
}

impl TPM2_Create_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        parentHandle: TPM_HANDLE,
        inSensitive: TPMS_SENSITIVE_CREATE,
        inPublic: TPMT_PUBLIC,
        outsideInfo: Vec<u8>,
        creationPCR: Vec<TPMS_PCR_SELECTION>,
        ) -> Self {
        Self {
            parentHandle,
            inSensitive,
            inPublic,
            outsideInfo,
            creationPCR,
        }
    }

}

impl TpmStructure for TPM2_Create_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_Create_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedObj(self.inSensitive);
        buf.writeSizedObj(self.inPublic);
        buf.writeSizedByteBuf(self.outsideInfo);
        buf.writeObjArr(self.creationPCR);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        buf.readSizedObj(self.inSensitive);
        buf.readSizedObj(self.inPublic);
        self.outsideInfo = buf.readSizedByteBuf();
        buf.readObjArr(self.creationPCR);
        Ok(())
    }

}

/// This command is used to create an object that can be loaded into a TPM using
/// TPM2_Load(). If the command completes successfully, the TPM will create the new object
/// and return the objects creation data (creationData), its public area (outPublic), and
/// its encrypted sensitive area (outPrivate). Preservation of the returned data is the
/// responsibility of the caller. The object will need to be loaded (TPM2_Load()) before
/// it may be used. The only difference between the inPublic TPMT_PUBLIC template and the
/// outPublic TPMT_PUBLIC object is in the unique field.
#[derive(Debug, Default)]
pub struct CreateResponse {
    /// The private portion of the object
    pub outPrivate: TPM2B_PRIVATE,

    /// The public portion of the created object
    pub outPublic: TPMT_PUBLIC,

    /// Contains a TPMS_CREATION_DATA
    pub creationData: TPMS_CREATION_DATA,

    /// Digest of creationData using nameAlg of outPublic
    pub creationHash: Vec<u8>,

    /// Ticket used by TPM2_CertifyCreation() to validate that the creation data was produced
    /// by the TPM
    pub creationTicket: TPMT_TK_CREATION,
}

impl CreateResponse {
}

impl TpmStructure for CreateResponse {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<CreateResponse>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.outPrivate.toTpm(buf);
        buf.writeSizedObj(self.outPublic);
        buf.writeSizedObj(self.creationData);
        buf.writeSizedByteBuf(self.creationHash);
        self.creationTicket.toTpm(buf);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.outPrivate.initFromTpm(buf);
        buf.readSizedObj(self.outPublic);
        buf.readSizedObj(self.creationData);
        self.creationHash = buf.readSizedByteBuf();
        self.creationTicket.initFromTpm(buf);
        Ok(())
    }

}

/// This command is used to load objects into the TPM. This command is used when both a
/// TPM2B_PUBLIC and TPM2B_PRIVATE are to be loaded. If only a TPM2B_PUBLIC is to be
/// loaded, the TPM2_LoadExternal command is used.
#[derive(Debug, Default)]
pub struct TPM2_Load_REQUEST {
    /// TPM handle of parent key; shall not be a reserved handle
    /// Auth Index: 1
    /// Auth Role: USER
    pub parentHandle: TPM_HANDLE,

    /// The private portion of the object
    pub inPrivate: TPM2B_PRIVATE,

    /// The public portion of the object
    pub inPublic: TPMT_PUBLIC,
}

impl TPM2_Load_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        parentHandle: TPM_HANDLE,
        inPrivate: TPM2B_PRIVATE,
        inPublic: TPMT_PUBLIC,
        ) -> Self {
        Self {
            parentHandle,
            inPrivate,
            inPublic,
        }
    }

}

impl TpmStructure for TPM2_Load_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_Load_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.inPrivate.toTpm(buf);
        buf.writeSizedObj(self.inPublic);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.inPrivate.initFromTpm(buf);
        buf.readSizedObj(self.inPublic);
        Ok(())
    }

}

/// This command is used to load objects into the TPM. This command is used when both a
/// TPM2B_PUBLIC and TPM2B_PRIVATE are to be loaded. If only a TPM2B_PUBLIC is to be
/// loaded, the TPM2_LoadExternal command is used.
#[derive(Debug, Default)]
pub struct LoadResponse {
    /// Handle of type TPM_HT_TRANSIENT for the loaded object
    pub handle: TPM_HANDLE,

    /// Name of the loaded object
    pub name: Vec<u8>,
}

impl LoadResponse {
}

impl TpmStructure for LoadResponse {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<LoadResponse>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.name);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.name = buf.readSizedByteBuf();
        Ok(())
    }

}

/// This command is used to load an object that is not a Protected Object into the TPM.
/// The command allows loading of a public area or both a public and sensitive area.
#[derive(Debug, Default)]
pub struct TPM2_LoadExternal_REQUEST {
    /// The sensitive portion of the object (optional)
    pub inPrivate: TPMT_SENSITIVE,

    /// The public portion of the object
    pub inPublic: TPMT_PUBLIC,

    /// Hierarchy with which the object area is associated
    pub hierarchy: TPM_HANDLE,
}

impl TPM2_LoadExternal_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        inPrivate: TPMT_SENSITIVE,
        inPublic: TPMT_PUBLIC,
        hierarchy: TPM_HANDLE,
        ) -> Self {
        Self {
            inPrivate,
            inPublic,
            hierarchy,
        }
    }

}

impl TpmStructure for TPM2_LoadExternal_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_LoadExternal_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedObj(self.inPrivate);
        buf.writeSizedObj(self.inPublic);
        self.hierarchy.toTpm(buf);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        buf.readSizedObj(self.inPrivate);
        buf.readSizedObj(self.inPublic);
        self.hierarchy.initFromTpm(buf);
        Ok(())
    }

}

/// This command is used to load an object that is not a Protected Object into the TPM.
/// The command allows loading of a public area or both a public and sensitive area.
#[derive(Debug, Default)]
pub struct LoadExternalResponse {
    /// Handle of type TPM_HT_TRANSIENT for the loaded object
    pub handle: TPM_HANDLE,

    /// Name of the loaded object
    pub name: Vec<u8>,
}

impl LoadExternalResponse {
}

impl TpmStructure for LoadExternalResponse {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<LoadExternalResponse>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.name);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.name = buf.readSizedByteBuf();
        Ok(())
    }

}

/// This command allows access to the public area of a loaded object.
#[derive(Debug, Default)]
pub struct TPM2_ReadPublic_REQUEST {
    /// TPM handle of an object
    /// Auth Index: None
    pub objectHandle: TPM_HANDLE,
}

impl TPM2_ReadPublic_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        objectHandle: TPM_HANDLE,
        ) -> Self {
        Self {
            objectHandle,
        }
    }

}

impl TpmStructure for TPM2_ReadPublic_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_ReadPublic_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        Ok(())
    }

}

/// This command allows access to the public area of a loaded object.
#[derive(Debug, Default)]
pub struct ReadPublicResponse {
    /// Structure containing the public area of an object
    pub outPublic: TPMT_PUBLIC,

    /// Name of the object
    pub name: Vec<u8>,

    /// The Qualified Name of the object
    pub qualifiedName: Vec<u8>,
}

impl ReadPublicResponse {
}

impl TpmStructure for ReadPublicResponse {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<ReadPublicResponse>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedObj(self.outPublic);
        buf.writeSizedByteBuf(self.name);
        buf.writeSizedByteBuf(self.qualifiedName);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        buf.readSizedObj(self.outPublic);
        self.name = buf.readSizedByteBuf();
        self.qualifiedName = buf.readSizedByteBuf();
        Ok(())
    }

}

/// This command enables the association of a credential with an object in a way that
/// ensures that the TPM has validated the parameters of the credentialed object.
#[derive(Debug, Default)]
pub struct TPM2_ActivateCredential_REQUEST {
    /// Handle of the object associated with certificate in credentialBlob
    /// Auth Index: 1
    /// Auth Role: ADMIN
    pub activateHandle: TPM_HANDLE,

    /// Loaded key used to decrypt the TPMS_SENSITIVE in credentialBlob
    /// Auth Index: 2
    /// Auth Role: USER
    pub keyHandle: TPM_HANDLE,

    /// The credential
    pub credentialBlob: TPMS_ID_OBJECT,

    /// KeyHandle algorithm-dependent encrypted seed that protects credentialBlob
    pub secret: Vec<u8>,
}

impl TPM2_ActivateCredential_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        activateHandle: TPM_HANDLE,
        keyHandle: TPM_HANDLE,
        credentialBlob: TPMS_ID_OBJECT,
        secret: Vec<u8>,
        ) -> Self {
        Self {
            activateHandle,
            keyHandle,
            credentialBlob,
            secret,
        }
    }

}

impl TpmStructure for TPM2_ActivateCredential_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_ActivateCredential_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedObj(self.credentialBlob);
        buf.writeSizedByteBuf(self.secret);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        buf.readSizedObj(self.credentialBlob);
        self.secret = buf.readSizedByteBuf();
        Ok(())
    }

}

/// This command enables the association of a credential with an object in a way that
/// ensures that the TPM has validated the parameters of the credentialed object.
#[derive(Debug, Default)]
pub struct ActivateCredentialResponse {
    /// The decrypted certificate information
    /// the data should be no larger than the size of the digest of the nameAlg associated
    /// with keyHandle
    pub certInfo: Vec<u8>,
}

impl ActivateCredentialResponse {
}

impl TpmStructure for ActivateCredentialResponse {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<ActivateCredentialResponse>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.certInfo);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.certInfo = buf.readSizedByteBuf();
        Ok(())
    }

}

/// This command allows the TPM to perform the actions required of a Certificate Authority
/// (CA) in creating a TPM2B_ID_OBJECT containing an activation credential.
#[derive(Debug, Default)]
pub struct TPM2_MakeCredential_REQUEST {
    /// Loaded public area, used to encrypt the sensitive area containing the credential key
    /// Auth Index: None
    pub handle: TPM_HANDLE,

    /// The credential information
    pub credential: Vec<u8>,

    /// Name of the object to which the credential applies
    pub objectName: Vec<u8>,
}

impl TPM2_MakeCredential_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        handle: TPM_HANDLE,
        credential: Vec<u8>,
        objectName: Vec<u8>,
        ) -> Self {
        Self {
            handle,
            credential,
            objectName,
        }
    }

}

impl TpmStructure for TPM2_MakeCredential_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_MakeCredential_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.credential);
        buf.writeSizedByteBuf(self.objectName);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.credential = buf.readSizedByteBuf();
        self.objectName = buf.readSizedByteBuf();
        Ok(())
    }

}

/// This command allows the TPM to perform the actions required of a Certificate Authority
/// (CA) in creating a TPM2B_ID_OBJECT containing an activation credential.
#[derive(Debug, Default)]
pub struct MakeCredentialResponse {
    /// The credential
    pub credentialBlob: TPMS_ID_OBJECT,

    /// Handle algorithm-dependent data that wraps the key that encrypts credentialBlob
    pub secret: Vec<u8>,
}

impl MakeCredentialResponse {
}

impl TpmStructure for MakeCredentialResponse {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<MakeCredentialResponse>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedObj(self.credentialBlob);
        buf.writeSizedByteBuf(self.secret);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        buf.readSizedObj(self.credentialBlob);
        self.secret = buf.readSizedByteBuf();
        Ok(())
    }

}

/// This command returns the data in a loaded Sealed Data Object.
#[derive(Debug, Default)]
pub struct TPM2_Unseal_REQUEST {
    /// Handle of a loaded data object
    /// Auth Index: 1
    /// Auth Role: USER
    pub itemHandle: TPM_HANDLE,
}

impl TPM2_Unseal_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        itemHandle: TPM_HANDLE,
        ) -> Self {
        Self {
            itemHandle,
        }
    }

}

impl TpmStructure for TPM2_Unseal_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_Unseal_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        Ok(())
    }

}

/// This command returns the data in a loaded Sealed Data Object.
#[derive(Debug, Default)]
pub struct UnsealResponse {
    /// Unsealed data
    /// Size of outData is limited to be no more than 128 octets.
    pub outData: Vec<u8>,
}

impl UnsealResponse {
}

impl TpmStructure for UnsealResponse {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<UnsealResponse>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.outData);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.outData = buf.readSizedByteBuf();
        Ok(())
    }

}

/// This command is used to change the authorization secret for a TPM-resident object.
#[derive(Debug, Default)]
pub struct TPM2_ObjectChangeAuth_REQUEST {
    /// Handle of the object
    /// Auth Index: 1
    /// Auth Role: ADMIN
    pub objectHandle: TPM_HANDLE,

    /// Handle of the parent
    /// Auth Index: None
    pub parentHandle: TPM_HANDLE,

    /// New authorization value
    pub newAuth: Vec<u8>,
}

impl TPM2_ObjectChangeAuth_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        objectHandle: TPM_HANDLE,
        parentHandle: TPM_HANDLE,
        newAuth: Vec<u8>,
        ) -> Self {
        Self {
            objectHandle,
            parentHandle,
            newAuth,
        }
    }

}

impl TpmStructure for TPM2_ObjectChangeAuth_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_ObjectChangeAuth_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.newAuth);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.newAuth = buf.readSizedByteBuf();
        Ok(())
    }

}

/// This command is used to change the authorization secret for a TPM-resident object.
#[derive(Debug, Default)]
pub struct ObjectChangeAuthResponse {
    /// Private area containing the new authorization value
    pub outPrivate: TPM2B_PRIVATE,
}

impl ObjectChangeAuthResponse {
}

impl TpmStructure for ObjectChangeAuthResponse {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<ObjectChangeAuthResponse>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.outPrivate.toTpm(buf);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.outPrivate.initFromTpm(buf);
        Ok(())
    }

}

/// This command creates an object and loads it in the TPM. This command allows creation
/// of any type of object (Primary, Ordinary, or Derived) depending on the type of
/// parentHandle. If parentHandle references a Primary Seed, then a Primary Object is
/// created; if parentHandle references a Storage Parent, then an Ordinary Object is
/// created; and if parentHandle references a Derivation Parent, then a Derived Object is generated.
#[derive(Debug, Default)]
pub struct TPM2_CreateLoaded_REQUEST {
    /// Handle of a transient storage key, a persistent storage key, TPM_RH_ENDORSEMENT,
    /// TPM_RH_OWNER, TPM_RH_PLATFORM+{PP}, or TPM_RH_NULL
    /// Auth Index: 1
    /// Auth Role: USER
    pub parentHandle: TPM_HANDLE,

    /// The sensitive data, see TPM 2.0 Part 1 Sensitive Values
    pub inSensitive: TPMS_SENSITIVE_CREATE,

    /// The public template
    pub inPublic: Vec<u8>,
}

impl TPM2_CreateLoaded_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        parentHandle: TPM_HANDLE,
        inSensitive: TPMS_SENSITIVE_CREATE,
        inPublic: Vec<u8>,
        ) -> Self {
        Self {
            parentHandle,
            inSensitive,
            inPublic,
        }
    }

}

impl TpmStructure for TPM2_CreateLoaded_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_CreateLoaded_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedObj(self.inSensitive);
        buf.writeSizedByteBuf(self.inPublic);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        buf.readSizedObj(self.inSensitive);
        self.inPublic = buf.readSizedByteBuf();
        Ok(())
    }

}

/// This command creates an object and loads it in the TPM. This command allows creation
/// of any type of object (Primary, Ordinary, or Derived) depending on the type of
/// parentHandle. If parentHandle references a Primary Seed, then a Primary Object is
/// created; if parentHandle references a Storage Parent, then an Ordinary Object is
/// created; and if parentHandle references a Derivation Parent, then a Derived Object is generated.
#[derive(Debug, Default)]
pub struct CreateLoadedResponse {
    /// Handle of type TPM_HT_TRANSIENT for created object
    pub handle: TPM_HANDLE,

    /// The sensitive area of the object (optional)
    pub outPrivate: TPM2B_PRIVATE,

    /// The public portion of the created object
    pub outPublic: TPMT_PUBLIC,

    /// The name of the created object
    pub name: Vec<u8>,
}

impl CreateLoadedResponse {
}

impl TpmStructure for CreateLoadedResponse {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<CreateLoadedResponse>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.outPrivate.toTpm(buf);
        buf.writeSizedObj(self.outPublic);
        buf.writeSizedByteBuf(self.name);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.outPrivate.initFromTpm(buf);
        buf.readSizedObj(self.outPublic);
        self.name = buf.readSizedByteBuf();
        Ok(())
    }

}

/// This command duplicates a loaded object so that it may be used in a different
/// hierarchy. The new parent key for the duplicate may be on the same or different TPM or
/// TPM_RH_NULL. Only the public area of newParentHandle is required to be loaded.
#[derive(Debug, Default)]
pub struct TPM2_Duplicate_REQUEST {
    /// Loaded object to duplicate
    /// Auth Index: 1
    /// Auth Role: DUP
    pub objectHandle: TPM_HANDLE,

    /// Shall reference the public area of an asymmetric key
    /// Auth Index: None
    pub newParentHandle: TPM_HANDLE,

    /// Optional symmetric encryption key
    /// The size for this key is set to zero when the TPM is to generate the key. This
    /// parameter may be encrypted.
    pub encryptionKeyIn: Vec<u8>,

    /// Definition for the symmetric algorithm to be used for the inner wrapper
    /// may be TPM_ALG_NULL if no inner wrapper is applied
    pub symmetricAlg: TPMT_SYM_DEF_OBJECT,
}

impl TPM2_Duplicate_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        objectHandle: TPM_HANDLE,
        newParentHandle: TPM_HANDLE,
        encryptionKeyIn: Vec<u8>,
        symmetricAlg: TPMT_SYM_DEF_OBJECT,
        ) -> Self {
        Self {
            objectHandle,
            newParentHandle,
            encryptionKeyIn,
            symmetricAlg,
        }
    }

}

impl TpmStructure for TPM2_Duplicate_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_Duplicate_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.encryptionKeyIn);
        self.symmetricAlg.toTpm(buf);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.encryptionKeyIn = buf.readSizedByteBuf();
        self.symmetricAlg.initFromTpm(buf);
        Ok(())
    }

}

/// This command duplicates a loaded object so that it may be used in a different
/// hierarchy. The new parent key for the duplicate may be on the same or different TPM or
/// TPM_RH_NULL. Only the public area of newParentHandle is required to be loaded.
#[derive(Debug, Default)]
pub struct DuplicateResponse {
    /// If the caller provided an encryption key or if symmetricAlg was TPM_ALG_NULL, then
    /// this will be the Empty Buffer; otherwise, it shall contain the TPM-generated,
    /// symmetric encryption key for the inner wrapper.
    pub encryptionKeyOut: Vec<u8>,

    /// Private area that may be encrypted by encryptionKeyIn; and may be doubly encrypted
    pub duplicate: TPM2B_PRIVATE,

    /// Seed protected by the asymmetric algorithms of new parent (NP)
    pub outSymSeed: Vec<u8>,
}

impl DuplicateResponse {
}

impl TpmStructure for DuplicateResponse {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<DuplicateResponse>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.encryptionKeyOut);
        self.duplicate.toTpm(buf);
        buf.writeSizedByteBuf(self.outSymSeed);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.encryptionKeyOut = buf.readSizedByteBuf();
        self.duplicate.initFromTpm(buf);
        self.outSymSeed = buf.readSizedByteBuf();
        Ok(())
    }

}

/// This command allows the TPM to serve in the role as a Duplication Authority. If proper
/// authorization for use of the oldParent is provided, then an HMAC key and a symmetric
/// key are recovered from inSymSeed and used to integrity check and decrypt inDuplicate.
/// A new protection seed value is generated according to the methods appropriate for
/// newParent and the blob is re-encrypted and a new integrity value is computed. The
/// re-encrypted blob is returned in outDuplicate and the symmetric key returned in outSymKey.
#[derive(Debug, Default)]
pub struct TPM2_Rewrap_REQUEST {
    /// Parent of object
    /// Auth Index: 1
    /// Auth Role: User
    pub oldParent: TPM_HANDLE,

    /// New parent of the object
    /// Auth Index: None
    pub newParent: TPM_HANDLE,

    /// An object encrypted using symmetric key derived from inSymSeed
    pub inDuplicate: TPM2B_PRIVATE,

    /// The Name of the object being rewrapped
    pub name: Vec<u8>,

    /// The seed for the symmetric key and HMAC key
    /// needs oldParent private key to recover the seed and generate the symmetric key
    pub inSymSeed: Vec<u8>,
}

impl TPM2_Rewrap_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        oldParent: TPM_HANDLE,
        newParent: TPM_HANDLE,
        inDuplicate: TPM2B_PRIVATE,
        name: Vec<u8>,
        inSymSeed: Vec<u8>,
        ) -> Self {
        Self {
            oldParent,
            newParent,
            inDuplicate,
            name,
            inSymSeed,
        }
    }

}

impl TpmStructure for TPM2_Rewrap_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_Rewrap_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.inDuplicate.toTpm(buf);
        buf.writeSizedByteBuf(self.name);
        buf.writeSizedByteBuf(self.inSymSeed);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.inDuplicate.initFromTpm(buf);
        self.name = buf.readSizedByteBuf();
        self.inSymSeed = buf.readSizedByteBuf();
        Ok(())
    }

}

/// This command allows the TPM to serve in the role as a Duplication Authority. If proper
/// authorization for use of the oldParent is provided, then an HMAC key and a symmetric
/// key are recovered from inSymSeed and used to integrity check and decrypt inDuplicate.
/// A new protection seed value is generated according to the methods appropriate for
/// newParent and the blob is re-encrypted and a new integrity value is computed. The
/// re-encrypted blob is returned in outDuplicate and the symmetric key returned in outSymKey.
#[derive(Debug, Default)]
pub struct RewrapResponse {
    /// An object encrypted using symmetric key derived from outSymSeed
    pub outDuplicate: TPM2B_PRIVATE,

    /// Seed for a symmetric key protected by newParent asymmetric key
    pub outSymSeed: Vec<u8>,
}

impl RewrapResponse {
}

impl TpmStructure for RewrapResponse {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<RewrapResponse>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.outDuplicate.toTpm(buf);
        buf.writeSizedByteBuf(self.outSymSeed);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.outDuplicate.initFromTpm(buf);
        self.outSymSeed = buf.readSizedByteBuf();
        Ok(())
    }

}

/// This command allows an object to be encrypted using the symmetric encryption values of
/// a Storage Key. After encryption, the object may be loaded and used in the new
/// hierarchy. The imported object (duplicate) may be singly encrypted, multiply
/// encrypted, or unencrypted.
#[derive(Debug, Default)]
pub struct TPM2_Import_REQUEST {
    /// The handle of the new parent for the object
    /// Auth Index: 1
    /// Auth Role: USER
    pub parentHandle: TPM_HANDLE,

    /// The optional symmetric encryption key used as the inner wrapper for duplicate
    /// If symmetricAlg is TPM_ALG_NULL, then this parameter shall be the Empty Buffer.
    pub encryptionKey: Vec<u8>,

    /// The public area of the object to be imported
    /// This is provided so that the integrity value for duplicate and the object attributes
    /// can be checked.
    /// NOTE Even if the integrity value of the object is not checked on input, the object
    /// Name is required to create the integrity value for the imported object.
    pub objectPublic: TPMT_PUBLIC,

    /// The symmetrically encrypted duplicate object that may contain an inner symmetric wrapper
    pub duplicate: TPM2B_PRIVATE,

    /// The seed for the symmetric key and HMAC key
    /// inSymSeed is encrypted/encoded using the algorithms of newParent.
    pub inSymSeed: Vec<u8>,

    /// Definition for the symmetric algorithm to use for the inner wrapper
    /// If this algorithm is TPM_ALG_NULL, no inner wrapper is present and encryptionKey shall
    /// be the Empty Buffer.
    pub symmetricAlg: TPMT_SYM_DEF_OBJECT,
}

impl TPM2_Import_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        parentHandle: TPM_HANDLE,
        encryptionKey: Vec<u8>,
        objectPublic: TPMT_PUBLIC,
        duplicate: TPM2B_PRIVATE,
        inSymSeed: Vec<u8>,
        symmetricAlg: TPMT_SYM_DEF_OBJECT,
        ) -> Self {
        Self {
            parentHandle,
            encryptionKey,
            objectPublic,
            duplicate,
            inSymSeed,
            symmetricAlg,
        }
    }

}

impl TpmStructure for TPM2_Import_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_Import_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.encryptionKey);
        buf.writeSizedObj(self.objectPublic);
        self.duplicate.toTpm(buf);
        buf.writeSizedByteBuf(self.inSymSeed);
        self.symmetricAlg.toTpm(buf);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.encryptionKey = buf.readSizedByteBuf();
        buf.readSizedObj(self.objectPublic);
        self.duplicate.initFromTpm(buf);
        self.inSymSeed = buf.readSizedByteBuf();
        self.symmetricAlg.initFromTpm(buf);
        Ok(())
    }

}

/// This command allows an object to be encrypted using the symmetric encryption values of
/// a Storage Key. After encryption, the object may be loaded and used in the new
/// hierarchy. The imported object (duplicate) may be singly encrypted, multiply
/// encrypted, or unencrypted.
#[derive(Debug, Default)]
pub struct ImportResponse {
    /// The sensitive area encrypted with the symmetric key of parentHandle
    pub outPrivate: TPM2B_PRIVATE,
}

impl ImportResponse {
}

impl TpmStructure for ImportResponse {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<ImportResponse>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.outPrivate.toTpm(buf);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.outPrivate.initFromTpm(buf);
        Ok(())
    }

}

/// This command performs RSA encryption using the indicated padding scheme according to
/// IETF RFC 8017. If the scheme of keyHandle is TPM_ALG_NULL, then the caller may use
/// inScheme to specify the padding scheme. If scheme of keyHandle is not TPM_ALG_NULL,
/// then inScheme shall either be TPM_ALG_NULL or be the same as scheme (TPM_RC_SCHEME).
#[derive(Debug, Default)]
pub struct TPM2_RSA_Encrypt_REQUEST {
    /// Reference to public portion of RSA key to use for encryption
    /// Auth Index: None
    pub keyHandle: TPM_HANDLE,

    /// Message to be encrypted
    /// NOTE 1 The data type was chosen because it limits the overall size of the input to no
    /// greater than the size of the largest RSA public key. This may be larger than allowed
    /// for keyHandle.
    pub message: Vec<u8>,

    /// Scheme selector

    /// The padding scheme to use if scheme associated with keyHandle is TPM_ALG_NULL
    /// One of: TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA,
    /// TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA,
    /// TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES,
    /// TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME.
    pub inScheme: Option<TPMU_ASYM_SCHEME>,

    /// Optional label L to be associated with the message
    /// Size of the buffer is zero if no label is present
    /// NOTE 2 See description of label above.
    pub label: Vec<u8>,
}

impl TPM2_RSA_Encrypt_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        keyHandle: TPM_HANDLE,
        message: Vec<u8>,
        inScheme: Option<TPMU_ASYM_SCHEME>,
        label: Vec<u8>,
        ) -> Self {
        Self {
            keyHandle,
            message,
            inScheme,
            label,
        }
    }

}

impl TpmStructure for TPM2_RSA_Encrypt_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_RSA_Encrypt_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.message);
        buf.writeShort(self.inScheme.unwrap().GetUnionSelector().unwrap());
        self.inScheme.unwrap().toTpm(buf);
        buf.writeSizedByteBuf(self.label);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.message = buf.readSizedByteBuf();
        let r#inSchemeScheme: TPM_ALG_ID = buf.readShort();
        self.inScheme = TPMU_ASYM_SCHEME::create(r#inSchemeScheme)?;
        self.inScheme.unwrap().initFromTpm(buf);
        self.label = buf.readSizedByteBuf();
        Ok(())
    }

}

/// This command performs RSA encryption using the indicated padding scheme according to
/// IETF RFC 8017. If the scheme of keyHandle is TPM_ALG_NULL, then the caller may use
/// inScheme to specify the padding scheme. If scheme of keyHandle is not TPM_ALG_NULL,
/// then inScheme shall either be TPM_ALG_NULL or be the same as scheme (TPM_RC_SCHEME).
#[derive(Debug, Default)]
pub struct RSA_EncryptResponse {
    /// Encrypted output
    pub outData: Vec<u8>,
}

impl RSA_EncryptResponse {
}

impl TpmStructure for RSA_EncryptResponse {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<RSA_EncryptResponse>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.outData);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.outData = buf.readSizedByteBuf();
        Ok(())
    }

}

/// This command performs RSA decryption using the indicated padding scheme according to
/// IETF RFC 8017 ((PKCS#1).
#[derive(Debug, Default)]
pub struct TPM2_RSA_Decrypt_REQUEST {
    /// RSA key to use for decryption
    /// Auth Index: 1
    /// Auth Role: USER
    pub keyHandle: TPM_HANDLE,

    /// Cipher text to be decrypted
    /// NOTE An encrypted RSA data block is the size of the public modulus.
    pub cipherText: Vec<u8>,

    /// Scheme selector

    /// The padding scheme to use if scheme associated with keyHandle is TPM_ALG_NULL
    /// One of: TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA,
    /// TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA,
    /// TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES,
    /// TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME.
    pub inScheme: Option<TPMU_ASYM_SCHEME>,

    /// Label whose association with the message is to be verified
    pub label: Vec<u8>,
}

impl TPM2_RSA_Decrypt_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        keyHandle: TPM_HANDLE,
        cipherText: Vec<u8>,
        inScheme: Option<TPMU_ASYM_SCHEME>,
        label: Vec<u8>,
        ) -> Self {
        Self {
            keyHandle,
            cipherText,
            inScheme,
            label,
        }
    }

}

impl TpmStructure for TPM2_RSA_Decrypt_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_RSA_Decrypt_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.cipherText);
        buf.writeShort(self.inScheme.unwrap().GetUnionSelector().unwrap());
        self.inScheme.unwrap().toTpm(buf);
        buf.writeSizedByteBuf(self.label);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.cipherText = buf.readSizedByteBuf();
        let r#inSchemeScheme: TPM_ALG_ID = buf.readShort();
        self.inScheme = TPMU_ASYM_SCHEME::create(r#inSchemeScheme)?;
        self.inScheme.unwrap().initFromTpm(buf);
        self.label = buf.readSizedByteBuf();
        Ok(())
    }

}

/// This command performs RSA decryption using the indicated padding scheme according to
/// IETF RFC 8017 ((PKCS#1).
#[derive(Debug, Default)]
pub struct RSA_DecryptResponse {
    /// Decrypted output
    pub message: Vec<u8>,
}

impl RSA_DecryptResponse {
}

impl TpmStructure for RSA_DecryptResponse {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<RSA_DecryptResponse>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.message);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.message = buf.readSizedByteBuf();
        Ok(())
    }

}

/// This command uses the TPM to generate an ephemeral key pair (de, Qe where Qe [de]G).
/// It uses the private ephemeral key and a loaded public key (QS) to compute the shared
/// secret value (P [hde]QS).
#[derive(Debug, Default)]
pub struct TPM2_ECDH_KeyGen_REQUEST {
    /// Handle of a loaded ECC key public area.
    /// Auth Index: None
    pub keyHandle: TPM_HANDLE,
}

impl TPM2_ECDH_KeyGen_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        keyHandle: TPM_HANDLE,
        ) -> Self {
        Self {
            keyHandle,
        }
    }

}

impl TpmStructure for TPM2_ECDH_KeyGen_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_ECDH_KeyGen_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        Ok(())
    }

}

/// This command uses the TPM to generate an ephemeral key pair (de, Qe where Qe [de]G).
/// It uses the private ephemeral key and a loaded public key (QS) to compute the shared
/// secret value (P [hde]QS).
#[derive(Debug, Default)]
pub struct ECDH_KeyGenResponse {
    /// Results of P h[de]Qs
    pub zPoint: TPMS_ECC_POINT,

    /// Generated ephemeral public point (Qe)
    pub pubPoint: TPMS_ECC_POINT,
}

impl ECDH_KeyGenResponse {
}

impl TpmStructure for ECDH_KeyGenResponse {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<ECDH_KeyGenResponse>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedObj(self.zPoint);
        buf.writeSizedObj(self.pubPoint);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        buf.readSizedObj(self.zPoint);
        buf.readSizedObj(self.pubPoint);
        Ok(())
    }

}

/// This command uses the TPM to recover the Z value from a public point (QB) and a
/// private key (ds). It will perform the multiplication of the provided inPoint (QB) with
/// the private key (ds) and return the coordinates of the resultant point (Z = (xZ , yZ)
/// [hds]QB; where h is the cofactor of the curve).
#[derive(Debug, Default)]
pub struct TPM2_ECDH_ZGen_REQUEST {
    /// Handle of a loaded ECC key
    /// Auth Index: 1
    /// Auth Role: USER
    pub keyHandle: TPM_HANDLE,

    /// A public key
    pub inPoint: TPMS_ECC_POINT,
}

impl TPM2_ECDH_ZGen_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        keyHandle: TPM_HANDLE,
        inPoint: TPMS_ECC_POINT,
        ) -> Self {
        Self {
            keyHandle,
            inPoint,
        }
    }

}

impl TpmStructure for TPM2_ECDH_ZGen_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_ECDH_ZGen_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedObj(self.inPoint);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        buf.readSizedObj(self.inPoint);
        Ok(())
    }

}

/// This command uses the TPM to recover the Z value from a public point (QB) and a
/// private key (ds). It will perform the multiplication of the provided inPoint (QB) with
/// the private key (ds) and return the coordinates of the resultant point (Z = (xZ , yZ)
/// [hds]QB; where h is the cofactor of the curve).
#[derive(Debug, Default)]
pub struct ECDH_ZGenResponse {
    /// X and Y coordinates of the product of the multiplication Z = (xZ , yZ) [hdS]QB
    pub outPoint: TPMS_ECC_POINT,
}

impl ECDH_ZGenResponse {
}

impl TpmStructure for ECDH_ZGenResponse {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<ECDH_ZGenResponse>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedObj(self.outPoint);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        buf.readSizedObj(self.outPoint);
        Ok(())
    }

}

/// This command returns the parameters of an ECC curve identified by its TCG-assigned curveID.
#[derive(Debug, Default)]
pub struct TPM2_ECC_Parameters_REQUEST {
    /// Parameter set selector
    pub curveID: TPM_ECC_CURVE,
}

impl TPM2_ECC_Parameters_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        curveID: TPM_ECC_CURVE,
        ) -> Self {
        Self {
            curveID,
        }
    }

}

impl TpmStructure for TPM2_ECC_Parameters_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_ECC_Parameters_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeShort(self.curveID);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.curveID = buf.readShort();
        Ok(())
    }

}

/// This command returns the parameters of an ECC curve identified by its TCG-assigned curveID.
#[derive(Debug, Default)]
pub struct ECC_ParametersResponse {
    /// ECC parameters for the selected curve
    pub parameters: TPMS_ALGORITHM_DETAIL_ECC,
}

impl ECC_ParametersResponse {
}

impl TpmStructure for ECC_ParametersResponse {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<ECC_ParametersResponse>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.parameters.toTpm(buf);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.parameters.initFromTpm(buf);
        Ok(())
    }

}

/// This command supports two-phase key exchange protocols. The command is used in
/// combination with TPM2_EC_Ephemeral(). TPM2_EC_Ephemeral() generates an ephemeral key
/// and returns the public point of that ephemeral key along with a numeric value that
/// allows the TPM to regenerate the associated private key.
#[derive(Debug, Default)]
pub struct TPM2_ZGen_2Phase_REQUEST {
    /// Handle of an unrestricted decryption key ECC
    /// The private key referenced by this handle is used as dS,A
    /// Auth Index: 1
    /// Auth Role: USER
    pub keyA: TPM_HANDLE,

    /// Other partys static public key (Qs,B = (Xs,B, Ys,B))
    pub inQsB: TPMS_ECC_POINT,

    /// Other party's ephemeral public key (Qe,B = (Xe,B, Ye,B))
    pub inQeB: TPMS_ECC_POINT,

    /// The key exchange scheme
    pub inScheme: TPM_ALG_ID,

    /// Value returned by TPM2_EC_Ephemeral()
    pub counter: u16,
}

impl TPM2_ZGen_2Phase_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        keyA: TPM_HANDLE,
        inQsB: TPMS_ECC_POINT,
        inQeB: TPMS_ECC_POINT,
        inScheme: TPM_ALG_ID,
        counter: u16,
        ) -> Self {
        Self {
            keyA,
            inQsB,
            inQeB,
            inScheme,
            counter,
        }
    }

}

impl TpmStructure for TPM2_ZGen_2Phase_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_ZGen_2Phase_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedObj(self.inQsB);
        buf.writeSizedObj(self.inQeB);
        buf.writeShort(self.inScheme);
        buf.writeShort(self.counter);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        buf.readSizedObj(self.inQsB);
        buf.readSizedObj(self.inQeB);
        self.inScheme = buf.readShort();
        self.counter = buf.readShort();
        Ok(())
    }

}

/// This command supports two-phase key exchange protocols. The command is used in
/// combination with TPM2_EC_Ephemeral(). TPM2_EC_Ephemeral() generates an ephemeral key
/// and returns the public point of that ephemeral key along with a numeric value that
/// allows the TPM to regenerate the associated private key.
#[derive(Debug, Default)]
pub struct ZGen_2PhaseResponse {
    /// X and Y coordinates of the computed value (scheme dependent)
    pub outZ1: TPMS_ECC_POINT,

    /// X and Y coordinates of the second computed value (scheme dependent)
    pub outZ2: TPMS_ECC_POINT,
}

impl ZGen_2PhaseResponse {
}

impl TpmStructure for ZGen_2PhaseResponse {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<ZGen_2PhaseResponse>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedObj(self.outZ1);
        buf.writeSizedObj(self.outZ2);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        buf.readSizedObj(self.outZ1);
        buf.readSizedObj(self.outZ2);
        Ok(())
    }

}

/// This command performs ECC encryption as described in Part 1, Annex D.
#[derive(Debug, Default)]
pub struct TPM2_ECC_Encrypt_REQUEST {
    /// Reference to public portion of ECC key to use for encryption
    /// Auth Index: None
    pub keyHandle: TPM_HANDLE,

    /// Plaintext to be encrypted
    pub plainText: Vec<u8>,

    /// Scheme selector

    /// The KDF to use if scheme associated with keyHandle is TPM_ALG_NULL
    /// One of: TPMS_KDF_SCHEME_MGF1, TPMS_KDF_SCHEME_KDF1_SP800_56A, TPMS_KDF_SCHEME_KDF2,
    /// TPMS_KDF_SCHEME_KDF1_SP800_108, TPMS_SCHEME_HASH, TPMS_NULL_KDF_SCHEME.
    pub inScheme: Option<TPMU_KDF_SCHEME>,
}

impl TPM2_ECC_Encrypt_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        keyHandle: TPM_HANDLE,
        plainText: Vec<u8>,
        inScheme: Option<TPMU_KDF_SCHEME>,
        ) -> Self {
        Self {
            keyHandle,
            plainText,
            inScheme,
        }
    }

}

impl TpmStructure for TPM2_ECC_Encrypt_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_ECC_Encrypt_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.plainText);
        buf.writeShort(self.inScheme.unwrap().GetUnionSelector().unwrap());
        self.inScheme.unwrap().toTpm(buf);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.plainText = buf.readSizedByteBuf();
        let r#inSchemeScheme: TPM_ALG_ID = buf.readShort();
        self.inScheme = TPMU_KDF_SCHEME::create(r#inSchemeScheme)?;
        self.inScheme.unwrap().initFromTpm(buf);
        Ok(())
    }

}

/// This command performs ECC encryption as described in Part 1, Annex D.
#[derive(Debug, Default)]
pub struct ECC_EncryptResponse {
    /// The public ephemeral key used for ECDH
    pub C1: TPMS_ECC_POINT,

    /// The data block produced by the XOR process
    pub C2: Vec<u8>,

    /// The integrity value
    pub C3: Vec<u8>,
}

impl ECC_EncryptResponse {
}

impl TpmStructure for ECC_EncryptResponse {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<ECC_EncryptResponse>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedObj(self.C1);
        buf.writeSizedByteBuf(self.C2);
        buf.writeSizedByteBuf(self.C3);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        buf.readSizedObj(self.C1);
        self.C2 = buf.readSizedByteBuf();
        self.C3 = buf.readSizedByteBuf();
        Ok(())
    }

}

/// This command performs ECC decryption.
#[derive(Debug, Default)]
pub struct TPM2_ECC_Decrypt_REQUEST {
    /// ECC key to use for decryption
    /// Auth Index: 1
    /// Auth Role: USER
    pub keyHandle: TPM_HANDLE,

    /// The public ephemeral key used for ECDH
    pub C1: TPMS_ECC_POINT,

    /// The data block produced by the XOR process
    pub C2: Vec<u8>,

    /// The integrity value
    pub C3: Vec<u8>,

    /// Scheme selector

    /// The KDF to use if scheme associated with keyHandle is TPM_ALG_NULL
    /// One of: TPMS_KDF_SCHEME_MGF1, TPMS_KDF_SCHEME_KDF1_SP800_56A, TPMS_KDF_SCHEME_KDF2,
    /// TPMS_KDF_SCHEME_KDF1_SP800_108, TPMS_SCHEME_HASH, TPMS_NULL_KDF_SCHEME.
    pub inScheme: Option<TPMU_KDF_SCHEME>,
}

impl TPM2_ECC_Decrypt_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        keyHandle: TPM_HANDLE,
        C1: TPMS_ECC_POINT,
        C2: Vec<u8>,
        C3: Vec<u8>,
        inScheme: Option<TPMU_KDF_SCHEME>,
        ) -> Self {
        Self {
            keyHandle,
            C1,
            C2,
            C3,
            inScheme,
        }
    }

}

impl TpmStructure for TPM2_ECC_Decrypt_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_ECC_Decrypt_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedObj(self.C1);
        buf.writeSizedByteBuf(self.C2);
        buf.writeSizedByteBuf(self.C3);
        buf.writeShort(self.inScheme.unwrap().GetUnionSelector().unwrap());
        self.inScheme.unwrap().toTpm(buf);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        buf.readSizedObj(self.C1);
        self.C2 = buf.readSizedByteBuf();
        self.C3 = buf.readSizedByteBuf();
        let r#inSchemeScheme: TPM_ALG_ID = buf.readShort();
        self.inScheme = TPMU_KDF_SCHEME::create(r#inSchemeScheme)?;
        self.inScheme.unwrap().initFromTpm(buf);
        Ok(())
    }

}

/// This command performs ECC decryption.
#[derive(Debug, Default)]
pub struct ECC_DecryptResponse {
    /// Decrypted output
    pub plainText: Vec<u8>,
}

impl ECC_DecryptResponse {
}

impl TpmStructure for ECC_DecryptResponse {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<ECC_DecryptResponse>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.plainText);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.plainText = buf.readSizedByteBuf();
        Ok(())
    }

}

/// NOTE 1 This command is deprecated, and TPM2_EncryptDecrypt2() is preferred. This
/// should be reflected in platform-specific specifications.
#[derive(Debug, Default)]
pub struct TPM2_EncryptDecrypt_REQUEST {
    /// The symmetric key used for the operation
    /// Auth Index: 1
    /// Auth Role: USER
    pub keyHandle: TPM_HANDLE,

    /// If YES, then the operation is decryption; if NO, the operation is encryption
    pub decrypt: u8,

    /// Symmetric encryption/decryption mode
    /// this field shall match the default mode of the key or be TPM_ALG_NULL.
    pub mode: TPM_ALG_ID,

    /// An initial value as required by the algorithm
    pub ivIn: Vec<u8>,

    /// The data to be encrypted/decrypted
    pub inData: Vec<u8>,
}

impl TPM2_EncryptDecrypt_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        keyHandle: TPM_HANDLE,
        decrypt: u8,
        mode: TPM_ALG_ID,
        ivIn: Vec<u8>,
        inData: Vec<u8>,
        ) -> Self {
        Self {
            keyHandle,
            decrypt,
            mode,
            ivIn,
            inData,
        }
    }

}

impl TpmStructure for TPM2_EncryptDecrypt_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_EncryptDecrypt_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeByte(self.decrypt);
        buf.writeShort(self.mode);
        buf.writeSizedByteBuf(self.ivIn);
        buf.writeSizedByteBuf(self.inData);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.decrypt = buf.readByte();
        self.mode = buf.readShort();
        self.ivIn = buf.readSizedByteBuf();
        self.inData = buf.readSizedByteBuf();
        Ok(())
    }

}

/// NOTE 1 This command is deprecated, and TPM2_EncryptDecrypt2() is preferred. This
/// should be reflected in platform-specific specifications.
#[derive(Debug, Default)]
pub struct EncryptDecryptResponse {
    /// Encrypted or decrypted output
    pub outData: Vec<u8>,

    /// Chaining value to use for IV in next round
    pub ivOut: Vec<u8>,
}

impl EncryptDecryptResponse {
}

impl TpmStructure for EncryptDecryptResponse {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<EncryptDecryptResponse>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.outData);
        buf.writeSizedByteBuf(self.ivOut);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.outData = buf.readSizedByteBuf();
        self.ivOut = buf.readSizedByteBuf();
        Ok(())
    }

}

/// This command is identical to TPM2_EncryptDecrypt(), except that the inData parameter
/// is the first parameter. This permits inData to be parameter encrypted.
#[derive(Debug, Default)]
pub struct TPM2_EncryptDecrypt2_REQUEST {
    /// The symmetric key used for the operation
    /// Auth Index: 1
    /// Auth Role: USER
    pub keyHandle: TPM_HANDLE,

    /// The data to be encrypted/decrypted
    pub inData: Vec<u8>,

    /// If YES, then the operation is decryption; if NO, the operation is encryption
    pub decrypt: u8,

    /// Symmetric mode
    /// this field shall match the default mode of the key or be TPM_ALG_NULL.
    pub mode: TPM_ALG_ID,

    /// An initial value as required by the algorithm
    pub ivIn: Vec<u8>,
}

impl TPM2_EncryptDecrypt2_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        keyHandle: TPM_HANDLE,
        inData: Vec<u8>,
        decrypt: u8,
        mode: TPM_ALG_ID,
        ivIn: Vec<u8>,
        ) -> Self {
        Self {
            keyHandle,
            inData,
            decrypt,
            mode,
            ivIn,
        }
    }

}

impl TpmStructure for TPM2_EncryptDecrypt2_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_EncryptDecrypt2_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.inData);
        buf.writeByte(self.decrypt);
        buf.writeShort(self.mode);
        buf.writeSizedByteBuf(self.ivIn);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.inData = buf.readSizedByteBuf();
        self.decrypt = buf.readByte();
        self.mode = buf.readShort();
        self.ivIn = buf.readSizedByteBuf();
        Ok(())
    }

}

/// This command is identical to TPM2_EncryptDecrypt(), except that the inData parameter
/// is the first parameter. This permits inData to be parameter encrypted.
#[derive(Debug, Default)]
pub struct EncryptDecrypt2Response {
    /// Encrypted or decrypted output
    pub outData: Vec<u8>,

    /// Chaining value to use for IV in next round
    pub ivOut: Vec<u8>,
}

impl EncryptDecrypt2Response {
}

impl TpmStructure for EncryptDecrypt2Response {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<EncryptDecrypt2Response>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.outData);
        buf.writeSizedByteBuf(self.ivOut);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.outData = buf.readSizedByteBuf();
        self.ivOut = buf.readSizedByteBuf();
        Ok(())
    }

}

/// This command performs a hash operation on a data buffer and returns the results.
#[derive(Debug, Default)]
pub struct TPM2_Hash_REQUEST {
    /// Data to be hashed
    pub data: Vec<u8>,

    /// Algorithm for the hash being computed shall not be TPM_ALG_NULL
    pub hashAlg: TPM_ALG_ID,

    /// Hierarchy to use for the ticket (TPM_RH_NULL allowed)
    pub hierarchy: TPM_HANDLE,
}

impl TPM2_Hash_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        data: Vec<u8>,
        hashAlg: TPM_ALG_ID,
        hierarchy: TPM_HANDLE,
        ) -> Self {
        Self {
            data,
            hashAlg,
            hierarchy,
        }
    }

}

impl TpmStructure for TPM2_Hash_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_Hash_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.data);
        buf.writeShort(self.hashAlg);
        self.hierarchy.toTpm(buf);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.data = buf.readSizedByteBuf();
        self.hashAlg = buf.readShort();
        self.hierarchy.initFromTpm(buf);
        Ok(())
    }

}

/// This command performs a hash operation on a data buffer and returns the results.
#[derive(Debug, Default)]
pub struct HashResponse {
    /// Results
    pub outHash: Vec<u8>,

    /// Ticket indicating that the sequence of octets used to compute outDigest did not start
    /// with TPM_GENERATED_VALUE
    /// will be a NULL ticket if the digest may not be signed with a restricted key
    pub validation: TPMT_TK_HASHCHECK,
}

impl HashResponse {
}

impl TpmStructure for HashResponse {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<HashResponse>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.outHash);
        self.validation.toTpm(buf);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.outHash = buf.readSizedByteBuf();
        self.validation.initFromTpm(buf);
        Ok(())
    }

}

/// This command performs an HMAC on the supplied data using the indicated hash algorithm.
#[derive(Debug, Default)]
pub struct TPM2_HMAC_REQUEST {
    /// Handle for the symmetric signing key providing the HMAC key
    /// Auth Index: 1
    /// Auth Role: USER
    pub handle: TPM_HANDLE,

    /// HMAC data
    pub buffer: Vec<u8>,

    /// Algorithm to use for HMAC
    pub hashAlg: TPM_ALG_ID,
}

impl TPM2_HMAC_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        handle: TPM_HANDLE,
        buffer: Vec<u8>,
        hashAlg: TPM_ALG_ID,
        ) -> Self {
        Self {
            handle,
            buffer,
            hashAlg,
        }
    }

}

impl TpmStructure for TPM2_HMAC_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_HMAC_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.buffer);
        buf.writeShort(self.hashAlg);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.buffer = buf.readSizedByteBuf();
        self.hashAlg = buf.readShort();
        Ok(())
    }

}

/// This command performs an HMAC on the supplied data using the indicated hash algorithm.
#[derive(Debug, Default)]
pub struct HMACResponse {
    /// The returned HMAC in a sized buffer
    pub outHMAC: Vec<u8>,
}

impl HMACResponse {
}

impl TpmStructure for HMACResponse {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<HMACResponse>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.outHMAC);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.outHMAC = buf.readSizedByteBuf();
        Ok(())
    }

}

/// This command performs an HMAC or a block cipher MAC on the supplied data using the
/// indicated algorithm.
#[derive(Debug, Default)]
pub struct TPM2_MAC_REQUEST {
    /// Handle for the symmetric signing key providing the MAC key
    /// Auth Index: 1
    /// Auth Role: USER
    pub handle: TPM_HANDLE,

    /// MAC data
    pub buffer: Vec<u8>,

    /// Algorithm to use for MAC
    pub inScheme: TPM_ALG_ID,
}

impl TPM2_MAC_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        handle: TPM_HANDLE,
        buffer: Vec<u8>,
        inScheme: TPM_ALG_ID,
        ) -> Self {
        Self {
            handle,
            buffer,
            inScheme,
        }
    }

}

impl TpmStructure for TPM2_MAC_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_MAC_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.buffer);
        buf.writeShort(self.inScheme);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.buffer = buf.readSizedByteBuf();
        self.inScheme = buf.readShort();
        Ok(())
    }

}

/// This command performs an HMAC or a block cipher MAC on the supplied data using the
/// indicated algorithm.
#[derive(Debug, Default)]
pub struct MACResponse {
    /// The returned MAC in a sized buffer
    pub outMAC: Vec<u8>,
}

impl MACResponse {
}

impl TpmStructure for MACResponse {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<MACResponse>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.outMAC);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.outMAC = buf.readSizedByteBuf();
        Ok(())
    }

}

/// This command returns the next bytesRequested octets from the random number generator (RNG).
#[derive(Debug, Default)]
pub struct TPM2_GetRandom_REQUEST {
    /// Number of octets to return
    pub bytesRequested: u16,
}

impl TPM2_GetRandom_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        bytesRequested: u16,
        ) -> Self {
        Self {
            bytesRequested,
        }
    }

}

impl TpmStructure for TPM2_GetRandom_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_GetRandom_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeShort(self.bytesRequested);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.bytesRequested = buf.readShort();
        Ok(())
    }

}

/// This command returns the next bytesRequested octets from the random number generator (RNG).
#[derive(Debug, Default)]
pub struct GetRandomResponse {
    /// The random octets
    pub randomBytes: Vec<u8>,
}

impl GetRandomResponse {
}

impl TpmStructure for GetRandomResponse {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<GetRandomResponse>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.randomBytes);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.randomBytes = buf.readSizedByteBuf();
        Ok(())
    }

}

/// This command is used to add "additional information" to the RNG state.
#[derive(Debug, Default)]
pub struct TPM2_StirRandom_REQUEST {
    /// Additional information
    pub inData: Vec<u8>,
}

impl TPM2_StirRandom_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        inData: Vec<u8>,
        ) -> Self {
        Self {
            inData,
        }
    }

}

impl TpmStructure for TPM2_StirRandom_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_StirRandom_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.inData);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.inData = buf.readSizedByteBuf();
        Ok(())
    }

}

/// This command starts an HMAC sequence. The TPM will create and initialize an HMAC
/// sequence structure, assign a handle to the sequence, and set the authValue of the
/// sequence object to the value in auth.
#[derive(Debug, Default)]
pub struct TPM2_HMAC_Start_REQUEST {
    /// Handle of an HMAC key
    /// Auth Index: 1
    /// Auth Role: USER
    pub handle: TPM_HANDLE,

    /// Authorization value for subsequent use of the sequence
    pub auth: Vec<u8>,

    /// The hash algorithm to use for the HMAC
    pub hashAlg: TPM_ALG_ID,
}

impl TPM2_HMAC_Start_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        handle: TPM_HANDLE,
        auth: Vec<u8>,
        hashAlg: TPM_ALG_ID,
        ) -> Self {
        Self {
            handle,
            auth,
            hashAlg,
        }
    }

}

impl TpmStructure for TPM2_HMAC_Start_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_HMAC_Start_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.auth);
        buf.writeShort(self.hashAlg);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.auth = buf.readSizedByteBuf();
        self.hashAlg = buf.readShort();
        Ok(())
    }

}

/// This command starts an HMAC sequence. The TPM will create and initialize an HMAC
/// sequence structure, assign a handle to the sequence, and set the authValue of the
/// sequence object to the value in auth.
#[derive(Debug, Default)]
pub struct HMAC_StartResponse {
    /// A handle to reference the sequence
    pub handle: TPM_HANDLE,
}

impl HMAC_StartResponse {
}

impl TpmStructure for HMAC_StartResponse {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<HMAC_StartResponse>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        Ok(())
    }

}

/// This command starts a MAC sequence. The TPM will create and initialize a MAC sequence
/// structure, assign a handle to the sequence, and set the authValue of the sequence
/// object to the value in auth.
#[derive(Debug, Default)]
pub struct TPM2_MAC_Start_REQUEST {
    /// Handle of a MAC key
    /// Auth Index: 1
    /// Auth Role: USER
    pub handle: TPM_HANDLE,

    /// Authorization value for subsequent use of the sequence
    pub auth: Vec<u8>,

    /// The algorithm to use for the MAC
    pub inScheme: TPM_ALG_ID,
}

impl TPM2_MAC_Start_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        handle: TPM_HANDLE,
        auth: Vec<u8>,
        inScheme: TPM_ALG_ID,
        ) -> Self {
        Self {
            handle,
            auth,
            inScheme,
        }
    }

}

impl TpmStructure for TPM2_MAC_Start_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_MAC_Start_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.auth);
        buf.writeShort(self.inScheme);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.auth = buf.readSizedByteBuf();
        self.inScheme = buf.readShort();
        Ok(())
    }

}

/// This command starts a MAC sequence. The TPM will create and initialize a MAC sequence
/// structure, assign a handle to the sequence, and set the authValue of the sequence
/// object to the value in auth.
#[derive(Debug, Default)]
pub struct MAC_StartResponse {
    /// A handle to reference the sequence
    pub handle: TPM_HANDLE,
}

impl MAC_StartResponse {
}

impl TpmStructure for MAC_StartResponse {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<MAC_StartResponse>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        Ok(())
    }

}

/// This command starts a hash or an Event Sequence. If hashAlg is an implemented hash,
/// then a hash sequence is started. If hashAlg is TPM_ALG_NULL, then an Event Sequence is
/// started. If hashAlg is neither an implemented algorithm nor TPM_ALG_NULL, then the TPM
/// shall return TPM_RC_HASH.
#[derive(Debug, Default)]
pub struct TPM2_HashSequenceStart_REQUEST {
    /// Authorization value for subsequent use of the sequence
    pub auth: Vec<u8>,

    /// The hash algorithm to use for the hash sequence
    /// An Event Sequence starts if this is TPM_ALG_NULL.
    pub hashAlg: TPM_ALG_ID,
}

impl TPM2_HashSequenceStart_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        auth: Vec<u8>,
        hashAlg: TPM_ALG_ID,
        ) -> Self {
        Self {
            auth,
            hashAlg,
        }
    }

}

impl TpmStructure for TPM2_HashSequenceStart_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_HashSequenceStart_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.auth);
        buf.writeShort(self.hashAlg);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.auth = buf.readSizedByteBuf();
        self.hashAlg = buf.readShort();
        Ok(())
    }

}

/// This command starts a hash or an Event Sequence. If hashAlg is an implemented hash,
/// then a hash sequence is started. If hashAlg is TPM_ALG_NULL, then an Event Sequence is
/// started. If hashAlg is neither an implemented algorithm nor TPM_ALG_NULL, then the TPM
/// shall return TPM_RC_HASH.
#[derive(Debug, Default)]
pub struct HashSequenceStartResponse {
    /// A handle to reference the sequence
    pub handle: TPM_HANDLE,
}

impl HashSequenceStartResponse {
}

impl TpmStructure for HashSequenceStartResponse {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<HashSequenceStartResponse>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        Ok(())
    }

}

/// This command is used to add data to a hash or HMAC sequence. The amount of data in
/// buffer may be any size up to the limits of the TPM.
#[derive(Debug, Default)]
pub struct TPM2_SequenceUpdate_REQUEST {
    /// Handle for the sequence object
    /// Auth Index: 1
    /// Auth Role: USER
    pub sequenceHandle: TPM_HANDLE,

    /// Data to be added to hash
    pub buffer: Vec<u8>,
}

impl TPM2_SequenceUpdate_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        sequenceHandle: TPM_HANDLE,
        buffer: Vec<u8>,
        ) -> Self {
        Self {
            sequenceHandle,
            buffer,
        }
    }

}

impl TpmStructure for TPM2_SequenceUpdate_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_SequenceUpdate_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.buffer);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.buffer = buf.readSizedByteBuf();
        Ok(())
    }

}

/// This command adds the last part of data, if any, to a hash/HMAC sequence and returns
/// the result.
#[derive(Debug, Default)]
pub struct TPM2_SequenceComplete_REQUEST {
    /// Authorization for the sequence
    /// Auth Index: 1
    /// Auth Role: USER
    pub sequenceHandle: TPM_HANDLE,

    /// Data to be added to the hash/HMAC
    pub buffer: Vec<u8>,

    /// Hierarchy of the ticket for a hash
    pub hierarchy: TPM_HANDLE,
}

impl TPM2_SequenceComplete_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        sequenceHandle: TPM_HANDLE,
        buffer: Vec<u8>,
        hierarchy: TPM_HANDLE,
        ) -> Self {
        Self {
            sequenceHandle,
            buffer,
            hierarchy,
        }
    }

}

impl TpmStructure for TPM2_SequenceComplete_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_SequenceComplete_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.buffer);
        self.hierarchy.toTpm(buf);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.buffer = buf.readSizedByteBuf();
        self.hierarchy.initFromTpm(buf);
        Ok(())
    }

}

/// This command adds the last part of data, if any, to a hash/HMAC sequence and returns
/// the result.
#[derive(Debug, Default)]
pub struct SequenceCompleteResponse {
    /// The returned HMAC or digest in a sized buffer
    pub result: Vec<u8>,

    /// Ticket indicating that the sequence of octets used to compute outDigest did not start
    /// with TPM_GENERATED_VALUE
    /// This is a NULL Ticket when the sequence is HMAC.
    pub validation: TPMT_TK_HASHCHECK,
}

impl SequenceCompleteResponse {
}

impl TpmStructure for SequenceCompleteResponse {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<SequenceCompleteResponse>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.result);
        self.validation.toTpm(buf);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.result = buf.readSizedByteBuf();
        self.validation.initFromTpm(buf);
        Ok(())
    }

}

/// This command adds the last part of data, if any, to an Event Sequence and returns the
/// result in a digest list. If pcrHandle references a PCR and not TPM_RH_NULL, then the
/// returned digest list is processed in the same manner as the digest list input
/// parameter to TPM2_PCR_Extend(). That is, if a bank contains a PCR associated with
/// pcrHandle, it is extended with the associated digest value from the list.
#[derive(Debug, Default)]
pub struct TPM2_EventSequenceComplete_REQUEST {
    /// PCR to be extended with the Event data
    /// Auth Index: 1
    /// Auth Role: USER
    pub pcrHandle: TPM_HANDLE,

    /// Authorization for the sequence
    /// Auth Index: 2
    /// Auth Role: USER
    pub sequenceHandle: TPM_HANDLE,

    /// Data to be added to the Event
    pub buffer: Vec<u8>,
}

impl TPM2_EventSequenceComplete_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        pcrHandle: TPM_HANDLE,
        sequenceHandle: TPM_HANDLE,
        buffer: Vec<u8>,
        ) -> Self {
        Self {
            pcrHandle,
            sequenceHandle,
            buffer,
        }
    }

}

impl TpmStructure for TPM2_EventSequenceComplete_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_EventSequenceComplete_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.buffer);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.buffer = buf.readSizedByteBuf();
        Ok(())
    }

}

/// This command adds the last part of data, if any, to an Event Sequence and returns the
/// result in a digest list. If pcrHandle references a PCR and not TPM_RH_NULL, then the
/// returned digest list is processed in the same manner as the digest list input
/// parameter to TPM2_PCR_Extend(). That is, if a bank contains a PCR associated with
/// pcrHandle, it is extended with the associated digest value from the list.
#[derive(Debug, Default)]
pub struct EventSequenceCompleteResponse {
    /// List of digests computed for the PCR
    pub results: Vec<TPMT_HA>,
}

impl EventSequenceCompleteResponse {
}

impl TpmStructure for EventSequenceCompleteResponse {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<EventSequenceCompleteResponse>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeObjArr(self.results);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        buf.readObjArr(self.results);
        Ok(())
    }

}

/// The purpose of this command is to prove that an object with a specific Name is loaded
/// in the TPM. By certifying that the object is loaded, the TPM warrants that a public
/// area with a given Name is self-consistent and associated with a valid sensitive area.
/// If a relying party has a public area that has the same Name as a Name certified with
/// this command, then the values in that public area are correct.
#[derive(Debug, Default)]
pub struct TPM2_Certify_REQUEST {
    /// Handle of the object to be certified
    /// Auth Index: 1
    /// Auth Role: ADMIN
    pub objectHandle: TPM_HANDLE,

    /// Handle of the key used to sign the attestation structure
    /// Auth Index: 2
    /// Auth Role: USER
    pub signHandle: TPM_HANDLE,

    /// User provided qualifying data
    pub qualifyingData: Vec<u8>,

    /// Scheme selector

    /// Signing scheme to use if the scheme for signHandle is TPM_ALG_NULL
    /// One of: TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA,
    /// TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR,
    /// TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME.
    pub inScheme: Option<TPMU_SIG_SCHEME>,
}

impl TPM2_Certify_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        objectHandle: TPM_HANDLE,
        signHandle: TPM_HANDLE,
        qualifyingData: Vec<u8>,
        inScheme: Option<TPMU_SIG_SCHEME>,
        ) -> Self {
        Self {
            objectHandle,
            signHandle,
            qualifyingData,
            inScheme,
        }
    }

}

impl TpmStructure for TPM2_Certify_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_Certify_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.qualifyingData);
        buf.writeShort(self.inScheme.unwrap().GetUnionSelector().unwrap());
        self.inScheme.unwrap().toTpm(buf);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.qualifyingData = buf.readSizedByteBuf();
        let r#inSchemeScheme: TPM_ALG_ID = buf.readShort();
        self.inScheme = TPMU_SIG_SCHEME::create(r#inSchemeScheme)?;
        self.inScheme.unwrap().initFromTpm(buf);
        Ok(())
    }

}

/// The purpose of this command is to prove that an object with a specific Name is loaded
/// in the TPM. By certifying that the object is loaded, the TPM warrants that a public
/// area with a given Name is self-consistent and associated with a valid sensitive area.
/// If a relying party has a public area that has the same Name as a Name certified with
/// this command, then the values in that public area are correct.
#[derive(Debug, Default)]
pub struct CertifyResponse {
    /// The structure that was signed
    pub certifyInfo: TPMS_ATTEST,

    /// Selector of the algorithm used to construct the signature

    /// The asymmetric signature over certifyInfo using the key referenced by signHandle
    /// One of: TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA,
    /// TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TPMT_HA,
    /// TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE.
    pub signature: Option<TPMU_SIGNATURE>,
}

impl CertifyResponse {
}

impl TpmStructure for CertifyResponse {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<CertifyResponse>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedObj(self.certifyInfo);
        buf.writeShort(self.signature.unwrap().GetUnionSelector().unwrap());
        self.signature.unwrap().toTpm(buf);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        buf.readSizedObj(self.certifyInfo);
        let r#signatureSigAlg: TPM_ALG_ID = buf.readShort();
        self.signature = TPMU_SIGNATURE::create(r#signatureSigAlg)?;
        self.signature.unwrap().initFromTpm(buf);
        Ok(())
    }

}

/// This command is used to prove the association between an object and its creation data.
/// The TPM will validate that the ticket was produced by the TPM and that the ticket
/// validates the association between a loaded public area and the provided hash of the
/// creation data (creationHash).
#[derive(Debug, Default)]
pub struct TPM2_CertifyCreation_REQUEST {
    /// Handle of the key that will sign the attestation block
    /// Auth Index: 1
    /// Auth Role: USER
    pub signHandle: TPM_HANDLE,

    /// The object associated with the creation data
    /// Auth Index: None
    pub objectHandle: TPM_HANDLE,

    /// User-provided qualifying data
    pub qualifyingData: Vec<u8>,

    /// Hash of the creation data produced by TPM2_Create() or TPM2_CreatePrimary()
    pub creationHash: Vec<u8>,

    /// Scheme selector

    /// Signing scheme to use if the scheme for signHandle is TPM_ALG_NULL
    /// One of: TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA,
    /// TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR,
    /// TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME.
    pub inScheme: Option<TPMU_SIG_SCHEME>,

    /// Ticket produced by TPM2_Create() or TPM2_CreatePrimary()
    pub creationTicket: TPMT_TK_CREATION,
}

impl TPM2_CertifyCreation_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        signHandle: TPM_HANDLE,
        objectHandle: TPM_HANDLE,
        qualifyingData: Vec<u8>,
        creationHash: Vec<u8>,
        inScheme: Option<TPMU_SIG_SCHEME>,
        creationTicket: TPMT_TK_CREATION,
        ) -> Self {
        Self {
            signHandle,
            objectHandle,
            qualifyingData,
            creationHash,
            inScheme,
            creationTicket,
        }
    }

}

impl TpmStructure for TPM2_CertifyCreation_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_CertifyCreation_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.qualifyingData);
        buf.writeSizedByteBuf(self.creationHash);
        buf.writeShort(self.inScheme.unwrap().GetUnionSelector().unwrap());
        self.inScheme.unwrap().toTpm(buf);
        self.creationTicket.toTpm(buf);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.qualifyingData = buf.readSizedByteBuf();
        self.creationHash = buf.readSizedByteBuf();
        let r#inSchemeScheme: TPM_ALG_ID = buf.readShort();
        self.inScheme = TPMU_SIG_SCHEME::create(r#inSchemeScheme)?;
        self.inScheme.unwrap().initFromTpm(buf);
        self.creationTicket.initFromTpm(buf);
        Ok(())
    }

}

/// This command is used to prove the association between an object and its creation data.
/// The TPM will validate that the ticket was produced by the TPM and that the ticket
/// validates the association between a loaded public area and the provided hash of the
/// creation data (creationHash).
#[derive(Debug, Default)]
pub struct CertifyCreationResponse {
    /// The structure that was signed
    pub certifyInfo: TPMS_ATTEST,

    /// Selector of the algorithm used to construct the signature

    /// The signature over certifyInfo
    /// One of: TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA,
    /// TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TPMT_HA,
    /// TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE.
    pub signature: Option<TPMU_SIGNATURE>,
}

impl CertifyCreationResponse {
}

impl TpmStructure for CertifyCreationResponse {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<CertifyCreationResponse>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedObj(self.certifyInfo);
        buf.writeShort(self.signature.unwrap().GetUnionSelector().unwrap());
        self.signature.unwrap().toTpm(buf);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        buf.readSizedObj(self.certifyInfo);
        let r#signatureSigAlg: TPM_ALG_ID = buf.readShort();
        self.signature = TPMU_SIGNATURE::create(r#signatureSigAlg)?;
        self.signature.unwrap().initFromTpm(buf);
        Ok(())
    }

}

/// This command is used to quote PCR values.
#[derive(Debug, Default)]
pub struct TPM2_Quote_REQUEST {
    /// Handle of key that will perform signature
    /// Auth Index: 1
    /// Auth Role: USER
    pub signHandle: TPM_HANDLE,

    /// Data supplied by the caller
    pub qualifyingData: Vec<u8>,

    /// Scheme selector

    /// Signing scheme to use if the scheme for signHandle is TPM_ALG_NULL
    /// One of: TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA,
    /// TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR,
    /// TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME.
    pub inScheme: Option<TPMU_SIG_SCHEME>,

    /// PCR set to quote
    pub PCRselect: Vec<TPMS_PCR_SELECTION>,
}

impl TPM2_Quote_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        signHandle: TPM_HANDLE,
        qualifyingData: Vec<u8>,
        inScheme: Option<TPMU_SIG_SCHEME>,
        PCRselect: Vec<TPMS_PCR_SELECTION>,
        ) -> Self {
        Self {
            signHandle,
            qualifyingData,
            inScheme,
            PCRselect,
        }
    }

}

impl TpmStructure for TPM2_Quote_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_Quote_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.qualifyingData);
        buf.writeShort(self.inScheme.unwrap().GetUnionSelector().unwrap());
        self.inScheme.unwrap().toTpm(buf);
        buf.writeObjArr(self.PCRselect);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.qualifyingData = buf.readSizedByteBuf();
        let r#inSchemeScheme: TPM_ALG_ID = buf.readShort();
        self.inScheme = TPMU_SIG_SCHEME::create(r#inSchemeScheme)?;
        self.inScheme.unwrap().initFromTpm(buf);
        buf.readObjArr(self.PCRselect);
        Ok(())
    }

}

/// This command is used to quote PCR values.
#[derive(Debug, Default)]
pub struct QuoteResponse {
    /// The quoted information
    pub quoted: TPMS_ATTEST,

    /// Selector of the algorithm used to construct the signature

    /// The signature over quoted
    /// One of: TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA,
    /// TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TPMT_HA,
    /// TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE.
    pub signature: Option<TPMU_SIGNATURE>,
}

impl QuoteResponse {
}

impl TpmStructure for QuoteResponse {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<QuoteResponse>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedObj(self.quoted);
        buf.writeShort(self.signature.unwrap().GetUnionSelector().unwrap());
        self.signature.unwrap().toTpm(buf);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        buf.readSizedObj(self.quoted);
        let r#signatureSigAlg: TPM_ALG_ID = buf.readShort();
        self.signature = TPMU_SIGNATURE::create(r#signatureSigAlg)?;
        self.signature.unwrap().initFromTpm(buf);
        Ok(())
    }

}

/// This command returns a digital signature of the audit session digest.
#[derive(Debug, Default)]
pub struct TPM2_GetSessionAuditDigest_REQUEST {
    /// Handle of the privacy administrator (TPM_RH_ENDORSEMENT)
    /// Auth Index: 1
    /// Auth Role: USER
    pub privacyAdminHandle: TPM_HANDLE,

    /// Handle of the signing key
    /// Auth Index: 2
    /// Auth Role: USER
    pub signHandle: TPM_HANDLE,

    /// Handle of the audit session
    /// Auth Index: None
    pub sessionHandle: TPM_HANDLE,

    /// User-provided qualifying data may be zero-length
    pub qualifyingData: Vec<u8>,

    /// Scheme selector

    /// Signing scheme to use if the scheme for signHandle is TPM_ALG_NULL
    /// One of: TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA,
    /// TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR,
    /// TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME.
    pub inScheme: Option<TPMU_SIG_SCHEME>,
}

impl TPM2_GetSessionAuditDigest_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        privacyAdminHandle: TPM_HANDLE,
        signHandle: TPM_HANDLE,
        sessionHandle: TPM_HANDLE,
        qualifyingData: Vec<u8>,
        inScheme: Option<TPMU_SIG_SCHEME>,
        ) -> Self {
        Self {
            privacyAdminHandle,
            signHandle,
            sessionHandle,
            qualifyingData,
            inScheme,
        }
    }

}

impl TpmStructure for TPM2_GetSessionAuditDigest_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_GetSessionAuditDigest_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.qualifyingData);
        buf.writeShort(self.inScheme.unwrap().GetUnionSelector().unwrap());
        self.inScheme.unwrap().toTpm(buf);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.qualifyingData = buf.readSizedByteBuf();
        let r#inSchemeScheme: TPM_ALG_ID = buf.readShort();
        self.inScheme = TPMU_SIG_SCHEME::create(r#inSchemeScheme)?;
        self.inScheme.unwrap().initFromTpm(buf);
        Ok(())
    }

}

/// This command returns a digital signature of the audit session digest.
#[derive(Debug, Default)]
pub struct GetSessionAuditDigestResponse {
    /// The audit information that was signed
    pub auditInfo: TPMS_ATTEST,

    /// Selector of the algorithm used to construct the signature

    /// The signature over auditInfo
    /// One of: TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA,
    /// TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TPMT_HA,
    /// TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE.
    pub signature: Option<TPMU_SIGNATURE>,
}

impl GetSessionAuditDigestResponse {
}

impl TpmStructure for GetSessionAuditDigestResponse {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<GetSessionAuditDigestResponse>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedObj(self.auditInfo);
        buf.writeShort(self.signature.unwrap().GetUnionSelector().unwrap());
        self.signature.unwrap().toTpm(buf);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        buf.readSizedObj(self.auditInfo);
        let r#signatureSigAlg: TPM_ALG_ID = buf.readShort();
        self.signature = TPMU_SIGNATURE::create(r#signatureSigAlg)?;
        self.signature.unwrap().initFromTpm(buf);
        Ok(())
    }

}

/// This command returns the current value of the command audit digest, a digest of the
/// commands being audited, and the audit hash algorithm. These values are placed in an
/// attestation structure and signed with the key referenced by signHandle.
#[derive(Debug, Default)]
pub struct TPM2_GetCommandAuditDigest_REQUEST {
    /// Handle of the privacy administrator (TPM_RH_ENDORSEMENT)
    /// Auth Index: 1
    /// Auth Role: USER
    pub privacyHandle: TPM_HANDLE,

    /// The handle of the signing key
    /// Auth Index: 2
    /// Auth Role: USER
    pub signHandle: TPM_HANDLE,

    /// Other data to associate with this audit digest
    pub qualifyingData: Vec<u8>,

    /// Scheme selector

    /// Signing scheme to use if the scheme for signHandle is TPM_ALG_NULL
    /// One of: TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA,
    /// TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR,
    /// TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME.
    pub inScheme: Option<TPMU_SIG_SCHEME>,
}

impl TPM2_GetCommandAuditDigest_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        privacyHandle: TPM_HANDLE,
        signHandle: TPM_HANDLE,
        qualifyingData: Vec<u8>,
        inScheme: Option<TPMU_SIG_SCHEME>,
        ) -> Self {
        Self {
            privacyHandle,
            signHandle,
            qualifyingData,
            inScheme,
        }
    }

}

impl TpmStructure for TPM2_GetCommandAuditDigest_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_GetCommandAuditDigest_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.qualifyingData);
        buf.writeShort(self.inScheme.unwrap().GetUnionSelector().unwrap());
        self.inScheme.unwrap().toTpm(buf);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.qualifyingData = buf.readSizedByteBuf();
        let r#inSchemeScheme: TPM_ALG_ID = buf.readShort();
        self.inScheme = TPMU_SIG_SCHEME::create(r#inSchemeScheme)?;
        self.inScheme.unwrap().initFromTpm(buf);
        Ok(())
    }

}

/// This command returns the current value of the command audit digest, a digest of the
/// commands being audited, and the audit hash algorithm. These values are placed in an
/// attestation structure and signed with the key referenced by signHandle.
#[derive(Debug, Default)]
pub struct GetCommandAuditDigestResponse {
    /// The auditInfo that was signed
    pub auditInfo: TPMS_ATTEST,

    /// Selector of the algorithm used to construct the signature

    /// The signature over auditInfo
    /// One of: TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA,
    /// TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TPMT_HA,
    /// TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE.
    pub signature: Option<TPMU_SIGNATURE>,
}

impl GetCommandAuditDigestResponse {
}

impl TpmStructure for GetCommandAuditDigestResponse {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<GetCommandAuditDigestResponse>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedObj(self.auditInfo);
        buf.writeShort(self.signature.unwrap().GetUnionSelector().unwrap());
        self.signature.unwrap().toTpm(buf);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        buf.readSizedObj(self.auditInfo);
        let r#signatureSigAlg: TPM_ALG_ID = buf.readShort();
        self.signature = TPMU_SIGNATURE::create(r#signatureSigAlg)?;
        self.signature.unwrap().initFromTpm(buf);
        Ok(())
    }

}

/// This command returns the current values of Time and Clock.
#[derive(Debug, Default)]
pub struct TPM2_GetTime_REQUEST {
    /// Handle of the privacy administrator (TPM_RH_ENDORSEMENT)
    /// Auth Index: 1
    /// Auth Role: USER
    pub privacyAdminHandle: TPM_HANDLE,

    /// The keyHandle identifier of a loaded key that can perform digital signatures
    /// Auth Index: 2
    /// Auth Role: USER
    pub signHandle: TPM_HANDLE,

    /// Data to tick stamp
    pub qualifyingData: Vec<u8>,

    /// Scheme selector

    /// Signing scheme to use if the scheme for signHandle is TPM_ALG_NULL
    /// One of: TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA,
    /// TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR,
    /// TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME.
    pub inScheme: Option<TPMU_SIG_SCHEME>,
}

impl TPM2_GetTime_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        privacyAdminHandle: TPM_HANDLE,
        signHandle: TPM_HANDLE,
        qualifyingData: Vec<u8>,
        inScheme: Option<TPMU_SIG_SCHEME>,
        ) -> Self {
        Self {
            privacyAdminHandle,
            signHandle,
            qualifyingData,
            inScheme,
        }
    }

}

impl TpmStructure for TPM2_GetTime_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_GetTime_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.qualifyingData);
        buf.writeShort(self.inScheme.unwrap().GetUnionSelector().unwrap());
        self.inScheme.unwrap().toTpm(buf);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.qualifyingData = buf.readSizedByteBuf();
        let r#inSchemeScheme: TPM_ALG_ID = buf.readShort();
        self.inScheme = TPMU_SIG_SCHEME::create(r#inSchemeScheme)?;
        self.inScheme.unwrap().initFromTpm(buf);
        Ok(())
    }

}

/// This command returns the current values of Time and Clock.
#[derive(Debug, Default)]
pub struct GetTimeResponse {
    /// Standard TPM-generated attestation block
    pub timeInfo: TPMS_ATTEST,

    /// Selector of the algorithm used to construct the signature

    /// The signature over timeInfo
    /// One of: TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA,
    /// TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TPMT_HA,
    /// TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE.
    pub signature: Option<TPMU_SIGNATURE>,
}

impl GetTimeResponse {
}

impl TpmStructure for GetTimeResponse {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<GetTimeResponse>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedObj(self.timeInfo);
        buf.writeShort(self.signature.unwrap().GetUnionSelector().unwrap());
        self.signature.unwrap().toTpm(buf);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        buf.readSizedObj(self.timeInfo);
        let r#signatureSigAlg: TPM_ALG_ID = buf.readShort();
        self.signature = TPMU_SIGNATURE::create(r#signatureSigAlg)?;
        self.signature.unwrap().initFromTpm(buf);
        Ok(())
    }

}

/// The purpose of this command is to generate an X.509 certificate that proves an object
/// with a specific public key and attributes is loaded in the TPM. In contrast to
/// TPM2_Certify, which uses a TCG-defined data structure to convey attestation
/// information, TPM2_CertifyX509 encodes the attestation information in a DER-encoded
/// X.509 certificate that is compliant with RFC5280 Internet X.509 Public Key
/// Infrastructure Certificate and Certificate Revocation List (CRL) Profile.
#[derive(Debug, Default)]
pub struct TPM2_CertifyX509_REQUEST {
    /// Handle of the object to be certified
    /// Auth Index: 1
    /// Auth Role: ADMIN
    pub objectHandle: TPM_HANDLE,

    /// Handle of the key used to sign the attestation structure
    /// Auth Index: 2
    /// Auth Role: USER
    pub signHandle: TPM_HANDLE,

    /// Shall be an Empty Buffer
    pub reserved: Vec<u8>,

    /// Scheme selector

    /// Signing scheme to use if the scheme for signHandle is TPM_ALG_NULL
    /// One of: TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA,
    /// TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR,
    /// TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME.
    pub inScheme: Option<TPMU_SIG_SCHEME>,

    /// A DER encoded partial certificate
    pub partialCertificate: Vec<u8>,
}

impl TPM2_CertifyX509_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        objectHandle: TPM_HANDLE,
        signHandle: TPM_HANDLE,
        reserved: Vec<u8>,
        inScheme: Option<TPMU_SIG_SCHEME>,
        partialCertificate: Vec<u8>,
        ) -> Self {
        Self {
            objectHandle,
            signHandle,
            reserved,
            inScheme,
            partialCertificate,
        }
    }

}

impl TpmStructure for TPM2_CertifyX509_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_CertifyX509_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.reserved);
        buf.writeShort(self.inScheme.unwrap().GetUnionSelector().unwrap());
        self.inScheme.unwrap().toTpm(buf);
        buf.writeSizedByteBuf(self.partialCertificate);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.reserved = buf.readSizedByteBuf();
        let r#inSchemeScheme: TPM_ALG_ID = buf.readShort();
        self.inScheme = TPMU_SIG_SCHEME::create(r#inSchemeScheme)?;
        self.inScheme.unwrap().initFromTpm(buf);
        self.partialCertificate = buf.readSizedByteBuf();
        Ok(())
    }

}

/// The purpose of this command is to generate an X.509 certificate that proves an object
/// with a specific public key and attributes is loaded in the TPM. In contrast to
/// TPM2_Certify, which uses a TCG-defined data structure to convey attestation
/// information, TPM2_CertifyX509 encodes the attestation information in a DER-encoded
/// X.509 certificate that is compliant with RFC5280 Internet X.509 Public Key
/// Infrastructure Certificate and Certificate Revocation List (CRL) Profile.
#[derive(Debug, Default)]
pub struct CertifyX509Response {
    /// A DER encoded SEQUENCE containing the DER encoded fields added to partialCertificate
    /// to make it a complete RFC5280 TBSCertificate.
    pub addedToCertificate: Vec<u8>,

    /// The digest that was signed
    pub tbsDigest: Vec<u8>,

    /// Selector of the algorithm used to construct the signature

    /// The signature over tbsDigest
    /// One of: TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA,
    /// TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TPMT_HA,
    /// TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE.
    pub signature: Option<TPMU_SIGNATURE>,
}

impl CertifyX509Response {
}

impl TpmStructure for CertifyX509Response {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<CertifyX509Response>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.addedToCertificate);
        buf.writeSizedByteBuf(self.tbsDigest);
        buf.writeShort(self.signature.unwrap().GetUnionSelector().unwrap());
        self.signature.unwrap().toTpm(buf);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.addedToCertificate = buf.readSizedByteBuf();
        self.tbsDigest = buf.readSizedByteBuf();
        let r#signatureSigAlg: TPM_ALG_ID = buf.readShort();
        self.signature = TPMU_SIGNATURE::create(r#signatureSigAlg)?;
        self.signature.unwrap().initFromTpm(buf);
        Ok(())
    }

}

/// TPM2_Commit() performs the first part of an ECC anonymous signing operation. The TPM
/// will perform the point multiplications on the provided points and return intermediate
/// signing values. The signHandle parameter shall refer to an ECC key and the signing
/// scheme must be anonymous (TPM_RC_SCHEME).
#[derive(Debug, Default)]
pub struct TPM2_Commit_REQUEST {
    /// Handle of the key that will be used in the signing operation
    /// Auth Index: 1
    /// Auth Role: USER
    pub signHandle: TPM_HANDLE,

    /// A point (M) on the curve used by signHandle
    pub P1: TPMS_ECC_POINT,

    /// Octet array used to derive x-coordinate of a base point
    pub s2: Vec<u8>,

    /// Y coordinate of the point associated with s2
    pub y2: Vec<u8>,
}

impl TPM2_Commit_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        signHandle: TPM_HANDLE,
        P1: TPMS_ECC_POINT,
        s2: Vec<u8>,
        y2: Vec<u8>,
        ) -> Self {
        Self {
            signHandle,
            P1,
            s2,
            y2,
        }
    }

}

impl TpmStructure for TPM2_Commit_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_Commit_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedObj(self.P1);
        buf.writeSizedByteBuf(self.s2);
        buf.writeSizedByteBuf(self.y2);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        buf.readSizedObj(self.P1);
        self.s2 = buf.readSizedByteBuf();
        self.y2 = buf.readSizedByteBuf();
        Ok(())
    }

}

/// TPM2_Commit() performs the first part of an ECC anonymous signing operation. The TPM
/// will perform the point multiplications on the provided points and return intermediate
/// signing values. The signHandle parameter shall refer to an ECC key and the signing
/// scheme must be anonymous (TPM_RC_SCHEME).
#[derive(Debug, Default)]
pub struct CommitResponse {
    /// ECC point K [ds](x2, y2)
    pub K: TPMS_ECC_POINT,

    /// ECC point L [r](x2, y2)
    pub L: TPMS_ECC_POINT,

    /// ECC point E [r]P1
    pub E: TPMS_ECC_POINT,

    /// Least-significant 16 bits of commitCount
    pub counter: u16,
}

impl CommitResponse {
}

impl TpmStructure for CommitResponse {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<CommitResponse>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedObj(self.K);
        buf.writeSizedObj(self.L);
        buf.writeSizedObj(self.E);
        buf.writeShort(self.counter);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        buf.readSizedObj(self.K);
        buf.readSizedObj(self.L);
        buf.readSizedObj(self.E);
        self.counter = buf.readShort();
        Ok(())
    }

}

/// TPM2_EC_Ephemeral() creates an ephemeral key for use in a two-phase key exchange protocol.
#[derive(Debug, Default)]
pub struct TPM2_EC_Ephemeral_REQUEST {
    /// The curve for the computed ephemeral point
    pub curveID: TPM_ECC_CURVE,
}

impl TPM2_EC_Ephemeral_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        curveID: TPM_ECC_CURVE,
        ) -> Self {
        Self {
            curveID,
        }
    }

}

impl TpmStructure for TPM2_EC_Ephemeral_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_EC_Ephemeral_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeShort(self.curveID);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.curveID = buf.readShort();
        Ok(())
    }

}

/// TPM2_EC_Ephemeral() creates an ephemeral key for use in a two-phase key exchange protocol.
#[derive(Debug, Default)]
pub struct EC_EphemeralResponse {
    /// Ephemeral public key Q [r]G
    pub Q: TPMS_ECC_POINT,

    /// Least-significant 16 bits of commitCount
    pub counter: u16,
}

impl EC_EphemeralResponse {
}

impl TpmStructure for EC_EphemeralResponse {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<EC_EphemeralResponse>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedObj(self.Q);
        buf.writeShort(self.counter);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        buf.readSizedObj(self.Q);
        self.counter = buf.readShort();
        Ok(())
    }

}

/// This command uses loaded keys to validate a signature on a message with the message
/// digest passed to the TPM.
#[derive(Debug, Default)]
pub struct TPM2_VerifySignature_REQUEST {
    /// Handle of public key that will be used in the validation
    /// Auth Index: None
    pub keyHandle: TPM_HANDLE,

    /// Digest of the signed message
    pub digest: Vec<u8>,

    /// Selector of the algorithm used to construct the signature

    /// Signature to be tested
    /// One of: TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA,
    /// TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TPMT_HA,
    /// TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE.
    pub signature: Option<TPMU_SIGNATURE>,
}

impl TPM2_VerifySignature_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        keyHandle: TPM_HANDLE,
        digest: Vec<u8>,
        signature: Option<TPMU_SIGNATURE>,
        ) -> Self {
        Self {
            keyHandle,
            digest,
            signature,
        }
    }

}

impl TpmStructure for TPM2_VerifySignature_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_VerifySignature_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.digest);
        buf.writeShort(self.signature.unwrap().GetUnionSelector().unwrap());
        self.signature.unwrap().toTpm(buf);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.digest = buf.readSizedByteBuf();
        let r#signatureSigAlg: TPM_ALG_ID = buf.readShort();
        self.signature = TPMU_SIGNATURE::create(r#signatureSigAlg)?;
        self.signature.unwrap().initFromTpm(buf);
        Ok(())
    }

}

/// This command uses loaded keys to validate a signature on a message with the message
/// digest passed to the TPM.
#[derive(Debug, Default)]
pub struct VerifySignatureResponse {
    pub validation: TPMT_TK_VERIFIED,
}

impl VerifySignatureResponse {
}

impl TpmStructure for VerifySignatureResponse {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<VerifySignatureResponse>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.validation.toTpm(buf);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.validation.initFromTpm(buf);
        Ok(())
    }

}

/// This command causes the TPM to sign an externally provided hash with the specified
/// symmetric or asymmetric signing key.
#[derive(Debug, Default)]
pub struct TPM2_Sign_REQUEST {
    /// Handle of key that will perform signing
    /// Auth Index: 1
    /// Auth Role: USER
    pub keyHandle: TPM_HANDLE,

    /// Digest to be signed
    pub digest: Vec<u8>,

    /// Scheme selector

    /// Signing scheme to use if the scheme for keyHandle is TPM_ALG_NULL
    /// One of: TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA,
    /// TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR,
    /// TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME.
    pub inScheme: Option<TPMU_SIG_SCHEME>,

    /// Proof that digest was created by the TPM
    /// If keyHandle is not a restricted signing key, then this may be a NULL Ticket with tag
    /// = TPM_ST_CHECKHASH.
    pub validation: TPMT_TK_HASHCHECK,
}

impl TPM2_Sign_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        keyHandle: TPM_HANDLE,
        digest: Vec<u8>,
        inScheme: Option<TPMU_SIG_SCHEME>,
        validation: TPMT_TK_HASHCHECK,
        ) -> Self {
        Self {
            keyHandle,
            digest,
            inScheme,
            validation,
        }
    }

}

impl TpmStructure for TPM2_Sign_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_Sign_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.digest);
        buf.writeShort(self.inScheme.unwrap().GetUnionSelector().unwrap());
        self.inScheme.unwrap().toTpm(buf);
        self.validation.toTpm(buf);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.digest = buf.readSizedByteBuf();
        let r#inSchemeScheme: TPM_ALG_ID = buf.readShort();
        self.inScheme = TPMU_SIG_SCHEME::create(r#inSchemeScheme)?;
        self.inScheme.unwrap().initFromTpm(buf);
        self.validation.initFromTpm(buf);
        Ok(())
    }

}

/// This command causes the TPM to sign an externally provided hash with the specified
/// symmetric or asymmetric signing key.
#[derive(Debug, Default)]
pub struct SignResponse {
    /// Selector of the algorithm used to construct the signature

    /// The signature
    /// One of: TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA,
    /// TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TPMT_HA,
    /// TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE.
    pub signature: Option<TPMU_SIGNATURE>,
}

impl SignResponse {
}

impl TpmStructure for SignResponse {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<SignResponse>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        if (self.signature.is_none()) { return Ok(()) };
        buf.writeShort(self.signature.unwrap().GetUnionSelector().unwrap());
        self.signature.unwrap().toTpm(buf);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        let r#signatureSigAlg: TPM_ALG_ID = buf.readShort();
        self.signature = TPMU_SIGNATURE::create(r#signatureSigAlg)?;
        self.signature.unwrap().initFromTpm(buf);
        Ok(())
    }

}

/// This command may be used by the Privacy Administrator or platform to change the audit
/// status of a command or to set the hash algorithm used for the audit digest, but not
/// both at the same time.
#[derive(Debug, Default)]
pub struct TPM2_SetCommandCodeAuditStatus_REQUEST {
    /// TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
    /// Auth Index: 1
    /// Auth Role: USER
    pub auth: TPM_HANDLE,

    /// Hash algorithm for the audit digest; if TPM_ALG_NULL, then the hash is not changed
    pub auditAlg: TPM_ALG_ID,

    /// List of commands that will be added to those that will be audited
    pub setList: Vec<TPM_CC>,

    /// List of commands that will no longer be audited
    pub clearList: Vec<TPM_CC>,
}

impl TPM2_SetCommandCodeAuditStatus_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        auth: TPM_HANDLE,
        auditAlg: TPM_ALG_ID,
        setList: Vec<TPM_CC>,
        clearList: Vec<TPM_CC>,
        ) -> Self {
        Self {
            auth,
            auditAlg,
            setList,
            clearList,
        }
    }

}

impl TpmStructure for TPM2_SetCommandCodeAuditStatus_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_SetCommandCodeAuditStatus_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeShort(self.auditAlg);
        buf.writeValArr(self.setList, 4);
        buf.writeValArr(self.clearList, 4);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.auditAlg = buf.readShort();
        buf.readValArr(self.setList, 4);
        buf.readValArr(self.clearList, 4);
        Ok(())
    }

}

/// This command is used to cause an update to the indicated PCR. The digests parameter
/// contains one or more tagged digest values identified by an algorithm ID. For each
/// digest, the PCR associated with pcrHandle is Extended into the bank identified by the
/// tag (hashAlg).
#[derive(Debug, Default)]
pub struct TPM2_PCR_Extend_REQUEST {
    /// Handle of the PCR
    /// Auth Handle: 1
    /// Auth Role: USER
    pub pcrHandle: TPM_HANDLE,

    /// List of tagged digest values to be extended
    pub digests: Vec<TPMT_HA>,
}

impl TPM2_PCR_Extend_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        pcrHandle: TPM_HANDLE,
        digests: Vec<TPMT_HA>,
        ) -> Self {
        Self {
            pcrHandle,
            digests,
        }
    }

}

impl TpmStructure for TPM2_PCR_Extend_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_PCR_Extend_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeObjArr(self.digests);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        buf.readObjArr(self.digests);
        Ok(())
    }

}

/// This command is used to cause an update to the indicated PCR.
#[derive(Debug, Default)]
pub struct TPM2_PCR_Event_REQUEST {
    /// Handle of the PCR
    /// Auth Handle: 1
    /// Auth Role: USER
    pub pcrHandle: TPM_HANDLE,

    /// Event data in sized buffer
    pub eventData: Vec<u8>,
}

impl TPM2_PCR_Event_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        pcrHandle: TPM_HANDLE,
        eventData: Vec<u8>,
        ) -> Self {
        Self {
            pcrHandle,
            eventData,
        }
    }

}

impl TpmStructure for TPM2_PCR_Event_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_PCR_Event_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.eventData);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.eventData = buf.readSizedByteBuf();
        Ok(())
    }

}

/// This command is used to cause an update to the indicated PCR.
#[derive(Debug, Default)]
pub struct PCR_EventResponse {
    pub digests: Vec<TPMT_HA>,
}

impl PCR_EventResponse {
}

impl TpmStructure for PCR_EventResponse {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<PCR_EventResponse>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeObjArr(self.digests);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        buf.readObjArr(self.digests);
        Ok(())
    }

}

/// This command returns the values of all PCR specified in pcrSelectionIn.
#[derive(Debug, Default)]
pub struct TPM2_PCR_Read_REQUEST {
    /// The selection of PCR to read
    pub pcrSelectionIn: Vec<TPMS_PCR_SELECTION>,
}

impl TPM2_PCR_Read_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        pcrSelectionIn: Vec<TPMS_PCR_SELECTION>,
        ) -> Self {
        Self {
            pcrSelectionIn,
        }
    }

}

impl TpmStructure for TPM2_PCR_Read_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_PCR_Read_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeObjArr(self.pcrSelectionIn);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        buf.readObjArr(self.pcrSelectionIn);
        Ok(())
    }

}

/// This command returns the values of all PCR specified in pcrSelectionIn.
#[derive(Debug, Default)]
pub struct PCR_ReadResponse {
    /// The current value of the PCR update counter
    pub pcrUpdateCounter: u32,

    /// The PCR in the returned list
    pub pcrSelectionOut: Vec<TPMS_PCR_SELECTION>,

    /// The contents of the PCR indicated in pcrSelectOut-˃ pcrSelection[] as tagged digests
    pub pcrValues: Vec<TPM2B_DIGEST>,
}

impl PCR_ReadResponse {
}

impl TpmStructure for PCR_ReadResponse {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<PCR_ReadResponse>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeInt(self.pcrUpdateCounter);
        buf.writeObjArr(self.pcrSelectionOut);
        buf.writeObjArr(self.pcrValues);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.pcrUpdateCounter = buf.readInt();
        buf.readObjArr(self.pcrSelectionOut);
        buf.readObjArr(self.pcrValues);
        Ok(())
    }

}

/// This command is used to set the desired PCR allocation of PCR and algorithms. This
/// command requires Platform Authorization.
#[derive(Debug, Default)]
pub struct TPM2_PCR_Allocate_REQUEST {
    /// TPM_RH_PLATFORM+{PP}
    /// Auth Index: 1
    /// Auth Role: USER
    pub authHandle: TPM_HANDLE,

    /// The requested allocation
    pub pcrAllocation: Vec<TPMS_PCR_SELECTION>,
}

impl TPM2_PCR_Allocate_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        authHandle: TPM_HANDLE,
        pcrAllocation: Vec<TPMS_PCR_SELECTION>,
        ) -> Self {
        Self {
            authHandle,
            pcrAllocation,
        }
    }

}

impl TpmStructure for TPM2_PCR_Allocate_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_PCR_Allocate_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeObjArr(self.pcrAllocation);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        buf.readObjArr(self.pcrAllocation);
        Ok(())
    }

}

/// This command is used to set the desired PCR allocation of PCR and algorithms. This
/// command requires Platform Authorization.
#[derive(Debug, Default)]
pub struct PCR_AllocateResponse {
    /// YES if the allocation succeeded
    pub allocationSuccess: u8,

    /// Maximum number of PCR that may be in a bank
    pub maxPCR: u32,

    /// Number of octets required to satisfy the request
    pub sizeNeeded: u32,

    /// Number of octets available. Computed before the allocation.
    pub sizeAvailable: u32,
}

impl PCR_AllocateResponse {
}

impl TpmStructure for PCR_AllocateResponse {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<PCR_AllocateResponse>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeByte(self.allocationSuccess);
        buf.writeInt(self.maxPCR);
        buf.writeInt(self.sizeNeeded);
        buf.writeInt(self.sizeAvailable);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.allocationSuccess = buf.readByte();
        self.maxPCR = buf.readInt();
        self.sizeNeeded = buf.readInt();
        self.sizeAvailable = buf.readInt();
        Ok(())
    }

}

/// This command is used to associate a policy with a PCR or group of PCR. The policy
/// determines the conditions under which a PCR may be extended or reset.
#[derive(Debug, Default)]
pub struct TPM2_PCR_SetAuthPolicy_REQUEST {
    /// TPM_RH_PLATFORM+{PP}
    /// Auth Index: 1
    /// Auth Role: USER
    pub authHandle: TPM_HANDLE,

    /// The desired authPolicy
    pub authPolicy: Vec<u8>,

    /// The hash algorithm of the policy
    pub hashAlg: TPM_ALG_ID,

    /// The PCR for which the policy is to be set
    pub pcrNum: TPM_HANDLE,
}

impl TPM2_PCR_SetAuthPolicy_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        authHandle: TPM_HANDLE,
        authPolicy: Vec<u8>,
        hashAlg: TPM_ALG_ID,
        pcrNum: TPM_HANDLE,
        ) -> Self {
        Self {
            authHandle,
            authPolicy,
            hashAlg,
            pcrNum,
        }
    }

}

impl TpmStructure for TPM2_PCR_SetAuthPolicy_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_PCR_SetAuthPolicy_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.authPolicy);
        buf.writeShort(self.hashAlg);
        self.pcrNum.toTpm(buf);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.authPolicy = buf.readSizedByteBuf();
        self.hashAlg = buf.readShort();
        self.pcrNum.initFromTpm(buf);
        Ok(())
    }

}

/// This command changes the authValue of a PCR or group of PCR.
#[derive(Debug, Default)]
pub struct TPM2_PCR_SetAuthValue_REQUEST {
    /// Handle for a PCR that may have an authorization value set
    /// Auth Index: 1
    /// Auth Role: USER
    pub pcrHandle: TPM_HANDLE,

    /// The desired authorization value
    pub auth: Vec<u8>,
}

impl TPM2_PCR_SetAuthValue_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        pcrHandle: TPM_HANDLE,
        auth: Vec<u8>,
        ) -> Self {
        Self {
            pcrHandle,
            auth,
        }
    }

}

impl TpmStructure for TPM2_PCR_SetAuthValue_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_PCR_SetAuthValue_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.auth);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.auth = buf.readSizedByteBuf();
        Ok(())
    }

}

/// If the attribute of a PCR allows the PCR to be reset and proper authorization is
/// provided, then this command may be used to set the PCR in all banks to zero. The
/// attributes of the PCR may restrict the locality that can perform the reset operation.
#[derive(Debug, Default)]
pub struct TPM2_PCR_Reset_REQUEST {
    /// The PCR to reset
    /// Auth Index: 1
    /// Auth Role: USER
    pub pcrHandle: TPM_HANDLE,
}

impl TPM2_PCR_Reset_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        pcrHandle: TPM_HANDLE,
        ) -> Self {
        Self {
            pcrHandle,
        }
    }

}

impl TpmStructure for TPM2_PCR_Reset_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_PCR_Reset_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        Ok(())
    }

}

/// This command includes a signed authorization in a policy. The command ties the policy
/// to a signing key by including the Name of the signing key in the policyDigest
#[derive(Debug, Default)]
pub struct TPM2_PolicySigned_REQUEST {
    /// Handle for a key that will validate the signature
    /// Auth Index: None
    pub authObject: TPM_HANDLE,

    /// Handle for the policy session being extended
    /// Auth Index: None
    pub policySession: TPM_HANDLE,

    /// The policy nonce for the session
    /// This can be the Empty Buffer.
    pub nonceTPM: Vec<u8>,

    /// Digest of the command parameters to which this authorization is limited
    /// This is not the cpHash for this command but the cpHash for the command to which this
    /// policy session will be applied. If it is not limited, the parameter will be the Empty Buffer.
    pub cpHashA: Vec<u8>,

    /// A reference to a policy relating to the authorization may be the Empty Buffer
    /// Size is limited to be no larger than the nonce size supported on the TPM.
    pub policyRef: Vec<u8>,

    /// Time when authorization will expire, measured in seconds from the time that nonceTPM
    /// was generated
    /// If expiration is non-negative, a NULL Ticket is returned. See 23.2.5.
    pub expiration: i32,

    /// Selector of the algorithm used to construct the signature

    /// Signed authorization (not optional)
    /// One of: TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA,
    /// TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TPMT_HA,
    /// TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE.
    pub auth: Option<TPMU_SIGNATURE>,
}

impl TPM2_PolicySigned_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        authObject: TPM_HANDLE,
        policySession: TPM_HANDLE,
        nonceTPM: Vec<u8>,
        cpHashA: Vec<u8>,
        policyRef: Vec<u8>,
        expiration: i32,
        auth: Option<TPMU_SIGNATURE>,
        ) -> Self {
        Self {
            authObject,
            policySession,
            nonceTPM,
            cpHashA,
            policyRef,
            expiration,
            auth,
        }
    }

}

impl TpmStructure for TPM2_PolicySigned_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_PolicySigned_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.nonceTPM);
        buf.writeSizedByteBuf(self.cpHashA);
        buf.writeSizedByteBuf(self.policyRef);
        buf.writeInt(self.expiration);
        buf.writeShort(self.auth.unwrap().GetUnionSelector().unwrap());
        self.auth.unwrap().toTpm(buf);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.nonceTPM = buf.readSizedByteBuf();
        self.cpHashA = buf.readSizedByteBuf();
        self.policyRef = buf.readSizedByteBuf();
        self.expiration = buf.readInt();
        let r#authSigAlg: TPM_ALG_ID = buf.readShort();
        self.auth = TPMU_SIGNATURE::create(r#authSigAlg)?;
        self.auth.unwrap().initFromTpm(buf);
        Ok(())
    }

}

/// This command includes a signed authorization in a policy. The command ties the policy
/// to a signing key by including the Name of the signing key in the policyDigest
#[derive(Debug, Default)]
pub struct PolicySignedResponse {
    /// Implementation-specific time value, used to indicate to the TPM when the ticket expires
    /// NOTE If policyTicket is a NULL Ticket, then this shall be the Empty Buffer.
    pub timeout: Vec<u8>,

    /// Produced if the command succeeds and expiration in the command was non-zero; this
    /// ticket will use the TPMT_ST_AUTH_SIGNED structure tag. See 23.2.5
    pub policyTicket: TPMT_TK_AUTH,
}

impl PolicySignedResponse {
}

impl TpmStructure for PolicySignedResponse {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<PolicySignedResponse>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.timeout);
        self.policyTicket.toTpm(buf);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.timeout = buf.readSizedByteBuf();
        self.policyTicket.initFromTpm(buf);
        Ok(())
    }

}

/// This command includes a secret-based authorization to a policy. The caller proves
/// knowledge of the secret value using an authorization session using the authValue
/// associated with authHandle. A password session, an HMAC session, or a policy session
/// containing TPM2_PolicyAuthValue() or TPM2_PolicyPassword() will satisfy this requirement.
#[derive(Debug, Default)]
pub struct TPM2_PolicySecret_REQUEST {
    /// Handle for an entity providing the authorization
    /// Auth Index: 1
    /// Auth Role: USER
    pub authHandle: TPM_HANDLE,

    /// Handle for the policy session being extended
    /// Auth Index: None
    pub policySession: TPM_HANDLE,

    /// The policy nonce for the session
    /// This can be the Empty Buffer.
    pub nonceTPM: Vec<u8>,

    /// Digest of the command parameters to which this authorization is limited
    /// This not the cpHash for this command but the cpHash for the command to which this
    /// policy session will be applied. If it is not limited, the parameter will be the Empty Buffer.
    pub cpHashA: Vec<u8>,

    /// A reference to a policy relating to the authorization may be the Empty Buffer
    /// Size is limited to be no larger than the nonce size supported on the TPM.
    pub policyRef: Vec<u8>,

    /// Time when authorization will expire, measured in seconds from the time that nonceTPM
    /// was generated
    /// If expiration is non-negative, a NULL Ticket is returned. See 23.2.5.
    pub expiration: i32,
}

impl TPM2_PolicySecret_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        authHandle: TPM_HANDLE,
        policySession: TPM_HANDLE,
        nonceTPM: Vec<u8>,
        cpHashA: Vec<u8>,
        policyRef: Vec<u8>,
        expiration: i32,
        ) -> Self {
        Self {
            authHandle,
            policySession,
            nonceTPM,
            cpHashA,
            policyRef,
            expiration,
        }
    }

}

impl TpmStructure for TPM2_PolicySecret_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_PolicySecret_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.nonceTPM);
        buf.writeSizedByteBuf(self.cpHashA);
        buf.writeSizedByteBuf(self.policyRef);
        buf.writeInt(self.expiration);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.nonceTPM = buf.readSizedByteBuf();
        self.cpHashA = buf.readSizedByteBuf();
        self.policyRef = buf.readSizedByteBuf();
        self.expiration = buf.readInt();
        Ok(())
    }

}

/// This command includes a secret-based authorization to a policy. The caller proves
/// knowledge of the secret value using an authorization session using the authValue
/// associated with authHandle. A password session, an HMAC session, or a policy session
/// containing TPM2_PolicyAuthValue() or TPM2_PolicyPassword() will satisfy this requirement.
#[derive(Debug, Default)]
pub struct PolicySecretResponse {
    /// Implementation-specific time value used to indicate to the TPM when the ticket expires
    pub timeout: Vec<u8>,

    /// Produced if the command succeeds and expiration in the command was non-zero ( See
    /// 23.2.5). This ticket will use the TPMT_ST_AUTH_SECRET structure tag
    pub policyTicket: TPMT_TK_AUTH,
}

impl PolicySecretResponse {
}

impl TpmStructure for PolicySecretResponse {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<PolicySecretResponse>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.timeout);
        self.policyTicket.toTpm(buf);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.timeout = buf.readSizedByteBuf();
        self.policyTicket.initFromTpm(buf);
        Ok(())
    }

}

/// This command is similar to TPM2_PolicySigned() except that it takes a ticket instead
/// of a signed authorization. The ticket represents a validated authorization that had an
/// expiration time associated with it.
#[derive(Debug, Default)]
pub struct TPM2_PolicyTicket_REQUEST {
    /// Handle for the policy session being extended
    /// Auth Index: None
    pub policySession: TPM_HANDLE,

    /// Time when authorization will expire
    /// The contents are TPM specific. This shall be the value returned when ticket was produced.
    pub timeout: Vec<u8>,

    /// Digest of the command parameters to which this authorization is limited
    /// If it is not limited, the parameter will be the Empty Buffer.
    pub cpHashA: Vec<u8>,

    /// Reference to a qualifier for the policy may be the Empty Buffer
    pub policyRef: Vec<u8>,

    /// Name of the object that provided the authorization
    pub authName: Vec<u8>,

    /// An authorization ticket returned by the TPM in response to a TPM2_PolicySigned() or
    /// TPM2_PolicySecret()
    pub ticket: TPMT_TK_AUTH,
}

impl TPM2_PolicyTicket_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        policySession: TPM_HANDLE,
        timeout: Vec<u8>,
        cpHashA: Vec<u8>,
        policyRef: Vec<u8>,
        authName: Vec<u8>,
        ticket: TPMT_TK_AUTH,
        ) -> Self {
        Self {
            policySession,
            timeout,
            cpHashA,
            policyRef,
            authName,
            ticket,
        }
    }

}

impl TpmStructure for TPM2_PolicyTicket_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_PolicyTicket_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.timeout);
        buf.writeSizedByteBuf(self.cpHashA);
        buf.writeSizedByteBuf(self.policyRef);
        buf.writeSizedByteBuf(self.authName);
        self.ticket.toTpm(buf);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.timeout = buf.readSizedByteBuf();
        self.cpHashA = buf.readSizedByteBuf();
        self.policyRef = buf.readSizedByteBuf();
        self.authName = buf.readSizedByteBuf();
        self.ticket.initFromTpm(buf);
        Ok(())
    }

}

/// This command allows options in authorizations without requiring that the TPM evaluate
/// all of the options. If a policy may be satisfied by different sets of conditions, the
/// TPM need only evaluate one set that satisfies the policy. This command will indicate
/// that one of the required sets of conditions has been satisfied.
#[derive(Debug, Default)]
pub struct TPM2_PolicyOR_REQUEST {
    /// Handle for the policy session being extended
    /// Auth Index: None
    pub policySession: TPM_HANDLE,

    /// The list of hashes to check for a match
    pub pHashList: Vec<TPM2B_DIGEST>,
}

impl TPM2_PolicyOR_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        policySession: TPM_HANDLE,
        pHashList: Vec<TPM2B_DIGEST>,
        ) -> Self {
        Self {
            policySession,
            pHashList,
        }
    }

}

impl TpmStructure for TPM2_PolicyOR_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_PolicyOR_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeObjArr(self.pHashList);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        buf.readObjArr(self.pHashList);
        Ok(())
    }

}

/// This command is used to cause conditional gating of a policy based on PCR. This
/// command together with TPM2_PolicyOR() allows one group of authorizations to occur when
/// PCR are in one state and a different set of authorizations when the PCR are in a
/// different state.
#[derive(Debug, Default)]
pub struct TPM2_PolicyPCR_REQUEST {
    /// Handle for the policy session being extended
    /// Auth Index: None
    pub policySession: TPM_HANDLE,

    /// Expected digest value of the selected PCR using the hash algorithm of the session; may
    /// be zero length
    pub pcrDigest: Vec<u8>,

    /// The PCR to include in the check digest
    pub pcrs: Vec<TPMS_PCR_SELECTION>,
}

impl TPM2_PolicyPCR_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        policySession: TPM_HANDLE,
        pcrDigest: Vec<u8>,
        pcrs: Vec<TPMS_PCR_SELECTION>,
        ) -> Self {
        Self {
            policySession,
            pcrDigest,
            pcrs,
        }
    }

}

impl TpmStructure for TPM2_PolicyPCR_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_PolicyPCR_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.pcrDigest);
        buf.writeObjArr(self.pcrs);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.pcrDigest = buf.readSizedByteBuf();
        buf.readObjArr(self.pcrs);
        Ok(())
    }

}

/// This command indicates that the authorization will be limited to a specific locality.
#[derive(Debug, Default)]
pub struct TPM2_PolicyLocality_REQUEST {
    /// Handle for the policy session being extended
    /// Auth Index: None
    pub policySession: TPM_HANDLE,

    /// The allowed localities for the policy
    pub locality: TPMA_LOCALITY,
}

impl TPM2_PolicyLocality_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        policySession: TPM_HANDLE,
        locality: TPMA_LOCALITY,
        ) -> Self {
        Self {
            policySession,
            locality,
        }
    }

}

impl TpmStructure for TPM2_PolicyLocality_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_PolicyLocality_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeByte(self.locality);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.locality = buf.readByte();
        Ok(())
    }

}

/// This command is used to cause conditional gating of a policy based on the contents of
/// an NV Index. It is an immediate assertion. The NV index is validated during the
/// TPM2_PolicyNV() command, not when the session is used for authorization.
#[derive(Debug, Default)]
pub struct TPM2_PolicyNV_REQUEST {
    /// Handle indicating the source of the authorization value
    /// Auth Index: 1
    /// Auth Role: USER
    pub authHandle: TPM_HANDLE,

    /// The NV Index of the area to read
    /// Auth Index: None
    pub nvIndex: TPM_HANDLE,

    /// Handle for the policy session being extended
    /// Auth Index: None
    pub policySession: TPM_HANDLE,

    /// The second operand
    pub operandB: Vec<u8>,

    /// The octet offset in the NV Index for the start of operand A
    pub offset: u16,

    /// The comparison to make
    pub operation: TPM_EO,
}

impl TPM2_PolicyNV_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        authHandle: TPM_HANDLE,
        nvIndex: TPM_HANDLE,
        policySession: TPM_HANDLE,
        operandB: Vec<u8>,
        offset: u16,
        operation: TPM_EO,
        ) -> Self {
        Self {
            authHandle,
            nvIndex,
            policySession,
            operandB,
            offset,
            operation,
        }
    }

}

impl TpmStructure for TPM2_PolicyNV_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_PolicyNV_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.operandB);
        buf.writeShort(self.offset);
        buf.writeShort(self.operation);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.operandB = buf.readSizedByteBuf();
        self.offset = buf.readShort();
        self.operation = buf.readShort();
        Ok(())
    }

}

/// This command is used to cause conditional gating of a policy based on the contents of
/// the TPMS_TIME_INFO structure.
#[derive(Debug, Default)]
pub struct TPM2_PolicyCounterTimer_REQUEST {
    /// Handle for the policy session being extended
    /// Auth Index: None
    pub policySession: TPM_HANDLE,

    /// The second operand
    pub operandB: Vec<u8>,

    /// The octet offset in the TPMS_TIME_INFO structure for the start of operand A
    pub offset: u16,

    /// The comparison to make
    pub operation: TPM_EO,
}

impl TPM2_PolicyCounterTimer_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        policySession: TPM_HANDLE,
        operandB: Vec<u8>,
        offset: u16,
        operation: TPM_EO,
        ) -> Self {
        Self {
            policySession,
            operandB,
            offset,
            operation,
        }
    }

}

impl TpmStructure for TPM2_PolicyCounterTimer_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_PolicyCounterTimer_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.operandB);
        buf.writeShort(self.offset);
        buf.writeShort(self.operation);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.operandB = buf.readSizedByteBuf();
        self.offset = buf.readShort();
        self.operation = buf.readShort();
        Ok(())
    }

}

/// This command indicates that the authorization will be limited to a specific command code.
#[derive(Debug, Default)]
pub struct TPM2_PolicyCommandCode_REQUEST {
    /// Handle for the policy session being extended
    /// Auth Index: None
    pub policySession: TPM_HANDLE,

    /// The allowed commandCode
    pub code: TPM_CC,
}

impl TPM2_PolicyCommandCode_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        policySession: TPM_HANDLE,
        code: TPM_CC,
        ) -> Self {
        Self {
            policySession,
            code,
        }
    }

}

impl TpmStructure for TPM2_PolicyCommandCode_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_PolicyCommandCode_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeInt(self.code);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.code = buf.readInt();
        Ok(())
    }

}

/// This command indicates that physical presence will need to be asserted at the time the
/// authorization is performed.
#[derive(Debug, Default)]
pub struct TPM2_PolicyPhysicalPresence_REQUEST {
    /// Handle for the policy session being extended
    /// Auth Index: None
    pub policySession: TPM_HANDLE,
}

impl TPM2_PolicyPhysicalPresence_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        policySession: TPM_HANDLE,
        ) -> Self {
        Self {
            policySession,
        }
    }

}

impl TpmStructure for TPM2_PolicyPhysicalPresence_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_PolicyPhysicalPresence_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        Ok(())
    }

}

/// This command is used to allow a policy to be bound to a specific command and command parameters.
#[derive(Debug, Default)]
pub struct TPM2_PolicyCpHash_REQUEST {
    /// Handle for the policy session being extended
    /// Auth Index: None
    pub policySession: TPM_HANDLE,

    /// The cpHash added to the policy
    pub cpHashA: Vec<u8>,
}

impl TPM2_PolicyCpHash_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        policySession: TPM_HANDLE,
        cpHashA: Vec<u8>,
        ) -> Self {
        Self {
            policySession,
            cpHashA,
        }
    }

}

impl TpmStructure for TPM2_PolicyCpHash_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_PolicyCpHash_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.cpHashA);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.cpHashA = buf.readSizedByteBuf();
        Ok(())
    }

}

/// This command allows a policy to be bound to a specific set of TPM entities without
/// being bound to the parameters of the command. This is most useful for commands such as
/// TPM2_Duplicate() and for TPM2_PCR_Event() when the referenced PCR requires a policy.
#[derive(Debug, Default)]
pub struct TPM2_PolicyNameHash_REQUEST {
    /// Handle for the policy session being extended
    /// Auth Index: None
    pub policySession: TPM_HANDLE,

    /// The digest to be added to the policy
    pub nameHash: Vec<u8>,
}

impl TPM2_PolicyNameHash_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        policySession: TPM_HANDLE,
        nameHash: Vec<u8>,
        ) -> Self {
        Self {
            policySession,
            nameHash,
        }
    }

}

impl TpmStructure for TPM2_PolicyNameHash_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_PolicyNameHash_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.nameHash);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.nameHash = buf.readSizedByteBuf();
        Ok(())
    }

}

/// This command allows qualification of duplication to allow duplication to a selected
/// new parent.
#[derive(Debug, Default)]
pub struct TPM2_PolicyDuplicationSelect_REQUEST {
    /// Handle for the policy session being extended
    /// Auth Index: None
    pub policySession: TPM_HANDLE,

    /// The Name of the object to be duplicated
    pub objectName: Vec<u8>,

    /// The Name of the new parent
    pub newParentName: Vec<u8>,

    /// If YES, the objectName will be included in the value in policySessionpolicyDigest
    pub includeObject: u8,
}

impl TPM2_PolicyDuplicationSelect_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        policySession: TPM_HANDLE,
        objectName: Vec<u8>,
        newParentName: Vec<u8>,
        includeObject: u8,
        ) -> Self {
        Self {
            policySession,
            objectName,
            newParentName,
            includeObject,
        }
    }

}

impl TpmStructure for TPM2_PolicyDuplicationSelect_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_PolicyDuplicationSelect_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.objectName);
        buf.writeSizedByteBuf(self.newParentName);
        buf.writeByte(self.includeObject);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.objectName = buf.readSizedByteBuf();
        self.newParentName = buf.readSizedByteBuf();
        self.includeObject = buf.readByte();
        Ok(())
    }

}

/// This command allows policies to change. If a policy were static, then it would be
/// difficult to add users to a policy. This command lets a policy authority sign a new
/// policy so that it may be used in an existing policy.
#[derive(Debug, Default)]
pub struct TPM2_PolicyAuthorize_REQUEST {
    /// Handle for the policy session being extended
    /// Auth Index: None
    pub policySession: TPM_HANDLE,

    /// Digest of the policy being approved
    pub approvedPolicy: Vec<u8>,

    /// A policy qualifier
    pub policyRef: Vec<u8>,

    /// Name of a key that can sign a policy addition
    pub keySign: Vec<u8>,

    /// Ticket validating that approvedPolicy and policyRef were signed by keySign
    pub checkTicket: TPMT_TK_VERIFIED,
}

impl TPM2_PolicyAuthorize_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        policySession: TPM_HANDLE,
        approvedPolicy: Vec<u8>,
        policyRef: Vec<u8>,
        keySign: Vec<u8>,
        checkTicket: TPMT_TK_VERIFIED,
        ) -> Self {
        Self {
            policySession,
            approvedPolicy,
            policyRef,
            keySign,
            checkTicket,
        }
    }

}

impl TpmStructure for TPM2_PolicyAuthorize_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_PolicyAuthorize_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.approvedPolicy);
        buf.writeSizedByteBuf(self.policyRef);
        buf.writeSizedByteBuf(self.keySign);
        self.checkTicket.toTpm(buf);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.approvedPolicy = buf.readSizedByteBuf();
        self.policyRef = buf.readSizedByteBuf();
        self.keySign = buf.readSizedByteBuf();
        self.checkTicket.initFromTpm(buf);
        Ok(())
    }

}

/// This command allows a policy to be bound to the authorization value of the authorized entity.
#[derive(Debug, Default)]
pub struct TPM2_PolicyAuthValue_REQUEST {
    /// Handle for the policy session being extended
    /// Auth Index: None
    pub policySession: TPM_HANDLE,
}

impl TPM2_PolicyAuthValue_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        policySession: TPM_HANDLE,
        ) -> Self {
        Self {
            policySession,
        }
    }

}

impl TpmStructure for TPM2_PolicyAuthValue_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_PolicyAuthValue_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        Ok(())
    }

}

/// This command allows a policy to be bound to the authorization value of the authorized object.
#[derive(Debug, Default)]
pub struct TPM2_PolicyPassword_REQUEST {
    /// Handle for the policy session being extended
    /// Auth Index: None
    pub policySession: TPM_HANDLE,
}

impl TPM2_PolicyPassword_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        policySession: TPM_HANDLE,
        ) -> Self {
        Self {
            policySession,
        }
    }

}

impl TpmStructure for TPM2_PolicyPassword_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_PolicyPassword_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        Ok(())
    }

}

/// This command returns the current policyDigest of the session. This command allows the
/// TPM to be used to perform the actions required to pre-compute the authPolicy for an object.
#[derive(Debug, Default)]
pub struct TPM2_PolicyGetDigest_REQUEST {
    /// Handle for the policy session
    /// Auth Index: None
    pub policySession: TPM_HANDLE,
}

impl TPM2_PolicyGetDigest_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        policySession: TPM_HANDLE,
        ) -> Self {
        Self {
            policySession,
        }
    }

}

impl TpmStructure for TPM2_PolicyGetDigest_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_PolicyGetDigest_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        Ok(())
    }

}

/// This command returns the current policyDigest of the session. This command allows the
/// TPM to be used to perform the actions required to pre-compute the authPolicy for an object.
#[derive(Debug, Default)]
pub struct PolicyGetDigestResponse {
    /// The current value of the policySessionpolicyDigest
    pub policyDigest: Vec<u8>,
}

impl PolicyGetDigestResponse {
}

impl TpmStructure for PolicyGetDigestResponse {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<PolicyGetDigestResponse>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.policyDigest);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.policyDigest = buf.readSizedByteBuf();
        Ok(())
    }

}

/// This command allows a policy to be bound to the TPMA_NV_WRITTEN attributes. This is a
/// deferred assertion. Values are stored in the policy session context and checked when
/// the policy is used for authorization.
#[derive(Debug, Default)]
pub struct TPM2_PolicyNvWritten_REQUEST {
    /// Handle for the policy session being extended
    /// Auth Index: None
    pub policySession: TPM_HANDLE,

    /// YES if NV Index is required to have been written
    /// NO if NV Index is required not to have been written
    pub writtenSet: u8,
}

impl TPM2_PolicyNvWritten_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        policySession: TPM_HANDLE,
        writtenSet: u8,
        ) -> Self {
        Self {
            policySession,
            writtenSet,
        }
    }

}

impl TpmStructure for TPM2_PolicyNvWritten_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_PolicyNvWritten_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeByte(self.writtenSet);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.writtenSet = buf.readByte();
        Ok(())
    }

}

/// This command allows a policy to be bound to a specific creation template. This is most
/// useful for an object creation command such as TPM2_Create(), TPM2_CreatePrimary(), or
/// TPM2_CreateLoaded().
#[derive(Debug, Default)]
pub struct TPM2_PolicyTemplate_REQUEST {
    /// Handle for the policy session being extended
    /// Auth Index: None
    pub policySession: TPM_HANDLE,

    /// The digest to be added to the policy
    pub templateHash: Vec<u8>,
}

impl TPM2_PolicyTemplate_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        policySession: TPM_HANDLE,
        templateHash: Vec<u8>,
        ) -> Self {
        Self {
            policySession,
            templateHash,
        }
    }

}

impl TpmStructure for TPM2_PolicyTemplate_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_PolicyTemplate_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.templateHash);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.templateHash = buf.readSizedByteBuf();
        Ok(())
    }

}

/// This command provides a capability that is the equivalent of a revocable policy. With
/// TPM2_PolicyAuthorize(), the authorization ticket never expires, so the authorization
/// may not be withdrawn. With this command, the approved policy is kept in an NV Index
/// location so that the policy may be changed as needed to render the old policy unusable.
#[derive(Debug, Default)]
pub struct TPM2_PolicyAuthorizeNV_REQUEST {
    /// Handle indicating the source of the authorization value
    /// Auth Index: 1
    /// Auth Role: USER
    pub authHandle: TPM_HANDLE,

    /// The NV Index of the area to read
    /// Auth Index: None
    pub nvIndex: TPM_HANDLE,

    /// Handle for the policy session being extended
    /// Auth Index: None
    pub policySession: TPM_HANDLE,
}

impl TPM2_PolicyAuthorizeNV_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        authHandle: TPM_HANDLE,
        nvIndex: TPM_HANDLE,
        policySession: TPM_HANDLE,
        ) -> Self {
        Self {
            authHandle,
            nvIndex,
            policySession,
        }
    }

}

impl TpmStructure for TPM2_PolicyAuthorizeNV_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_PolicyAuthorizeNV_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        Ok(())
    }

}

/// This command is used to create a Primary Object under one of the Primary Seeds or a
/// Temporary Object under TPM_RH_NULL. The command uses a TPM2B_PUBLIC as a template for
/// the object to be created. The size of the unique field shall not be checked for
/// consistency with the other object parameters. The command will create and load a
/// Primary Object. The sensitive area is not returned.
#[derive(Debug, Default)]
pub struct TPM2_CreatePrimary_REQUEST {
    /// TPM_RH_ENDORSEMENT, TPM_RH_OWNER, TPM_RH_PLATFORM+{PP}, or TPM_RH_NULL
    /// Auth Index: 1
    /// Auth Role: USER
    pub primaryHandle: TPM_HANDLE,

    /// The sensitive data, see TPM 2.0 Part 1 Sensitive Values
    pub inSensitive: TPMS_SENSITIVE_CREATE,

    /// The public template
    pub inPublic: TPMT_PUBLIC,

    /// Data that will be included in the creation data for this object to provide permanent,
    /// verifiable linkage between this object and some object owner data
    pub outsideInfo: Vec<u8>,

    /// PCR that will be used in creation data
    pub creationPCR: Vec<TPMS_PCR_SELECTION>,
}

impl TPM2_CreatePrimary_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        primaryHandle: TPM_HANDLE,
        inSensitive: TPMS_SENSITIVE_CREATE,
        inPublic: TPMT_PUBLIC,
        outsideInfo: Vec<u8>,
        creationPCR: Vec<TPMS_PCR_SELECTION>,
        ) -> Self {
        Self {
            primaryHandle,
            inSensitive,
            inPublic,
            outsideInfo,
            creationPCR,
        }
    }

}

impl TpmStructure for TPM2_CreatePrimary_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_CreatePrimary_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedObj(self.inSensitive);
        buf.writeSizedObj(self.inPublic);
        buf.writeSizedByteBuf(self.outsideInfo);
        buf.writeObjArr(self.creationPCR);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        buf.readSizedObj(self.inSensitive);
        buf.readSizedObj(self.inPublic);
        self.outsideInfo = buf.readSizedByteBuf();
        buf.readObjArr(self.creationPCR);
        Ok(())
    }

}

/// This command is used to create a Primary Object under one of the Primary Seeds or a
/// Temporary Object under TPM_RH_NULL. The command uses a TPM2B_PUBLIC as a template for
/// the object to be created. The size of the unique field shall not be checked for
/// consistency with the other object parameters. The command will create and load a
/// Primary Object. The sensitive area is not returned.
#[derive(Debug, Default)]
pub struct CreatePrimaryResponse {
    /// Handle of type TPM_HT_TRANSIENT for created Primary Object
    pub handle: TPM_HANDLE,

    /// The public portion of the created object
    pub outPublic: TPMT_PUBLIC,

    /// Contains a TPMT_CREATION_DATA
    pub creationData: TPMS_CREATION_DATA,

    /// Digest of creationData using nameAlg of outPublic
    pub creationHash: Vec<u8>,

    /// Ticket used by TPM2_CertifyCreation() to validate that the creation data was produced
    /// by the TPM
    pub creationTicket: TPMT_TK_CREATION,

    /// The name of the created object
    pub name: Vec<u8>,
}

impl CreatePrimaryResponse {
}

impl TpmStructure for CreatePrimaryResponse {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<CreatePrimaryResponse>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedObj(self.outPublic);
        buf.writeSizedObj(self.creationData);
        buf.writeSizedByteBuf(self.creationHash);
        self.creationTicket.toTpm(buf);
        buf.writeSizedByteBuf(self.name);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        buf.readSizedObj(self.outPublic);
        buf.readSizedObj(self.creationData);
        self.creationHash = buf.readSizedByteBuf();
        self.creationTicket.initFromTpm(buf);
        self.name = buf.readSizedByteBuf();
        Ok(())
    }

}

/// This command enables and disables use of a hierarchy and its associated NV storage.
/// The command allows phEnable, phEnableNV, shEnable, and ehEnable to be changed when the
/// proper authorization is provided.
#[derive(Debug, Default)]
pub struct TPM2_HierarchyControl_REQUEST {
    /// TPM_RH_ENDORSEMENT, TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
    /// Auth Index: 1
    /// Auth Role: USER
    pub authHandle: TPM_HANDLE,

    /// The enable being modified
    /// TPM_RH_ENDORSEMENT, TPM_RH_OWNER, TPM_RH_PLATFORM, or TPM_RH_PLATFORM_NV
    pub enable: TPM_HANDLE,

    /// YES if the enable should be SET, NO if the enable should be CLEAR
    pub state: u8,
}

impl TPM2_HierarchyControl_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        authHandle: TPM_HANDLE,
        enable: TPM_HANDLE,
        state: u8,
        ) -> Self {
        Self {
            authHandle,
            enable,
            state,
        }
    }

}

impl TpmStructure for TPM2_HierarchyControl_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_HierarchyControl_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.enable.toTpm(buf);
        buf.writeByte(self.state);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.enable.initFromTpm(buf);
        self.state = buf.readByte();
        Ok(())
    }

}

/// This command allows setting of the authorization policy for the lockout
/// (lockoutPolicy), the platform hierarchy (platformPolicy), the storage hierarchy
/// (ownerPolicy), and the endorsement hierarchy (endorsementPolicy). On TPMs implementing
/// Authenticated Countdown Timers (ACT), this command may also be used to set the
/// authorization policy for an ACT.
#[derive(Debug, Default)]
pub struct TPM2_SetPrimaryPolicy_REQUEST {
    /// TPM_RH_LOCKOUT, TPM_RH_ENDORSEMENT, TPM_RH_OWNER, TPMI_RH_ACT or TPM_RH_PLATFORM+{PP}
    /// Auth Index: 1
    /// Auth Role: USER
    pub authHandle: TPM_HANDLE,

    /// An authorization policy digest; may be the Empty Buffer
    /// If hashAlg is TPM_ALG_NULL, then this shall be an Empty Buffer.
    pub authPolicy: Vec<u8>,

    /// The hash algorithm to use for the policy
    /// If the authPolicy is an Empty Buffer, then this field shall be TPM_ALG_NULL.
    pub hashAlg: TPM_ALG_ID,
}

impl TPM2_SetPrimaryPolicy_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        authHandle: TPM_HANDLE,
        authPolicy: Vec<u8>,
        hashAlg: TPM_ALG_ID,
        ) -> Self {
        Self {
            authHandle,
            authPolicy,
            hashAlg,
        }
    }

}

impl TpmStructure for TPM2_SetPrimaryPolicy_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_SetPrimaryPolicy_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.authPolicy);
        buf.writeShort(self.hashAlg);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.authPolicy = buf.readSizedByteBuf();
        self.hashAlg = buf.readShort();
        Ok(())
    }

}

/// This replaces the current platform primary seed (PPS) with a value from the RNG and
/// sets platformPolicy to the default initialization value (the Empty Buffer).
#[derive(Debug, Default)]
pub struct TPM2_ChangePPS_REQUEST {
    /// TPM_RH_PLATFORM+{PP}
    /// Auth Index: 1
    /// Auth Role: USER
    pub authHandle: TPM_HANDLE,
}

impl TPM2_ChangePPS_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        authHandle: TPM_HANDLE,
        ) -> Self {
        Self {
            authHandle,
        }
    }

}

impl TpmStructure for TPM2_ChangePPS_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_ChangePPS_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        Ok(())
    }

}

/// This replaces the current endorsement primary seed (EPS) with a value from the RNG and
/// sets the Endorsement hierarchy controls to their default initialization values:
/// ehEnable is SET, endorsementAuth and endorsementPolicy are both set to the Empty
/// Buffer. It will flush any resident objects (transient or persistent) in the
/// Endorsement hierarchy and not allow objects in the hierarchy associated with the
/// previous EPS to be loaded.
#[derive(Debug, Default)]
pub struct TPM2_ChangeEPS_REQUEST {
    /// TPM_RH_PLATFORM+{PP}
    /// Auth Handle: 1
    /// Auth Role: USER
    pub authHandle: TPM_HANDLE,
}

impl TPM2_ChangeEPS_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        authHandle: TPM_HANDLE,
        ) -> Self {
        Self {
            authHandle,
        }
    }

}

impl TpmStructure for TPM2_ChangeEPS_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_ChangeEPS_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        Ok(())
    }

}

/// This command removes all TPM context associated with a specific Owner.
#[derive(Debug, Default)]
pub struct TPM2_Clear_REQUEST {
    /// TPM_RH_LOCKOUT or TPM_RH_PLATFORM+{PP}
    /// Auth Handle: 1
    /// Auth Role: USER
    pub authHandle: TPM_HANDLE,
}

impl TPM2_Clear_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        authHandle: TPM_HANDLE,
        ) -> Self {
        Self {
            authHandle,
        }
    }

}

impl TpmStructure for TPM2_Clear_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_Clear_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        Ok(())
    }

}

/// TPM2_ClearControl() disables and enables the execution of TPM2_Clear().
#[derive(Debug, Default)]
pub struct TPM2_ClearControl_REQUEST {
    /// TPM_RH_LOCKOUT or TPM_RH_PLATFORM+{PP}
    /// Auth Handle: 1
    /// Auth Role: USER
    pub auth: TPM_HANDLE,

    /// YES if the disableOwnerClear flag is to be SET, NO if the flag is to be CLEAR.
    pub disable: u8,
}

impl TPM2_ClearControl_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        auth: TPM_HANDLE,
        disable: u8,
        ) -> Self {
        Self {
            auth,
            disable,
        }
    }

}

impl TpmStructure for TPM2_ClearControl_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_ClearControl_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeByte(self.disable);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.disable = buf.readByte();
        Ok(())
    }

}

/// This command allows the authorization secret for a hierarchy or lockout to be changed
/// using the current authorization value as the command authorization.
#[derive(Debug, Default)]
pub struct TPM2_HierarchyChangeAuth_REQUEST {
    /// TPM_RH_LOCKOUT, TPM_RH_ENDORSEMENT, TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
    /// Auth Index: 1
    /// Auth Role: USER
    pub authHandle: TPM_HANDLE,

    /// New authorization value
    pub newAuth: Vec<u8>,
}

impl TPM2_HierarchyChangeAuth_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        authHandle: TPM_HANDLE,
        newAuth: Vec<u8>,
        ) -> Self {
        Self {
            authHandle,
            newAuth,
        }
    }

}

impl TpmStructure for TPM2_HierarchyChangeAuth_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_HierarchyChangeAuth_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.newAuth);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.newAuth = buf.readSizedByteBuf();
        Ok(())
    }

}

/// This command cancels the effect of a TPM lockout due to a number of successive
/// authorization failures. If this command is properly authorized, the lockout counter is
/// set to zero.
#[derive(Debug, Default)]
pub struct TPM2_DictionaryAttackLockReset_REQUEST {
    /// TPM_RH_LOCKOUT
    /// Auth Index: 1
    /// Auth Role: USER
    pub lockHandle: TPM_HANDLE,
}

impl TPM2_DictionaryAttackLockReset_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        lockHandle: TPM_HANDLE,
        ) -> Self {
        Self {
            lockHandle,
        }
    }

}

impl TpmStructure for TPM2_DictionaryAttackLockReset_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_DictionaryAttackLockReset_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        Ok(())
    }

}

/// This command changes the lockout parameters.
#[derive(Debug, Default)]
pub struct TPM2_DictionaryAttackParameters_REQUEST {
    /// TPM_RH_LOCKOUT
    /// Auth Index: 1
    /// Auth Role: USER
    pub lockHandle: TPM_HANDLE,

    /// Count of authorization failures before the lockout is imposed
    pub newMaxTries: u32,

    /// Time in seconds before the authorization failure count is automatically decremented
    /// A value of zero indicates that DA protection is disabled.
    pub newRecoveryTime: u32,

    /// Time in seconds after a lockoutAuth failure before use of lockoutAuth is allowed
    /// A value of zero indicates that a reboot is required.
    pub lockoutRecovery: u32,
}

impl TPM2_DictionaryAttackParameters_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        lockHandle: TPM_HANDLE,
        newMaxTries: u32,
        newRecoveryTime: u32,
        lockoutRecovery: u32,
        ) -> Self {
        Self {
            lockHandle,
            newMaxTries,
            newRecoveryTime,
            lockoutRecovery,
        }
    }

}

impl TpmStructure for TPM2_DictionaryAttackParameters_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_DictionaryAttackParameters_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeInt(self.newMaxTries);
        buf.writeInt(self.newRecoveryTime);
        buf.writeInt(self.lockoutRecovery);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.newMaxTries = buf.readInt();
        self.newRecoveryTime = buf.readInt();
        self.lockoutRecovery = buf.readInt();
        Ok(())
    }

}

/// This command is used to determine which commands require assertion of Physical
/// Presence (PP) in addition to platformAuth/platformPolicy.
#[derive(Debug, Default)]
pub struct TPM2_PP_Commands_REQUEST {
    /// TPM_RH_PLATFORM+PP
    /// Auth Index: 1
    /// Auth Role: USER + Physical Presence
    pub auth: TPM_HANDLE,

    /// List of commands to be added to those that will require that Physical Presence be asserted
    pub setList: Vec<TPM_CC>,

    /// List of commands that will no longer require that Physical Presence be asserted
    pub clearList: Vec<TPM_CC>,
}

impl TPM2_PP_Commands_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        auth: TPM_HANDLE,
        setList: Vec<TPM_CC>,
        clearList: Vec<TPM_CC>,
        ) -> Self {
        Self {
            auth,
            setList,
            clearList,
        }
    }

}

impl TpmStructure for TPM2_PP_Commands_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_PP_Commands_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeValArr(self.setList, 4);
        buf.writeValArr(self.clearList, 4);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        buf.readValArr(self.setList, 4);
        buf.readValArr(self.clearList, 4);
        Ok(())
    }

}

/// This command allows the platform to change the set of algorithms that are used by the
/// TPM. The algorithmSet setting is a vendor-dependent value.
#[derive(Debug, Default)]
pub struct TPM2_SetAlgorithmSet_REQUEST {
    /// TPM_RH_PLATFORM
    /// Auth Index: 1
    /// Auth Role: USER
    pub authHandle: TPM_HANDLE,

    /// A TPM vendor-dependent value indicating the algorithm set selection
    pub algorithmSet: u32,
}

impl TPM2_SetAlgorithmSet_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        authHandle: TPM_HANDLE,
        algorithmSet: u32,
        ) -> Self {
        Self {
            authHandle,
            algorithmSet,
        }
    }

}

impl TpmStructure for TPM2_SetAlgorithmSet_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_SetAlgorithmSet_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeInt(self.algorithmSet);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.algorithmSet = buf.readInt();
        Ok(())
    }

}

/// This command uses platformPolicy and a TPM Vendor Authorization Key to authorize a
/// Field Upgrade Manifest.
#[derive(Debug, Default)]
pub struct TPM2_FieldUpgradeStart_REQUEST {
    /// TPM_RH_PLATFORM+{PP}
    /// Auth Index:1
    /// Auth Role: ADMIN
    pub authorization: TPM_HANDLE,

    /// Handle of a public area that contains the TPM Vendor Authorization Key that will be
    /// used to validate manifestSignature
    /// Auth Index: None
    pub keyHandle: TPM_HANDLE,

    /// Digest of the first block in the field upgrade sequence
    pub fuDigest: Vec<u8>,

    /// Selector of the algorithm used to construct the signature

    /// Signature over fuDigest using the key associated with keyHandle (not optional)
    /// One of: TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA,
    /// TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TPMT_HA,
    /// TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE.
    pub manifestSignature: Option<TPMU_SIGNATURE>,
}

impl TPM2_FieldUpgradeStart_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        authorization: TPM_HANDLE,
        keyHandle: TPM_HANDLE,
        fuDigest: Vec<u8>,
        manifestSignature: Option<TPMU_SIGNATURE>,
        ) -> Self {
        Self {
            authorization,
            keyHandle,
            fuDigest,
            manifestSignature,
        }
    }

}

impl TpmStructure for TPM2_FieldUpgradeStart_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_FieldUpgradeStart_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.fuDigest);
        buf.writeShort(self.manifestSignature.unwrap().GetUnionSelector().unwrap());
        self.manifestSignature.unwrap().toTpm(buf);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.fuDigest = buf.readSizedByteBuf();
        let r#manifestSignatureSigAlg: TPM_ALG_ID = buf.readShort();
        self.manifestSignature = TPMU_SIGNATURE::create(r#manifestSignatureSigAlg)?;
        self.manifestSignature.unwrap().initFromTpm(buf);
        Ok(())
    }

}

/// This command will take the actual field upgrade image to be installed on the TPM. The
/// exact format of fuData is vendor-specific. This command is only possible following a
/// successful TPM2_FieldUpgradeStart(). If the TPM has not received a properly authorized
/// TPM2_FieldUpgradeStart(), then the TPM shall return TPM_RC_FIELDUPGRADE.
#[derive(Debug, Default)]
pub struct TPM2_FieldUpgradeData_REQUEST {
    /// Field upgrade image data
    pub fuData: Vec<u8>,
}

impl TPM2_FieldUpgradeData_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        fuData: Vec<u8>,
        ) -> Self {
        Self {
            fuData,
        }
    }

}

impl TpmStructure for TPM2_FieldUpgradeData_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_FieldUpgradeData_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.fuData);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.fuData = buf.readSizedByteBuf();
        Ok(())
    }

}

/// This command will take the actual field upgrade image to be installed on the TPM. The
/// exact format of fuData is vendor-specific. This command is only possible following a
/// successful TPM2_FieldUpgradeStart(). If the TPM has not received a properly authorized
/// TPM2_FieldUpgradeStart(), then the TPM shall return TPM_RC_FIELDUPGRADE.
#[derive(Debug, Default)]
pub struct FieldUpgradeDataResponse {
    /// Tagged digest of the next block
    /// TPM_ALG_NULL if field update is complete
    pub nextDigest: TPMT_HA,

    /// Tagged digest of the first block of the sequence
    pub firstDigest: TPMT_HA,
}

impl FieldUpgradeDataResponse {
}

impl TpmStructure for FieldUpgradeDataResponse {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<FieldUpgradeDataResponse>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.nextDigest.toTpm(buf);
        self.firstDigest.toTpm(buf);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.nextDigest.initFromTpm(buf);
        self.firstDigest.initFromTpm(buf);
        Ok(())
    }

}

/// This command is used to read a copy of the current firmware installed in the TPM.
#[derive(Debug, Default)]
pub struct TPM2_FirmwareRead_REQUEST {
    /// The number of previous calls to this command in this sequence
    /// set to 0 on the first call
    pub sequenceNumber: u32,
}

impl TPM2_FirmwareRead_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        sequenceNumber: u32,
        ) -> Self {
        Self {
            sequenceNumber,
        }
    }

}

impl TpmStructure for TPM2_FirmwareRead_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_FirmwareRead_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeInt(self.sequenceNumber);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.sequenceNumber = buf.readInt();
        Ok(())
    }

}

/// This command is used to read a copy of the current firmware installed in the TPM.
#[derive(Debug, Default)]
pub struct FirmwareReadResponse {
    /// Field upgrade image data
    pub fuData: Vec<u8>,
}

impl FirmwareReadResponse {
}

impl TpmStructure for FirmwareReadResponse {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<FirmwareReadResponse>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.fuData);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.fuData = buf.readSizedByteBuf();
        Ok(())
    }

}

/// This command saves a session context, object context, or sequence object context
/// outside the TPM.
#[derive(Debug, Default)]
pub struct TPM2_ContextSave_REQUEST {
    /// Handle of the resource to save
    /// Auth Index: None
    pub saveHandle: TPM_HANDLE,
}

impl TPM2_ContextSave_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        saveHandle: TPM_HANDLE,
        ) -> Self {
        Self {
            saveHandle,
        }
    }

}

impl TpmStructure for TPM2_ContextSave_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_ContextSave_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        Ok(())
    }

}

/// This command saves a session context, object context, or sequence object context
/// outside the TPM.
#[derive(Debug, Default)]
pub struct ContextSaveResponse {
    pub context: TPMS_CONTEXT,
}

impl ContextSaveResponse {
}

impl TpmStructure for ContextSaveResponse {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<ContextSaveResponse>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.context.toTpm(buf);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.context.initFromTpm(buf);
        Ok(())
    }

}

/// This command is used to reload a context that has been saved by TPM2_ContextSave().
#[derive(Debug, Default)]
pub struct TPM2_ContextLoad_REQUEST {
    /// The context blob
    pub context: TPMS_CONTEXT,
}

impl TPM2_ContextLoad_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        context: TPMS_CONTEXT,
        ) -> Self {
        Self {
            context,
        }
    }

}

impl TpmStructure for TPM2_ContextLoad_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_ContextLoad_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.context.toTpm(buf);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.context.initFromTpm(buf);
        Ok(())
    }

}

/// This command is used to reload a context that has been saved by TPM2_ContextSave().
#[derive(Debug, Default)]
pub struct ContextLoadResponse {
    /// The handle assigned to the resource after it has been successfully loaded
    pub handle: TPM_HANDLE,
}

impl ContextLoadResponse {
}

impl TpmStructure for ContextLoadResponse {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<ContextLoadResponse>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        Ok(())
    }

}

/// This command causes all context associated with a loaded object, sequence object, or
/// session to be removed from TPM memory.
#[derive(Debug, Default)]
pub struct TPM2_FlushContext_REQUEST {
    /// The handle of the item to flush
    /// NOTE This is a use of a handle as a parameter.
    pub flushHandle: TPM_HANDLE,
}

impl TPM2_FlushContext_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        flushHandle: TPM_HANDLE,
        ) -> Self {
        Self {
            flushHandle,
        }
    }

}

impl TpmStructure for TPM2_FlushContext_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_FlushContext_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.flushHandle.toTpm(buf);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.flushHandle.initFromTpm(buf);
        Ok(())
    }

}

/// This command allows certain Transient Objects to be made persistent or a persistent
/// object to be evicted.
#[derive(Debug, Default)]
pub struct TPM2_EvictControl_REQUEST {
    /// TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
    /// Auth Handle: 1
    /// Auth Role: USER
    pub auth: TPM_HANDLE,

    /// The handle of a loaded object
    /// Auth Index: None
    pub objectHandle: TPM_HANDLE,

    /// If objectHandle is a transient object handle, then this is the persistent handle for
    /// the object
    /// if objectHandle is a persistent object handle, then it shall be the same value as
    /// persistentHandle
    pub persistentHandle: TPM_HANDLE,
}

impl TPM2_EvictControl_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        auth: TPM_HANDLE,
        objectHandle: TPM_HANDLE,
        persistentHandle: TPM_HANDLE,
        ) -> Self {
        Self {
            auth,
            objectHandle,
            persistentHandle,
        }
    }

}

impl TpmStructure for TPM2_EvictControl_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_EvictControl_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.persistentHandle.toTpm(buf);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.persistentHandle.initFromTpm(buf);
        Ok(())
    }

}

/// This command reads the current TPMS_TIME_INFO structure that contains the current
/// setting of Time, Clock, resetCount, and restartCount.
#[derive(Debug, Default)]
pub struct TPM2_ReadClock_REQUEST {
}

impl TPM2_ReadClock_REQUEST {
}

impl TpmStructure for TPM2_ReadClock_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_ReadClock_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        Ok(())
    }

}

/// This command reads the current TPMS_TIME_INFO structure that contains the current
/// setting of Time, Clock, resetCount, and restartCount.
#[derive(Debug, Default)]
pub struct ReadClockResponse {
    pub currentTime: TPMS_TIME_INFO,
}

impl ReadClockResponse {
}

impl TpmStructure for ReadClockResponse {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<ReadClockResponse>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.currentTime.toTpm(buf);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.currentTime.initFromTpm(buf);
        Ok(())
    }

}

/// This command is used to advance the value of the TPMs Clock. The command will fail if
/// newTime is less than the current value of Clock or if the new time is greater than
/// FFFF00000000000016. If both of these checks succeed, Clock is set to newTime. If
/// either of these checks fails, the TPM shall return TPM_RC_VALUE and make no change to Clock.
#[derive(Debug, Default)]
pub struct TPM2_ClockSet_REQUEST {
    /// TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
    /// Auth Handle: 1
    /// Auth Role: USER
    pub auth: TPM_HANDLE,

    /// New Clock setting in milliseconds
    pub newTime: u64,
}

impl TPM2_ClockSet_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        auth: TPM_HANDLE,
        newTime: u64,
        ) -> Self {
        Self {
            auth,
            newTime,
        }
    }

}

impl TpmStructure for TPM2_ClockSet_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_ClockSet_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeInt64(self.newTime);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.newTime = buf.readInt64();
        Ok(())
    }

}

/// This command adjusts the rate of advance of Clock and Time to provide a better
/// approximation to real time.
#[derive(Debug, Default)]
pub struct TPM2_ClockRateAdjust_REQUEST {
    /// TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
    /// Auth Handle: 1
    /// Auth Role: USER
    pub auth: TPM_HANDLE,

    /// Adjustment to current Clock update rate
    pub rateAdjust: TPM_CLOCK_ADJUST,
}

impl TPM2_ClockRateAdjust_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        auth: TPM_HANDLE,
        rateAdjust: TPM_CLOCK_ADJUST,
        ) -> Self {
        Self {
            auth,
            rateAdjust,
        }
    }

}

impl TpmStructure for TPM2_ClockRateAdjust_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_ClockRateAdjust_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeByte(self.rateAdjust);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.rateAdjust = buf.readByte();
        Ok(())
    }

}

/// This command returns various information regarding the TPM and its current state.
#[derive(Debug, Default)]
pub struct TPM2_GetCapability_REQUEST {
    /// Group selection; determines the format of the response
    pub capability: TPM_CAP,

    /// Further definition of information
    pub property: u32,

    /// Number of properties of the indicated type to return
    pub propertyCount: u32,
}

impl TPM2_GetCapability_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        capability: TPM_CAP,
        property: u32,
        propertyCount: u32,
        ) -> Self {
        Self {
            capability,
            property,
            propertyCount,
        }
    }

}

impl TpmStructure for TPM2_GetCapability_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_GetCapability_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeInt(self.capability);
        buf.writeInt(self.property);
        buf.writeInt(self.propertyCount);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.capability = buf.readInt();
        self.property = buf.readInt();
        self.propertyCount = buf.readInt();
        Ok(())
    }

}

/// This command returns various information regarding the TPM and its current state.
#[derive(Debug, Default)]
pub struct GetCapabilityResponse {
    /// Flag to indicate if there are more values of this type
    pub moreData: u8,

    /// The capability

    /// The capability data
    /// One of: TPML_ALG_PROPERTY, TPML_HANDLE, TPML_CCA, TPML_CC, TPML_PCR_SELECTION,
    /// TPML_TAGGED_TPM_PROPERTY, TPML_TAGGED_PCR_PROPERTY, TPML_ECC_CURVE,
    /// TPML_TAGGED_POLICY, TPML_ACT_DATA.
    pub capabilityData: Option<TPMU_CAPABILITIES>,
}

impl GetCapabilityResponse {
}

impl TpmStructure for GetCapabilityResponse {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<GetCapabilityResponse>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeByte(self.moreData);
        buf.writeInt(self.capabilityData.unwrap().GetUnionSelector().unwrap());
        self.capabilityData.unwrap().toTpm(buf);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.moreData = buf.readByte();
        let r#capabilityDataCapability: TPM_CAP = buf.readInt();
        self.capabilityData = TPMU_CAPABILITIES::create(r#capabilityDataCapability)?;
        self.capabilityData.unwrap().initFromTpm(buf);
        Ok(())
    }

}

/// This command is used to check to see if specific combinations of algorithm parameters
/// are supported.
#[derive(Debug, Default)]
pub struct TPM2_TestParms_REQUEST {
    /// The algorithm to be tested

    /// Algorithm parameters to be validated
    /// One of: TPMS_KEYEDHASH_PARMS, TPMS_SYMCIPHER_PARMS, TPMS_RSA_PARMS, TPMS_ECC_PARMS,
    /// TPMS_ASYM_PARMS.
    pub parameters: Option<TPMU_PUBLIC_PARMS>,
}

impl TPM2_TestParms_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        parameters: Option<TPMU_PUBLIC_PARMS>,
        ) -> Self {
        Self {
            parameters,
        }
    }

}

impl TpmStructure for TPM2_TestParms_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_TestParms_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        if (self.parameters.is_none()) { return Ok(()) };
        buf.writeShort(self.parameters.unwrap().GetUnionSelector().unwrap());
        self.parameters.unwrap().toTpm(buf);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        let r#parametersType: TPM_ALG_ID = buf.readShort();
        self.parameters = TPMU_PUBLIC_PARMS::create(r#parametersType)?;
        self.parameters.unwrap().initFromTpm(buf);
        Ok(())
    }

}

/// This command defines the attributes of an NV Index and causes the TPM to reserve space
/// to hold the data associated with the NV Index. If a definition already exists at the
/// NV Index, the TPM will return TPM_RC_NV_DEFINED.
#[derive(Debug, Default)]
pub struct TPM2_NV_DefineSpace_REQUEST {
    /// TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
    /// Auth Index: 1
    /// Auth Role: USER
    pub authHandle: TPM_HANDLE,

    /// The authorization value
    pub auth: Vec<u8>,

    /// The public parameters of the NV area
    pub publicInfo: TPMS_NV_PUBLIC,
}

impl TPM2_NV_DefineSpace_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        authHandle: TPM_HANDLE,
        auth: Vec<u8>,
        publicInfo: TPMS_NV_PUBLIC,
        ) -> Self {
        Self {
            authHandle,
            auth,
            publicInfo,
        }
    }

}

impl TpmStructure for TPM2_NV_DefineSpace_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_NV_DefineSpace_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.auth);
        buf.writeSizedObj(self.publicInfo);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.auth = buf.readSizedByteBuf();
        buf.readSizedObj(self.publicInfo);
        Ok(())
    }

}

/// This command removes an Index from the TPM.
#[derive(Debug, Default)]
pub struct TPM2_NV_UndefineSpace_REQUEST {
    /// TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
    /// Auth Index: 1
    /// Auth Role: USER
    pub authHandle: TPM_HANDLE,

    /// The NV Index to remove from NV space
    /// Auth Index: None
    pub nvIndex: TPM_HANDLE,
}

impl TPM2_NV_UndefineSpace_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        authHandle: TPM_HANDLE,
        nvIndex: TPM_HANDLE,
        ) -> Self {
        Self {
            authHandle,
            nvIndex,
        }
    }

}

impl TpmStructure for TPM2_NV_UndefineSpace_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_NV_UndefineSpace_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        Ok(())
    }

}

/// This command allows removal of a platform-created NV Index that has
/// TPMA_NV_POLICY_DELETE SET.
#[derive(Debug, Default)]
pub struct TPM2_NV_UndefineSpaceSpecial_REQUEST {
    /// Index to be deleted
    /// Auth Index: 1
    /// Auth Role: ADMIN
    pub nvIndex: TPM_HANDLE,

    /// TPM_RH_PLATFORM + {PP}
    /// Auth Index: 2
    /// Auth Role: USER
    pub platform: TPM_HANDLE,
}

impl TPM2_NV_UndefineSpaceSpecial_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        nvIndex: TPM_HANDLE,
        platform: TPM_HANDLE,
        ) -> Self {
        Self {
            nvIndex,
            platform,
        }
    }

}

impl TpmStructure for TPM2_NV_UndefineSpaceSpecial_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_NV_UndefineSpaceSpecial_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        Ok(())
    }

}

/// This command is used to read the public area and Name of an NV Index. The public area
/// of an Index is not privacy-sensitive and no authorization is required to read this data.
#[derive(Debug, Default)]
pub struct TPM2_NV_ReadPublic_REQUEST {
    /// The NV Index
    /// Auth Index: None
    pub nvIndex: TPM_HANDLE,
}

impl TPM2_NV_ReadPublic_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        nvIndex: TPM_HANDLE,
        ) -> Self {
        Self {
            nvIndex,
        }
    }

}

impl TpmStructure for TPM2_NV_ReadPublic_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_NV_ReadPublic_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        Ok(())
    }

}

/// This command is used to read the public area and Name of an NV Index. The public area
/// of an Index is not privacy-sensitive and no authorization is required to read this data.
#[derive(Debug, Default)]
pub struct NV_ReadPublicResponse {
    /// The public area of the NV Index
    pub nvPublic: TPMS_NV_PUBLIC,

    /// The Name of the nvIndex
    pub nvName: Vec<u8>,
}

impl NV_ReadPublicResponse {
}

impl TpmStructure for NV_ReadPublicResponse {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<NV_ReadPublicResponse>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedObj(self.nvPublic);
        buf.writeSizedByteBuf(self.nvName);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        buf.readSizedObj(self.nvPublic);
        self.nvName = buf.readSizedByteBuf();
        Ok(())
    }

}

/// This command writes a value to an area in NV memory that was previously defined by
/// TPM2_NV_DefineSpace().
#[derive(Debug, Default)]
pub struct TPM2_NV_Write_REQUEST {
    /// Handle indicating the source of the authorization value
    /// Auth Index: 1
    /// Auth Role: USER
    pub authHandle: TPM_HANDLE,

    /// The NV Index of the area to write
    /// Auth Index: None
    pub nvIndex: TPM_HANDLE,

    /// The data to write
    pub data: Vec<u8>,

    /// The octet offset into the NV Area
    pub offset: u16,
}

impl TPM2_NV_Write_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        authHandle: TPM_HANDLE,
        nvIndex: TPM_HANDLE,
        data: Vec<u8>,
        offset: u16,
        ) -> Self {
        Self {
            authHandle,
            nvIndex,
            data,
            offset,
        }
    }

}

impl TpmStructure for TPM2_NV_Write_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_NV_Write_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.data);
        buf.writeShort(self.offset);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.data = buf.readSizedByteBuf();
        self.offset = buf.readShort();
        Ok(())
    }

}

/// This command is used to increment the value in an NV Index that has the TPM_NT_COUNTER
/// attribute. The data value of the NV Index is incremented by one.
#[derive(Debug, Default)]
pub struct TPM2_NV_Increment_REQUEST {
    /// Handle indicating the source of the authorization value
    /// Auth Index: 1
    /// Auth Role: USER
    pub authHandle: TPM_HANDLE,

    /// The NV Index to increment
    /// Auth Index: None
    pub nvIndex: TPM_HANDLE,
}

impl TPM2_NV_Increment_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        authHandle: TPM_HANDLE,
        nvIndex: TPM_HANDLE,
        ) -> Self {
        Self {
            authHandle,
            nvIndex,
        }
    }

}

impl TpmStructure for TPM2_NV_Increment_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_NV_Increment_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        Ok(())
    }

}

/// This command extends a value to an area in NV memory that was previously defined by
/// TPM2_NV_DefineSpace.
#[derive(Debug, Default)]
pub struct TPM2_NV_Extend_REQUEST {
    /// Handle indicating the source of the authorization value
    /// Auth Index: 1
    /// Auth Role: USER
    pub authHandle: TPM_HANDLE,

    /// The NV Index to extend
    /// Auth Index: None
    pub nvIndex: TPM_HANDLE,

    /// The data to extend
    pub data: Vec<u8>,
}

impl TPM2_NV_Extend_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        authHandle: TPM_HANDLE,
        nvIndex: TPM_HANDLE,
        data: Vec<u8>,
        ) -> Self {
        Self {
            authHandle,
            nvIndex,
            data,
        }
    }

}

impl TpmStructure for TPM2_NV_Extend_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_NV_Extend_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.data);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.data = buf.readSizedByteBuf();
        Ok(())
    }

}

/// This command is used to SET bits in an NV Index that was created as a bit field. Any
/// number of bits from 0 to 64 may be SET. The contents of bits are ORed with the current
/// contents of the NV Index.
#[derive(Debug, Default)]
pub struct TPM2_NV_SetBits_REQUEST {
    /// Handle indicating the source of the authorization value
    /// Auth Index: 1
    /// Auth Role: USER
    pub authHandle: TPM_HANDLE,

    /// NV Index of the area in which the bit is to be set
    /// Auth Index: None
    pub nvIndex: TPM_HANDLE,

    /// The data to OR with the current contents
    pub bits: u64,
}

impl TPM2_NV_SetBits_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        authHandle: TPM_HANDLE,
        nvIndex: TPM_HANDLE,
        bits: u64,
        ) -> Self {
        Self {
            authHandle,
            nvIndex,
            bits,
        }
    }

}

impl TpmStructure for TPM2_NV_SetBits_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_NV_SetBits_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeInt64(self.bits);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.bits = buf.readInt64();
        Ok(())
    }

}

/// If the TPMA_NV_WRITEDEFINE or TPMA_NV_WRITE_STCLEAR attributes of an NV location are
/// SET, then this command may be used to inhibit further writes of the NV Index.
#[derive(Debug, Default)]
pub struct TPM2_NV_WriteLock_REQUEST {
    /// Handle indicating the source of the authorization value
    /// Auth Index: 1
    /// Auth Role: USER
    pub authHandle: TPM_HANDLE,

    /// The NV Index of the area to lock
    /// Auth Index: None
    pub nvIndex: TPM_HANDLE,
}

impl TPM2_NV_WriteLock_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        authHandle: TPM_HANDLE,
        nvIndex: TPM_HANDLE,
        ) -> Self {
        Self {
            authHandle,
            nvIndex,
        }
    }

}

impl TpmStructure for TPM2_NV_WriteLock_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_NV_WriteLock_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        Ok(())
    }

}

/// The command will SET TPMA_NV_WRITELOCKED for all indexes that have their
/// TPMA_NV_GLOBALLOCK attribute SET.
#[derive(Debug, Default)]
pub struct TPM2_NV_GlobalWriteLock_REQUEST {
    /// TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
    /// Auth Index: 1
    /// Auth Role: USER
    pub authHandle: TPM_HANDLE,
}

impl TPM2_NV_GlobalWriteLock_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        authHandle: TPM_HANDLE,
        ) -> Self {
        Self {
            authHandle,
        }
    }

}

impl TpmStructure for TPM2_NV_GlobalWriteLock_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_NV_GlobalWriteLock_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        Ok(())
    }

}

/// This command reads a value from an area in NV memory previously defined by TPM2_NV_DefineSpace().
#[derive(Debug, Default)]
pub struct TPM2_NV_Read_REQUEST {
    /// The handle indicating the source of the authorization value
    /// Auth Index: 1
    /// Auth Role: USER
    pub authHandle: TPM_HANDLE,

    /// The NV Index to be read
    /// Auth Index: None
    pub nvIndex: TPM_HANDLE,

    /// Number of octets to read
    pub size: u16,

    /// Octet offset into the NV area
    /// This value shall be less than or equal to the size of the nvIndex data.
    pub offset: u16,
}

impl TPM2_NV_Read_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        authHandle: TPM_HANDLE,
        nvIndex: TPM_HANDLE,
        size: u16,
        offset: u16,
        ) -> Self {
        Self {
            authHandle,
            nvIndex,
            size,
            offset,
        }
    }

}

impl TpmStructure for TPM2_NV_Read_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_NV_Read_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeShort(self.size);
        buf.writeShort(self.offset);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.size = buf.readShort();
        self.offset = buf.readShort();
        Ok(())
    }

}

/// This command reads a value from an area in NV memory previously defined by TPM2_NV_DefineSpace().
#[derive(Debug, Default)]
pub struct NV_ReadResponse {
    /// The data read
    pub data: Vec<u8>,
}

impl NV_ReadResponse {
}

impl TpmStructure for NV_ReadResponse {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<NV_ReadResponse>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.data);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.data = buf.readSizedByteBuf();
        Ok(())
    }

}

/// If TPMA_NV_READ_STCLEAR is SET in an Index, then this command may be used to prevent
/// further reads of the NV Index until the next TPM2_Startup (TPM_SU_CLEAR).
#[derive(Debug, Default)]
pub struct TPM2_NV_ReadLock_REQUEST {
    /// The handle indicating the source of the authorization value
    /// Auth Index: 1
    /// Auth Role: USER
    pub authHandle: TPM_HANDLE,

    /// The NV Index to be locked
    /// Auth Index: None
    pub nvIndex: TPM_HANDLE,
}

impl TPM2_NV_ReadLock_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        authHandle: TPM_HANDLE,
        nvIndex: TPM_HANDLE,
        ) -> Self {
        Self {
            authHandle,
            nvIndex,
        }
    }

}

impl TpmStructure for TPM2_NV_ReadLock_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_NV_ReadLock_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        Ok(())
    }

}

/// This command allows the authorization secret for an NV Index to be changed.
#[derive(Debug, Default)]
pub struct TPM2_NV_ChangeAuth_REQUEST {
    /// Handle of the entity
    /// Auth Index: 1
    /// Auth Role: ADMIN
    pub nvIndex: TPM_HANDLE,

    /// New authorization value
    pub newAuth: Vec<u8>,
}

impl TPM2_NV_ChangeAuth_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        nvIndex: TPM_HANDLE,
        newAuth: Vec<u8>,
        ) -> Self {
        Self {
            nvIndex,
            newAuth,
        }
    }

}

impl TpmStructure for TPM2_NV_ChangeAuth_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_NV_ChangeAuth_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.newAuth);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.newAuth = buf.readSizedByteBuf();
        Ok(())
    }

}

/// The purpose of this command is to certify the contents of an NV Index or portion of an
/// NV Index.
#[derive(Debug, Default)]
pub struct TPM2_NV_Certify_REQUEST {
    /// Handle of the key used to sign the attestation structure
    /// Auth Index: 1
    /// Auth Role: USER
    pub signHandle: TPM_HANDLE,

    /// Handle indicating the source of the authorization value for the NV Index
    /// Auth Index: 2
    /// Auth Role: USER
    pub authHandle: TPM_HANDLE,

    /// Index for the area to be certified
    /// Auth Index: None
    pub nvIndex: TPM_HANDLE,

    /// User-provided qualifying data
    pub qualifyingData: Vec<u8>,

    /// Scheme selector

    /// Signing scheme to use if the scheme for signHandle is TPM_ALG_NULL
    /// One of: TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA,
    /// TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR,
    /// TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME.
    pub inScheme: Option<TPMU_SIG_SCHEME>,

    /// Number of octets to certify
    pub size: u16,

    /// Octet offset into the NV area
    /// This value shall be less than or equal to the size of the nvIndex data.
    pub offset: u16,
}

impl TPM2_NV_Certify_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        signHandle: TPM_HANDLE,
        authHandle: TPM_HANDLE,
        nvIndex: TPM_HANDLE,
        qualifyingData: Vec<u8>,
        inScheme: Option<TPMU_SIG_SCHEME>,
        size: u16,
        offset: u16,
        ) -> Self {
        Self {
            signHandle,
            authHandle,
            nvIndex,
            qualifyingData,
            inScheme,
            size,
            offset,
        }
    }

}

impl TpmStructure for TPM2_NV_Certify_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_NV_Certify_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.qualifyingData);
        buf.writeShort(self.inScheme.unwrap().GetUnionSelector().unwrap());
        self.inScheme.unwrap().toTpm(buf);
        buf.writeShort(self.size);
        buf.writeShort(self.offset);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.qualifyingData = buf.readSizedByteBuf();
        let r#inSchemeScheme: TPM_ALG_ID = buf.readShort();
        self.inScheme = TPMU_SIG_SCHEME::create(r#inSchemeScheme)?;
        self.inScheme.unwrap().initFromTpm(buf);
        self.size = buf.readShort();
        self.offset = buf.readShort();
        Ok(())
    }

}

/// The purpose of this command is to certify the contents of an NV Index or portion of an
/// NV Index.
#[derive(Debug, Default)]
pub struct NV_CertifyResponse {
    /// The structure that was signed
    pub certifyInfo: TPMS_ATTEST,

    /// Selector of the algorithm used to construct the signature

    /// The asymmetric signature over certifyInfo using the key referenced by signHandle
    /// One of: TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA,
    /// TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TPMT_HA,
    /// TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE.
    pub signature: Option<TPMU_SIGNATURE>,
}

impl NV_CertifyResponse {
}

impl TpmStructure for NV_CertifyResponse {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<NV_CertifyResponse>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedObj(self.certifyInfo);
        buf.writeShort(self.signature.unwrap().GetUnionSelector().unwrap());
        self.signature.unwrap().toTpm(buf);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        buf.readSizedObj(self.certifyInfo);
        let r#signatureSigAlg: TPM_ALG_ID = buf.readShort();
        self.signature = TPMU_SIGNATURE::create(r#signatureSigAlg)?;
        self.signature.unwrap().initFromTpm(buf);
        Ok(())
    }

}

/// The purpose of this command is to obtain information about an Attached Component
/// referenced by an AC handle.
#[derive(Debug, Default)]
pub struct TPM2_AC_GetCapability_REQUEST {
    /// Handle indicating the Attached Component
    /// Auth Index: None
    pub ac: TPM_HANDLE,

    /// Starting info type
    pub capability: TPM_AT,

    /// Maximum number of values to return
    pub count: u32,
}

impl TPM2_AC_GetCapability_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        ac: TPM_HANDLE,
        capability: TPM_AT,
        count: u32,
        ) -> Self {
        Self {
            ac,
            capability,
            count,
        }
    }

}

impl TpmStructure for TPM2_AC_GetCapability_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_AC_GetCapability_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeInt(self.capability);
        buf.writeInt(self.count);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.capability = buf.readInt();
        self.count = buf.readInt();
        Ok(())
    }

}

/// The purpose of this command is to obtain information about an Attached Component
/// referenced by an AC handle.
#[derive(Debug, Default)]
pub struct AC_GetCapabilityResponse {
    /// Flag to indicate whether there are more values
    pub moreData: u8,

    /// List of capabilities
    pub capabilitiesData: Vec<TPMS_AC_OUTPUT>,
}

impl AC_GetCapabilityResponse {
}

impl TpmStructure for AC_GetCapabilityResponse {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<AC_GetCapabilityResponse>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeByte(self.moreData);
        buf.writeObjArr(self.capabilitiesData);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.moreData = buf.readByte();
        buf.readObjArr(self.capabilitiesData);
        Ok(())
    }

}

/// The purpose of this command is to send (copy) a loaded object from the TPM to an
/// Attached Component.
#[derive(Debug, Default)]
pub struct TPM2_AC_Send_REQUEST {
    /// Handle of the object being sent to ac
    /// Auth Index: 1
    /// Auth Role: DUP
    pub sendObject: TPM_HANDLE,

    /// The handle indicating the source of the authorization value
    /// Auth Index: 2
    /// Auth Role: USER
    pub authHandle: TPM_HANDLE,

    /// Handle indicating the Attached Component to which the object will be sent
    /// Auth Index: None
    pub ac: TPM_HANDLE,

    /// Optional non sensitive information related to the object
    pub acDataIn: Vec<u8>,
}

impl TPM2_AC_Send_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        sendObject: TPM_HANDLE,
        authHandle: TPM_HANDLE,
        ac: TPM_HANDLE,
        acDataIn: Vec<u8>,
        ) -> Self {
        Self {
            sendObject,
            authHandle,
            ac,
            acDataIn,
        }
    }

}

impl TpmStructure for TPM2_AC_Send_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_AC_Send_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.acDataIn);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.acDataIn = buf.readSizedByteBuf();
        Ok(())
    }

}

/// The purpose of this command is to send (copy) a loaded object from the TPM to an
/// Attached Component.
#[derive(Debug, Default)]
pub struct AC_SendResponse {
    /// May include AC specific data or information about an error.
    pub acDataOut: TPMS_AC_OUTPUT,
}

impl AC_SendResponse {
}

impl TpmStructure for AC_SendResponse {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<AC_SendResponse>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.acDataOut.toTpm(buf);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.acDataOut.initFromTpm(buf);
        Ok(())
    }

}

/// This command allows qualification of the sending (copying) of an Object to an Attached
/// Component (AC). Qualification includes selection of the receiving AC and the method of
/// authentication for the AC, and, in certain circumstances, the Object to be sent may be
/// specified.
#[derive(Debug, Default)]
pub struct TPM2_Policy_AC_SendSelect_REQUEST {
    /// Handle for the policy session being extended
    /// Auth Index: None
    pub policySession: TPM_HANDLE,

    /// The Name of the Object to be sent
    pub objectName: Vec<u8>,

    /// The Name associated with authHandle used in the TPM2_AC_Send() command
    pub authHandleName: Vec<u8>,

    /// The Name of the Attached Component to which the Object will be sent
    pub acName: Vec<u8>,

    /// If SET, objectName will be included in the value in policySessionpolicyDigest
    pub includeObject: u8,
}

impl TPM2_Policy_AC_SendSelect_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        policySession: TPM_HANDLE,
        objectName: Vec<u8>,
        authHandleName: Vec<u8>,
        acName: Vec<u8>,
        includeObject: u8,
        ) -> Self {
        Self {
            policySession,
            objectName,
            authHandleName,
            acName,
            includeObject,
        }
    }

}

impl TpmStructure for TPM2_Policy_AC_SendSelect_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_Policy_AC_SendSelect_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.objectName);
        buf.writeSizedByteBuf(self.authHandleName);
        buf.writeSizedByteBuf(self.acName);
        buf.writeByte(self.includeObject);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.objectName = buf.readSizedByteBuf();
        self.authHandleName = buf.readSizedByteBuf();
        self.acName = buf.readSizedByteBuf();
        self.includeObject = buf.readByte();
        Ok(())
    }

}

/// This command is used to set the time remaining before an Authenticated Countdown Timer
/// (ACT) expires.
#[derive(Debug, Default)]
pub struct TPM2_ACT_SetTimeout_REQUEST {
    /// Handle of the selected ACT
    /// Auth Index: 1
    /// Auth Role: USER
    pub actHandle: TPM_HANDLE,

    /// The start timeout value for the ACT in seconds
    pub startTimeout: u32,
}

impl TPM2_ACT_SetTimeout_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        actHandle: TPM_HANDLE,
        startTimeout: u32,
        ) -> Self {
        Self {
            actHandle,
            startTimeout,
        }
    }

}

impl TpmStructure for TPM2_ACT_SetTimeout_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_ACT_SetTimeout_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeInt(self.startTimeout);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.startTimeout = buf.readInt();
        Ok(())
    }

}

/// This is a placeholder to allow testing of the dispatch code.
#[derive(Debug, Default)]
pub struct TPM2_Vendor_TCG_Test_REQUEST {
    /// Dummy data
    pub inputData: Vec<u8>,
}

impl TPM2_Vendor_TCG_Test_REQUEST {
    /// Creates a new instance with the specified values
    pub fn new(
        inputData: Vec<u8>,
        ) -> Self {
        Self {
            inputData,
        }
    }

}

impl TpmStructure for TPM2_Vendor_TCG_Test_REQUEST {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2_Vendor_TCG_Test_REQUEST>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.inputData);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.inputData = buf.readSizedByteBuf();
        Ok(())
    }

}

/// This is a placeholder to allow testing of the dispatch code.
#[derive(Debug, Default)]
pub struct Vendor_TCG_TestResponse {
    /// Dummy data
    pub outputData: Vec<u8>,
}

impl Vendor_TCG_TestResponse {
}

impl TpmStructure for Vendor_TCG_TestResponse {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<Vendor_TCG_TestResponse>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.outputData);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.outputData = buf.readSizedByteBuf();
        Ok(())
    }

}

/// These are the RSA schemes that only need a hash algorithm as a scheme parameter.
pub type TPMS_SCHEME_RSASSA = TPMS_SIG_SCHEME_RSASSA;

/// These are the RSA schemes that only need a hash algorithm as a scheme parameter.
pub type TPMS_SCHEME_RSAPSS = TPMS_SIG_SCHEME_RSAPSS;

/// Most of the ECC signature schemes only require a hash algorithm to complete the
/// definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a
/// count value so they are typed to be TPMS_SCHEME_ECDAA.
pub type TPMS_SCHEME_ECDSA = TPMS_SIG_SCHEME_ECDSA;

/// Most of the ECC signature schemes only require a hash algorithm to complete the
/// definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a
/// count value so they are typed to be TPMS_SCHEME_ECDAA.
pub type TPMS_SCHEME_SM2 = TPMS_SIG_SCHEME_SM2;

/// Most of the ECC signature schemes only require a hash algorithm to complete the
/// definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a
/// count value so they are typed to be TPMS_SCHEME_ECDAA.
pub type TPMS_SCHEME_ECSCHNORR = TPMS_SIG_SCHEME_ECSCHNORR;

/// These are the RSA encryption schemes that only need a hash algorithm as a controlling parameter.
pub type TPMS_SCHEME_OAEP = TPMS_ENC_SCHEME_OAEP;

/// These are the RSA encryption schemes that only need a hash algorithm as a controlling parameter.
pub type TPMS_SCHEME_RSAES = TPMS_ENC_SCHEME_RSAES;

/// These are the ECC schemes that only need a hash algorithm as a controlling parameter.
pub type TPMS_SCHEME_ECDH = TPMS_KEY_SCHEME_ECDH;

/// These are the ECC schemes that only need a hash algorithm as a controlling parameter.
pub type TPMS_SCHEME_ECMQV = TPMS_KEY_SCHEME_ECMQV;

/// These structures are used to define the key derivation for symmetric secret sharing
/// using asymmetric methods. A secret sharing scheme is required in any asymmetric key
/// with the decrypt attribute SET.
pub type TPMS_SCHEME_MGF1 = TPMS_KDF_SCHEME_MGF1;

/// These structures are used to define the key derivation for symmetric secret sharing
/// using asymmetric methods. A secret sharing scheme is required in any asymmetric key
/// with the decrypt attribute SET.
pub type TPMS_SCHEME_KDF1_SP800_56A = TPMS_KDF_SCHEME_KDF1_SP800_56A;

/// These structures are used to define the key derivation for symmetric secret sharing
/// using asymmetric methods. A secret sharing scheme is required in any asymmetric key
/// with the decrypt attribute SET.
pub type TPMS_SCHEME_KDF2 = TPMS_KDF_SCHEME_KDF2;

/// These structures are used to define the key derivation for symmetric secret sharing
/// using asymmetric methods. A secret sharing scheme is required in any asymmetric key
/// with the decrypt attribute SET.
pub type TPMS_SCHEME_KDF1_SP800_108 = TPMS_KDF_SCHEME_KDF1_SP800_108;

/// Contains the public and the plaintext-sensitive and/or encrypted private part of a TPM
/// key (or other object)
#[derive(Debug, Default)]
pub struct TssObject {
    /// Public part of key
    pub Public: TPMT_PUBLIC,

    /// Sensitive part of key
    pub Sensitive: TPMT_SENSITIVE,

    /// Private part is the encrypted sensitive part of key
    pub Private: TPM2B_PRIVATE,
}

impl TssObject {
    /// Creates a new instance with the specified values
    pub fn new(
        Public: TPMT_PUBLIC,
        Sensitive: TPMT_SENSITIVE,
        Private: TPM2B_PRIVATE,
        ) -> Self {
        Self {
            Public,
            Sensitive,
            Private,
        }
    }

}

impl TpmStructure for TssObject {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TssObject>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.Public.toTpm(buf);
        self.Sensitive.toTpm(buf);
        self.Private.toTpm(buf);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.Public.initFromTpm(buf);
        self.Sensitive.initFromTpm(buf);
        self.Private.initFromTpm(buf);
        Ok(())
    }

}

/// Contains a PCR index and associated hash(pcr-value) [TSS]
#[derive(Debug, Default)]
pub struct PcrValue {
    /// PCR Index
    pub index: u32,

    /// PCR Value
    pub value: TPMT_HA,
}

impl PcrValue {
    /// Creates a new instance with the specified values
    pub fn new(
        index: u32,
        value: TPMT_HA,
        ) -> Self {
        Self {
            index,
            value,
        }
    }

}

impl TpmStructure for PcrValue {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<PcrValue>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeInt(self.index);
        self.value.toTpm(buf);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.index = buf.readInt();
        self.value.initFromTpm(buf);
        Ok(())
    }

}

/// Structure representing a session block in a command buffer [TSS]
#[derive(Debug, Default)]
pub struct SessionIn {
    /// Session handle
    pub handle: TPM_HANDLE,

    /// Caller nonce
    pub nonceCaller: Vec<u8>,

    /// Session attributes
    pub attributes: TPMA_SESSION,

    /// AuthValue (or HMAC)
    pub auth: Vec<u8>,
}

impl SessionIn {
    /// Creates a new instance with the specified values
    pub fn new(
        handle: TPM_HANDLE,
        nonceCaller: Vec<u8>,
        attributes: TPMA_SESSION,
        auth: Vec<u8>,
        ) -> Self {
        Self {
            handle,
            nonceCaller,
            attributes,
            auth,
        }
    }

}

impl TpmStructure for SessionIn {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<SessionIn>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.handle.toTpm(buf);
        buf.writeSizedByteBuf(self.nonceCaller);
        buf.writeByte(self.attributes);
        buf.writeSizedByteBuf(self.auth);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.handle.initFromTpm(buf);
        self.nonceCaller = buf.readSizedByteBuf();
        self.attributes = buf.readByte();
        self.auth = buf.readSizedByteBuf();
        Ok(())
    }

}

/// Structure representing a session block in a response buffer [TSS]
#[derive(Debug, Default)]
pub struct SessionOut {
    /// TPM nonce
    pub nonceTpm: Vec<u8>,

    /// Session attributes
    pub attributes: TPMA_SESSION,

    /// HMAC value
    pub auth: Vec<u8>,
}

impl SessionOut {
    /// Creates a new instance with the specified values
    pub fn new(
        nonceTpm: Vec<u8>,
        attributes: TPMA_SESSION,
        auth: Vec<u8>,
        ) -> Self {
        Self {
            nonceTpm,
            attributes,
            auth,
        }
    }

}

impl TpmStructure for SessionOut {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<SessionOut>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeSizedByteBuf(self.nonceTpm);
        buf.writeByte(self.attributes);
        buf.writeSizedByteBuf(self.auth);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.nonceTpm = buf.readSizedByteBuf();
        self.attributes = buf.readByte();
        self.auth = buf.readSizedByteBuf();
        Ok(())
    }

}

/// Command header [TSS]
#[derive(Debug, Default)]
pub struct CommandHeader {
    /// Command tag (sessions, or no sessions)
    pub Tag: TPM_ST,

    /// Total command buffer length
    pub CommandSize: u32,

    /// Command code
    pub CommandCode: TPM_CC,
}

impl CommandHeader {
    /// Creates a new instance with the specified values
    pub fn new(
        Tag: TPM_ST,
        CommandSize: u32,
        CommandCode: TPM_CC,
        ) -> Self {
        Self {
            Tag,
            CommandSize,
            CommandCode,
        }
    }

}

impl TpmStructure for CommandHeader {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<CommandHeader>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buf.writeShort(self.Tag);
        buf.writeInt(self.CommandSize);
        buf.writeInt(self.CommandCode);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.Tag = buf.readShort();
        self.CommandSize = buf.readInt();
        self.CommandCode = buf.readInt();
        Ok(())
    }

}

/// Contains the public and private part of a TPM key
#[derive(Debug, Default)]
pub struct TSS_KEY {
    /// Public part of key
    pub publicPart: TPMT_PUBLIC,

    /// Private part is the encrypted sensitive part of key
    pub privatePart: Vec<u8>,
}

impl TSS_KEY {
    /// Creates a new instance with the specified values
    pub fn new(
        publicPart: TPMT_PUBLIC,
        privatePart: Vec<u8>,
        ) -> Self {
        Self {
            publicPart,
            privatePart,
        }
    }

}

impl TpmStructure for TSS_KEY {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TSS_KEY>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.publicPart.toTpm(buf);
        buf.writeSizedByteBuf(self.privatePart);
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        self.publicPart.initFromTpm(buf);
        self.privatePart = buf.readSizedByteBuf();
        Ok(())
    }

}

/// Auto-derived from TPM2B_DIGEST to provide unique GetUnionSelector() implementation
#[derive(Debug, Default)]
pub struct TPM2B_DIGEST_SYMCIPHER {
}

impl TPM2B_DIGEST_SYMCIPHER {
    fn GetUnionSelector() -> Option<TPM_ALG_ID> {
        Some(TPM_ALG_ID::SYMCIPHER)
    }
}

impl TpmStructure for TPM2B_DIGEST_SYMCIPHER {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2B_DIGEST_SYMCIPHER>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        Ok(())
    }

}

/// Auto-derived from TPM2B_DIGEST
#[derive(Debug, Default)]
pub struct TPM2B_DIGEST_KEYEDHASH {
}

impl TPM2B_DIGEST_KEYEDHASH {
    fn GetUnionSelector() -> Option<TPM_ALG_ID> {
        Some(TPM_ALG_ID::KEYEDHASH)
    }
}

impl TpmStructure for TPM2B_DIGEST_KEYEDHASH {
    /// Serialize this structure to a TPM buffer
    fn toTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    /// Deserialize this structure from a TPM buffer
    fn initFromTpm(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

    fn fromTpm(&self, buffer: &mut Tpmbuffer) -> Result<(), TpmError> {
        buffer.createObj::<TPM2B_DIGEST_KEYEDHASH>();
        Ok(())
    }

    fn fromBytes(&self, buffer: &mut Vec<u8>) -> Result<(), TpmError> {
        self.initFromTpm(buffer)
    }

    // Implement serialization/deserialization
    fn serialize(&self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        Ok(())
    }

    fn deserialize(&mut self, buf: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        Ok(())
    }

}

lazy_static::lazy_static! {
    /// Maps enum type IDs to a map of values to string representations
    static ref ENUM_TO_STR_MAP: HashMap<std::any::TypeId, HashMap<u32, &'static str>> = {
    let mut map = HashMap::new();
        let  TPM_ALG_ID_map = HashMap::new();
        map.insert(std::any::TypeId::of::<TPM_ALG_ID>(), TPM_ALG_ID_map);

        let mut TPM_ECC_CURVE_map = HashMap::new();
        TPM_ECC_CURVE_map.insert(0x0, "NONE");
        TPM_ECC_CURVE_map.insert(0x1, "NIST_P192");
        TPM_ECC_CURVE_map.insert(0x2, "NIST_P224");
        TPM_ECC_CURVE_map.insert(0x3, "NIST_P256");
        TPM_ECC_CURVE_map.insert(0x4, "NIST_P384");
        TPM_ECC_CURVE_map.insert(0x5, "NIST_P521");
        TPM_ECC_CURVE_map.insert(0x10, "BN_P256");
        TPM_ECC_CURVE_map.insert(0x11, "BN_P638");
        TPM_ECC_CURVE_map.insert(0x20, "SM2_P256");
        TPM_ECC_CURVE_map.insert(0x21, "TEST_P192");
        map.insert(std::any::TypeId::of::<TPM_ECC_CURVE>(), TPM_ECC_CURVE_map);

        let mut SHA1_map = HashMap::new();
        SHA1_map.insert(0x14, "DIGEST_SIZE");
        SHA1_map.insert(0x40, "BLOCK_SIZE");
        map.insert(std::any::TypeId::of::<SHA1>(), SHA1_map);

        let mut SHA256_map = HashMap::new();
        SHA256_map.insert(0x20, "DIGEST_SIZE");
        SHA256_map.insert(0x40, "BLOCK_SIZE");
        map.insert(std::any::TypeId::of::<SHA256>(), SHA256_map);

        let mut SHA384_map = HashMap::new();
        SHA384_map.insert(0x30, "DIGEST_SIZE");
        SHA384_map.insert(0x80, "BLOCK_SIZE");
        map.insert(std::any::TypeId::of::<SHA384>(), SHA384_map);

        let mut SHA512_map = HashMap::new();
        SHA512_map.insert(0x40, "DIGEST_SIZE");
        SHA512_map.insert(0x80, "BLOCK_SIZE");
        map.insert(std::any::TypeId::of::<SHA512>(), SHA512_map);

        let mut SM3_256_map = HashMap::new();
        SM3_256_map.insert(0x20, "DIGEST_SIZE");
        SM3_256_map.insert(0x40, "BLOCK_SIZE");
        map.insert(std::any::TypeId::of::<SM3_256>(), SM3_256_map);

        let mut SHA3_256_map = HashMap::new();
        SHA3_256_map.insert(0x20, "DIGEST_SIZE");
        SHA3_256_map.insert(0x88, "BLOCK_SIZE");
        map.insert(std::any::TypeId::of::<SHA3_256>(), SHA3_256_map);

        let mut SHA3_384_map = HashMap::new();
        SHA3_384_map.insert(0x30, "DIGEST_SIZE");
        SHA3_384_map.insert(0x68, "BLOCK_SIZE");
        map.insert(std::any::TypeId::of::<SHA3_384>(), SHA3_384_map);

        let mut SHA3_512_map = HashMap::new();
        SHA3_512_map.insert(0x40, "DIGEST_SIZE");
        SHA3_512_map.insert(0x48, "BLOCK_SIZE");
        map.insert(std::any::TypeId::of::<SHA3_512>(), SHA3_512_map);

        let  Logic_map = HashMap::new();
        map.insert(std::any::TypeId::of::<Logic>(), Logic_map);

        let mut TPM_SPEC_map = HashMap::new();
        TPM_SPEC_map.insert(0x322E3000, "FAMILY");
        TPM_SPEC_map.insert(0x0, "LEVEL");
        TPM_SPEC_map.insert(0xA2, "VERSION");
        TPM_SPEC_map.insert(0x7E3, "YEAR");
        TPM_SPEC_map.insert(0x168, "DAY_OF_YEAR");
        map.insert(std::any::TypeId::of::<TPM_SPEC>(), TPM_SPEC_map);

        let mut TPM_GENERATED_map = HashMap::new();
        TPM_GENERATED_map.insert(0xFF544347, "VALUE");
        map.insert(std::any::TypeId::of::<TPM_GENERATED>(), TPM_GENERATED_map);

        let  TPM_CC_map = HashMap::new();
        map.insert(std::any::TypeId::of::<TPM_CC>(), TPM_CC_map);

        let  ImplementationConstants_map = HashMap::new();
        map.insert(std::any::TypeId::of::<ImplementationConstants>(), ImplementationConstants_map);

        let  TPM_RC_map = HashMap::new();
        map.insert(std::any::TypeId::of::<TPM_RC>(), TPM_RC_map);

        let mut TPM_CLOCK_ADJUST_map = HashMap::new();
        TPM_CLOCK_ADJUST_map.insert(0xFFFFFFFFFFFFFFFD, "COARSE_SLOWER");
        TPM_CLOCK_ADJUST_map.insert(0xFFFFFFFFFFFFFFFE, "MEDIUM_SLOWER");
        TPM_CLOCK_ADJUST_map.insert(0xFFFFFFFFFFFFFFFF, "FINE_SLOWER");
        TPM_CLOCK_ADJUST_map.insert(0x0, "NO_CHANGE");
        TPM_CLOCK_ADJUST_map.insert(0x1, "FINE_FASTER");
        TPM_CLOCK_ADJUST_map.insert(0x2, "MEDIUM_FASTER");
        TPM_CLOCK_ADJUST_map.insert(0x3, "COARSE_FASTER");
        map.insert(std::any::TypeId::of::<TPM_CLOCK_ADJUST>(), TPM_CLOCK_ADJUST_map);

        let mut TPM_EO_map = HashMap::new();
        TPM_EO_map.insert(0x0, "EQ");
        TPM_EO_map.insert(0x1, "NEQ");
        TPM_EO_map.insert(0x2, "SIGNED_GT");
        TPM_EO_map.insert(0x3, "UNSIGNED_GT");
        TPM_EO_map.insert(0x4, "SIGNED_LT");
        TPM_EO_map.insert(0x5, "UNSIGNED_LT");
        TPM_EO_map.insert(0x6, "SIGNED_GE");
        TPM_EO_map.insert(0x7, "UNSIGNED_GE");
        TPM_EO_map.insert(0x8, "SIGNED_LE");
        TPM_EO_map.insert(0x9, "UNSIGNED_LE");
        TPM_EO_map.insert(0xA, "BITSET");
        TPM_EO_map.insert(0xB, "BITCLEAR");
        map.insert(std::any::TypeId::of::<TPM_EO>(), TPM_EO_map);

        let mut TPM_ST_map = HashMap::new();
        TPM_ST_map.insert(0xC4, "RSP_COMMAND");
        TPM_ST_map.insert(0x8000, "NULL");
        TPM_ST_map.insert(0x8001, "NO_SESSIONS");
        TPM_ST_map.insert(0x8002, "SESSIONS");
        TPM_ST_map.insert(0x8014, "ATTEST_NV");
        TPM_ST_map.insert(0x8015, "ATTEST_COMMAND_AUDIT");
        TPM_ST_map.insert(0x8016, "ATTEST_SESSION_AUDIT");
        TPM_ST_map.insert(0x8017, "ATTEST_CERTIFY");
        TPM_ST_map.insert(0x8018, "ATTEST_QUOTE");
        TPM_ST_map.insert(0x8019, "ATTEST_TIME");
        TPM_ST_map.insert(0x801A, "ATTEST_CREATION");
        TPM_ST_map.insert(0x801C, "ATTEST_NV_DIGEST");
        TPM_ST_map.insert(0x8021, "CREATION");
        TPM_ST_map.insert(0x8022, "VERIFIED");
        TPM_ST_map.insert(0x8023, "AUTH_SECRET");
        TPM_ST_map.insert(0x8024, "HASHCHECK");
        TPM_ST_map.insert(0x8025, "AUTH_SIGNED");
        TPM_ST_map.insert(0x8029, "FU_MANIFEST");
        map.insert(std::any::TypeId::of::<TPM_ST>(), TPM_ST_map);

        let mut TPM_SU_map = HashMap::new();
        TPM_SU_map.insert(0x0, "CLEAR");
        TPM_SU_map.insert(0x1, "STATE");
        map.insert(std::any::TypeId::of::<TPM_SU>(), TPM_SU_map);

        let mut TPM_SE_map = HashMap::new();
        TPM_SE_map.insert(0x0, "HMAC");
        TPM_SE_map.insert(0x1, "POLICY");
        TPM_SE_map.insert(0x3, "TRIAL");
        map.insert(std::any::TypeId::of::<TPM_SE>(), TPM_SE_map);

        let  TPM_CAP_map = HashMap::new();
        map.insert(std::any::TypeId::of::<TPM_CAP>(), TPM_CAP_map);

        let  TPM_PT_map = HashMap::new();
        map.insert(std::any::TypeId::of::<TPM_PT>(), TPM_PT_map);

        let  TPM_PT_PCR_map = HashMap::new();
        map.insert(std::any::TypeId::of::<TPM_PT_PCR>(), TPM_PT_PCR_map);

        let mut TPM_PS_map = HashMap::new();
        TPM_PS_map.insert(0x0, "MAIN");
        TPM_PS_map.insert(0x1, "PC");
        TPM_PS_map.insert(0x2, "PDA");
        TPM_PS_map.insert(0x3, "CELL_PHONE");
        TPM_PS_map.insert(0x4, "SERVER");
        TPM_PS_map.insert(0x5, "PERIPHERAL");
        TPM_PS_map.insert(0x6, "TSS");
        TPM_PS_map.insert(0x7, "STORAGE");
        TPM_PS_map.insert(0x8, "AUTHENTICATION");
        TPM_PS_map.insert(0x9, "EMBEDDED");
        TPM_PS_map.insert(0xA, "HARDCOPY");
        TPM_PS_map.insert(0xB, "INFRASTRUCTURE");
        TPM_PS_map.insert(0xC, "VIRTUALIZATION");
        TPM_PS_map.insert(0xD, "TNC");
        TPM_PS_map.insert(0xE, "MULTI_TENANT");
        TPM_PS_map.insert(0xF, "TC");
        map.insert(std::any::TypeId::of::<TPM_PS>(), TPM_PS_map);

        let  TPM_HT_map = HashMap::new();
        map.insert(std::any::TypeId::of::<TPM_HT>(), TPM_HT_map);

        let  TPM_RH_map = HashMap::new();
        map.insert(std::any::TypeId::of::<TPM_RH>(), TPM_RH_map);

        let mut TPM_NT_map = HashMap::new();
        TPM_NT_map.insert(0x0, "ORDINARY");
        TPM_NT_map.insert(0x1, "COUNTER");
        TPM_NT_map.insert(0x2, "BITS");
        TPM_NT_map.insert(0x4, "EXTEND");
        TPM_NT_map.insert(0x8, "PIN_FAIL");
        TPM_NT_map.insert(0x9, "PIN_PASS");
        map.insert(std::any::TypeId::of::<TPM_NT>(), TPM_NT_map);

        let mut TPM_AT_map = HashMap::new();
        TPM_AT_map.insert(0x0, "ANY");
        TPM_AT_map.insert(0x1, "ERROR");
        TPM_AT_map.insert(0x2, "PV1");
        TPM_AT_map.insert(0x80000000, "VEND");
        map.insert(std::any::TypeId::of::<TPM_AT>(), TPM_AT_map);

        let mut TPM_AE_map = HashMap::new();
        TPM_AE_map.insert(0x0, "NONE");
        map.insert(std::any::TypeId::of::<TPM_AE>(), TPM_AE_map);

        let mut PLATFORM_map = HashMap::new();
        PLATFORM_map.insert(0x322E3000, "FAMILY");
        PLATFORM_map.insert(0x0, "LEVEL");
        PLATFORM_map.insert(0xA2, "VERSION");
        PLATFORM_map.insert(0x7E3, "YEAR");
        PLATFORM_map.insert(0x168, "DAY_OF_YEAR");
        map.insert(std::any::TypeId::of::<PLATFORM>(), PLATFORM_map);

        let  Implementation_map = HashMap::new();
        map.insert(std::any::TypeId::of::<Implementation>(), Implementation_map);

        let  TPM_HC_map = HashMap::new();
        map.insert(std::any::TypeId::of::<TPM_HC>(), TPM_HC_map);

        let mut TPMA_ALGORITHM_map = HashMap::new();
        TPMA_ALGORITHM_map.insert(0x1, "asymmetric");
        TPMA_ALGORITHM_map.insert(0x2, "symmetric");
        TPMA_ALGORITHM_map.insert(0x4, "hash");
        TPMA_ALGORITHM_map.insert(0x8, "object");
        TPMA_ALGORITHM_map.insert(0x100, "signing");
        TPMA_ALGORITHM_map.insert(0x200, "encrypting");
        TPMA_ALGORITHM_map.insert(0x400, "method");
        map.insert(std::any::TypeId::of::<TPMA_ALGORITHM>(), TPMA_ALGORITHM_map);

        let  TPMA_OBJECT_map = HashMap::new();
        map.insert(std::any::TypeId::of::<TPMA_OBJECT>(), TPMA_OBJECT_map);

        let mut TPMA_SESSION_map = HashMap::new();
        TPMA_SESSION_map.insert(0x1, "continueSession");
        TPMA_SESSION_map.insert(0x2, "auditExclusive");
        TPMA_SESSION_map.insert(0x4, "auditReset");
        TPMA_SESSION_map.insert(0x20, "decrypt");
        TPMA_SESSION_map.insert(0x40, "encrypt");
        TPMA_SESSION_map.insert(0x80, "audit");
        map.insert(std::any::TypeId::of::<TPMA_SESSION>(), TPMA_SESSION_map);

        let mut TPMA_LOCALITY_map = HashMap::new();
        TPMA_LOCALITY_map.insert(0x1, "LOC_ZERO");
        TPMA_LOCALITY_map.insert(0x2, "LOC_ONE");
        TPMA_LOCALITY_map.insert(0x4, "LOC_TWO");
        TPMA_LOCALITY_map.insert(0x8, "LOC_THREE");
        TPMA_LOCALITY_map.insert(0x10, "LOC_FOUR");
        map.insert(std::any::TypeId::of::<TPMA_LOCALITY>(), TPMA_LOCALITY_map);

        let mut TPMA_PERMANENT_map = HashMap::new();
        TPMA_PERMANENT_map.insert(0x1, "ownerAuthSet");
        TPMA_PERMANENT_map.insert(0x2, "endorsementAuthSet");
        TPMA_PERMANENT_map.insert(0x4, "lockoutAuthSet");
        TPMA_PERMANENT_map.insert(0x100, "disableClear");
        TPMA_PERMANENT_map.insert(0x200, "inLockout");
        TPMA_PERMANENT_map.insert(0x400, "tpmGeneratedEPS");
        map.insert(std::any::TypeId::of::<TPMA_PERMANENT>(), TPMA_PERMANENT_map);

        let mut TPMA_STARTUP_CLEAR_map = HashMap::new();
        TPMA_STARTUP_CLEAR_map.insert(0x1, "phEnable");
        TPMA_STARTUP_CLEAR_map.insert(0x2, "shEnable");
        TPMA_STARTUP_CLEAR_map.insert(0x4, "ehEnable");
        TPMA_STARTUP_CLEAR_map.insert(0x8, "phEnableNV");
        TPMA_STARTUP_CLEAR_map.insert(0xFFFFFFFF80000000, "orderly");
        map.insert(std::any::TypeId::of::<TPMA_STARTUP_CLEAR>(), TPMA_STARTUP_CLEAR_map);

        let mut TPMA_MEMORY_map = HashMap::new();
        TPMA_MEMORY_map.insert(0x1, "sharedRAM");
        TPMA_MEMORY_map.insert(0x2, "sharedNV");
        TPMA_MEMORY_map.insert(0x4, "objectCopiedToRam");
        map.insert(std::any::TypeId::of::<TPMA_MEMORY>(), TPMA_MEMORY_map);

        let mut TPMA_CC_map = HashMap::new();
        TPMA_CC_map.insert(0x400000, "nv");
        TPMA_CC_map.insert(0x800000, "extensive");
        TPMA_CC_map.insert(0x1000000, "flushed");
        TPMA_CC_map.insert(0x10000000, "rHandle");
        TPMA_CC_map.insert(0x20000000, "V");
        map.insert(std::any::TypeId::of::<TPMA_CC>(), TPMA_CC_map);

        let mut TPMA_MODES_map = HashMap::new();
        TPMA_MODES_map.insert(0x1, "FIPS_140_2");
        map.insert(std::any::TypeId::of::<TPMA_MODES>(), TPMA_MODES_map);

        let  TPMA_X509_KEY_USAGE_map = HashMap::new();
        map.insert(std::any::TypeId::of::<TPMA_X509_KEY_USAGE>(), TPMA_X509_KEY_USAGE_map);

        let mut TPMA_ACT_map = HashMap::new();
        TPMA_ACT_map.insert(0x1, "signaled");
        TPMA_ACT_map.insert(0x2, "preserveSignaled");
        map.insert(std::any::TypeId::of::<TPMA_ACT>(), TPMA_ACT_map);

        let  TPM_NV_INDEX_map = HashMap::new();
        map.insert(std::any::TypeId::of::<TPM_NV_INDEX>(), TPM_NV_INDEX_map);

        let  TPMA_NV_map = HashMap::new();
        map.insert(std::any::TypeId::of::<TPMA_NV>(), TPMA_NV_map);

        map
    };

    /// Maps enum type IDs to a map of string representations to values
    static ref STR_TO_ENUM_MAP: HashMap<std::any::TypeId, HashMap<&'static str, u32>> = {
    let mut map = HashMap::new();
        let  TPM_ALG_ID_map = HashMap::new();
        map.insert(std::any::TypeId::of::<TPM_ALG_ID>(), TPM_ALG_ID_map);

        let mut TPM_ECC_CURVE_map = HashMap::new();
        TPM_ECC_CURVE_map.insert("NONE", 0x0);
        TPM_ECC_CURVE_map.insert("NIST_P192", 0x1);
        TPM_ECC_CURVE_map.insert("NIST_P224", 0x2);
        TPM_ECC_CURVE_map.insert("NIST_P256", 0x3);
        TPM_ECC_CURVE_map.insert("NIST_P384", 0x4);
        TPM_ECC_CURVE_map.insert("NIST_P521", 0x5);
        TPM_ECC_CURVE_map.insert("BN_P256", 0x10);
        TPM_ECC_CURVE_map.insert("BN_P638", 0x11);
        TPM_ECC_CURVE_map.insert("SM2_P256", 0x20);
        TPM_ECC_CURVE_map.insert("TEST_P192", 0x21);
        map.insert(std::any::TypeId::of::<TPM_ECC_CURVE>(), TPM_ECC_CURVE_map);

        let mut SHA1_map = HashMap::new();
        SHA1_map.insert("DIGEST_SIZE", 0x14);
        SHA1_map.insert("BLOCK_SIZE", 0x40);
        map.insert(std::any::TypeId::of::<SHA1>(), SHA1_map);

        let mut SHA256_map = HashMap::new();
        SHA256_map.insert("DIGEST_SIZE", 0x20);
        SHA256_map.insert("BLOCK_SIZE", 0x40);
        map.insert(std::any::TypeId::of::<SHA256>(), SHA256_map);

        let mut SHA384_map = HashMap::new();
        SHA384_map.insert("DIGEST_SIZE", 0x30);
        SHA384_map.insert("BLOCK_SIZE", 0x80);
        map.insert(std::any::TypeId::of::<SHA384>(), SHA384_map);

        let mut SHA512_map = HashMap::new();
        SHA512_map.insert("DIGEST_SIZE", 0x40);
        SHA512_map.insert("BLOCK_SIZE", 0x80);
        map.insert(std::any::TypeId::of::<SHA512>(), SHA512_map);

        let mut SM3_256_map = HashMap::new();
        SM3_256_map.insert("DIGEST_SIZE", 0x20);
        SM3_256_map.insert("BLOCK_SIZE", 0x40);
        map.insert(std::any::TypeId::of::<SM3_256>(), SM3_256_map);

        let mut SHA3_256_map = HashMap::new();
        SHA3_256_map.insert("DIGEST_SIZE", 0x20);
        SHA3_256_map.insert("BLOCK_SIZE", 0x88);
        map.insert(std::any::TypeId::of::<SHA3_256>(), SHA3_256_map);

        let mut SHA3_384_map = HashMap::new();
        SHA3_384_map.insert("DIGEST_SIZE", 0x30);
        SHA3_384_map.insert("BLOCK_SIZE", 0x68);
        map.insert(std::any::TypeId::of::<SHA3_384>(), SHA3_384_map);

        let mut SHA3_512_map = HashMap::new();
        SHA3_512_map.insert("DIGEST_SIZE", 0x40);
        SHA3_512_map.insert("BLOCK_SIZE", 0x48);
        map.insert(std::any::TypeId::of::<SHA3_512>(), SHA3_512_map);

        let  Logic_map = HashMap::new();
        map.insert(std::any::TypeId::of::<Logic>(), Logic_map);

        let mut TPM_SPEC_map = HashMap::new();
        TPM_SPEC_map.insert("FAMILY", 0x322E3000);
        TPM_SPEC_map.insert("LEVEL", 0x0);
        TPM_SPEC_map.insert("VERSION", 0xA2);
        TPM_SPEC_map.insert("YEAR", 0x7E3);
        TPM_SPEC_map.insert("DAY_OF_YEAR", 0x168);
        map.insert(std::any::TypeId::of::<TPM_SPEC>(), TPM_SPEC_map);

        let mut TPM_GENERATED_map = HashMap::new();
        TPM_GENERATED_map.insert("VALUE", 0xFF544347);
        map.insert(std::any::TypeId::of::<TPM_GENERATED>(), TPM_GENERATED_map);

        let  TPM_CC_map = HashMap::new();
        map.insert(std::any::TypeId::of::<TPM_CC>(), TPM_CC_map);

        let  ImplementationConstants_map = HashMap::new();
        map.insert(std::any::TypeId::of::<ImplementationConstants>(), ImplementationConstants_map);

        let  TPM_RC_map = HashMap::new();
        map.insert(std::any::TypeId::of::<TPM_RC>(), TPM_RC_map);

        let mut TPM_CLOCK_ADJUST_map = HashMap::new();
        TPM_CLOCK_ADJUST_map.insert("COARSE_SLOWER", 0xFFFFFFFFFFFFFFFD);
        TPM_CLOCK_ADJUST_map.insert("MEDIUM_SLOWER", 0xFFFFFFFFFFFFFFFE);
        TPM_CLOCK_ADJUST_map.insert("FINE_SLOWER", 0xFFFFFFFFFFFFFFFF);
        TPM_CLOCK_ADJUST_map.insert("NO_CHANGE", 0x0);
        TPM_CLOCK_ADJUST_map.insert("FINE_FASTER", 0x1);
        TPM_CLOCK_ADJUST_map.insert("MEDIUM_FASTER", 0x2);
        TPM_CLOCK_ADJUST_map.insert("COARSE_FASTER", 0x3);
        map.insert(std::any::TypeId::of::<TPM_CLOCK_ADJUST>(), TPM_CLOCK_ADJUST_map);

        let mut TPM_EO_map = HashMap::new();
        TPM_EO_map.insert("EQ", 0x0);
        TPM_EO_map.insert("NEQ", 0x1);
        TPM_EO_map.insert("SIGNED_GT", 0x2);
        TPM_EO_map.insert("UNSIGNED_GT", 0x3);
        TPM_EO_map.insert("SIGNED_LT", 0x4);
        TPM_EO_map.insert("UNSIGNED_LT", 0x5);
        TPM_EO_map.insert("SIGNED_GE", 0x6);
        TPM_EO_map.insert("UNSIGNED_GE", 0x7);
        TPM_EO_map.insert("SIGNED_LE", 0x8);
        TPM_EO_map.insert("UNSIGNED_LE", 0x9);
        TPM_EO_map.insert("BITSET", 0xA);
        TPM_EO_map.insert("BITCLEAR", 0xB);
        map.insert(std::any::TypeId::of::<TPM_EO>(), TPM_EO_map);

        let mut TPM_ST_map = HashMap::new();
        TPM_ST_map.insert("RSP_COMMAND", 0xC4);
        TPM_ST_map.insert("NULL", 0x8000);
        TPM_ST_map.insert("NO_SESSIONS", 0x8001);
        TPM_ST_map.insert("SESSIONS", 0x8002);
        TPM_ST_map.insert("ATTEST_NV", 0x8014);
        TPM_ST_map.insert("ATTEST_COMMAND_AUDIT", 0x8015);
        TPM_ST_map.insert("ATTEST_SESSION_AUDIT", 0x8016);
        TPM_ST_map.insert("ATTEST_CERTIFY", 0x8017);
        TPM_ST_map.insert("ATTEST_QUOTE", 0x8018);
        TPM_ST_map.insert("ATTEST_TIME", 0x8019);
        TPM_ST_map.insert("ATTEST_CREATION", 0x801A);
        TPM_ST_map.insert("ATTEST_NV_DIGEST", 0x801C);
        TPM_ST_map.insert("CREATION", 0x8021);
        TPM_ST_map.insert("VERIFIED", 0x8022);
        TPM_ST_map.insert("AUTH_SECRET", 0x8023);
        TPM_ST_map.insert("HASHCHECK", 0x8024);
        TPM_ST_map.insert("AUTH_SIGNED", 0x8025);
        TPM_ST_map.insert("FU_MANIFEST", 0x8029);
        map.insert(std::any::TypeId::of::<TPM_ST>(), TPM_ST_map);

        let mut TPM_SU_map = HashMap::new();
        TPM_SU_map.insert("CLEAR", 0x0);
        TPM_SU_map.insert("STATE", 0x1);
        map.insert(std::any::TypeId::of::<TPM_SU>(), TPM_SU_map);

        let mut TPM_SE_map = HashMap::new();
        TPM_SE_map.insert("HMAC", 0x0);
        TPM_SE_map.insert("POLICY", 0x1);
        TPM_SE_map.insert("TRIAL", 0x3);
        map.insert(std::any::TypeId::of::<TPM_SE>(), TPM_SE_map);

        let  TPM_CAP_map = HashMap::new();
        map.insert(std::any::TypeId::of::<TPM_CAP>(), TPM_CAP_map);

        let  TPM_PT_map = HashMap::new();
        map.insert(std::any::TypeId::of::<TPM_PT>(), TPM_PT_map);

        let  TPM_PT_PCR_map = HashMap::new();
        map.insert(std::any::TypeId::of::<TPM_PT_PCR>(), TPM_PT_PCR_map);

        let mut TPM_PS_map = HashMap::new();
        TPM_PS_map.insert("MAIN", 0x0);
        TPM_PS_map.insert("PC", 0x1);
        TPM_PS_map.insert("PDA", 0x2);
        TPM_PS_map.insert("CELL_PHONE", 0x3);
        TPM_PS_map.insert("SERVER", 0x4);
        TPM_PS_map.insert("PERIPHERAL", 0x5);
        TPM_PS_map.insert("TSS", 0x6);
        TPM_PS_map.insert("STORAGE", 0x7);
        TPM_PS_map.insert("AUTHENTICATION", 0x8);
        TPM_PS_map.insert("EMBEDDED", 0x9);
        TPM_PS_map.insert("HARDCOPY", 0xA);
        TPM_PS_map.insert("INFRASTRUCTURE", 0xB);
        TPM_PS_map.insert("VIRTUALIZATION", 0xC);
        TPM_PS_map.insert("TNC", 0xD);
        TPM_PS_map.insert("MULTI_TENANT", 0xE);
        TPM_PS_map.insert("TC", 0xF);
        map.insert(std::any::TypeId::of::<TPM_PS>(), TPM_PS_map);

        let  TPM_HT_map = HashMap::new();
        map.insert(std::any::TypeId::of::<TPM_HT>(), TPM_HT_map);

        let  TPM_RH_map = HashMap::new();
        map.insert(std::any::TypeId::of::<TPM_RH>(), TPM_RH_map);

        let mut TPM_NT_map = HashMap::new();
        TPM_NT_map.insert("ORDINARY", 0x0);
        TPM_NT_map.insert("COUNTER", 0x1);
        TPM_NT_map.insert("BITS", 0x2);
        TPM_NT_map.insert("EXTEND", 0x4);
        TPM_NT_map.insert("PIN_FAIL", 0x8);
        TPM_NT_map.insert("PIN_PASS", 0x9);
        map.insert(std::any::TypeId::of::<TPM_NT>(), TPM_NT_map);

        let mut TPM_AT_map = HashMap::new();
        TPM_AT_map.insert("ANY", 0x0);
        TPM_AT_map.insert("ERROR", 0x1);
        TPM_AT_map.insert("PV1", 0x2);
        TPM_AT_map.insert("VEND", 0x80000000);
        map.insert(std::any::TypeId::of::<TPM_AT>(), TPM_AT_map);

        let mut TPM_AE_map = HashMap::new();
        TPM_AE_map.insert("NONE", 0x0);
        map.insert(std::any::TypeId::of::<TPM_AE>(), TPM_AE_map);

        let mut PLATFORM_map = HashMap::new();
        PLATFORM_map.insert("FAMILY", 0x322E3000);
        PLATFORM_map.insert("LEVEL", 0x0);
        PLATFORM_map.insert("VERSION", 0xA2);
        PLATFORM_map.insert("YEAR", 0x7E3);
        PLATFORM_map.insert("DAY_OF_YEAR", 0x168);
        map.insert(std::any::TypeId::of::<PLATFORM>(), PLATFORM_map);

        let  Implementation_map = HashMap::new();
        map.insert(std::any::TypeId::of::<Implementation>(), Implementation_map);

        let  TPM_HC_map = HashMap::new();
        map.insert(std::any::TypeId::of::<TPM_HC>(), TPM_HC_map);

        let mut TPMA_ALGORITHM_map = HashMap::new();
        TPMA_ALGORITHM_map.insert("asymmetric", 0x1);
        TPMA_ALGORITHM_map.insert("symmetric", 0x2);
        TPMA_ALGORITHM_map.insert("hash", 0x4);
        TPMA_ALGORITHM_map.insert("object", 0x8);
        TPMA_ALGORITHM_map.insert("signing", 0x100);
        TPMA_ALGORITHM_map.insert("encrypting", 0x200);
        TPMA_ALGORITHM_map.insert("method", 0x400);
        map.insert(std::any::TypeId::of::<TPMA_ALGORITHM>(), TPMA_ALGORITHM_map);

        let  TPMA_OBJECT_map = HashMap::new();
        map.insert(std::any::TypeId::of::<TPMA_OBJECT>(), TPMA_OBJECT_map);

        let mut TPMA_SESSION_map = HashMap::new();
        TPMA_SESSION_map.insert("continueSession", 0x1);
        TPMA_SESSION_map.insert("auditExclusive", 0x2);
        TPMA_SESSION_map.insert("auditReset", 0x4);
        TPMA_SESSION_map.insert("decrypt", 0x20);
        TPMA_SESSION_map.insert("encrypt", 0x40);
        TPMA_SESSION_map.insert("audit", 0x80);
        map.insert(std::any::TypeId::of::<TPMA_SESSION>(), TPMA_SESSION_map);

        let mut TPMA_LOCALITY_map = HashMap::new();
        TPMA_LOCALITY_map.insert("LOC_ZERO", 0x1);
        TPMA_LOCALITY_map.insert("LOC_ONE", 0x2);
        TPMA_LOCALITY_map.insert("LOC_TWO", 0x4);
        TPMA_LOCALITY_map.insert("LOC_THREE", 0x8);
        TPMA_LOCALITY_map.insert("LOC_FOUR", 0x10);
        map.insert(std::any::TypeId::of::<TPMA_LOCALITY>(), TPMA_LOCALITY_map);

        let mut TPMA_PERMANENT_map = HashMap::new();
        TPMA_PERMANENT_map.insert("ownerAuthSet", 0x1);
        TPMA_PERMANENT_map.insert("endorsementAuthSet", 0x2);
        TPMA_PERMANENT_map.insert("lockoutAuthSet", 0x4);
        TPMA_PERMANENT_map.insert("disableClear", 0x100);
        TPMA_PERMANENT_map.insert("inLockout", 0x200);
        TPMA_PERMANENT_map.insert("tpmGeneratedEPS", 0x400);
        map.insert(std::any::TypeId::of::<TPMA_PERMANENT>(), TPMA_PERMANENT_map);

        let mut TPMA_STARTUP_CLEAR_map = HashMap::new();
        TPMA_STARTUP_CLEAR_map.insert("phEnable", 0x1);
        TPMA_STARTUP_CLEAR_map.insert("shEnable", 0x2);
        TPMA_STARTUP_CLEAR_map.insert("ehEnable", 0x4);
        TPMA_STARTUP_CLEAR_map.insert("phEnableNV", 0x8);
        TPMA_STARTUP_CLEAR_map.insert("orderly", 0xFFFFFFFF80000000);
        map.insert(std::any::TypeId::of::<TPMA_STARTUP_CLEAR>(), TPMA_STARTUP_CLEAR_map);

        let mut TPMA_MEMORY_map = HashMap::new();
        TPMA_MEMORY_map.insert("sharedRAM", 0x1);
        TPMA_MEMORY_map.insert("sharedNV", 0x2);
        TPMA_MEMORY_map.insert("objectCopiedToRam", 0x4);
        map.insert(std::any::TypeId::of::<TPMA_MEMORY>(), TPMA_MEMORY_map);

        let mut TPMA_CC_map = HashMap::new();
        TPMA_CC_map.insert("nv", 0x400000);
        TPMA_CC_map.insert("extensive", 0x800000);
        TPMA_CC_map.insert("flushed", 0x1000000);
        TPMA_CC_map.insert("rHandle", 0x10000000);
        TPMA_CC_map.insert("V", 0x20000000);
        map.insert(std::any::TypeId::of::<TPMA_CC>(), TPMA_CC_map);

        let mut TPMA_MODES_map = HashMap::new();
        TPMA_MODES_map.insert("FIPS_140_2", 0x1);
        map.insert(std::any::TypeId::of::<TPMA_MODES>(), TPMA_MODES_map);

        let  TPMA_X509_KEY_USAGE_map = HashMap::new();
        map.insert(std::any::TypeId::of::<TPMA_X509_KEY_USAGE>(), TPMA_X509_KEY_USAGE_map);

        let mut TPMA_ACT_map = HashMap::new();
        TPMA_ACT_map.insert("signaled", 0x1);
        TPMA_ACT_map.insert("preserveSignaled", 0x2);
        map.insert(std::any::TypeId::of::<TPMA_ACT>(), TPMA_ACT_map);

        let  TPM_NV_INDEX_map = HashMap::new();
        map.insert(std::any::TypeId::of::<TPM_NV_INDEX>(), TPM_NV_INDEX_map);

        let  TPMA_NV_map = HashMap::new();
        map.insert(std::any::TypeId::of::<TPMA_NV>(), TPMA_NV_map);

        map
    };

}

