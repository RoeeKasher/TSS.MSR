/*
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See the LICENSE file in the project root for full license information.
 */

use crate::auth_session::Session;
use crate::device::TpmDevice;
use crate::tpm_buffer::{TpmBuffer, TpmMarshaller};
use crate::tpm_structure::{ReqStructure, RespStructure, TpmEnum, TpmStructure};
use crate::tpm_types::{TPM_CC, TPM_HANDLE, TPM_RC, TPM_RH, TPM_ST};
use crate::error::TpmError;


/// A TPM error with associated command and context information
#[derive(Debug, Clone)]
pub struct TpmCommandError {
    /// Response code returned by the TPM
    pub response_code: TPM_RC,
    /// Command code that triggered the error
    pub command_code: TPM_CC,
    /// Description of the error
    pub message: String,
}

impl std::fmt::Display for TpmCommandError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "TPM command {:?} failed with response code {:?}: {}",
            self.command_code, self.response_code, self.message
        )
    }
}

impl std::error::Error for TpmCommandError {}

impl From<TpmCommandError> for TpmError {
    fn from(err: TpmCommandError) -> Self {
        TpmError::GenericError(err.to_string())
    }
}

/// Base implementation for TPM operations
pub struct Tpm2 {
    /// The TPM device used for communication
    device: Box<dyn TpmDevice>,

    /// Response code returned by the last executed command
    last_response_code: TPM_RC,

    /// Error object (may be None) generated during the last TPM command execution
    last_error: Option<TpmCommandError>,

    /// TPM sessions associated with the next command
    sessions: Option<Vec<Session>>,

    /// Controls whether exceptions are enabled
    exceptions_enabled: bool,

    /// Suppresses exceptions in response to the next command failure, when exceptions are enabled
    errors_allowed: bool,

    /// Command code for the current operation (for error reporting)
    current_cmd_code: Option<TPM_CC>,

    /// Session tag for the current operation
    current_session_tag: Option<TPM_ST>,
}

impl Tpm2 {
    /// Creates a new Tpm2 with the specified device
    pub fn new(device: Box<dyn TpmDevice>) -> Self {
        Tpm2 {
            device,
            last_response_code: TPM_RC::SUCCESS,
            last_error: None,
            sessions: None,
            exceptions_enabled: false,
            errors_allowed: true,
            current_cmd_code: None,
            current_session_tag: None,
        }
    }

    /// Checks whether the response code is generated by the TSS.Rust implementation
    fn is_comm_medium_error(code: TPM_RC) -> bool {
        // Check if error is in the TSS communication layer rather than TPM itself
        (code.get_value()) & 0xFFFF0000 == 0x80280000
    }

    /// Cleans the raw response code from the TPM
    fn clean_response_code(raw_response: TPM_RC) -> TPM_RC {
        if Self::is_comm_medium_error(raw_response) {
            return raw_response;
        }

        let raw_response_u32 = raw_response.get_value();
        let mask: u32 = if (raw_response_u32) & (TPM_RC::RC_FMT1.get_value()) != 0 {
            (TPM_RC::RC_FMT1.get_value()) | 0x3F
        } else {
            (TPM_RC::RC_WARN.get_value()) | (TPM_RC::RC_VER1.get_value()) | 0x7F
        };

        unsafe { std::mem::transmute((raw_response_u32) & mask) }
    }

    /// Generates an error response buffer
    fn generate_error_response(&self, rc: TPM_RC) -> TpmBuffer {
        let mut resp_buf = TpmBuffer::new(None);
        resp_buf.writeShort(TPM_ST::NO_SESSIONS as u16);
        resp_buf.writeInt(10);
        resp_buf.writeInt(rc.get_value());
        resp_buf
    }

    /// Generates an error based on the response code
    fn generate_error(&mut self, resp_code: TPM_RC, err_msg: &str, errors_allowed: bool) -> Result<(), TpmCommandError> {
        let cmd_code = self.current_cmd_code.unwrap_or(TPM_CC::FIRST);
        let error = TpmCommandError {
            response_code: resp_code,
            command_code: cmd_code,
            message: err_msg.to_string(),
        };
        
        self.last_error = Some(error.clone());
        
        if self.exceptions_enabled && !errors_allowed {
            Err(error)
        } else {
            Ok(())
        }
    }

    /// Send a TPM command to the underlying TPM device.
    pub fn dispatch<R: ReqStructure, S: RespStructure>(
        &mut self,
        cmd_code: TPM_CC,
        req: R,
        resp: &mut S,
    ) -> Result<(), TpmError> {
        loop {
            let process_phase_two: bool = self.dispatch_command(cmd_code, &req)?;
            if (!process_phase_two || self.process_response(cmd_code, resp)?)
            {
                break;
            }
            std::thread::sleep(std::time::Duration::from_millis(1000));
        }

        Ok(())
    }

    /// Internal method to dispatch a command to the TPM
    pub fn dispatch_command<R: ReqStructure>(
        &mut self,
        cmd_code: TPM_CC,
        req: &R,
    ) -> Result<(bool), TpmError> {
        let handles = req.get_handles();
        let num_auth_handles = req.num_auth_handles();
        let mut cmd_buf = TpmBuffer::new(None);

        self.current_cmd_code = Some(cmd_code);
        self.current_session_tag = if num_auth_handles > 0 { Some(TPM_ST::SESSIONS) } else { Some(TPM_ST::NO_SESSIONS) };

        // Create command buffer header
        cmd_buf.writeShort(self.current_session_tag.unwrap().get_value() as u16);
        cmd_buf.writeInt(0); // to be filled in later
        cmd_buf.writeInt(cmd_code.get_value());

        // Marshal handles, if any
        for handle in handles.iter() {
            handle.toTpm(&mut cmd_buf)?;
        }

        // Marshal auth sessions, if any
        if num_auth_handles > 0 {
            // If the caller has not provided a session for a handle that requires authorization,
            // a password session is automatically created.
            let sessions = if let Some(ref mut sessions) = self.sessions {
                // Ensure we have enough sessions
                if sessions.len() < num_auth_handles as usize {
                    for _ in sessions.len()..(num_auth_handles as usize) {
                        sessions.push(Session::pw(None));
                    }
                }
                sessions
            } else {
                // Create all password sessions
                let mut new_sessions = Vec::with_capacity(num_auth_handles as usize);
                for _ in 0..num_auth_handles {
                    new_sessions.push(Session::pw(None));
                }
                self.sessions = Some(new_sessions);
                self.sessions.as_mut().unwrap()
            };

            // We do not know the size of the authorization area yet.
            // Remember the place to marshal it, ...
            let auth_size_pos = cmd_buf.current_pos();
            // ... and marshal a placeholder 0 value for now.
            cmd_buf.writeInt(0);

            for sess in sessions.iter() {
                sess.sess_in.toTpm(&mut cmd_buf)?;
            }

            cmd_buf.write_num_at_pos((cmd_buf.current_pos() - auth_size_pos - 4) as u64, auth_size_pos, 4);
        }
        
        // Clear the sessions after use
        self.sessions = None;

        // Marshal command parameters
        req.toTpm(&mut cmd_buf)?;

        // Fill in command buffer size in the command header
        cmd_buf.write_num_at_pos(cmd_buf.current_pos() as u64, 2, 4);
        cmd_buf.trim();
        
        // Dispatch command to the device
        self.device.dispatch_command(cmd_buf.buffer().as_slice())?;

        Ok(true)
    }

    /// Process the TPM response and update the response structure
    pub fn process_response<T: RespStructure>(
        &mut self,
        cmd_code: TPM_CC,
        resp_struct: &mut T,
    ) -> Result<(bool), TpmError> {
        let errors_allowed = self.errors_allowed;
        self.errors_allowed = !self.exceptions_enabled;

        // Wait for and process the response
        let resp_bytes = self.device.get_response()?;

        let mut resp_buf = TpmBuffer::from(&resp_bytes);
        
        if resp_buf.size() < 10 {
            return match self.generate_error(
                TPM_RC::TSS_RESP_BUF_TOO_SHORT,
                &format!("Response buffer is too short: {}", resp_buf.size()),
                errors_allowed,
            ) {
                Ok(_) => Ok((false)),
                Err(e) => Err(e.into()),
            };
        }

        let tag = TPM_ST::try_from(resp_buf.readShort())?;
        let resp_size = resp_buf.readInt();
        let rc = TPM_RC::try_from(resp_buf.readInt())?;

        self.last_response_code = Self::clean_response_code(rc);

        let sess_tag = self.current_session_tag.unwrap_or(TPM_ST::NULL);
        if (rc == TPM_RC::SUCCESS && tag != sess_tag) ||
           (rc != TPM_RC::SUCCESS && tag != TPM_ST::NO_SESSIONS)
        {
            return match self.generate_error(
                TPM_RC::TSS_RESP_BUF_INVALID_SESSION_TAG,
                "Invalid session tag in the response buffer",
                errors_allowed,
            ) {
                Ok(_) => Ok((false)),
                Err(e) => Err(e.into()),
            };
        }

        if (rc == TPM_RC::RETRY) {
            // Retry the command if the TPM indicates so
            return Ok(false);
        }

        if self.last_response_code != TPM_RC::SUCCESS {
            let cmd_name = if let Some(cmd_code) = self.current_cmd_code {
                format!("{:?}", cmd_code)
            } else {
                "Unknown".to_string()
            };
            
            return match self.generate_error(
                self.last_response_code,
                &format!("TPM command {} failed with response code {:?}", cmd_name, rc),
                errors_allowed,
            ) {
                Ok(_) => Ok((false)),
                Err(e) => Err(e.into()),
            };
        }

        // Get the handles if any
        if resp_struct.num_handles() > 0 {
            let handle = resp_buf.readInt();
            resp_struct.set_handle(&TPM_HANDLE::new(handle));
        }

        // If a response session is present, response buffer contains a field specifying the size of response parameters
        let resp_params_size = if tag == TPM_ST::SESSIONS {
            resp_buf.readInt() as usize
        } else {
            resp_buf.size()
        };

        let param_start = resp_buf.current_pos();
        resp_struct.initFromTpm(&mut resp_buf)?;

        if resp_params_size != resp_buf.current_pos() - param_start {
            return match self.generate_error(
                TPM_RC::TSS_RESP_BUF_INVALID_SIZE,
                &format!(
                    "Inconsistent TPM response params size: expected {}, actual {}",
                    resp_params_size,
                    resp_buf.current_pos() - param_start
                ),
                errors_allowed,
            ) {
                Ok(_) => Ok((false)),
                Err(e) => Err(e.into()),
            };
        }

        Ok((true))
    }
}

impl Tpm2 {
    fn last_response_code(&self) -> TPM_RC {
        self.last_response_code
    }

    fn last_error(&self) -> Option<TpmCommandError> {
        self.last_error.clone()
    }

    fn allow_errors(&mut self) -> &mut Self {
        self.errors_allowed = true;
        self
    }

    fn enable_exceptions(&mut self, enable: bool) {
        self.exceptions_enabled = enable;
        self.errors_allowed = !enable;
    }

    fn with_session(&mut self, session: Session) -> &mut Self {
        self.sessions = Some(vec![session]);
        self
    }

    fn with_sessions(&mut self, sessions: Vec<Session>) -> &mut Self {
        self.sessions = Some(sessions);
        self
    }

    fn connect(&mut self) -> Result<(), TpmError> {
        self.device.connect()?;
        self.last_response_code = TPM_RC::SUCCESS;
        Ok(())
    }

    fn close(&mut self) {
        self.device.close();
    }
}

/// Factory function to create a new TPM implementation based on the available platform
pub fn create_tpm() -> Tpm2 {
    #[cfg(target_os = "windows")]
    {
        use crate::device::TpmTbsDevice;
        Tpm2::new(Box::new(TpmTbsDevice::new()))
    }
    #[cfg(not(target_os = "windows"))]
    {
        use crate::device::{TpmTbsDevice, TpmTcpDevice};
        
        // Try to create a TBS device first (for Linux/Unix), falling back to TCP simulator
        let mut tbs_device = TpmTbsDevice::new();
        match tbs_device.connect() {
            Ok(_) => Tpm2::new(tbs_device),
            Err(_) => {
                // Fall back to TCP simulator
                let tcp_device = TpmTcpDevice::new("127.0.0.1".to_string(), 2321);
                Tpm2::new(Box::new(tcp_device))
            }
        }
    }
}

/// Factory function to create a TPM implementation with a custom device
pub fn create_tpm_with_device(device: Box<dyn TpmDevice>) -> Tpm2 {
    Tpm2::new(device)
}