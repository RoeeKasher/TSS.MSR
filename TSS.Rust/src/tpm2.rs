// /*
//  *  Copyright (c) Microsoft Corporation. All rights reserved.
//  *  Licensed under the MIT License. See the LICENSE file in the project root for full license information.
//  */

// /*
//  * NOTE: this file is partially auto generated!
//  *
//  * All code after the point marked with the '// <<AUTOGEN_BEGIN>>' comment
//  * is autogenerated from the TPM 2.0 Specification docs.
//  *
//  * DO NOT EDIT AUTOGENERATED PART - all manual changes will be lost!
//  */

//                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         // <<AUTOGEN_BEGIN>>
// ------------------------------------------------------------------------------------------------
// DO NOT REMOVE the <<AUTOGEN_BEGIN>> comment!
// DO NOT MODIFY any code below this point - all manual changes will be lost!
// ------------------------------------------------------------------------------------------------

//! TPM2 command implementations

use crate::error::TpmError;
use crate::tpm_buffer::*;
use crate::tpm_types::*;

/// Main TPM2 interface
#[derive(Debug)]
pub struct Tpm2 {
    // Implementation details
    device: crate::device::TpmDevice,
}

impl Tpm2 {
    /// Creates a new TPM2 instance
    pub fn new() -> Result<Self, TpmError> {
        Ok(Self {
            device: crate::device::TpmDevice::new()?,
        })

    }

    /// Main dispatch function for synchronous commands
    fn dispatch<Req: TpmStructure, Resp: TpmStructure>(&mut self, req: Req, resp: &mut Resp) -> Result<(), TpmError> {
        // Create buffer and marshal request
        let mut buffer = TpmBuffer::new(None);
        req.serialize(&mut buffer)?;

        // Send command to device
        let response_data = self.device.send_command(buffer.to_vec())?;

        // Parse response
        let mut resp_buffer = TpmBuffer::from(&response_data);
        resp.deserialize(&mut resp_buffer)?;

        Ok(())
    }

    /// Dispatch function for asynchronous command phase
    fn dispatch_async_command<Req: TpmStructure>(&mut self, req: Req) -> Result<(), TpmError> {
    // Create buffer and marshal request
        let mut buffer = TpmBuffer::new(None);
        req.serialize(&mut buffer)?;

        // Send command to device
        self.device.send_async_command(buffer.to_vec())?;

        Ok(())
    }

    /// Dispatch function for asynchronous response phase
    fn dispatch_async_response<Resp: TpmStructure>(&mut self, resp: &mut Resp) -> Result<(), TpmError> {
    // Receive response from device
        let response_data = self.device.receive_async_response()?;

        // Parse response
        let mut resp_buffer = TpmBuffer::from(&response_data);
        resp.deserialize(&mut resp_buffer)?;

        Ok(())
    }

    /// TPM2_Startup() is always preceded by _TPM_Init, which is the physical indication that TPM
    /// initialization is necessary because of a system-wide reset. TPM2_Startup() is only valid
    /// after _TPM_Init. Additional TPM2_Startup() commands are not allowed after it has completed
    /// successfully. If a TPM requires TPM2_Startup() and another command is received, or if the
    /// TPM receives TPM2_Startup() when it is not required, the TPM shall return TPM_RC_INITIALIZE.
    /// startupType: TPM_SU_CLEAR or TPM_SU_STATE
    pub fn Startup(
        &mut self,
        startupType: TPM_SU,
    ) -> Result<(), TpmError> {
        // Create request structure
        let req = TPM2_Startup_REQUEST {
            startupType,
        };

        // Send command and process response
        let mut resp = TPMS_EMPTY::default();
        self.dispatch(req, &mut resp)?;
        Ok(())
    }

    /// This command is used to prepare the TPM for a power cycle. The shutdownType parameter
    /// indicates how the subsequent TPM2_Startup() will be processed.
    /// shutdownType: TPM_SU_CLEAR or TPM_SU_STATE
    pub fn Shutdown(
        &mut self,
        shutdownType: TPM_SU,
    ) -> Result<(), TpmError> {
        // Create request structure
        let req = TPM2_Shutdown_REQUEST {
            shutdownType,
        };

        // Send command and process response
        let mut resp = TPMS_EMPTY::default();
        self.dispatch(req, &mut resp)?;
        Ok(())
    }

    /// This command causes the TPM to perform a test of its capabilities. If the fullTest is YES,
    /// the TPM will test all functions. If fullTest = NO, the TPM will only test those functions
    /// that have not previously been tested.
    /// fullTest: YES if full test to be performed
    ///        NO if only test of untested functions required
    pub fn SelfTest(
        &mut self,
        fullTest: u8,
    ) -> Result<(), TpmError> {
        // Create request structure
        let req = TPM2_SelfTest_REQUEST {
            fullTest,
        };

        // Send command and process response
        let mut resp = TPMS_EMPTY::default();
        self.dispatch(req, &mut resp)?;
        Ok(())
    }

    /// This command causes the TPM to perform a test of the selected algorithms.
    /// toTest: List of algorithms that should be tested
    ///     toDoList - List of algorithms that need testing
    pub fn IncrementalSelfTest(
        &mut self,
        toTest: Vec<TPM_ALG_ID>,
    ) -> Result<Vec<TPM_ALG_ID>, TpmError> {
        // Create request structure
        let req = TPM2_IncrementalSelfTest_REQUEST {
            toTest,
        };

        // Send command and process response
        let mut resp = IncrementalSelfTestResponse::default();
        self.dispatch(req, &mut resp)?;
        Ok(resp.toDoList)
    }

    /// This command returns manufacturer-specific information regarding the results of a
    /// self-test and an indication of the test status.
    ///     outData - Test result data
    ///               contains manufacturer-specific information
    ///     testResult - TBD
    pub fn GetTestResult(
        &mut self,
    ) -> Result<GetTestResultResponse, TpmError> {
        // Create request structure
        let req = TPM2_GetTestResult_REQUEST::default();

        // Send command and process response
        let mut resp = GetTestResultResponse::default();
        self.dispatch(req, &mut resp)?;
        Ok(resp)
    }

    /// This command is used to start an authorization session using alternative methods of
    /// establishing the session key (sessionKey). The session key is then used to derive values
    /// used for authorization and for encrypting parameters.
    /// tpmKey: Handle of a loaded decrypt key used to encrypt salt
    ///        may be TPM_RH_NULL
    ///        Auth Index: None
    /// bind: Entity providing the authValue
    ///        may be TPM_RH_NULL
    ///        Auth Index: None
    /// nonceCaller: Initial nonceCaller, sets nonceTPM size for the session
    ///        shall be at least 16 octets
    /// encryptedSalt: Value encrypted according to the type of tpmKey
    ///        If tpmKey is TPM_RH_NULL, this shall be the Empty Buffer.
    /// sessionType: Indicates the type of the session; simple HMAC or policy (including a trial policy)
    /// symmetric: The algorithm and key size for parameter encryption
    ///        may select TPM_ALG_NULL
    /// authHash: Hash algorithm to use for the session
    ///        Shall be a hash algorithm supported by the TPM and not TPM_ALG_NULL
    ///     handle - Handle for the newly created session
    ///     nonceTPM - The initial nonce from the TPM, used in the computation of the sessionKey
    pub fn StartAuthSession(
        &mut self,
        tpmKey: TPM_HANDLE,
        bind: TPM_HANDLE,
        nonceCaller: Vec<u8>,
        encryptedSalt: Vec<u8>,
        sessionType: TPM_SE,
        symmetric: TPMT_SYM_DEF,
        authHash: TPM_ALG_ID,
    ) -> Result<StartAuthSessionResponse, TpmError> {
        // Create request structure
        let req = TPM2_StartAuthSession_REQUEST {
            tpmKey,
            bind,
            nonceCaller,
            encryptedSalt,
            sessionType,
            symmetric,
            authHash,
        };

        // Send command and process response
        let mut resp = StartAuthSessionResponse::default();
        self.dispatch(req, &mut resp)?;
        Ok(resp)
    }

    /// This command allows a policy authorization session to be returned to its initial state.
    /// This command is used after the TPM returns TPM_RC_PCR_CHANGED. That response code
    /// indicates that a policy will fail because the PCR have changed after TPM2_PolicyPCR() was
    /// executed. Restarting the session allows the authorizations to be replayed because the
    /// session restarts with the same nonceTPM. If the PCR are valid for the policy, the policy
    /// may then succeed.
    /// sessionHandle: The handle for the policy session
    pub fn PolicyRestart(
        &mut self,
        sessionHandle: TPM_HANDLE,
    ) -> Result<(), TpmError> {
        // Create request structure
        let req = TPM2_PolicyRestart_REQUEST {
            sessionHandle,
        };

        // Send command and process response
        let mut resp = TPMS_EMPTY::default();
        self.dispatch(req, &mut resp)?;
        Ok(())
    }

    /// This command is used to create an object that can be loaded into a TPM using TPM2_Load().
    /// If the command completes successfully, the TPM will create the new object and return the
    /// objects creation data (creationData), its public area (outPublic), and its encrypted
    /// sensitive area (outPrivate). Preservation of the returned data is the responsibility of
    /// the caller. The object will need to be loaded (TPM2_Load()) before it may be used. The
    /// only difference between the inPublic TPMT_PUBLIC template and the outPublic TPMT_PUBLIC
    /// object is in the unique field.
    /// parentHandle: Handle of parent for new object
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// inSensitive: The sensitive data
    /// inPublic: The public template
    /// outsideInfo: Data that will be included in the creation data for this object to provide
    ///        permanent, verifiable linkage between this object and some object owner data
    /// creationPCR: PCR that will be used in creation data
    ///     outPrivate - The private portion of the object
    ///     outPublic - The public portion of the created object
    ///     creationData - Contains a TPMS_CREATION_DATA
    ///     creationHash - Digest of creationData using nameAlg of outPublic
    ///     creationTicket - Ticket used by TPM2_CertifyCreation() to validate that the creation
    ///                      data was produced by the TPM
    pub fn Create(
        &mut self,
        parentHandle: TPM_HANDLE,
        inSensitive: TPMS_SENSITIVE_CREATE,
        inPublic: TPMT_PUBLIC,
        outsideInfo: Vec<u8>,
        creationPCR: Vec<TPMS_PCR_SELECTION>,
    ) -> Result<CreateResponse, TpmError> {
        // Create request structure
        let req = TPM2_Create_REQUEST {
            parentHandle,
            inSensitive,
            inPublic,
            outsideInfo,
            creationPCR,
        };

        // Send command and process response
        let mut resp = CreateResponse::default();
        self.dispatch(req, &mut resp)?;
        Ok(resp)
    }

    /// This command is used to load objects into the TPM. This command is used when both a
    /// TPM2B_PUBLIC and TPM2B_PRIVATE are to be loaded. If only a TPM2B_PUBLIC is to be loaded,
    /// the TPM2_LoadExternal command is used.
    /// parentHandle: TPM handle of parent key; shall not be a reserved handle
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// inPrivate: The private portion of the object
    /// inPublic: The public portion of the object
    ///     handle - Handle of type TPM_HT_TRANSIENT for the loaded object
    ///     name - Name of the loaded object
    pub fn Load(
        &mut self,
        parentHandle: TPM_HANDLE,
        inPrivate: TPM2B_PRIVATE,
        inPublic: TPMT_PUBLIC,
    ) -> Result<TPM_HANDLE, TpmError> {
        // Create request structure
        let req = TPM2_Load_REQUEST {
            parentHandle,
            inPrivate,
            inPublic,
        };

        // Send command and process response
        let mut resp = LoadResponse::default();
        self.dispatch(req, &mut resp)?;
        Ok(resp.handle)
    }

    /// This command is used to load an object that is not a Protected Object into the TPM. The
    /// command allows loading of a public area or both a public and sensitive area.
    /// inPrivate: The sensitive portion of the object (optional)
    /// inPublic: The public portion of the object
    /// hierarchy: Hierarchy with which the object area is associated
    ///     handle - Handle of type TPM_HT_TRANSIENT for the loaded object
    ///     name - Name of the loaded object
    pub fn LoadExternal(
        &mut self,
        inPrivate: TPMT_SENSITIVE,
        inPublic: TPMT_PUBLIC,
        hierarchy: TPM_HANDLE,
    ) -> Result<TPM_HANDLE, TpmError> {
        // Create request structure
        let req = TPM2_LoadExternal_REQUEST {
            inPrivate,
            inPublic,
            hierarchy,
        };

        // Send command and process response
        let mut resp = LoadExternalResponse::default();
        self.dispatch(req, &mut resp)?;
        Ok(resp.handle)
    }

    /// This command allows access to the public area of a loaded object.
    /// objectHandle: TPM handle of an object
    ///        Auth Index: None
    ///     outPublic - Structure containing the public area of an object
    ///     name - Name of the object
    ///     qualifiedName - The Qualified Name of the object
    pub fn ReadPublic(
        &mut self,
        objectHandle: TPM_HANDLE,
    ) -> Result<ReadPublicResponse, TpmError> {
        // Create request structure
        let req = TPM2_ReadPublic_REQUEST {
            objectHandle,
        };

        // Send command and process response
        let mut resp = ReadPublicResponse::default();
        self.dispatch(req, &mut resp)?;
        Ok(resp)
    }

    /// This command enables the association of a credential with an object in a way that ensures
    /// that the TPM has validated the parameters of the credentialed object.
    /// activateHandle: Handle of the object associated with certificate in credentialBlob
    ///        Auth Index: 1
    ///        Auth Role: ADMIN
    /// keyHandle: Loaded key used to decrypt the TPMS_SENSITIVE in credentialBlob
    ///        Auth Index: 2
    ///        Auth Role: USER
    /// credentialBlob: The credential
    /// secret: KeyHandle algorithm-dependent encrypted seed that protects credentialBlob
    ///     certInfo - The decrypted certificate information
    ///                the data should be no larger than the size of the digest of the nameAlg
    ///                associated with keyHandle
    pub fn ActivateCredential(
        &mut self,
        activateHandle: TPM_HANDLE,
        keyHandle: TPM_HANDLE,
        credentialBlob: TPMS_ID_OBJECT,
        secret: Vec<u8>,
    ) -> Result<Vec<u8>, TpmError> {
        // Create request structure
        let req = TPM2_ActivateCredential_REQUEST {
            activateHandle,
            keyHandle,
            credentialBlob,
            secret,
        };

        // Send command and process response
        let mut resp = ActivateCredentialResponse::default();
        self.dispatch(req, &mut resp)?;
        Ok(resp.certInfo)
    }

    /// This command allows the TPM to perform the actions required of a Certificate Authority
    /// (CA) in creating a TPM2B_ID_OBJECT containing an activation credential.
    /// handle: Loaded public area, used to encrypt the sensitive area containing the credential key
    ///        Auth Index: None
    /// credential: The credential information
    /// objectName: Name of the object to which the credential applies
    ///     credentialBlob - The credential
    ///     secret - Handle algorithm-dependent data that wraps the key that encrypts credentialBlob
    pub fn MakeCredential(
        &mut self,
        handle: TPM_HANDLE,
        credential: Vec<u8>,
        objectName: Vec<u8>,
    ) -> Result<MakeCredentialResponse, TpmError> {
        // Create request structure
        let req = TPM2_MakeCredential_REQUEST {
            handle,
            credential,
            objectName,
        };

        // Send command and process response
        let mut resp = MakeCredentialResponse::default();
        self.dispatch(req, &mut resp)?;
        Ok(resp)
    }

    /// This command returns the data in a loaded Sealed Data Object.
    /// itemHandle: Handle of a loaded data object
    ///        Auth Index: 1
    ///        Auth Role: USER
    ///     outData - Unsealed data
    ///               Size of outData is limited to be no more than 128 octets.
    pub fn Unseal(
        &mut self,
        itemHandle: TPM_HANDLE,
    ) -> Result<Vec<u8>, TpmError> {
        // Create request structure
        let req = TPM2_Unseal_REQUEST {
            itemHandle,
        };

        // Send command and process response
        let mut resp = UnsealResponse::default();
        self.dispatch(req, &mut resp)?;
        Ok(resp.outData)
    }

    /// This command is used to change the authorization secret for a TPM-resident object.
    /// objectHandle: Handle of the object
    ///        Auth Index: 1
    ///        Auth Role: ADMIN
    /// parentHandle: Handle of the parent
    ///        Auth Index: None
    /// newAuth: New authorization value
    ///     outPrivate - Private area containing the new authorization value
    pub fn ObjectChangeAuth(
        &mut self,
        objectHandle: TPM_HANDLE,
        parentHandle: TPM_HANDLE,
        newAuth: Vec<u8>,
    ) -> Result<TPM2B_PRIVATE, TpmError> {
        // Create request structure
        let req = TPM2_ObjectChangeAuth_REQUEST {
            objectHandle,
            parentHandle,
            newAuth,
        };

        // Send command and process response
        let mut resp = ObjectChangeAuthResponse::default();
        self.dispatch(req, &mut resp)?;
        Ok(resp.outPrivate)
    }

    /// This command creates an object and loads it in the TPM. This command allows creation of
    /// any type of object (Primary, Ordinary, or Derived) depending on the type of parentHandle.
    /// If parentHandle references a Primary Seed, then a Primary Object is created; if
    /// parentHandle references a Storage Parent, then an Ordinary Object is created; and if
    /// parentHandle references a Derivation Parent, then a Derived Object is generated.
    /// parentHandle: Handle of a transient storage key, a persistent storage key,
    ///        TPM_RH_ENDORSEMENT, TPM_RH_OWNER, TPM_RH_PLATFORM+{PP}, or TPM_RH_NULL
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// inSensitive: The sensitive data, see TPM 2.0 Part 1 Sensitive Values
    /// inPublic: The public template
    ///     handle - Handle of type TPM_HT_TRANSIENT for created object
    ///     outPrivate - The sensitive area of the object (optional)
    ///     outPublic - The public portion of the created object
    ///     name - The name of the created object
    pub fn CreateLoaded(
        &mut self,
        parentHandle: TPM_HANDLE,
        inSensitive: TPMS_SENSITIVE_CREATE,
        inPublic: Vec<u8>,
    ) -> Result<CreateLoadedResponse, TpmError> {
        // Create request structure
        let req = TPM2_CreateLoaded_REQUEST {
            parentHandle,
            inSensitive,
            inPublic,
        };

        // Send command and process response
        let mut resp = CreateLoadedResponse::default();
        self.dispatch(req, &mut resp)?;
        Ok(resp)
    }

    /// This command duplicates a loaded object so that it may be used in a different hierarchy.
    /// The new parent key for the duplicate may be on the same or different TPM or TPM_RH_NULL.
    /// Only the public area of newParentHandle is required to be loaded.
    /// objectHandle: Loaded object to duplicate
    ///        Auth Index: 1
    ///        Auth Role: DUP
    /// newParentHandle: Shall reference the public area of an asymmetric key
    ///        Auth Index: None
    /// encryptionKeyIn: Optional symmetric encryption key
    ///        The size for this key is set to zero when the TPM is to generate the key. This
    ///        parameter may be encrypted.
    /// symmetricAlg: Definition for the symmetric algorithm to be used for the inner wrapper
    ///        may be TPM_ALG_NULL if no inner wrapper is applied
    ///     encryptionKeyOut - If the caller provided an encryption key or if symmetricAlg was
    ///                        TPM_ALG_NULL, then this will be the Empty Buffer; otherwise, it
    ///                        shall contain the TPM-generated, symmetric encryption key for the
    ///                        inner wrapper.
    ///     duplicate - Private area that may be encrypted by encryptionKeyIn; and may be doubly encrypted
    ///     outSymSeed - Seed protected by the asymmetric algorithms of new parent (NP)
    pub fn Duplicate(
        &mut self,
        objectHandle: TPM_HANDLE,
        newParentHandle: TPM_HANDLE,
        encryptionKeyIn: Vec<u8>,
        symmetricAlg: TPMT_SYM_DEF_OBJECT,
    ) -> Result<DuplicateResponse, TpmError> {
        // Create request structure
        let req = TPM2_Duplicate_REQUEST {
            objectHandle,
            newParentHandle,
            encryptionKeyIn,
            symmetricAlg,
        };

        // Send command and process response
        let mut resp = DuplicateResponse::default();
        self.dispatch(req, &mut resp)?;
        Ok(resp)
    }

    /// This command allows the TPM to serve in the role as a Duplication Authority. If proper
    /// authorization for use of the oldParent is provided, then an HMAC key and a symmetric key
    /// are recovered from inSymSeed and used to integrity check and decrypt inDuplicate. A new
    /// protection seed value is generated according to the methods appropriate for newParent and
    /// the blob is re-encrypted and a new integrity value is computed. The re-encrypted blob is
    /// returned in outDuplicate and the symmetric key returned in outSymKey.
    /// oldParent: Parent of object
    ///        Auth Index: 1
    ///        Auth Role: User
    /// newParent: New parent of the object
    ///        Auth Index: None
    /// inDuplicate: An object encrypted using symmetric key derived from inSymSeed
    /// name: The Name of the object being rewrapped
    /// inSymSeed: The seed for the symmetric key and HMAC key
    ///        needs oldParent private key to recover the seed and generate the symmetric key
    ///     outDuplicate - An object encrypted using symmetric key derived from outSymSeed
    ///     outSymSeed - Seed for a symmetric key protected by newParent asymmetric key
    pub fn Rewrap(
        &mut self,
        oldParent: TPM_HANDLE,
        newParent: TPM_HANDLE,
        inDuplicate: TPM2B_PRIVATE,
        name: Vec<u8>,
        inSymSeed: Vec<u8>,
    ) -> Result<RewrapResponse, TpmError> {
        // Create request structure
        let req = TPM2_Rewrap_REQUEST {
            oldParent,
            newParent,
            inDuplicate,
            name,
            inSymSeed,
        };

        // Send command and process response
        let mut resp = RewrapResponse::default();
        self.dispatch(req, &mut resp)?;
        Ok(resp)
    }

    /// This command allows an object to be encrypted using the symmetric encryption values of a
    /// Storage Key. After encryption, the object may be loaded and used in the new hierarchy. The
    /// imported object (duplicate) may be singly encrypted, multiply encrypted, or unencrypted.
    /// parentHandle: The handle of the new parent for the object
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// encryptionKey: The optional symmetric encryption key used as the inner wrapper for duplicate
    ///        If symmetricAlg is TPM_ALG_NULL, then this parameter shall be the Empty Buffer.
    /// objectPublic: The public area of the object to be imported
    ///        This is provided so that the integrity value for duplicate and the object
    ///        attributes can be checked.
    ///        NOTE Even if the integrity value of the object is not checked on input, the object
    ///        Name is required to create the integrity value for the imported object.
    /// duplicate: The symmetrically encrypted duplicate object that may contain an inner
    ///        symmetric wrapper
    /// inSymSeed: The seed for the symmetric key and HMAC key
    ///        inSymSeed is encrypted/encoded using the algorithms of newParent.
    /// symmetricAlg: Definition for the symmetric algorithm to use for the inner wrapper
    ///        If this algorithm is TPM_ALG_NULL, no inner wrapper is present and encryptionKey
    ///        shall be the Empty Buffer.
    ///     outPrivate - The sensitive area encrypted with the symmetric key of parentHandle
    pub fn Import(
        &mut self,
        parentHandle: TPM_HANDLE,
        encryptionKey: Vec<u8>,
        objectPublic: TPMT_PUBLIC,
        duplicate: TPM2B_PRIVATE,
        inSymSeed: Vec<u8>,
        symmetricAlg: TPMT_SYM_DEF_OBJECT,
    ) -> Result<TPM2B_PRIVATE, TpmError> {
        // Create request structure
        let req = TPM2_Import_REQUEST {
            parentHandle,
            encryptionKey,
            objectPublic,
            duplicate,
            inSymSeed,
            symmetricAlg,
        };

        // Send command and process response
        let mut resp = ImportResponse::default();
        self.dispatch(req, &mut resp)?;
        Ok(resp.outPrivate)
    }

    /// This command performs RSA encryption using the indicated padding scheme according to IETF
    /// RFC 8017. If the scheme of keyHandle is TPM_ALG_NULL, then the caller may use inScheme to
    /// specify the padding scheme. If scheme of keyHandle is not TPM_ALG_NULL, then inScheme
    /// shall either be TPM_ALG_NULL or be the same as scheme (TPM_RC_SCHEME).
    /// keyHandle: Reference to public portion of RSA key to use for encryption
    ///        Auth Index: None
    /// message: Message to be encrypted
    ///        NOTE 1 The data type was chosen because it limits the overall size of the input to
    ///        no greater than the size of the largest RSA public key. This may be larger than
    ///        allowed for keyHandle.
    /// inScheme: The padding scheme to use if scheme associated with keyHandle is TPM_ALG_NULL
    ///        One of: TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA,
    ///        TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA,
    ///        TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES,
    ///        TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME.
    /// label: Optional label L to be associated with the message
    ///        Size of the buffer is zero if no label is present
    ///        NOTE 2 See description of label above.
    ///     outData - Encrypted output
    pub fn RSA_Encrypt(
        &mut self,
        keyHandle: TPM_HANDLE,
        message: Vec<u8>,
        inScheme: Option<TPMU_ASYM_SCHEME>,
        label: Vec<u8>,
    ) -> Result<Vec<u8>, TpmError> {
        // Create request structure
        let req = TPM2_RSA_Encrypt_REQUEST {
            keyHandle,
            message,
            inScheme,
            label,
        };

        // Send command and process response
        let mut resp = RSA_EncryptResponse::default();
        self.dispatch(req, &mut resp)?;
        Ok(resp.outData)
    }

    /// This command performs RSA decryption using the indicated padding scheme according to IETF
    /// RFC 8017 ((PKCS#1).
    /// keyHandle: RSA key to use for decryption
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// cipherText: Cipher text to be decrypted
    ///        NOTE An encrypted RSA data block is the size of the public modulus.
    /// inScheme: The padding scheme to use if scheme associated with keyHandle is TPM_ALG_NULL
    ///        One of: TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA,
    ///        TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA,
    ///        TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES,
    ///        TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME.
    /// label: Label whose association with the message is to be verified
    ///     message - Decrypted output
    pub fn RSA_Decrypt(
        &mut self,
        keyHandle: TPM_HANDLE,
        cipherText: Vec<u8>,
        inScheme: Option<TPMU_ASYM_SCHEME>,
        label: Vec<u8>,
    ) -> Result<Vec<u8>, TpmError> {
        // Create request structure
        let req = TPM2_RSA_Decrypt_REQUEST {
            keyHandle,
            cipherText,
            inScheme,
            label,
        };

        // Send command and process response
        let mut resp = RSA_DecryptResponse::default();
        self.dispatch(req, &mut resp)?;
        Ok(resp.message)
    }

    /// This command uses the TPM to generate an ephemeral key pair (de, Qe where Qe [de]G). It
    /// uses the private ephemeral key and a loaded public key (QS) to compute the shared secret
    /// value (P [hde]QS).
    /// keyHandle: Handle of a loaded ECC key public area.
    ///        Auth Index: None
    ///     zPoint - Results of P h[de]Qs
    ///     pubPoint - Generated ephemeral public point (Qe)
    pub fn ECDH_KeyGen(
        &mut self,
        keyHandle: TPM_HANDLE,
    ) -> Result<ECDH_KeyGenResponse, TpmError> {
        // Create request structure
        let req = TPM2_ECDH_KeyGen_REQUEST {
            keyHandle,
        };

        // Send command and process response
        let mut resp = ECDH_KeyGenResponse::default();
        self.dispatch(req, &mut resp)?;
        Ok(resp)
    }

    /// This command uses the TPM to recover the Z value from a public point (QB) and a private
    /// key (ds). It will perform the multiplication of the provided inPoint (QB) with the private
    /// key (ds) and return the coordinates of the resultant point (Z = (xZ , yZ) [hds]QB; where h
    /// is the cofactor of the curve).
    /// keyHandle: Handle of a loaded ECC key
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// inPoint: A public key
    ///     outPoint - X and Y coordinates of the product of the multiplication Z = (xZ , yZ) [hdS]QB
    pub fn ECDH_ZGen(
        &mut self,
        keyHandle: TPM_HANDLE,
        inPoint: TPMS_ECC_POINT,
    ) -> Result<TPMS_ECC_POINT, TpmError> {
        // Create request structure
        let req = TPM2_ECDH_ZGen_REQUEST {
            keyHandle,
            inPoint,
        };

        // Send command and process response
        let mut resp = ECDH_ZGenResponse::default();
        self.dispatch(req, &mut resp)?;
        Ok(resp.outPoint)
    }

    /// This command returns the parameters of an ECC curve identified by its TCG-assigned curveID.
    /// curveID: Parameter set selector
    ///     parameters - ECC parameters for the selected curve
    pub fn ECC_Parameters(
        &mut self,
        curveID: TPM_ECC_CURVE,
    ) -> Result<TPMS_ALGORITHM_DETAIL_ECC, TpmError> {
        // Create request structure
        let req = TPM2_ECC_Parameters_REQUEST {
            curveID,
        };

        // Send command and process response
        let mut resp = ECC_ParametersResponse::default();
        self.dispatch(req, &mut resp)?;
        Ok(resp.parameters)
    }

    /// This command supports two-phase key exchange protocols. The command is used in combination
    /// with TPM2_EC_Ephemeral(). TPM2_EC_Ephemeral() generates an ephemeral key and returns the
    /// public point of that ephemeral key along with a numeric value that allows the TPM to
    /// regenerate the associated private key.
    /// keyA: Handle of an unrestricted decryption key ECC
    ///        The private key referenced by this handle is used as dS,A
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// inQsB: Other partys static public key (Qs,B = (Xs,B, Ys,B))
    /// inQeB: Other party's ephemeral public key (Qe,B = (Xe,B, Ye,B))
    /// inScheme: The key exchange scheme
    /// counter: Value returned by TPM2_EC_Ephemeral()
    ///     outZ1 - X and Y coordinates of the computed value (scheme dependent)
    ///     outZ2 - X and Y coordinates of the second computed value (scheme dependent)
    pub fn ZGen_2Phase(
        &mut self,
        keyA: TPM_HANDLE,
        inQsB: TPMS_ECC_POINT,
        inQeB: TPMS_ECC_POINT,
        inScheme: TPM_ALG_ID,
        counter: u16,
    ) -> Result<ZGen_2PhaseResponse, TpmError> {
        // Create request structure
        let req = TPM2_ZGen_2Phase_REQUEST {
            keyA,
            inQsB,
            inQeB,
            inScheme,
            counter,
        };

        // Send command and process response
        let mut resp = ZGen_2PhaseResponse::default();
        self.dispatch(req, &mut resp)?;
        Ok(resp)
    }

    /// This command performs ECC encryption as described in Part 1, Annex D.
    /// keyHandle: Reference to public portion of ECC key to use for encryption
    ///        Auth Index: None
    /// plainText: Plaintext to be encrypted
    /// inScheme: The KDF to use if scheme associated with keyHandle is TPM_ALG_NULL
    ///        One of: TPMS_KDF_SCHEME_MGF1, TPMS_KDF_SCHEME_KDF1_SP800_56A, TPMS_KDF_SCHEME_KDF2,
    ///        TPMS_KDF_SCHEME_KDF1_SP800_108, TPMS_SCHEME_HASH, TPMS_NULL_KDF_SCHEME.
    ///     C1 - The public ephemeral key used for ECDH
    ///     C2 - The data block produced by the XOR process
    ///     C3 - The integrity value
    pub fn ECC_Encrypt(
        &mut self,
        keyHandle: TPM_HANDLE,
        plainText: Vec<u8>,
        inScheme: Option<TPMU_KDF_SCHEME>,
    ) -> Result<ECC_EncryptResponse, TpmError> {
        // Create request structure
        let req = TPM2_ECC_Encrypt_REQUEST {
            keyHandle,
            plainText,
            inScheme,
        };

        // Send command and process response
        let mut resp = ECC_EncryptResponse::default();
        self.dispatch(req, &mut resp)?;
        Ok(resp)
    }

    /// This command performs ECC decryption.
    /// keyHandle: ECC key to use for decryption
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// C1: The public ephemeral key used for ECDH
    /// C2: The data block produced by the XOR process
    /// C3: The integrity value
    /// inScheme: The KDF to use if scheme associated with keyHandle is TPM_ALG_NULL
    ///        One of: TPMS_KDF_SCHEME_MGF1, TPMS_KDF_SCHEME_KDF1_SP800_56A, TPMS_KDF_SCHEME_KDF2,
    ///        TPMS_KDF_SCHEME_KDF1_SP800_108, TPMS_SCHEME_HASH, TPMS_NULL_KDF_SCHEME.
    ///     plainText - Decrypted output
    pub fn ECC_Decrypt(
        &mut self,
        keyHandle: TPM_HANDLE,
        C1: TPMS_ECC_POINT,
        C2: Vec<u8>,
        C3: Vec<u8>,
        inScheme: Option<TPMU_KDF_SCHEME>,
    ) -> Result<Vec<u8>, TpmError> {
        // Create request structure
        let req = TPM2_ECC_Decrypt_REQUEST {
            keyHandle,
            C1,
            C2,
            C3,
            inScheme,
        };

        // Send command and process response
        let mut resp = ECC_DecryptResponse::default();
        self.dispatch(req, &mut resp)?;
        Ok(resp.plainText)
    }

    /// NOTE 1 This command is deprecated, and TPM2_EncryptDecrypt2() is preferred. This should be
    /// reflected in platform-specific specifications.
    /// keyHandle: The symmetric key used for the operation
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// decrypt: If YES, then the operation is decryption; if NO, the operation is encryption
    /// mode: Symmetric encryption/decryption mode
    ///        this field shall match the default mode of the key or be TPM_ALG_NULL.
    /// ivIn: An initial value as required by the algorithm
    /// inData: The data to be encrypted/decrypted
    ///     outData - Encrypted or decrypted output
    ///     ivOut - Chaining value to use for IV in next round
    pub fn EncryptDecrypt(
        &mut self,
        keyHandle: TPM_HANDLE,
        decrypt: u8,
        mode: TPM_ALG_ID,
        ivIn: Vec<u8>,
        inData: Vec<u8>,
    ) -> Result<EncryptDecryptResponse, TpmError> {
        // Create request structure
        let req = TPM2_EncryptDecrypt_REQUEST {
            keyHandle,
            decrypt,
            mode,
            ivIn,
            inData,
        };

        // Send command and process response
        let mut resp = EncryptDecryptResponse::default();
        self.dispatch(req, &mut resp)?;
        Ok(resp)
    }

    /// This command is identical to TPM2_EncryptDecrypt(), except that the inData parameter is
    /// the first parameter. This permits inData to be parameter encrypted.
    /// keyHandle: The symmetric key used for the operation
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// inData: The data to be encrypted/decrypted
    /// decrypt: If YES, then the operation is decryption; if NO, the operation is encryption
    /// mode: Symmetric mode
    ///        this field shall match the default mode of the key or be TPM_ALG_NULL.
    /// ivIn: An initial value as required by the algorithm
    ///     outData - Encrypted or decrypted output
    ///     ivOut - Chaining value to use for IV in next round
    pub fn EncryptDecrypt2(
        &mut self,
        keyHandle: TPM_HANDLE,
        inData: Vec<u8>,
        decrypt: u8,
        mode: TPM_ALG_ID,
        ivIn: Vec<u8>,
    ) -> Result<EncryptDecrypt2Response, TpmError> {
        // Create request structure
        let req = TPM2_EncryptDecrypt2_REQUEST {
            keyHandle,
            inData,
            decrypt,
            mode,
            ivIn,
        };

        // Send command and process response
        let mut resp = EncryptDecrypt2Response::default();
        self.dispatch(req, &mut resp)?;
        Ok(resp)
    }

    /// This command performs a hash operation on a data buffer and returns the results.
    /// data: Data to be hashed
    /// hashAlg: Algorithm for the hash being computed shall not be TPM_ALG_NULL
    /// hierarchy: Hierarchy to use for the ticket (TPM_RH_NULL allowed)
    ///     outHash - Results
    ///     validation - Ticket indicating that the sequence of octets used to compute outDigest
    ///                  did not start with TPM_GENERATED_VALUE
    ///                  will be a NULL ticket if the digest may not be signed with a restricted key
    pub fn Hash(
        &mut self,
        data: Vec<u8>,
        hashAlg: TPM_ALG_ID,
        hierarchy: TPM_HANDLE,
    ) -> Result<HashResponse, TpmError> {
        // Create request structure
        let req = TPM2_Hash_REQUEST {
            data,
            hashAlg,
            hierarchy,
        };

        // Send command and process response
        let mut resp = HashResponse::default();
        self.dispatch(req, &mut resp)?;
        Ok(resp)
    }

    /// This command performs an HMAC on the supplied data using the indicated hash algorithm.
    /// handle: Handle for the symmetric signing key providing the HMAC key
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// buffer: HMAC data
    /// hashAlg: Algorithm to use for HMAC
    ///     outHMAC - The returned HMAC in a sized buffer
    pub fn HMAC(
        &mut self,
        handle: TPM_HANDLE,
        buffer: Vec<u8>,
        hashAlg: TPM_ALG_ID,
    ) -> Result<Vec<u8>, TpmError> {
        // Create request structure
        let req = TPM2_HMAC_REQUEST {
            handle,
            buffer,
            hashAlg,
        };

        // Send command and process response
        let mut resp = HMACResponse::default();
        self.dispatch(req, &mut resp)?;
        Ok(resp.outHMAC)
    }

    /// This command performs an HMAC or a block cipher MAC on the supplied data using the
    /// indicated algorithm.
    /// handle: Handle for the symmetric signing key providing the MAC key
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// buffer: MAC data
    /// inScheme: Algorithm to use for MAC
    ///     outMAC - The returned MAC in a sized buffer
    pub fn MAC(
        &mut self,
        handle: TPM_HANDLE,
        buffer: Vec<u8>,
        inScheme: TPM_ALG_ID,
    ) -> Result<Vec<u8>, TpmError> {
        // Create request structure
        let req = TPM2_MAC_REQUEST {
            handle,
            buffer,
            inScheme,
        };

        // Send command and process response
        let mut resp = MACResponse::default();
        self.dispatch(req, &mut resp)?;
        Ok(resp.outMAC)
    }

    /// This command returns the next bytesRequested octets from the random number generator (RNG).
    /// bytesRequested: Number of octets to return
    ///     randomBytes - The random octets
    pub fn GetRandom(
        &mut self,
        bytesRequested: u16,
    ) -> Result<Vec<u8>, TpmError> {
        // Create request structure
        let req = TPM2_GetRandom_REQUEST {
            bytesRequested,
        };

        // Send command and process response
        let mut resp = GetRandomResponse::default();
        self.dispatch(req, &mut resp)?;
        Ok(resp.randomBytes)
    }

    /// This command is used to add "additional information" to the RNG state.
    /// inData: Additional information
    pub fn StirRandom(
        &mut self,
        inData: Vec<u8>,
    ) -> Result<(), TpmError> {
        // Create request structure
        let req = TPM2_StirRandom_REQUEST {
            inData,
        };

        // Send command and process response
        let mut resp = TPMS_EMPTY::default();
        self.dispatch(req, &mut resp)?;
        Ok(())
    }

    /// This command starts an HMAC sequence. The TPM will create and initialize an HMAC sequence
    /// structure, assign a handle to the sequence, and set the authValue of the sequence object
    /// to the value in auth.
    /// handle: Handle of an HMAC key
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// auth: Authorization value for subsequent use of the sequence
    /// hashAlg: The hash algorithm to use for the HMAC
    ///     handle - A handle to reference the sequence
    pub fn HMAC_Start(
        &mut self,
        handle: TPM_HANDLE,
        auth: Vec<u8>,
        hashAlg: TPM_ALG_ID,
    ) -> Result<TPM_HANDLE, TpmError> {
        // Create request structure
        let req = TPM2_HMAC_Start_REQUEST {
            handle,
            auth,
            hashAlg,
        };

        // Send command and process response
        let mut resp = HMAC_StartResponse::default();
        self.dispatch(req, &mut resp)?;
        Ok(resp.handle)
    }

    /// This command starts a MAC sequence. The TPM will create and initialize a MAC sequence
    /// structure, assign a handle to the sequence, and set the authValue of the sequence object
    /// to the value in auth.
    /// handle: Handle of a MAC key
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// auth: Authorization value for subsequent use of the sequence
    /// inScheme: The algorithm to use for the MAC
    ///     handle - A handle to reference the sequence
    pub fn MAC_Start(
        &mut self,
        handle: TPM_HANDLE,
        auth: Vec<u8>,
        inScheme: TPM_ALG_ID,
    ) -> Result<TPM_HANDLE, TpmError> {
        // Create request structure
        let req = TPM2_MAC_Start_REQUEST {
            handle,
            auth,
            inScheme,
        };

        // Send command and process response
        let mut resp = MAC_StartResponse::default();
        self.dispatch(req, &mut resp)?;
        Ok(resp.handle)
    }

    /// This command starts a hash or an Event Sequence. If hashAlg is an implemented hash, then a
    /// hash sequence is started. If hashAlg is TPM_ALG_NULL, then an Event Sequence is started.
    /// If hashAlg is neither an implemented algorithm nor TPM_ALG_NULL, then the TPM shall return
    /// TPM_RC_HASH.
    /// auth: Authorization value for subsequent use of the sequence
    /// hashAlg: The hash algorithm to use for the hash sequence
    ///        An Event Sequence starts if this is TPM_ALG_NULL.
    ///     handle - A handle to reference the sequence
    pub fn HashSequenceStart(
        &mut self,
        auth: Vec<u8>,
        hashAlg: TPM_ALG_ID,
    ) -> Result<TPM_HANDLE, TpmError> {
        // Create request structure
        let req = TPM2_HashSequenceStart_REQUEST {
            auth,
            hashAlg,
        };

        // Send command and process response
        let mut resp = HashSequenceStartResponse::default();
        self.dispatch(req, &mut resp)?;
        Ok(resp.handle)
    }

    /// This command is used to add data to a hash or HMAC sequence. The amount of data in buffer
    /// may be any size up to the limits of the TPM.
    /// sequenceHandle: Handle for the sequence object
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// buffer: Data to be added to hash
    pub fn SequenceUpdate(
        &mut self,
        sequenceHandle: TPM_HANDLE,
        buffer: Vec<u8>,
    ) -> Result<(), TpmError> {
        // Create request structure
        let req = TPM2_SequenceUpdate_REQUEST {
            sequenceHandle,
            buffer,
        };

        // Send command and process response
        let mut resp = TPMS_EMPTY::default();
        self.dispatch(req, &mut resp)?;
        Ok(())
    }

    /// This command adds the last part of data, if any, to a hash/HMAC sequence and returns the result.
    /// sequenceHandle: Authorization for the sequence
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// buffer: Data to be added to the hash/HMAC
    /// hierarchy: Hierarchy of the ticket for a hash
    ///     result - The returned HMAC or digest in a sized buffer
    ///     validation - Ticket indicating that the sequence of octets used to compute outDigest
    ///                  did not start with TPM_GENERATED_VALUE
    ///                  This is a NULL Ticket when the sequence is HMAC.
    pub fn SequenceComplete(
        &mut self,
        sequenceHandle: TPM_HANDLE,
        buffer: Vec<u8>,
        hierarchy: TPM_HANDLE,
    ) -> Result<SequenceCompleteResponse, TpmError> {
        // Create request structure
        let req = TPM2_SequenceComplete_REQUEST {
            sequenceHandle,
            buffer,
            hierarchy,
        };

        // Send command and process response
        let mut resp = SequenceCompleteResponse::default();
        self.dispatch(req, &mut resp)?;
        Ok(resp)
    }

    /// This command adds the last part of data, if any, to an Event Sequence and returns the
    /// result in a digest list. If pcrHandle references a PCR and not TPM_RH_NULL, then the
    /// returned digest list is processed in the same manner as the digest list input parameter to
    /// TPM2_PCR_Extend(). That is, if a bank contains a PCR associated with pcrHandle, it is
    /// extended with the associated digest value from the list.
    /// pcrHandle: PCR to be extended with the Event data
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// sequenceHandle: Authorization for the sequence
    ///        Auth Index: 2
    ///        Auth Role: USER
    /// buffer: Data to be added to the Event
    ///     results - List of digests computed for the PCR
    pub fn EventSequenceComplete(
        &mut self,
        pcrHandle: TPM_HANDLE,
        sequenceHandle: TPM_HANDLE,
        buffer: Vec<u8>,
    ) -> Result<Vec<TPMT_HA>, TpmError> {
        // Create request structure
        let req = TPM2_EventSequenceComplete_REQUEST {
            pcrHandle,
            sequenceHandle,
            buffer,
        };

        // Send command and process response
        let mut resp = EventSequenceCompleteResponse::default();
        self.dispatch(req, &mut resp)?;
        Ok(resp.results)
    }

    /// The purpose of this command is to prove that an object with a specific Name is loaded in
    /// the TPM. By certifying that the object is loaded, the TPM warrants that a public area with
    /// a given Name is self-consistent and associated with a valid sensitive area. If a relying
    /// party has a public area that has the same Name as a Name certified with this command, then
    /// the values in that public area are correct.
    /// objectHandle: Handle of the object to be certified
    ///        Auth Index: 1
    ///        Auth Role: ADMIN
    /// signHandle: Handle of the key used to sign the attestation structure
    ///        Auth Index: 2
    ///        Auth Role: USER
    /// qualifyingData: User provided qualifying data
    /// inScheme: Signing scheme to use if the scheme for signHandle is TPM_ALG_NULL
    ///        One of: TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA,
    ///        TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR,
    ///        TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME.
    ///     certifyInfo - The structure that was signed
    ///     signature - The asymmetric signature over certifyInfo using the key referenced by signHandle
    pub fn Certify(
        &mut self,
        objectHandle: TPM_HANDLE,
        signHandle: TPM_HANDLE,
        qualifyingData: Vec<u8>,
        inScheme: Option<TPMU_SIG_SCHEME>,
    ) -> Result<CertifyResponse, TpmError> {
        // Create request structure
        let req = TPM2_Certify_REQUEST {
            objectHandle,
            signHandle,
            qualifyingData,
            inScheme,
        };

        // Send command and process response
        let mut resp = CertifyResponse::default();
        self.dispatch(req, &mut resp)?;
        Ok(resp)
    }

    /// This command is used to prove the association between an object and its creation data. The
    /// TPM will validate that the ticket was produced by the TPM and that the ticket validates
    /// the association between a loaded public area and the provided hash of the creation data
    /// (creationHash).
    /// signHandle: Handle of the key that will sign the attestation block
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// objectHandle: The object associated with the creation data
    ///        Auth Index: None
    /// qualifyingData: User-provided qualifying data
    /// creationHash: Hash of the creation data produced by TPM2_Create() or TPM2_CreatePrimary()
    /// inScheme: Signing scheme to use if the scheme for signHandle is TPM_ALG_NULL
    ///        One of: TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA,
    ///        TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR,
    ///        TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME.
    /// creationTicket: Ticket produced by TPM2_Create() or TPM2_CreatePrimary()
    ///     certifyInfo - The structure that was signed
    ///     signature - The signature over certifyInfo
    pub fn CertifyCreation(
        &mut self,
        signHandle: TPM_HANDLE,
        objectHandle: TPM_HANDLE,
        qualifyingData: Vec<u8>,
        creationHash: Vec<u8>,
        inScheme: Option<TPMU_SIG_SCHEME>,
        creationTicket: TPMT_TK_CREATION,
    ) -> Result<CertifyCreationResponse, TpmError> {
        // Create request structure
        let req = TPM2_CertifyCreation_REQUEST {
            signHandle,
            objectHandle,
            qualifyingData,
            creationHash,
            inScheme,
            creationTicket,
        };

        // Send command and process response
        let mut resp = CertifyCreationResponse::default();
        self.dispatch(req, &mut resp)?;
        Ok(resp)
    }

    /// This command is used to quote PCR values.
    /// signHandle: Handle of key that will perform signature
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// qualifyingData: Data supplied by the caller
    /// inScheme: Signing scheme to use if the scheme for signHandle is TPM_ALG_NULL
    ///        One of: TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA,
    ///        TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR,
    ///        TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME.
    /// PCRselect: PCR set to quote
    ///     quoted - The quoted information
    ///     signature - The signature over quoted
    pub fn Quote(
        &mut self,
        signHandle: TPM_HANDLE,
        qualifyingData: Vec<u8>,
        inScheme: Option<TPMU_SIG_SCHEME>,
        PCRselect: Vec<TPMS_PCR_SELECTION>,
    ) -> Result<QuoteResponse, TpmError> {
        // Create request structure
        let req = TPM2_Quote_REQUEST {
            signHandle,
            qualifyingData,
            inScheme,
            PCRselect,
        };

        // Send command and process response
        let mut resp = QuoteResponse::default();
        self.dispatch(req, &mut resp)?;
        Ok(resp)
    }

    /// This command returns a digital signature of the audit session digest.
    /// privacyAdminHandle: Handle of the privacy administrator (TPM_RH_ENDORSEMENT)
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// signHandle: Handle of the signing key
    ///        Auth Index: 2
    ///        Auth Role: USER
    /// sessionHandle: Handle of the audit session
    ///        Auth Index: None
    /// qualifyingData: User-provided qualifying data may be zero-length
    /// inScheme: Signing scheme to use if the scheme for signHandle is TPM_ALG_NULL
    ///        One of: TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA,
    ///        TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR,
    ///        TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME.
    ///     auditInfo - The audit information that was signed
    ///     signature - The signature over auditInfo
    pub fn GetSessionAuditDigest(
        &mut self,
        privacyAdminHandle: TPM_HANDLE,
        signHandle: TPM_HANDLE,
        sessionHandle: TPM_HANDLE,
        qualifyingData: Vec<u8>,
        inScheme: Option<TPMU_SIG_SCHEME>,
    ) -> Result<GetSessionAuditDigestResponse, TpmError> {
        // Create request structure
        let req = TPM2_GetSessionAuditDigest_REQUEST {
            privacyAdminHandle,
            signHandle,
            sessionHandle,
            qualifyingData,
            inScheme,
        };

        // Send command and process response
        let mut resp = GetSessionAuditDigestResponse::default();
        self.dispatch(req, &mut resp)?;
        Ok(resp)
    }

    /// This command returns the current value of the command audit digest, a digest of the
    /// commands being audited, and the audit hash algorithm. These values are placed in an
    /// attestation structure and signed with the key referenced by signHandle.
    /// privacyHandle: Handle of the privacy administrator (TPM_RH_ENDORSEMENT)
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// signHandle: The handle of the signing key
    ///        Auth Index: 2
    ///        Auth Role: USER
    /// qualifyingData: Other data to associate with this audit digest
    /// inScheme: Signing scheme to use if the scheme for signHandle is TPM_ALG_NULL
    ///        One of: TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA,
    ///        TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR,
    ///        TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME.
    ///     auditInfo - The auditInfo that was signed
    ///     signature - The signature over auditInfo
    pub fn GetCommandAuditDigest(
        &mut self,
        privacyHandle: TPM_HANDLE,
        signHandle: TPM_HANDLE,
        qualifyingData: Vec<u8>,
        inScheme: Option<TPMU_SIG_SCHEME>,
    ) -> Result<GetCommandAuditDigestResponse, TpmError> {
        // Create request structure
        let req = TPM2_GetCommandAuditDigest_REQUEST {
            privacyHandle,
            signHandle,
            qualifyingData,
            inScheme,
        };

        // Send command and process response
        let mut resp = GetCommandAuditDigestResponse::default();
        self.dispatch(req, &mut resp)?;
        Ok(resp)
    }

    /// This command returns the current values of Time and Clock.
    /// privacyAdminHandle: Handle of the privacy administrator (TPM_RH_ENDORSEMENT)
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// signHandle: The keyHandle identifier of a loaded key that can perform digital signatures
    ///        Auth Index: 2
    ///        Auth Role: USER
    /// qualifyingData: Data to tick stamp
    /// inScheme: Signing scheme to use if the scheme for signHandle is TPM_ALG_NULL
    ///        One of: TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA,
    ///        TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR,
    ///        TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME.
    ///     timeInfo - Standard TPM-generated attestation block
    ///     signature - The signature over timeInfo
    pub fn GetTime(
        &mut self,
        privacyAdminHandle: TPM_HANDLE,
        signHandle: TPM_HANDLE,
        qualifyingData: Vec<u8>,
        inScheme: Option<TPMU_SIG_SCHEME>,
    ) -> Result<GetTimeResponse, TpmError> {
        // Create request structure
        let req = TPM2_GetTime_REQUEST {
            privacyAdminHandle,
            signHandle,
            qualifyingData,
            inScheme,
        };

        // Send command and process response
        let mut resp = GetTimeResponse::default();
        self.dispatch(req, &mut resp)?;
        Ok(resp)
    }

    /// The purpose of this command is to generate an X.509 certificate that proves an object with
    /// a specific public key and attributes is loaded in the TPM. In contrast to TPM2_Certify,
    /// which uses a TCG-defined data structure to convey attestation information,
    /// TPM2_CertifyX509 encodes the attestation information in a DER-encoded X.509 certificate
    /// that is compliant with RFC5280 Internet X.509 Public Key Infrastructure Certificate and
    /// Certificate Revocation List (CRL) Profile.
    /// objectHandle: Handle of the object to be certified
    ///        Auth Index: 1
    ///        Auth Role: ADMIN
    /// signHandle: Handle of the key used to sign the attestation structure
    ///        Auth Index: 2
    ///        Auth Role: USER
    /// reserved: Shall be an Empty Buffer
    /// inScheme: Signing scheme to use if the scheme for signHandle is TPM_ALG_NULL
    ///        One of: TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA,
    ///        TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR,
    ///        TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME.
    /// partialCertificate: A DER encoded partial certificate
    ///     addedToCertificate - A DER encoded SEQUENCE containing the DER encoded fields added to
    ///                          partialCertificate to make it a complete RFC5280 TBSCertificate.
    ///     tbsDigest - The digest that was signed
    ///     signature - The signature over tbsDigest
    pub fn CertifyX509(
        &mut self,
        objectHandle: TPM_HANDLE,
        signHandle: TPM_HANDLE,
        reserved: Vec<u8>,
        inScheme: Option<TPMU_SIG_SCHEME>,
        partialCertificate: Vec<u8>,
    ) -> Result<CertifyX509Response, TpmError> {
        // Create request structure
        let req = TPM2_CertifyX509_REQUEST {
            objectHandle,
            signHandle,
            reserved,
            inScheme,
            partialCertificate,
        };

        // Send command and process response
        let mut resp = CertifyX509Response::default();
        self.dispatch(req, &mut resp)?;
        Ok(resp)
    }

    /// TPM2_Commit() performs the first part of an ECC anonymous signing operation. The TPM will
    /// perform the point multiplications on the provided points and return intermediate signing
    /// values. The signHandle parameter shall refer to an ECC key and the signing scheme must be
    /// anonymous (TPM_RC_SCHEME).
    /// signHandle: Handle of the key that will be used in the signing operation
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// P1: A point (M) on the curve used by signHandle
    /// s2: Octet array used to derive x-coordinate of a base point
    /// y2: Y coordinate of the point associated with s2
    ///     K - ECC point K [ds](x2, y2)
    ///     L - ECC point L [r](x2, y2)
    ///     E - ECC point E [r]P1
    ///     counter - Least-significant 16 bits of commitCount
    pub fn Commit(
        &mut self,
        signHandle: TPM_HANDLE,
        P1: TPMS_ECC_POINT,
        s2: Vec<u8>,
        y2: Vec<u8>,
    ) -> Result<CommitResponse, TpmError> {
        // Create request structure
        let req = TPM2_Commit_REQUEST {
            signHandle,
            P1,
            s2,
            y2,
        };

        // Send command and process response
        let mut resp = CommitResponse::default();
        self.dispatch(req, &mut resp)?;
        Ok(resp)
    }

    /// TPM2_EC_Ephemeral() creates an ephemeral key for use in a two-phase key exchange protocol.
    /// curveID: The curve for the computed ephemeral point
    ///     Q - Ephemeral public key Q [r]G
    ///     counter - Least-significant 16 bits of commitCount
    pub fn EC_Ephemeral(
        &mut self,
        curveID: TPM_ECC_CURVE,
    ) -> Result<EC_EphemeralResponse, TpmError> {
        // Create request structure
        let req = TPM2_EC_Ephemeral_REQUEST {
            curveID,
        };

        // Send command and process response
        let mut resp = EC_EphemeralResponse::default();
        self.dispatch(req, &mut resp)?;
        Ok(resp)
    }

    /// This command uses loaded keys to validate a signature on a message with the message digest
    /// passed to the TPM.
    /// keyHandle: Handle of public key that will be used in the validation
    ///        Auth Index: None
    /// digest: Digest of the signed message
    /// signature: Signature to be tested
    ///        One of: TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA,
    ///        TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TPMT_HA,
    ///        TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE.
    ///     validation - This ticket is produced by TPM2_VerifySignature(). This formulation is
    ///                  used for multiple ticket uses. The ticket provides evidence that the TPM
    ///                  has validated that a digest was signed by a key with the Name of keyName.
    ///                  The ticket is computed by
    pub fn VerifySignature(
        &mut self,
        keyHandle: TPM_HANDLE,
        digest: Vec<u8>,
        signature: Option<TPMU_SIGNATURE>,
    ) -> Result<TPMT_TK_VERIFIED, TpmError> {
        // Create request structure
        let req = TPM2_VerifySignature_REQUEST {
            keyHandle,
            digest,
            signature,
        };

        // Send command and process response
        let mut resp = VerifySignatureResponse::default();
        self.dispatch(req, &mut resp)?;
        Ok(resp.validation)
    }

    /// This command causes the TPM to sign an externally provided hash with the specified
    /// symmetric or asymmetric signing key.
    /// keyHandle: Handle of key that will perform signing
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// digest: Digest to be signed
    /// inScheme: Signing scheme to use if the scheme for keyHandle is TPM_ALG_NULL
    ///        One of: TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA,
    ///        TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR,
    ///        TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME.
    /// validation: Proof that digest was created by the TPM
    ///        If keyHandle is not a restricted signing key, then this may be a NULL Ticket with
    ///        tag = TPM_ST_CHECKHASH.
    ///     signature - The signature
    pub fn Sign(
        &mut self,
        keyHandle: TPM_HANDLE,
        digest: Vec<u8>,
        inScheme: Option<TPMU_SIG_SCHEME>,
        validation: TPMT_TK_HASHCHECK,
    ) -> Result<Option<TPMU_SIGNATURE>, TpmError> {
        // Create request structure
        let req = TPM2_Sign_REQUEST {
            keyHandle,
            digest,
            inScheme,
            validation,
        };

        // Send command and process response
        let mut resp = SignResponse::default();
        self.dispatch(req, &mut resp)?;
        Ok(resp.signature)
    }

    /// This command may be used by the Privacy Administrator or platform to change the audit
    /// status of a command or to set the hash algorithm used for the audit digest, but not both
    /// at the same time.
    /// auth: TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// auditAlg: Hash algorithm for the audit digest; if TPM_ALG_NULL, then the hash is not changed
    /// setList: List of commands that will be added to those that will be audited
    /// clearList: List of commands that will no longer be audited
    pub fn SetCommandCodeAuditStatus(
        &mut self,
        auth: TPM_HANDLE,
        auditAlg: TPM_ALG_ID,
        setList: Vec<TPM_CC>,
        clearList: Vec<TPM_CC>,
    ) -> Result<(), TpmError> {
        // Create request structure
        let req = TPM2_SetCommandCodeAuditStatus_REQUEST {
            auth,
            auditAlg,
            setList,
            clearList,
        };

        // Send command and process response
        let mut resp = TPMS_EMPTY::default();
        self.dispatch(req, &mut resp)?;
        Ok(())
    }

    /// This command is used to cause an update to the indicated PCR. The digests parameter
    /// contains one or more tagged digest values identified by an algorithm ID. For each digest,
    /// the PCR associated with pcrHandle is Extended into the bank identified by the tag (hashAlg).
    /// pcrHandle: Handle of the PCR
    ///        Auth Handle: 1
    ///        Auth Role: USER
    /// digests: List of tagged digest values to be extended
    pub fn PCR_Extend(
        &mut self,
        pcrHandle: TPM_HANDLE,
        digests: Vec<TPMT_HA>,
    ) -> Result<(), TpmError> {
        // Create request structure
        let req = TPM2_PCR_Extend_REQUEST {
            pcrHandle,
            digests,
        };

        // Send command and process response
        let mut resp = TPMS_EMPTY::default();
        self.dispatch(req, &mut resp)?;
        Ok(())
    }

    /// This command is used to cause an update to the indicated PCR.
    /// pcrHandle: Handle of the PCR
    ///        Auth Handle: 1
    ///        Auth Role: USER
    /// eventData: Event data in sized buffer
    ///     digests - Table 80 shows the basic hash-agile structure used in this specification. To
    ///               handle hash agility, this structure uses the hashAlg parameter to indicate
    ///               the algorithm used to compute the digest and, by implication, the size of
    ///               the digest.
    pub fn PCR_Event(
        &mut self,
        pcrHandle: TPM_HANDLE,
        eventData: Vec<u8>,
    ) -> Result<Vec<TPMT_HA>, TpmError> {
        // Create request structure
        let req = TPM2_PCR_Event_REQUEST {
            pcrHandle,
            eventData,
        };

        // Send command and process response
        let mut resp = PCR_EventResponse::default();
        self.dispatch(req, &mut resp)?;
        Ok(resp.digests)
    }

    /// This command returns the values of all PCR specified in pcrSelectionIn.
    /// pcrSelectionIn: The selection of PCR to read
    ///     pcrUpdateCounter - The current value of the PCR update counter
    ///     pcrSelectionOut - The PCR in the returned list
    ///     pcrValues - The contents of the PCR indicated in pcrSelectOut-˃ pcrSelection[] as
    ///                 tagged digests
    pub fn PCR_Read(
        &mut self,
        pcrSelectionIn: Vec<TPMS_PCR_SELECTION>,
    ) -> Result<PCR_ReadResponse, TpmError> {
        // Create request structure
        let req = TPM2_PCR_Read_REQUEST {
            pcrSelectionIn,
        };

        // Send command and process response
        let mut resp = PCR_ReadResponse::default();
        self.dispatch(req, &mut resp)?;
        Ok(resp)
    }

    /// This command is used to set the desired PCR allocation of PCR and algorithms. This command
    /// requires Platform Authorization.
    /// authHandle: TPM_RH_PLATFORM+{PP}
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// pcrAllocation: The requested allocation
    ///     allocationSuccess - YES if the allocation succeeded
    ///     maxPCR - Maximum number of PCR that may be in a bank
    ///     sizeNeeded - Number of octets required to satisfy the request
    ///     sizeAvailable - Number of octets available. Computed before the allocation.
    pub fn PCR_Allocate(
        &mut self,
        authHandle: TPM_HANDLE,
        pcrAllocation: Vec<TPMS_PCR_SELECTION>,
    ) -> Result<PCR_AllocateResponse, TpmError> {
        // Create request structure
        let req = TPM2_PCR_Allocate_REQUEST {
            authHandle,
            pcrAllocation,
        };

        // Send command and process response
        let mut resp = PCR_AllocateResponse::default();
        self.dispatch(req, &mut resp)?;
        Ok(resp)
    }

    /// This command is used to associate a policy with a PCR or group of PCR. The policy
    /// determines the conditions under which a PCR may be extended or reset.
    /// authHandle: TPM_RH_PLATFORM+{PP}
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// authPolicy: The desired authPolicy
    /// hashAlg: The hash algorithm of the policy
    /// pcrNum: The PCR for which the policy is to be set
    pub fn PCR_SetAuthPolicy(
        &mut self,
        authHandle: TPM_HANDLE,
        authPolicy: Vec<u8>,
        hashAlg: TPM_ALG_ID,
        pcrNum: TPM_HANDLE,
    ) -> Result<(), TpmError> {
        // Create request structure
        let req = TPM2_PCR_SetAuthPolicy_REQUEST {
            authHandle,
            authPolicy,
            hashAlg,
            pcrNum,
        };

        // Send command and process response
        let mut resp = TPMS_EMPTY::default();
        self.dispatch(req, &mut resp)?;
        Ok(())
    }

    /// This command changes the authValue of a PCR or group of PCR.
    /// pcrHandle: Handle for a PCR that may have an authorization value set
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// auth: The desired authorization value
    pub fn PCR_SetAuthValue(
        &mut self,
        pcrHandle: TPM_HANDLE,
        auth: Vec<u8>,
    ) -> Result<(), TpmError> {
        // Create request structure
        let req = TPM2_PCR_SetAuthValue_REQUEST {
            pcrHandle,
            auth,
        };

        // Send command and process response
        let mut resp = TPMS_EMPTY::default();
        self.dispatch(req, &mut resp)?;
        Ok(())
    }

    /// If the attribute of a PCR allows the PCR to be reset and proper authorization is provided,
    /// then this command may be used to set the PCR in all banks to zero. The attributes of the
    /// PCR may restrict the locality that can perform the reset operation.
    /// pcrHandle: The PCR to reset
    ///        Auth Index: 1
    ///        Auth Role: USER
    pub fn PCR_Reset(
        &mut self,
        pcrHandle: TPM_HANDLE,
    ) -> Result<(), TpmError> {
        // Create request structure
        let req = TPM2_PCR_Reset_REQUEST {
            pcrHandle,
        };

        // Send command and process response
        let mut resp = TPMS_EMPTY::default();
        self.dispatch(req, &mut resp)?;
        Ok(())
    }

    /// This command includes a signed authorization in a policy. The command ties the policy to a
    /// signing key by including the Name of the signing key in the policyDigest
    /// authObject: Handle for a key that will validate the signature
    ///        Auth Index: None
    /// policySession: Handle for the policy session being extended
    ///        Auth Index: None
    /// nonceTPM: The policy nonce for the session
    ///        This can be the Empty Buffer.
    /// cpHashA: Digest of the command parameters to which this authorization is limited
    ///        This is not the cpHash for this command but the cpHash for the command to which
    ///        this policy session will be applied. If it is not limited, the parameter will be
    ///        the Empty Buffer.
    /// policyRef: A reference to a policy relating to the authorization may be the Empty Buffer
    ///        Size is limited to be no larger than the nonce size supported on the TPM.
    /// expiration: Time when authorization will expire, measured in seconds from the time that
    ///        nonceTPM was generated
    ///        If expiration is non-negative, a NULL Ticket is returned. See 23.2.5.
    /// auth: Signed authorization (not optional)
    ///        One of: TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA,
    ///        TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TPMT_HA,
    ///        TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE.
    ///     timeout - Implementation-specific time value, used to indicate to the TPM when the
    ///               ticket expires
    ///               NOTE If policyTicket is a NULL Ticket, then this shall be the Empty Buffer.
    ///     policyTicket - Produced if the command succeeds and expiration in the command was
    ///                    non-zero; this ticket will use the TPMT_ST_AUTH_SIGNED structure tag.
    ///                    See 23.2.5
    pub fn PolicySigned(
        &mut self,
        authObject: TPM_HANDLE,
        policySession: TPM_HANDLE,
        nonceTPM: Vec<u8>,
        cpHashA: Vec<u8>,
        policyRef: Vec<u8>,
        expiration: i32,
        auth: Option<TPMU_SIGNATURE>,
    ) -> Result<PolicySignedResponse, TpmError> {
        // Create request structure
        let req = TPM2_PolicySigned_REQUEST {
            authObject,
            policySession,
            nonceTPM,
            cpHashA,
            policyRef,
            expiration,
            auth,
        };

        // Send command and process response
        let mut resp = PolicySignedResponse::default();
        self.dispatch(req, &mut resp)?;
        Ok(resp)
    }

    /// This command includes a secret-based authorization to a policy. The caller proves
    /// knowledge of the secret value using an authorization session using the authValue
    /// associated with authHandle. A password session, an HMAC session, or a policy session
    /// containing TPM2_PolicyAuthValue() or TPM2_PolicyPassword() will satisfy this requirement.
    /// authHandle: Handle for an entity providing the authorization
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// policySession: Handle for the policy session being extended
    ///        Auth Index: None
    /// nonceTPM: The policy nonce for the session
    ///        This can be the Empty Buffer.
    /// cpHashA: Digest of the command parameters to which this authorization is limited
    ///        This not the cpHash for this command but the cpHash for the command to which this
    ///        policy session will be applied. If it is not limited, the parameter will be the
    ///        Empty Buffer.
    /// policyRef: A reference to a policy relating to the authorization may be the Empty Buffer
    ///        Size is limited to be no larger than the nonce size supported on the TPM.
    /// expiration: Time when authorization will expire, measured in seconds from the time that
    ///        nonceTPM was generated
    ///        If expiration is non-negative, a NULL Ticket is returned. See 23.2.5.
    ///     timeout - Implementation-specific time value used to indicate to the TPM when the
    ///               ticket expires
    ///     policyTicket - Produced if the command succeeds and expiration in the command was
    ///                    non-zero ( See 23.2.5). This ticket will use the TPMT_ST_AUTH_SECRET
    ///                    structure tag
    pub fn PolicySecret(
        &mut self,
        authHandle: TPM_HANDLE,
        policySession: TPM_HANDLE,
        nonceTPM: Vec<u8>,
        cpHashA: Vec<u8>,
        policyRef: Vec<u8>,
        expiration: i32,
    ) -> Result<PolicySecretResponse, TpmError> {
        // Create request structure
        let req = TPM2_PolicySecret_REQUEST {
            authHandle,
            policySession,
            nonceTPM,
            cpHashA,
            policyRef,
            expiration,
        };

        // Send command and process response
        let mut resp = PolicySecretResponse::default();
        self.dispatch(req, &mut resp)?;
        Ok(resp)
    }

    /// This command is similar to TPM2_PolicySigned() except that it takes a ticket instead of a
    /// signed authorization. The ticket represents a validated authorization that had an
    /// expiration time associated with it.
    /// policySession: Handle for the policy session being extended
    ///        Auth Index: None
    /// timeout: Time when authorization will expire
    ///        The contents are TPM specific. This shall be the value returned when ticket was produced.
    /// cpHashA: Digest of the command parameters to which this authorization is limited
    ///        If it is not limited, the parameter will be the Empty Buffer.
    /// policyRef: Reference to a qualifier for the policy may be the Empty Buffer
    /// authName: Name of the object that provided the authorization
    /// ticket: An authorization ticket returned by the TPM in response to a TPM2_PolicySigned()
    ///        or TPM2_PolicySecret()
    pub fn PolicyTicket(
        &mut self,
        policySession: TPM_HANDLE,
        timeout: Vec<u8>,
        cpHashA: Vec<u8>,
        policyRef: Vec<u8>,
        authName: Vec<u8>,
        ticket: TPMT_TK_AUTH,
    ) -> Result<(), TpmError> {
        // Create request structure
        let req = TPM2_PolicyTicket_REQUEST {
            policySession,
            timeout,
            cpHashA,
            policyRef,
            authName,
            ticket,
        };

        // Send command and process response
        let mut resp = TPMS_EMPTY::default();
        self.dispatch(req, &mut resp)?;
        Ok(())
    }

    /// This command allows options in authorizations without requiring that the TPM evaluate all
    /// of the options. If a policy may be satisfied by different sets of conditions, the TPM need
    /// only evaluate one set that satisfies the policy. This command will indicate that one of
    /// the required sets of conditions has been satisfied.
    /// policySession: Handle for the policy session being extended
    ///        Auth Index: None
    /// pHashList: The list of hashes to check for a match
    pub fn PolicyOR(
        &mut self,
        policySession: TPM_HANDLE,
        pHashList: Vec<TPM2B_DIGEST>,
    ) -> Result<(), TpmError> {
        // Create request structure
        let req = TPM2_PolicyOR_REQUEST {
            policySession,
            pHashList,
        };

        // Send command and process response
        let mut resp = TPMS_EMPTY::default();
        self.dispatch(req, &mut resp)?;
        Ok(())
    }

    /// This command is used to cause conditional gating of a policy based on PCR. This command
    /// together with TPM2_PolicyOR() allows one group of authorizations to occur when PCR are in
    /// one state and a different set of authorizations when the PCR are in a different state.
    /// policySession: Handle for the policy session being extended
    ///        Auth Index: None
    /// pcrDigest: Expected digest value of the selected PCR using the hash algorithm of the
    ///        session; may be zero length
    /// pcrs: The PCR to include in the check digest
    pub fn PolicyPCR(
        &mut self,
        policySession: TPM_HANDLE,
        pcrDigest: Vec<u8>,
        pcrs: Vec<TPMS_PCR_SELECTION>,
    ) -> Result<(), TpmError> {
        // Create request structure
        let req = TPM2_PolicyPCR_REQUEST {
            policySession,
            pcrDigest,
            pcrs,
        };

        // Send command and process response
        let mut resp = TPMS_EMPTY::default();
        self.dispatch(req, &mut resp)?;
        Ok(())
    }

    /// This command indicates that the authorization will be limited to a specific locality.
    /// policySession: Handle for the policy session being extended
    ///        Auth Index: None
    /// locality: The allowed localities for the policy
    pub fn PolicyLocality(
        &mut self,
        policySession: TPM_HANDLE,
        locality: TPMA_LOCALITY,
    ) -> Result<(), TpmError> {
        // Create request structure
        let req = TPM2_PolicyLocality_REQUEST {
            policySession,
            locality,
        };

        // Send command and process response
        let mut resp = TPMS_EMPTY::default();
        self.dispatch(req, &mut resp)?;
        Ok(())
    }

    /// This command is used to cause conditional gating of a policy based on the contents of an
    /// NV Index. It is an immediate assertion. The NV index is validated during the
    /// TPM2_PolicyNV() command, not when the session is used for authorization.
    /// authHandle: Handle indicating the source of the authorization value
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// nvIndex: The NV Index of the area to read
    ///        Auth Index: None
    /// policySession: Handle for the policy session being extended
    ///        Auth Index: None
    /// operandB: The second operand
    /// offset: The octet offset in the NV Index for the start of operand A
    /// operation: The comparison to make
    pub fn PolicyNV(
        &mut self,
        authHandle: TPM_HANDLE,
        nvIndex: TPM_HANDLE,
        policySession: TPM_HANDLE,
        operandB: Vec<u8>,
        offset: u16,
        operation: TPM_EO,
    ) -> Result<(), TpmError> {
        // Create request structure
        let req = TPM2_PolicyNV_REQUEST {
            authHandle,
            nvIndex,
            policySession,
            operandB,
            offset,
            operation,
        };

        // Send command and process response
        let mut resp = TPMS_EMPTY::default();
        self.dispatch(req, &mut resp)?;
        Ok(())
    }

    /// This command is used to cause conditional gating of a policy based on the contents of the
    /// TPMS_TIME_INFO structure.
    /// policySession: Handle for the policy session being extended
    ///        Auth Index: None
    /// operandB: The second operand
    /// offset: The octet offset in the TPMS_TIME_INFO structure for the start of operand A
    /// operation: The comparison to make
    pub fn PolicyCounterTimer(
        &mut self,
        policySession: TPM_HANDLE,
        operandB: Vec<u8>,
        offset: u16,
        operation: TPM_EO,
    ) -> Result<(), TpmError> {
        // Create request structure
        let req = TPM2_PolicyCounterTimer_REQUEST {
            policySession,
            operandB,
            offset,
            operation,
        };

        // Send command and process response
        let mut resp = TPMS_EMPTY::default();
        self.dispatch(req, &mut resp)?;
        Ok(())
    }

    /// This command indicates that the authorization will be limited to a specific command code.
    /// policySession: Handle for the policy session being extended
    ///        Auth Index: None
    /// code: The allowed commandCode
    pub fn PolicyCommandCode(
        &mut self,
        policySession: TPM_HANDLE,
        code: TPM_CC,
    ) -> Result<(), TpmError> {
        // Create request structure
        let req = TPM2_PolicyCommandCode_REQUEST {
            policySession,
            code,
        };

        // Send command and process response
        let mut resp = TPMS_EMPTY::default();
        self.dispatch(req, &mut resp)?;
        Ok(())
    }

    /// This command indicates that physical presence will need to be asserted at the time the
    /// authorization is performed.
    /// policySession: Handle for the policy session being extended
    ///        Auth Index: None
    pub fn PolicyPhysicalPresence(
        &mut self,
        policySession: TPM_HANDLE,
    ) -> Result<(), TpmError> {
        // Create request structure
        let req = TPM2_PolicyPhysicalPresence_REQUEST {
            policySession,
        };

        // Send command and process response
        let mut resp = TPMS_EMPTY::default();
        self.dispatch(req, &mut resp)?;
        Ok(())
    }

    /// This command is used to allow a policy to be bound to a specific command and command parameters.
    /// policySession: Handle for the policy session being extended
    ///        Auth Index: None
    /// cpHashA: The cpHash added to the policy
    pub fn PolicyCpHash(
        &mut self,
        policySession: TPM_HANDLE,
        cpHashA: Vec<u8>,
    ) -> Result<(), TpmError> {
        // Create request structure
        let req = TPM2_PolicyCpHash_REQUEST {
            policySession,
            cpHashA,
        };

        // Send command and process response
        let mut resp = TPMS_EMPTY::default();
        self.dispatch(req, &mut resp)?;
        Ok(())
    }

    /// This command allows a policy to be bound to a specific set of TPM entities without being
    /// bound to the parameters of the command. This is most useful for commands such as
    /// TPM2_Duplicate() and for TPM2_PCR_Event() when the referenced PCR requires a policy.
    /// policySession: Handle for the policy session being extended
    ///        Auth Index: None
    /// nameHash: The digest to be added to the policy
    pub fn PolicyNameHash(
        &mut self,
        policySession: TPM_HANDLE,
        nameHash: Vec<u8>,
    ) -> Result<(), TpmError> {
        // Create request structure
        let req = TPM2_PolicyNameHash_REQUEST {
            policySession,
            nameHash,
        };

        // Send command and process response
        let mut resp = TPMS_EMPTY::default();
        self.dispatch(req, &mut resp)?;
        Ok(())
    }

    /// This command allows qualification of duplication to allow duplication to a selected new parent.
    /// policySession: Handle for the policy session being extended
    ///        Auth Index: None
    /// objectName: The Name of the object to be duplicated
    /// newParentName: The Name of the new parent
    /// includeObject: If YES, the objectName will be included in the value in policySessionpolicyDigest
    pub fn PolicyDuplicationSelect(
        &mut self,
        policySession: TPM_HANDLE,
        objectName: Vec<u8>,
        newParentName: Vec<u8>,
        includeObject: u8,
    ) -> Result<(), TpmError> {
        // Create request structure
        let req = TPM2_PolicyDuplicationSelect_REQUEST {
            policySession,
            objectName,
            newParentName,
            includeObject,
        };

        // Send command and process response
        let mut resp = TPMS_EMPTY::default();
        self.dispatch(req, &mut resp)?;
        Ok(())
    }

    /// This command allows policies to change. If a policy were static, then it would be
    /// difficult to add users to a policy. This command lets a policy authority sign a new policy
    /// so that it may be used in an existing policy.
    /// policySession: Handle for the policy session being extended
    ///        Auth Index: None
    /// approvedPolicy: Digest of the policy being approved
    /// policyRef: A policy qualifier
    /// keySign: Name of a key that can sign a policy addition
    /// checkTicket: Ticket validating that approvedPolicy and policyRef were signed by keySign
    pub fn PolicyAuthorize(
        &mut self,
        policySession: TPM_HANDLE,
        approvedPolicy: Vec<u8>,
        policyRef: Vec<u8>,
        keySign: Vec<u8>,
        checkTicket: TPMT_TK_VERIFIED,
    ) -> Result<(), TpmError> {
        // Create request structure
        let req = TPM2_PolicyAuthorize_REQUEST {
            policySession,
            approvedPolicy,
            policyRef,
            keySign,
            checkTicket,
        };

        // Send command and process response
        let mut resp = TPMS_EMPTY::default();
        self.dispatch(req, &mut resp)?;
        Ok(())
    }

    /// This command allows a policy to be bound to the authorization value of the authorized entity.
    /// policySession: Handle for the policy session being extended
    ///        Auth Index: None
    pub fn PolicyAuthValue(
        &mut self,
        policySession: TPM_HANDLE,
    ) -> Result<(), TpmError> {
        // Create request structure
        let req = TPM2_PolicyAuthValue_REQUEST {
            policySession,
        };

        // Send command and process response
        let mut resp = TPMS_EMPTY::default();
        self.dispatch(req, &mut resp)?;
        Ok(())
    }

    /// This command allows a policy to be bound to the authorization value of the authorized object.
    /// policySession: Handle for the policy session being extended
    ///        Auth Index: None
    pub fn PolicyPassword(
        &mut self,
        policySession: TPM_HANDLE,
    ) -> Result<(), TpmError> {
        // Create request structure
        let req = TPM2_PolicyPassword_REQUEST {
            policySession,
        };

        // Send command and process response
        let mut resp = TPMS_EMPTY::default();
        self.dispatch(req, &mut resp)?;
        Ok(())
    }

    /// This command returns the current policyDigest of the session. This command allows the TPM
    /// to be used to perform the actions required to pre-compute the authPolicy for an object.
    /// policySession: Handle for the policy session
    ///        Auth Index: None
    ///     policyDigest - The current value of the policySessionpolicyDigest
    pub fn PolicyGetDigest(
        &mut self,
        policySession: TPM_HANDLE,
    ) -> Result<Vec<u8>, TpmError> {
        // Create request structure
        let req = TPM2_PolicyGetDigest_REQUEST {
            policySession,
        };

        // Send command and process response
        let mut resp = PolicyGetDigestResponse::default();
        self.dispatch(req, &mut resp)?;
        Ok(resp.policyDigest)
    }

    /// This command allows a policy to be bound to the TPMA_NV_WRITTEN attributes. This is a
    /// deferred assertion. Values are stored in the policy session context and checked when the
    /// policy is used for authorization.
    /// policySession: Handle for the policy session being extended
    ///        Auth Index: None
    /// writtenSet: YES if NV Index is required to have been written
    ///        NO if NV Index is required not to have been written
    pub fn PolicyNvWritten(
        &mut self,
        policySession: TPM_HANDLE,
        writtenSet: u8,
    ) -> Result<(), TpmError> {
        // Create request structure
        let req = TPM2_PolicyNvWritten_REQUEST {
            policySession,
            writtenSet,
        };

        // Send command and process response
        let mut resp = TPMS_EMPTY::default();
        self.dispatch(req, &mut resp)?;
        Ok(())
    }

    /// This command allows a policy to be bound to a specific creation template. This is most
    /// useful for an object creation command such as TPM2_Create(), TPM2_CreatePrimary(), or
    /// TPM2_CreateLoaded().
    /// policySession: Handle for the policy session being extended
    ///        Auth Index: None
    /// templateHash: The digest to be added to the policy
    pub fn PolicyTemplate(
        &mut self,
        policySession: TPM_HANDLE,
        templateHash: Vec<u8>,
    ) -> Result<(), TpmError> {
        // Create request structure
        let req = TPM2_PolicyTemplate_REQUEST {
            policySession,
            templateHash,
        };

        // Send command and process response
        let mut resp = TPMS_EMPTY::default();
        self.dispatch(req, &mut resp)?;
        Ok(())
    }

    /// This command provides a capability that is the equivalent of a revocable policy. With
    /// TPM2_PolicyAuthorize(), the authorization ticket never expires, so the authorization may
    /// not be withdrawn. With this command, the approved policy is kept in an NV Index location
    /// so that the policy may be changed as needed to render the old policy unusable.
    /// authHandle: Handle indicating the source of the authorization value
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// nvIndex: The NV Index of the area to read
    ///        Auth Index: None
    /// policySession: Handle for the policy session being extended
    ///        Auth Index: None
    pub fn PolicyAuthorizeNV(
        &mut self,
        authHandle: TPM_HANDLE,
        nvIndex: TPM_HANDLE,
        policySession: TPM_HANDLE,
    ) -> Result<(), TpmError> {
        // Create request structure
        let req = TPM2_PolicyAuthorizeNV_REQUEST {
            authHandle,
            nvIndex,
            policySession,
        };

        // Send command and process response
        let mut resp = TPMS_EMPTY::default();
        self.dispatch(req, &mut resp)?;
        Ok(())
    }

    /// This command is used to create a Primary Object under one of the Primary Seeds or a
    /// Temporary Object under TPM_RH_NULL. The command uses a TPM2B_PUBLIC as a template for the
    /// object to be created. The size of the unique field shall not be checked for consistency
    /// with the other object parameters. The command will create and load a Primary Object. The
    /// sensitive area is not returned.
    /// primaryHandle: TPM_RH_ENDORSEMENT, TPM_RH_OWNER, TPM_RH_PLATFORM+{PP}, or TPM_RH_NULL
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// inSensitive: The sensitive data, see TPM 2.0 Part 1 Sensitive Values
    /// inPublic: The public template
    /// outsideInfo: Data that will be included in the creation data for this object to provide
    ///        permanent, verifiable linkage between this object and some object owner data
    /// creationPCR: PCR that will be used in creation data
    ///     handle - Handle of type TPM_HT_TRANSIENT for created Primary Object
    ///     outPublic - The public portion of the created object
    ///     creationData - Contains a TPMT_CREATION_DATA
    ///     creationHash - Digest of creationData using nameAlg of outPublic
    ///     creationTicket - Ticket used by TPM2_CertifyCreation() to validate that the creation
    ///                      data was produced by the TPM
    ///     name - The name of the created object
    pub fn CreatePrimary(
        &mut self,
        primaryHandle: TPM_HANDLE,
        inSensitive: TPMS_SENSITIVE_CREATE,
        inPublic: TPMT_PUBLIC,
        outsideInfo: Vec<u8>,
        creationPCR: Vec<TPMS_PCR_SELECTION>,
    ) -> Result<CreatePrimaryResponse, TpmError> {
        // Create request structure
        let req = TPM2_CreatePrimary_REQUEST {
            primaryHandle,
            inSensitive,
            inPublic,
            outsideInfo,
            creationPCR,
        };

        // Send command and process response
        let mut resp = CreatePrimaryResponse::default();
        self.dispatch(req, &mut resp)?;
        Ok(resp)
    }

    /// This command enables and disables use of a hierarchy and its associated NV storage. The
    /// command allows phEnable, phEnableNV, shEnable, and ehEnable to be changed when the proper
    /// authorization is provided.
    /// authHandle: TPM_RH_ENDORSEMENT, TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// enable: The enable being modified
    ///        TPM_RH_ENDORSEMENT, TPM_RH_OWNER, TPM_RH_PLATFORM, or TPM_RH_PLATFORM_NV
    /// state: YES if the enable should be SET, NO if the enable should be CLEAR
    pub fn HierarchyControl(
        &mut self,
        authHandle: TPM_HANDLE,
        enable: TPM_HANDLE,
        state: u8,
    ) -> Result<(), TpmError> {
        // Create request structure
        let req = TPM2_HierarchyControl_REQUEST {
            authHandle,
            enable,
            state,
        };

        // Send command and process response
        let mut resp = TPMS_EMPTY::default();
        self.dispatch(req, &mut resp)?;
        Ok(())
    }

    /// This command allows setting of the authorization policy for the lockout (lockoutPolicy),
    /// the platform hierarchy (platformPolicy), the storage hierarchy (ownerPolicy), and the
    /// endorsement hierarchy (endorsementPolicy). On TPMs implementing Authenticated Countdown
    /// Timers (ACT), this command may also be used to set the authorization policy for an ACT.
    /// authHandle: TPM_RH_LOCKOUT, TPM_RH_ENDORSEMENT, TPM_RH_OWNER, TPMI_RH_ACT or TPM_RH_PLATFORM+{PP}
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// authPolicy: An authorization policy digest; may be the Empty Buffer
    ///        If hashAlg is TPM_ALG_NULL, then this shall be an Empty Buffer.
    /// hashAlg: The hash algorithm to use for the policy
    ///        If the authPolicy is an Empty Buffer, then this field shall be TPM_ALG_NULL.
    pub fn SetPrimaryPolicy(
        &mut self,
        authHandle: TPM_HANDLE,
        authPolicy: Vec<u8>,
        hashAlg: TPM_ALG_ID,
    ) -> Result<(), TpmError> {
        // Create request structure
        let req = TPM2_SetPrimaryPolicy_REQUEST {
            authHandle,
            authPolicy,
            hashAlg,
        };

        // Send command and process response
        let mut resp = TPMS_EMPTY::default();
        self.dispatch(req, &mut resp)?;
        Ok(())
    }

    /// This replaces the current platform primary seed (PPS) with a value from the RNG and sets
    /// platformPolicy to the default initialization value (the Empty Buffer).
    /// authHandle: TPM_RH_PLATFORM+{PP}
    ///        Auth Index: 1
    ///        Auth Role: USER
    pub fn ChangePPS(
        &mut self,
        authHandle: TPM_HANDLE,
    ) -> Result<(), TpmError> {
        // Create request structure
        let req = TPM2_ChangePPS_REQUEST {
            authHandle,
        };

        // Send command and process response
        let mut resp = TPMS_EMPTY::default();
        self.dispatch(req, &mut resp)?;
        Ok(())
    }

    /// This replaces the current endorsement primary seed (EPS) with a value from the RNG and
    /// sets the Endorsement hierarchy controls to their default initialization values: ehEnable
    /// is SET, endorsementAuth and endorsementPolicy are both set to the Empty Buffer. It will
    /// flush any resident objects (transient or persistent) in the Endorsement hierarchy and not
    /// allow objects in the hierarchy associated with the previous EPS to be loaded.
    /// authHandle: TPM_RH_PLATFORM+{PP}
    ///        Auth Handle: 1
    ///        Auth Role: USER
    pub fn ChangeEPS(
        &mut self,
        authHandle: TPM_HANDLE,
    ) -> Result<(), TpmError> {
        // Create request structure
        let req = TPM2_ChangeEPS_REQUEST {
            authHandle,
        };

        // Send command and process response
        let mut resp = TPMS_EMPTY::default();
        self.dispatch(req, &mut resp)?;
        Ok(())
    }

    /// This command removes all TPM context associated with a specific Owner.
    /// authHandle: TPM_RH_LOCKOUT or TPM_RH_PLATFORM+{PP}
    ///        Auth Handle: 1
    ///        Auth Role: USER
    pub fn Clear(
        &mut self,
        authHandle: TPM_HANDLE,
    ) -> Result<(), TpmError> {
        // Create request structure
        let req = TPM2_Clear_REQUEST {
            authHandle,
        };

        // Send command and process response
        let mut resp = TPMS_EMPTY::default();
        self.dispatch(req, &mut resp)?;
        Ok(())
    }

    /// TPM2_ClearControl() disables and enables the execution of TPM2_Clear().
    /// auth: TPM_RH_LOCKOUT or TPM_RH_PLATFORM+{PP}
    ///        Auth Handle: 1
    ///        Auth Role: USER
    /// disable: YES if the disableOwnerClear flag is to be SET, NO if the flag is to be CLEAR.
    pub fn ClearControl(
        &mut self,
        auth: TPM_HANDLE,
        disable: u8,
    ) -> Result<(), TpmError> {
        // Create request structure
        let req = TPM2_ClearControl_REQUEST {
            auth,
            disable,
        };

        // Send command and process response
        let mut resp = TPMS_EMPTY::default();
        self.dispatch(req, &mut resp)?;
        Ok(())
    }

    /// This command allows the authorization secret for a hierarchy or lockout to be changed
    /// using the current authorization value as the command authorization.
    /// authHandle: TPM_RH_LOCKOUT, TPM_RH_ENDORSEMENT, TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// newAuth: New authorization value
    pub fn HierarchyChangeAuth(
        &mut self,
        authHandle: TPM_HANDLE,
        newAuth: Vec<u8>,
    ) -> Result<(), TpmError> {
        // Create request structure
        let req = TPM2_HierarchyChangeAuth_REQUEST {
            authHandle,
            newAuth,
        };

        // Send command and process response
        let mut resp = TPMS_EMPTY::default();
        self.dispatch(req, &mut resp)?;
        Ok(())
    }

    /// This command cancels the effect of a TPM lockout due to a number of successive
    /// authorization failures. If this command is properly authorized, the lockout counter is set
    /// to zero.
    /// lockHandle: TPM_RH_LOCKOUT
    ///        Auth Index: 1
    ///        Auth Role: USER
    pub fn DictionaryAttackLockReset(
        &mut self,
        lockHandle: TPM_HANDLE,
    ) -> Result<(), TpmError> {
        // Create request structure
        let req = TPM2_DictionaryAttackLockReset_REQUEST {
            lockHandle,
        };

        // Send command and process response
        let mut resp = TPMS_EMPTY::default();
        self.dispatch(req, &mut resp)?;
        Ok(())
    }

    /// This command changes the lockout parameters.
    /// lockHandle: TPM_RH_LOCKOUT
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// newMaxTries: Count of authorization failures before the lockout is imposed
    /// newRecoveryTime: Time in seconds before the authorization failure count is automatically decremented
    ///        A value of zero indicates that DA protection is disabled.
    /// lockoutRecovery: Time in seconds after a lockoutAuth failure before use of lockoutAuth is allowed
    ///        A value of zero indicates that a reboot is required.
    pub fn DictionaryAttackParameters(
        &mut self,
        lockHandle: TPM_HANDLE,
        newMaxTries: u32,
        newRecoveryTime: u32,
        lockoutRecovery: u32,
    ) -> Result<(), TpmError> {
        // Create request structure
        let req = TPM2_DictionaryAttackParameters_REQUEST {
            lockHandle,
            newMaxTries,
            newRecoveryTime,
            lockoutRecovery,
        };

        // Send command and process response
        let mut resp = TPMS_EMPTY::default();
        self.dispatch(req, &mut resp)?;
        Ok(())
    }

    /// This command is used to determine which commands require assertion of Physical Presence
    /// (PP) in addition to platformAuth/platformPolicy.
    /// auth: TPM_RH_PLATFORM+PP
    ///        Auth Index: 1
    ///        Auth Role: USER + Physical Presence
    /// setList: List of commands to be added to those that will require that Physical Presence be
    ///        asserted
    /// clearList: List of commands that will no longer require that Physical Presence be asserted
    pub fn PP_Commands(
        &mut self,
        auth: TPM_HANDLE,
        setList: Vec<TPM_CC>,
        clearList: Vec<TPM_CC>,
    ) -> Result<(), TpmError> {
        // Create request structure
        let req = TPM2_PP_Commands_REQUEST {
            auth,
            setList,
            clearList,
        };

        // Send command and process response
        let mut resp = TPMS_EMPTY::default();
        self.dispatch(req, &mut resp)?;
        Ok(())
    }

    /// This command allows the platform to change the set of algorithms that are used by the TPM.
    /// The algorithmSet setting is a vendor-dependent value.
    /// authHandle: TPM_RH_PLATFORM
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// algorithmSet: A TPM vendor-dependent value indicating the algorithm set selection
    pub fn SetAlgorithmSet(
        &mut self,
        authHandle: TPM_HANDLE,
        algorithmSet: u32,
    ) -> Result<(), TpmError> {
        // Create request structure
        let req = TPM2_SetAlgorithmSet_REQUEST {
            authHandle,
            algorithmSet,
        };

        // Send command and process response
        let mut resp = TPMS_EMPTY::default();
        self.dispatch(req, &mut resp)?;
        Ok(())
    }

    /// This command uses platformPolicy and a TPM Vendor Authorization Key to authorize a Field
    /// Upgrade Manifest.
    /// authorization: TPM_RH_PLATFORM+{PP}
    ///        Auth Index:1
    ///        Auth Role: ADMIN
    /// keyHandle: Handle of a public area that contains the TPM Vendor Authorization Key that
    ///        will be used to validate manifestSignature
    ///        Auth Index: None
    /// fuDigest: Digest of the first block in the field upgrade sequence
    /// manifestSignature: Signature over fuDigest using the key associated with keyHandle (not optional)
    ///        One of: TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA,
    ///        TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TPMT_HA,
    ///        TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE.
    pub fn FieldUpgradeStart(
        &mut self,
        authorization: TPM_HANDLE,
        keyHandle: TPM_HANDLE,
        fuDigest: Vec<u8>,
        manifestSignature: Option<TPMU_SIGNATURE>,
    ) -> Result<(), TpmError> {
        // Create request structure
        let req = TPM2_FieldUpgradeStart_REQUEST {
            authorization,
            keyHandle,
            fuDigest,
            manifestSignature,
        };

        // Send command and process response
        let mut resp = TPMS_EMPTY::default();
        self.dispatch(req, &mut resp)?;
        Ok(())
    }

    /// This command will take the actual field upgrade image to be installed on the TPM. The
    /// exact format of fuData is vendor-specific. This command is only possible following a
    /// successful TPM2_FieldUpgradeStart(). If the TPM has not received a properly authorized
    /// TPM2_FieldUpgradeStart(), then the TPM shall return TPM_RC_FIELDUPGRADE.
    /// fuData: Field upgrade image data
    ///     nextDigest - Tagged digest of the next block
    ///                  TPM_ALG_NULL if field update is complete
    ///     firstDigest - Tagged digest of the first block of the sequence
    pub fn FieldUpgradeData(
        &mut self,
        fuData: Vec<u8>,
    ) -> Result<FieldUpgradeDataResponse, TpmError> {
        // Create request structure
        let req = TPM2_FieldUpgradeData_REQUEST {
            fuData,
        };

        // Send command and process response
        let mut resp = FieldUpgradeDataResponse::default();
        self.dispatch(req, &mut resp)?;
        Ok(resp)
    }

    /// This command is used to read a copy of the current firmware installed in the TPM.
    /// sequenceNumber: The number of previous calls to this command in this sequence
    ///        set to 0 on the first call
    ///     fuData - Field upgrade image data
    pub fn FirmwareRead(
        &mut self,
        sequenceNumber: u32,
    ) -> Result<Vec<u8>, TpmError> {
        // Create request structure
        let req = TPM2_FirmwareRead_REQUEST {
            sequenceNumber,
        };

        // Send command and process response
        let mut resp = FirmwareReadResponse::default();
        self.dispatch(req, &mut resp)?;
        Ok(resp.fuData)
    }

    /// This command saves a session context, object context, or sequence object context outside
    /// the TPM.
    /// saveHandle: Handle of the resource to save
    ///        Auth Index: None
    ///     context - This structure is used in TPM2_ContextLoad() and TPM2_ContextSave(). If the
    ///               values of the TPMS_CONTEXT structure in TPM2_ContextLoad() are not the same
    ///               as the values when the context was saved (TPM2_ContextSave()), then the TPM
    ///               shall not load the context.
    pub fn ContextSave(
        &mut self,
        saveHandle: TPM_HANDLE,
    ) -> Result<TPMS_CONTEXT, TpmError> {
        // Create request structure
        let req = TPM2_ContextSave_REQUEST {
            saveHandle,
        };

        // Send command and process response
        let mut resp = ContextSaveResponse::default();
        self.dispatch(req, &mut resp)?;
        Ok(resp.context)
    }

    /// This command is used to reload a context that has been saved by TPM2_ContextSave().
    /// context: The context blob
    ///     handle - The handle assigned to the resource after it has been successfully loaded
    pub fn ContextLoad(
        &mut self,
        context: TPMS_CONTEXT,
    ) -> Result<TPM_HANDLE, TpmError> {
        // Create request structure
        let req = TPM2_ContextLoad_REQUEST {
            context,
        };

        // Send command and process response
        let mut resp = ContextLoadResponse::default();
        self.dispatch(req, &mut resp)?;
        Ok(resp.handle)
    }

    /// This command causes all context associated with a loaded object, sequence object, or
    /// session to be removed from TPM memory.
    /// flushHandle: The handle of the item to flush
    ///        NOTE This is a use of a handle as a parameter.
    pub fn FlushContext(
        &mut self,
        flushHandle: TPM_HANDLE,
    ) -> Result<(), TpmError> {
        // Create request structure
        let req = TPM2_FlushContext_REQUEST {
            flushHandle,
        };

        // Send command and process response
        let mut resp = TPMS_EMPTY::default();
        self.dispatch(req, &mut resp)?;
        Ok(())
    }

    /// This command allows certain Transient Objects to be made persistent or a persistent object
    /// to be evicted.
    /// auth: TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
    ///        Auth Handle: 1
    ///        Auth Role: USER
    /// objectHandle: The handle of a loaded object
    ///        Auth Index: None
    /// persistentHandle: If objectHandle is a transient object handle, then this is the
    ///        persistent handle for the object
    ///        if objectHandle is a persistent object handle, then it shall be the same value as
    ///        persistentHandle
    pub fn EvictControl(
        &mut self,
        auth: TPM_HANDLE,
        objectHandle: TPM_HANDLE,
        persistentHandle: TPM_HANDLE,
    ) -> Result<(), TpmError> {
        // Create request structure
        let req = TPM2_EvictControl_REQUEST {
            auth,
            objectHandle,
            persistentHandle,
        };

        // Send command and process response
        let mut resp = TPMS_EMPTY::default();
        self.dispatch(req, &mut resp)?;
        Ok(())
    }

    /// This command reads the current TPMS_TIME_INFO structure that contains the current setting
    /// of Time, Clock, resetCount, and restartCount.
    ///     currentTime - This structure is used in, e.g., the TPM2_GetTime() attestation and
    ///                   TPM2_ReadClock().
    pub fn ReadClock(
        &mut self,
    ) -> Result<TPMS_TIME_INFO, TpmError> {
        // Create request structure
        let req = TPM2_ReadClock_REQUEST::default();

        // Send command and process response
        let mut resp = ReadClockResponse::default();
        self.dispatch(req, &mut resp)?;
        Ok(resp.currentTime)
    }

    /// This command is used to advance the value of the TPMs Clock. The command will fail if
    /// newTime is less than the current value of Clock or if the new time is greater than
    /// FFFF00000000000016. If both of these checks succeed, Clock is set to newTime. If either of
    /// these checks fails, the TPM shall return TPM_RC_VALUE and make no change to Clock.
    /// auth: TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
    ///        Auth Handle: 1
    ///        Auth Role: USER
    /// newTime: New Clock setting in milliseconds
    pub fn ClockSet(
        &mut self,
        auth: TPM_HANDLE,
        newTime: u64,
    ) -> Result<(), TpmError> {
        // Create request structure
        let req = TPM2_ClockSet_REQUEST {
            auth,
            newTime,
        };

        // Send command and process response
        let mut resp = TPMS_EMPTY::default();
        self.dispatch(req, &mut resp)?;
        Ok(())
    }

    /// This command adjusts the rate of advance of Clock and Time to provide a better
    /// approximation to real time.
    /// auth: TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
    ///        Auth Handle: 1
    ///        Auth Role: USER
    /// rateAdjust: Adjustment to current Clock update rate
    pub fn ClockRateAdjust(
        &mut self,
        auth: TPM_HANDLE,
        rateAdjust: TPM_CLOCK_ADJUST,
    ) -> Result<(), TpmError> {
        // Create request structure
        let req = TPM2_ClockRateAdjust_REQUEST {
            auth,
            rateAdjust,
        };

        // Send command and process response
        let mut resp = TPMS_EMPTY::default();
        self.dispatch(req, &mut resp)?;
        Ok(())
    }

    /// This command returns various information regarding the TPM and its current state.
    /// capability: Group selection; determines the format of the response
    /// property: Further definition of information
    /// propertyCount: Number of properties of the indicated type to return
    ///     moreData - Flag to indicate if there are more values of this type
    ///     capabilityData - The capability data
    pub fn GetCapability(
        &mut self,
        capability: TPM_CAP,
        property: u32,
        propertyCount: u32,
    ) -> Result<GetCapabilityResponse, TpmError> {
        // Create request structure
        let req = TPM2_GetCapability_REQUEST {
            capability,
            property,
            propertyCount,
        };

        // Send command and process response
        let mut resp = GetCapabilityResponse::default();
        self.dispatch(req, &mut resp)?;
        Ok(resp)
    }

    /// This command is used to check to see if specific combinations of algorithm parameters are supported.
    /// parameters: Algorithm parameters to be validated
    ///        One of: TPMS_KEYEDHASH_PARMS, TPMS_SYMCIPHER_PARMS, TPMS_RSA_PARMS, TPMS_ECC_PARMS,
    ///        TPMS_ASYM_PARMS.
    pub fn TestParms(
        &mut self,
        parameters: Option<TPMU_PUBLIC_PARMS>,
    ) -> Result<(), TpmError> {
        // Create request structure
        let req = TPM2_TestParms_REQUEST {
            parameters,
        };

        // Send command and process response
        let mut resp = TPMS_EMPTY::default();
        self.dispatch(req, &mut resp)?;
        Ok(())
    }

    /// This command defines the attributes of an NV Index and causes the TPM to reserve space to
    /// hold the data associated with the NV Index. If a definition already exists at the NV
    /// Index, the TPM will return TPM_RC_NV_DEFINED.
    /// authHandle: TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// auth: The authorization value
    /// publicInfo: The public parameters of the NV area
    pub fn NV_DefineSpace(
        &mut self,
        authHandle: TPM_HANDLE,
        auth: Vec<u8>,
        publicInfo: TPMS_NV_PUBLIC,
    ) -> Result<(), TpmError> {
        // Create request structure
        let req = TPM2_NV_DefineSpace_REQUEST {
            authHandle,
            auth,
            publicInfo,
        };

        // Send command and process response
        let mut resp = TPMS_EMPTY::default();
        self.dispatch(req, &mut resp)?;
        Ok(())
    }

    /// This command removes an Index from the TPM.
    /// authHandle: TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// nvIndex: The NV Index to remove from NV space
    ///        Auth Index: None
    pub fn NV_UndefineSpace(
        &mut self,
        authHandle: TPM_HANDLE,
        nvIndex: TPM_HANDLE,
    ) -> Result<(), TpmError> {
        // Create request structure
        let req = TPM2_NV_UndefineSpace_REQUEST {
            authHandle,
            nvIndex,
        };

        // Send command and process response
        let mut resp = TPMS_EMPTY::default();
        self.dispatch(req, &mut resp)?;
        Ok(())
    }

    /// This command allows removal of a platform-created NV Index that has TPMA_NV_POLICY_DELETE SET.
    /// nvIndex: Index to be deleted
    ///        Auth Index: 1
    ///        Auth Role: ADMIN
    /// platform: TPM_RH_PLATFORM + {PP}
    ///        Auth Index: 2
    ///        Auth Role: USER
    pub fn NV_UndefineSpaceSpecial(
        &mut self,
        nvIndex: TPM_HANDLE,
        platform: TPM_HANDLE,
    ) -> Result<(), TpmError> {
        // Create request structure
        let req = TPM2_NV_UndefineSpaceSpecial_REQUEST {
            nvIndex,
            platform,
        };

        // Send command and process response
        let mut resp = TPMS_EMPTY::default();
        self.dispatch(req, &mut resp)?;
        Ok(())
    }

    /// This command is used to read the public area and Name of an NV Index. The public area of
    /// an Index is not privacy-sensitive and no authorization is required to read this data.
    /// nvIndex: The NV Index
    ///        Auth Index: None
    ///     nvPublic - The public area of the NV Index
    ///     nvName - The Name of the nvIndex
    pub fn NV_ReadPublic(
        &mut self,
        nvIndex: TPM_HANDLE,
    ) -> Result<NV_ReadPublicResponse, TpmError> {
        // Create request structure
        let req = TPM2_NV_ReadPublic_REQUEST {
            nvIndex,
        };

        // Send command and process response
        let mut resp = NV_ReadPublicResponse::default();
        self.dispatch(req, &mut resp)?;
        Ok(resp)
    }

    /// This command writes a value to an area in NV memory that was previously defined by
    /// TPM2_NV_DefineSpace().
    /// authHandle: Handle indicating the source of the authorization value
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// nvIndex: The NV Index of the area to write
    ///        Auth Index: None
    /// data: The data to write
    /// offset: The octet offset into the NV Area
    pub fn NV_Write(
        &mut self,
        authHandle: TPM_HANDLE,
        nvIndex: TPM_HANDLE,
        data: Vec<u8>,
        offset: u16,
    ) -> Result<(), TpmError> {
        // Create request structure
        let req = TPM2_NV_Write_REQUEST {
            authHandle,
            nvIndex,
            data,
            offset,
        };

        // Send command and process response
        let mut resp = TPMS_EMPTY::default();
        self.dispatch(req, &mut resp)?;
        Ok(())
    }

    /// This command is used to increment the value in an NV Index that has the TPM_NT_COUNTER
    /// attribute. The data value of the NV Index is incremented by one.
    /// authHandle: Handle indicating the source of the authorization value
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// nvIndex: The NV Index to increment
    ///        Auth Index: None
    pub fn NV_Increment(
        &mut self,
        authHandle: TPM_HANDLE,
        nvIndex: TPM_HANDLE,
    ) -> Result<(), TpmError> {
        // Create request structure
        let req = TPM2_NV_Increment_REQUEST {
            authHandle,
            nvIndex,
        };

        // Send command and process response
        let mut resp = TPMS_EMPTY::default();
        self.dispatch(req, &mut resp)?;
        Ok(())
    }

    /// This command extends a value to an area in NV memory that was previously defined by
    /// TPM2_NV_DefineSpace.
    /// authHandle: Handle indicating the source of the authorization value
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// nvIndex: The NV Index to extend
    ///        Auth Index: None
    /// data: The data to extend
    pub fn NV_Extend(
        &mut self,
        authHandle: TPM_HANDLE,
        nvIndex: TPM_HANDLE,
        data: Vec<u8>,
    ) -> Result<(), TpmError> {
        // Create request structure
        let req = TPM2_NV_Extend_REQUEST {
            authHandle,
            nvIndex,
            data,
        };

        // Send command and process response
        let mut resp = TPMS_EMPTY::default();
        self.dispatch(req, &mut resp)?;
        Ok(())
    }

    /// This command is used to SET bits in an NV Index that was created as a bit field. Any
    /// number of bits from 0 to 64 may be SET. The contents of bits are ORed with the current
    /// contents of the NV Index.
    /// authHandle: Handle indicating the source of the authorization value
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// nvIndex: NV Index of the area in which the bit is to be set
    ///        Auth Index: None
    /// bits: The data to OR with the current contents
    pub fn NV_SetBits(
        &mut self,
        authHandle: TPM_HANDLE,
        nvIndex: TPM_HANDLE,
        bits: u64,
    ) -> Result<(), TpmError> {
        // Create request structure
        let req = TPM2_NV_SetBits_REQUEST {
            authHandle,
            nvIndex,
            bits,
        };

        // Send command and process response
        let mut resp = TPMS_EMPTY::default();
        self.dispatch(req, &mut resp)?;
        Ok(())
    }

    /// If the TPMA_NV_WRITEDEFINE or TPMA_NV_WRITE_STCLEAR attributes of an NV location are SET,
    /// then this command may be used to inhibit further writes of the NV Index.
    /// authHandle: Handle indicating the source of the authorization value
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// nvIndex: The NV Index of the area to lock
    ///        Auth Index: None
    pub fn NV_WriteLock(
        &mut self,
        authHandle: TPM_HANDLE,
        nvIndex: TPM_HANDLE,
    ) -> Result<(), TpmError> {
        // Create request structure
        let req = TPM2_NV_WriteLock_REQUEST {
            authHandle,
            nvIndex,
        };

        // Send command and process response
        let mut resp = TPMS_EMPTY::default();
        self.dispatch(req, &mut resp)?;
        Ok(())
    }

    /// The command will SET TPMA_NV_WRITELOCKED for all indexes that have their
    /// TPMA_NV_GLOBALLOCK attribute SET.
    /// authHandle: TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
    ///        Auth Index: 1
    ///        Auth Role: USER
    pub fn NV_GlobalWriteLock(
        &mut self,
        authHandle: TPM_HANDLE,
    ) -> Result<(), TpmError> {
        // Create request structure
        let req = TPM2_NV_GlobalWriteLock_REQUEST {
            authHandle,
        };

        // Send command and process response
        let mut resp = TPMS_EMPTY::default();
        self.dispatch(req, &mut resp)?;
        Ok(())
    }

    /// This command reads a value from an area in NV memory previously defined by TPM2_NV_DefineSpace().
    /// authHandle: The handle indicating the source of the authorization value
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// nvIndex: The NV Index to be read
    ///        Auth Index: None
    /// size: Number of octets to read
    /// offset: Octet offset into the NV area
    ///        This value shall be less than or equal to the size of the nvIndex data.
    ///     data - The data read
    pub fn NV_Read(
        &mut self,
        authHandle: TPM_HANDLE,
        nvIndex: TPM_HANDLE,
        size: u16,
        offset: u16,
    ) -> Result<Vec<u8>, TpmError> {
        // Create request structure
        let req = TPM2_NV_Read_REQUEST {
            authHandle,
            nvIndex,
            size,
            offset,
        };

        // Send command and process response
        let mut resp = NV_ReadResponse::default();
        self.dispatch(req, &mut resp)?;
        Ok(resp.data)
    }

    /// If TPMA_NV_READ_STCLEAR is SET in an Index, then this command may be used to prevent
    /// further reads of the NV Index until the next TPM2_Startup (TPM_SU_CLEAR).
    /// authHandle: The handle indicating the source of the authorization value
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// nvIndex: The NV Index to be locked
    ///        Auth Index: None
    pub fn NV_ReadLock(
        &mut self,
        authHandle: TPM_HANDLE,
        nvIndex: TPM_HANDLE,
    ) -> Result<(), TpmError> {
        // Create request structure
        let req = TPM2_NV_ReadLock_REQUEST {
            authHandle,
            nvIndex,
        };

        // Send command and process response
        let mut resp = TPMS_EMPTY::default();
        self.dispatch(req, &mut resp)?;
        Ok(())
    }

    /// This command allows the authorization secret for an NV Index to be changed.
    /// nvIndex: Handle of the entity
    ///        Auth Index: 1
    ///        Auth Role: ADMIN
    /// newAuth: New authorization value
    pub fn NV_ChangeAuth(
        &mut self,
        nvIndex: TPM_HANDLE,
        newAuth: Vec<u8>,
    ) -> Result<(), TpmError> {
        // Create request structure
        let req = TPM2_NV_ChangeAuth_REQUEST {
            nvIndex,
            newAuth,
        };

        // Send command and process response
        let mut resp = TPMS_EMPTY::default();
        self.dispatch(req, &mut resp)?;
        Ok(())
    }

    /// The purpose of this command is to certify the contents of an NV Index or portion of an NV Index.
    /// signHandle: Handle of the key used to sign the attestation structure
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// authHandle: Handle indicating the source of the authorization value for the NV Index
    ///        Auth Index: 2
    ///        Auth Role: USER
    /// nvIndex: Index for the area to be certified
    ///        Auth Index: None
    /// qualifyingData: User-provided qualifying data
    /// inScheme: Signing scheme to use if the scheme for signHandle is TPM_ALG_NULL
    ///        One of: TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA,
    ///        TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR,
    ///        TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME.
    /// size: Number of octets to certify
    /// offset: Octet offset into the NV area
    ///        This value shall be less than or equal to the size of the nvIndex data.
    ///     certifyInfo - The structure that was signed
    ///     signature - The asymmetric signature over certifyInfo using the key referenced by signHandle
    pub fn NV_Certify(
        &mut self,
        signHandle: TPM_HANDLE,
        authHandle: TPM_HANDLE,
        nvIndex: TPM_HANDLE,
        qualifyingData: Vec<u8>,
        inScheme: Option<TPMU_SIG_SCHEME>,
        size: u16,
        offset: u16,
    ) -> Result<NV_CertifyResponse, TpmError> {
        // Create request structure
        let req = TPM2_NV_Certify_REQUEST {
            signHandle,
            authHandle,
            nvIndex,
            qualifyingData,
            inScheme,
            size,
            offset,
        };

        // Send command and process response
        let mut resp = NV_CertifyResponse::default();
        self.dispatch(req, &mut resp)?;
        Ok(resp)
    }

    /// The purpose of this command is to obtain information about an Attached Component
    /// referenced by an AC handle.
    /// ac: Handle indicating the Attached Component
    ///        Auth Index: None
    /// capability: Starting info type
    /// count: Maximum number of values to return
    ///     moreData - Flag to indicate whether there are more values
    ///     capabilitiesData - List of capabilities
    pub fn AC_GetCapability(
        &mut self,
        ac: TPM_HANDLE,
        capability: TPM_AT,
        count: u32,
    ) -> Result<AC_GetCapabilityResponse, TpmError> {
        // Create request structure
        let req = TPM2_AC_GetCapability_REQUEST {
            ac,
            capability,
            count,
        };

        // Send command and process response
        let mut resp = AC_GetCapabilityResponse::default();
        self.dispatch(req, &mut resp)?;
        Ok(resp)
    }

    /// The purpose of this command is to send (copy) a loaded object from the TPM to an Attached Component.
    /// sendObject: Handle of the object being sent to ac
    ///        Auth Index: 1
    ///        Auth Role: DUP
    /// authHandle: The handle indicating the source of the authorization value
    ///        Auth Index: 2
    ///        Auth Role: USER
    /// ac: Handle indicating the Attached Component to which the object will be sent
    ///        Auth Index: None
    /// acDataIn: Optional non sensitive information related to the object
    ///     acDataOut - May include AC specific data or information about an error.
    pub fn AC_Send(
        &mut self,
        sendObject: TPM_HANDLE,
        authHandle: TPM_HANDLE,
        ac: TPM_HANDLE,
        acDataIn: Vec<u8>,
    ) -> Result<TPMS_AC_OUTPUT, TpmError> {
        // Create request structure
        let req = TPM2_AC_Send_REQUEST {
            sendObject,
            authHandle,
            ac,
            acDataIn,
        };

        // Send command and process response
        let mut resp = AC_SendResponse::default();
        self.dispatch(req, &mut resp)?;
        Ok(resp.acDataOut)
    }

    /// This command allows qualification of the sending (copying) of an Object to an Attached
    /// Component (AC). Qualification includes selection of the receiving AC and the method of
    /// authentication for the AC, and, in certain circumstances, the Object to be sent may be specified.
    /// policySession: Handle for the policy session being extended
    ///        Auth Index: None
    /// objectName: The Name of the Object to be sent
    /// authHandleName: The Name associated with authHandle used in the TPM2_AC_Send() command
    /// acName: The Name of the Attached Component to which the Object will be sent
    /// includeObject: If SET, objectName will be included in the value in policySessionpolicyDigest
    pub fn Policy_AC_SendSelect(
        &mut self,
        policySession: TPM_HANDLE,
        objectName: Vec<u8>,
        authHandleName: Vec<u8>,
        acName: Vec<u8>,
        includeObject: u8,
    ) -> Result<(), TpmError> {
        // Create request structure
        let req = TPM2_Policy_AC_SendSelect_REQUEST {
            policySession,
            objectName,
            authHandleName,
            acName,
            includeObject,
        };

        // Send command and process response
        let mut resp = TPMS_EMPTY::default();
        self.dispatch(req, &mut resp)?;
        Ok(())
    }

    /// This command is used to set the time remaining before an Authenticated Countdown Timer
    /// (ACT) expires.
    /// actHandle: Handle of the selected ACT
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// startTimeout: The start timeout value for the ACT in seconds
    pub fn ACT_SetTimeout(
        &mut self,
        actHandle: TPM_HANDLE,
        startTimeout: u32,
    ) -> Result<(), TpmError> {
        // Create request structure
        let req = TPM2_ACT_SetTimeout_REQUEST {
            actHandle,
            startTimeout,
        };

        // Send command and process response
        let mut resp = TPMS_EMPTY::default();
        self.dispatch(req, &mut resp)?;
        Ok(())
    }

    /// This is a placeholder to allow testing of the dispatch code.
    /// inputData: Dummy data
    ///     outputData - Dummy data
    pub fn Vendor_TCG_Test(
        &mut self,
        inputData: Vec<u8>,
    ) -> Result<Vec<u8>, TpmError> {
        // Create request structure
        let req = TPM2_Vendor_TCG_Test_REQUEST {
            inputData,
        };

        // Send command and process response
        let mut resp = Vendor_TCG_TestResponse::default();
        self.dispatch(req, &mut resp)?;
        Ok(resp.outputData)
    }

    /// Get async command methods
    pub fn async_methods(&mut self) -> AsyncMethods {
    AsyncMethods { tpm: self }
    }

}

/// Asynchronous TPM2 command methods
pub struct AsyncMethods<'a> {
tpm: &'a mut Tpm2,
}

impl<'a> AsyncMethods<'a> {
    /// TPM2_Startup() is always preceded by _TPM_Init, which is the physical indication that TPM
    /// initialization is necessary because of a system-wide reset. TPM2_Startup() is only valid
    /// after _TPM_Init. Additional TPM2_Startup() commands are not allowed after it has completed
    /// successfully. If a TPM requires TPM2_Startup() and another command is received, or if the
    /// TPM receives TPM2_Startup() when it is not required, the TPM shall return TPM_RC_INITIALIZE.
    /// startupType: TPM_SU_CLEAR or TPM_SU_STATE
    pub fn Startup_async(
        &mut self,
        startupType: TPM_SU,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_Startup_REQUEST {
            startupType,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command is used to prepare the TPM for a power cycle. The shutdownType parameter
    /// indicates how the subsequent TPM2_Startup() will be processed.
    /// shutdownType: TPM_SU_CLEAR or TPM_SU_STATE
    pub fn Shutdown_async(
        &mut self,
        shutdownType: TPM_SU,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_Shutdown_REQUEST {
            shutdownType,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command causes the TPM to perform a test of its capabilities. If the fullTest is YES,
    /// the TPM will test all functions. If fullTest = NO, the TPM will only test those functions
    /// that have not previously been tested.
    /// fullTest: YES if full test to be performed
    ///        NO if only test of untested functions required
    pub fn SelfTest_async(
        &mut self,
        fullTest: u8,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_SelfTest_REQUEST {
            fullTest,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command causes the TPM to perform a test of the selected algorithms.
    /// toTest: List of algorithms that should be tested
    ///     toDoList - List of algorithms that need testing
    pub fn IncrementalSelfTest_async(
        &mut self,
        toTest: Vec<TPM_ALG_ID>,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_IncrementalSelfTest_REQUEST {
            toTest,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command returns manufacturer-specific information regarding the results of a
    /// self-test and an indication of the test status.
    ///     outData - Test result data
    ///               contains manufacturer-specific information
    ///     testResult - TBD
    pub fn GetTestResult_async(
        &mut self,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_GetTestResult_REQUEST::default();
        self.tpm.dispatch_async_command(req)
    }

    /// This command is used to start an authorization session using alternative methods of
    /// establishing the session key (sessionKey). The session key is then used to derive values
    /// used for authorization and for encrypting parameters.
    /// tpmKey: Handle of a loaded decrypt key used to encrypt salt
    ///        may be TPM_RH_NULL
    ///        Auth Index: None
    /// bind: Entity providing the authValue
    ///        may be TPM_RH_NULL
    ///        Auth Index: None
    /// nonceCaller: Initial nonceCaller, sets nonceTPM size for the session
    ///        shall be at least 16 octets
    /// encryptedSalt: Value encrypted according to the type of tpmKey
    ///        If tpmKey is TPM_RH_NULL, this shall be the Empty Buffer.
    /// sessionType: Indicates the type of the session; simple HMAC or policy (including a trial policy)
    /// symmetric: The algorithm and key size for parameter encryption
    ///        may select TPM_ALG_NULL
    /// authHash: Hash algorithm to use for the session
    ///        Shall be a hash algorithm supported by the TPM and not TPM_ALG_NULL
    ///     handle - Handle for the newly created session
    ///     nonceTPM - The initial nonce from the TPM, used in the computation of the sessionKey
    pub fn StartAuthSession_async(
        &mut self,
        tpmKey: TPM_HANDLE,
        bind: TPM_HANDLE,
        nonceCaller: Vec<u8>,
        encryptedSalt: Vec<u8>,
        sessionType: TPM_SE,
        symmetric: TPMT_SYM_DEF,
        authHash: TPM_ALG_ID,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_StartAuthSession_REQUEST {
            tpmKey,
            bind,
            nonceCaller,
            encryptedSalt,
            sessionType,
            symmetric,
            authHash,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command allows a policy authorization session to be returned to its initial state.
    /// This command is used after the TPM returns TPM_RC_PCR_CHANGED. That response code
    /// indicates that a policy will fail because the PCR have changed after TPM2_PolicyPCR() was
    /// executed. Restarting the session allows the authorizations to be replayed because the
    /// session restarts with the same nonceTPM. If the PCR are valid for the policy, the policy
    /// may then succeed.
    /// sessionHandle: The handle for the policy session
    pub fn PolicyRestart_async(
        &mut self,
        sessionHandle: TPM_HANDLE,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_PolicyRestart_REQUEST {
            sessionHandle,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command is used to create an object that can be loaded into a TPM using TPM2_Load().
    /// If the command completes successfully, the TPM will create the new object and return the
    /// objects creation data (creationData), its public area (outPublic), and its encrypted
    /// sensitive area (outPrivate). Preservation of the returned data is the responsibility of
    /// the caller. The object will need to be loaded (TPM2_Load()) before it may be used. The
    /// only difference between the inPublic TPMT_PUBLIC template and the outPublic TPMT_PUBLIC
    /// object is in the unique field.
    /// parentHandle: Handle of parent for new object
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// inSensitive: The sensitive data
    /// inPublic: The public template
    /// outsideInfo: Data that will be included in the creation data for this object to provide
    ///        permanent, verifiable linkage between this object and some object owner data
    /// creationPCR: PCR that will be used in creation data
    ///     outPrivate - The private portion of the object
    ///     outPublic - The public portion of the created object
    ///     creationData - Contains a TPMS_CREATION_DATA
    ///     creationHash - Digest of creationData using nameAlg of outPublic
    ///     creationTicket - Ticket used by TPM2_CertifyCreation() to validate that the creation
    ///                      data was produced by the TPM
    pub fn Create_async(
        &mut self,
        parentHandle: TPM_HANDLE,
        inSensitive: TPMS_SENSITIVE_CREATE,
        inPublic: TPMT_PUBLIC,
        outsideInfo: Vec<u8>,
        creationPCR: Vec<TPMS_PCR_SELECTION>,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_Create_REQUEST {
            parentHandle,
            inSensitive,
            inPublic,
            outsideInfo,
            creationPCR,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command is used to load objects into the TPM. This command is used when both a
    /// TPM2B_PUBLIC and TPM2B_PRIVATE are to be loaded. If only a TPM2B_PUBLIC is to be loaded,
    /// the TPM2_LoadExternal command is used.
    /// parentHandle: TPM handle of parent key; shall not be a reserved handle
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// inPrivate: The private portion of the object
    /// inPublic: The public portion of the object
    ///     handle - Handle of type TPM_HT_TRANSIENT for the loaded object
    ///     name - Name of the loaded object
    pub fn Load_async(
        &mut self,
        parentHandle: TPM_HANDLE,
        inPrivate: TPM2B_PRIVATE,
        inPublic: TPMT_PUBLIC,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_Load_REQUEST {
            parentHandle,
            inPrivate,
            inPublic,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command is used to load an object that is not a Protected Object into the TPM. The
    /// command allows loading of a public area or both a public and sensitive area.
    /// inPrivate: The sensitive portion of the object (optional)
    /// inPublic: The public portion of the object
    /// hierarchy: Hierarchy with which the object area is associated
    ///     handle - Handle of type TPM_HT_TRANSIENT for the loaded object
    ///     name - Name of the loaded object
    pub fn LoadExternal_async(
        &mut self,
        inPrivate: TPMT_SENSITIVE,
        inPublic: TPMT_PUBLIC,
        hierarchy: TPM_HANDLE,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_LoadExternal_REQUEST {
            inPrivate,
            inPublic,
            hierarchy,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command allows access to the public area of a loaded object.
    /// objectHandle: TPM handle of an object
    ///        Auth Index: None
    ///     outPublic - Structure containing the public area of an object
    ///     name - Name of the object
    ///     qualifiedName - The Qualified Name of the object
    pub fn ReadPublic_async(
        &mut self,
        objectHandle: TPM_HANDLE,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_ReadPublic_REQUEST {
            objectHandle,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command enables the association of a credential with an object in a way that ensures
    /// that the TPM has validated the parameters of the credentialed object.
    /// activateHandle: Handle of the object associated with certificate in credentialBlob
    ///        Auth Index: 1
    ///        Auth Role: ADMIN
    /// keyHandle: Loaded key used to decrypt the TPMS_SENSITIVE in credentialBlob
    ///        Auth Index: 2
    ///        Auth Role: USER
    /// credentialBlob: The credential
    /// secret: KeyHandle algorithm-dependent encrypted seed that protects credentialBlob
    ///     certInfo - The decrypted certificate information
    ///                the data should be no larger than the size of the digest of the nameAlg
    ///                associated with keyHandle
    pub fn ActivateCredential_async(
        &mut self,
        activateHandle: TPM_HANDLE,
        keyHandle: TPM_HANDLE,
        credentialBlob: TPMS_ID_OBJECT,
        secret: Vec<u8>,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_ActivateCredential_REQUEST {
            activateHandle,
            keyHandle,
            credentialBlob,
            secret,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command allows the TPM to perform the actions required of a Certificate Authority
    /// (CA) in creating a TPM2B_ID_OBJECT containing an activation credential.
    /// handle: Loaded public area, used to encrypt the sensitive area containing the credential key
    ///        Auth Index: None
    /// credential: The credential information
    /// objectName: Name of the object to which the credential applies
    ///     credentialBlob - The credential
    ///     secret - Handle algorithm-dependent data that wraps the key that encrypts credentialBlob
    pub fn MakeCredential_async(
        &mut self,
        handle: TPM_HANDLE,
        credential: Vec<u8>,
        objectName: Vec<u8>,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_MakeCredential_REQUEST {
            handle,
            credential,
            objectName,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command returns the data in a loaded Sealed Data Object.
    /// itemHandle: Handle of a loaded data object
    ///        Auth Index: 1
    ///        Auth Role: USER
    ///     outData - Unsealed data
    ///               Size of outData is limited to be no more than 128 octets.
    pub fn Unseal_async(
        &mut self,
        itemHandle: TPM_HANDLE,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_Unseal_REQUEST {
            itemHandle,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command is used to change the authorization secret for a TPM-resident object.
    /// objectHandle: Handle of the object
    ///        Auth Index: 1
    ///        Auth Role: ADMIN
    /// parentHandle: Handle of the parent
    ///        Auth Index: None
    /// newAuth: New authorization value
    ///     outPrivate - Private area containing the new authorization value
    pub fn ObjectChangeAuth_async(
        &mut self,
        objectHandle: TPM_HANDLE,
        parentHandle: TPM_HANDLE,
        newAuth: Vec<u8>,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_ObjectChangeAuth_REQUEST {
            objectHandle,
            parentHandle,
            newAuth,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command creates an object and loads it in the TPM. This command allows creation of
    /// any type of object (Primary, Ordinary, or Derived) depending on the type of parentHandle.
    /// If parentHandle references a Primary Seed, then a Primary Object is created; if
    /// parentHandle references a Storage Parent, then an Ordinary Object is created; and if
    /// parentHandle references a Derivation Parent, then a Derived Object is generated.
    /// parentHandle: Handle of a transient storage key, a persistent storage key,
    ///        TPM_RH_ENDORSEMENT, TPM_RH_OWNER, TPM_RH_PLATFORM+{PP}, or TPM_RH_NULL
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// inSensitive: The sensitive data, see TPM 2.0 Part 1 Sensitive Values
    /// inPublic: The public template
    ///     handle - Handle of type TPM_HT_TRANSIENT for created object
    ///     outPrivate - The sensitive area of the object (optional)
    ///     outPublic - The public portion of the created object
    ///     name - The name of the created object
    pub fn CreateLoaded_async(
        &mut self,
        parentHandle: TPM_HANDLE,
        inSensitive: TPMS_SENSITIVE_CREATE,
        inPublic: Vec<u8>,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_CreateLoaded_REQUEST {
            parentHandle,
            inSensitive,
            inPublic,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command duplicates a loaded object so that it may be used in a different hierarchy.
    /// The new parent key for the duplicate may be on the same or different TPM or TPM_RH_NULL.
    /// Only the public area of newParentHandle is required to be loaded.
    /// objectHandle: Loaded object to duplicate
    ///        Auth Index: 1
    ///        Auth Role: DUP
    /// newParentHandle: Shall reference the public area of an asymmetric key
    ///        Auth Index: None
    /// encryptionKeyIn: Optional symmetric encryption key
    ///        The size for this key is set to zero when the TPM is to generate the key. This
    ///        parameter may be encrypted.
    /// symmetricAlg: Definition for the symmetric algorithm to be used for the inner wrapper
    ///        may be TPM_ALG_NULL if no inner wrapper is applied
    ///     encryptionKeyOut - If the caller provided an encryption key or if symmetricAlg was
    ///                        TPM_ALG_NULL, then this will be the Empty Buffer; otherwise, it
    ///                        shall contain the TPM-generated, symmetric encryption key for the
    ///                        inner wrapper.
    ///     duplicate - Private area that may be encrypted by encryptionKeyIn; and may be doubly encrypted
    ///     outSymSeed - Seed protected by the asymmetric algorithms of new parent (NP)
    pub fn Duplicate_async(
        &mut self,
        objectHandle: TPM_HANDLE,
        newParentHandle: TPM_HANDLE,
        encryptionKeyIn: Vec<u8>,
        symmetricAlg: TPMT_SYM_DEF_OBJECT,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_Duplicate_REQUEST {
            objectHandle,
            newParentHandle,
            encryptionKeyIn,
            symmetricAlg,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command allows the TPM to serve in the role as a Duplication Authority. If proper
    /// authorization for use of the oldParent is provided, then an HMAC key and a symmetric key
    /// are recovered from inSymSeed and used to integrity check and decrypt inDuplicate. A new
    /// protection seed value is generated according to the methods appropriate for newParent and
    /// the blob is re-encrypted and a new integrity value is computed. The re-encrypted blob is
    /// returned in outDuplicate and the symmetric key returned in outSymKey.
    /// oldParent: Parent of object
    ///        Auth Index: 1
    ///        Auth Role: User
    /// newParent: New parent of the object
    ///        Auth Index: None
    /// inDuplicate: An object encrypted using symmetric key derived from inSymSeed
    /// name: The Name of the object being rewrapped
    /// inSymSeed: The seed for the symmetric key and HMAC key
    ///        needs oldParent private key to recover the seed and generate the symmetric key
    ///     outDuplicate - An object encrypted using symmetric key derived from outSymSeed
    ///     outSymSeed - Seed for a symmetric key protected by newParent asymmetric key
    pub fn Rewrap_async(
        &mut self,
        oldParent: TPM_HANDLE,
        newParent: TPM_HANDLE,
        inDuplicate: TPM2B_PRIVATE,
        name: Vec<u8>,
        inSymSeed: Vec<u8>,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_Rewrap_REQUEST {
            oldParent,
            newParent,
            inDuplicate,
            name,
            inSymSeed,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command allows an object to be encrypted using the symmetric encryption values of a
    /// Storage Key. After encryption, the object may be loaded and used in the new hierarchy. The
    /// imported object (duplicate) may be singly encrypted, multiply encrypted, or unencrypted.
    /// parentHandle: The handle of the new parent for the object
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// encryptionKey: The optional symmetric encryption key used as the inner wrapper for duplicate
    ///        If symmetricAlg is TPM_ALG_NULL, then this parameter shall be the Empty Buffer.
    /// objectPublic: The public area of the object to be imported
    ///        This is provided so that the integrity value for duplicate and the object
    ///        attributes can be checked.
    ///        NOTE Even if the integrity value of the object is not checked on input, the object
    ///        Name is required to create the integrity value for the imported object.
    /// duplicate: The symmetrically encrypted duplicate object that may contain an inner
    ///        symmetric wrapper
    /// inSymSeed: The seed for the symmetric key and HMAC key
    ///        inSymSeed is encrypted/encoded using the algorithms of newParent.
    /// symmetricAlg: Definition for the symmetric algorithm to use for the inner wrapper
    ///        If this algorithm is TPM_ALG_NULL, no inner wrapper is present and encryptionKey
    ///        shall be the Empty Buffer.
    ///     outPrivate - The sensitive area encrypted with the symmetric key of parentHandle
    pub fn Import_async(
        &mut self,
        parentHandle: TPM_HANDLE,
        encryptionKey: Vec<u8>,
        objectPublic: TPMT_PUBLIC,
        duplicate: TPM2B_PRIVATE,
        inSymSeed: Vec<u8>,
        symmetricAlg: TPMT_SYM_DEF_OBJECT,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_Import_REQUEST {
            parentHandle,
            encryptionKey,
            objectPublic,
            duplicate,
            inSymSeed,
            symmetricAlg,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command performs RSA encryption using the indicated padding scheme according to IETF
    /// RFC 8017. If the scheme of keyHandle is TPM_ALG_NULL, then the caller may use inScheme to
    /// specify the padding scheme. If scheme of keyHandle is not TPM_ALG_NULL, then inScheme
    /// shall either be TPM_ALG_NULL or be the same as scheme (TPM_RC_SCHEME).
    /// keyHandle: Reference to public portion of RSA key to use for encryption
    ///        Auth Index: None
    /// message: Message to be encrypted
    ///        NOTE 1 The data type was chosen because it limits the overall size of the input to
    ///        no greater than the size of the largest RSA public key. This may be larger than
    ///        allowed for keyHandle.
    /// inScheme: The padding scheme to use if scheme associated with keyHandle is TPM_ALG_NULL
    ///        One of: TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA,
    ///        TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA,
    ///        TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES,
    ///        TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME.
    /// label: Optional label L to be associated with the message
    ///        Size of the buffer is zero if no label is present
    ///        NOTE 2 See description of label above.
    ///     outData - Encrypted output
    pub fn RSA_Encrypt_async(
        &mut self,
        keyHandle: TPM_HANDLE,
        message: Vec<u8>,
        inScheme: Option<TPMU_ASYM_SCHEME>,
        label: Vec<u8>,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_RSA_Encrypt_REQUEST {
            keyHandle,
            message,
            inScheme,
            label,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command performs RSA decryption using the indicated padding scheme according to IETF
    /// RFC 8017 ((PKCS#1).
    /// keyHandle: RSA key to use for decryption
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// cipherText: Cipher text to be decrypted
    ///        NOTE An encrypted RSA data block is the size of the public modulus.
    /// inScheme: The padding scheme to use if scheme associated with keyHandle is TPM_ALG_NULL
    ///        One of: TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA,
    ///        TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA,
    ///        TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES,
    ///        TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME.
    /// label: Label whose association with the message is to be verified
    ///     message - Decrypted output
    pub fn RSA_Decrypt_async(
        &mut self,
        keyHandle: TPM_HANDLE,
        cipherText: Vec<u8>,
        inScheme: Option<TPMU_ASYM_SCHEME>,
        label: Vec<u8>,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_RSA_Decrypt_REQUEST {
            keyHandle,
            cipherText,
            inScheme,
            label,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command uses the TPM to generate an ephemeral key pair (de, Qe where Qe [de]G). It
    /// uses the private ephemeral key and a loaded public key (QS) to compute the shared secret
    /// value (P [hde]QS).
    /// keyHandle: Handle of a loaded ECC key public area.
    ///        Auth Index: None
    ///     zPoint - Results of P h[de]Qs
    ///     pubPoint - Generated ephemeral public point (Qe)
    pub fn ECDH_KeyGen_async(
        &mut self,
        keyHandle: TPM_HANDLE,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_ECDH_KeyGen_REQUEST {
            keyHandle,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command uses the TPM to recover the Z value from a public point (QB) and a private
    /// key (ds). It will perform the multiplication of the provided inPoint (QB) with the private
    /// key (ds) and return the coordinates of the resultant point (Z = (xZ , yZ) [hds]QB; where h
    /// is the cofactor of the curve).
    /// keyHandle: Handle of a loaded ECC key
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// inPoint: A public key
    ///     outPoint - X and Y coordinates of the product of the multiplication Z = (xZ , yZ) [hdS]QB
    pub fn ECDH_ZGen_async(
        &mut self,
        keyHandle: TPM_HANDLE,
        inPoint: TPMS_ECC_POINT,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_ECDH_ZGen_REQUEST {
            keyHandle,
            inPoint,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command returns the parameters of an ECC curve identified by its TCG-assigned curveID.
    /// curveID: Parameter set selector
    ///     parameters - ECC parameters for the selected curve
    pub fn ECC_Parameters_async(
        &mut self,
        curveID: TPM_ECC_CURVE,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_ECC_Parameters_REQUEST {
            curveID,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command supports two-phase key exchange protocols. The command is used in combination
    /// with TPM2_EC_Ephemeral(). TPM2_EC_Ephemeral() generates an ephemeral key and returns the
    /// public point of that ephemeral key along with a numeric value that allows the TPM to
    /// regenerate the associated private key.
    /// keyA: Handle of an unrestricted decryption key ECC
    ///        The private key referenced by this handle is used as dS,A
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// inQsB: Other partys static public key (Qs,B = (Xs,B, Ys,B))
    /// inQeB: Other party's ephemeral public key (Qe,B = (Xe,B, Ye,B))
    /// inScheme: The key exchange scheme
    /// counter: Value returned by TPM2_EC_Ephemeral()
    ///     outZ1 - X and Y coordinates of the computed value (scheme dependent)
    ///     outZ2 - X and Y coordinates of the second computed value (scheme dependent)
    pub fn ZGen_2Phase_async(
        &mut self,
        keyA: TPM_HANDLE,
        inQsB: TPMS_ECC_POINT,
        inQeB: TPMS_ECC_POINT,
        inScheme: TPM_ALG_ID,
        counter: u16,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_ZGen_2Phase_REQUEST {
            keyA,
            inQsB,
            inQeB,
            inScheme,
            counter,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command performs ECC encryption as described in Part 1, Annex D.
    /// keyHandle: Reference to public portion of ECC key to use for encryption
    ///        Auth Index: None
    /// plainText: Plaintext to be encrypted
    /// inScheme: The KDF to use if scheme associated with keyHandle is TPM_ALG_NULL
    ///        One of: TPMS_KDF_SCHEME_MGF1, TPMS_KDF_SCHEME_KDF1_SP800_56A, TPMS_KDF_SCHEME_KDF2,
    ///        TPMS_KDF_SCHEME_KDF1_SP800_108, TPMS_SCHEME_HASH, TPMS_NULL_KDF_SCHEME.
    ///     C1 - The public ephemeral key used for ECDH
    ///     C2 - The data block produced by the XOR process
    ///     C3 - The integrity value
    pub fn ECC_Encrypt_async(
        &mut self,
        keyHandle: TPM_HANDLE,
        plainText: Vec<u8>,
        inScheme: Option<TPMU_KDF_SCHEME>,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_ECC_Encrypt_REQUEST {
            keyHandle,
            plainText,
            inScheme,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command performs ECC decryption.
    /// keyHandle: ECC key to use for decryption
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// C1: The public ephemeral key used for ECDH
    /// C2: The data block produced by the XOR process
    /// C3: The integrity value
    /// inScheme: The KDF to use if scheme associated with keyHandle is TPM_ALG_NULL
    ///        One of: TPMS_KDF_SCHEME_MGF1, TPMS_KDF_SCHEME_KDF1_SP800_56A, TPMS_KDF_SCHEME_KDF2,
    ///        TPMS_KDF_SCHEME_KDF1_SP800_108, TPMS_SCHEME_HASH, TPMS_NULL_KDF_SCHEME.
    ///     plainText - Decrypted output
    pub fn ECC_Decrypt_async(
        &mut self,
        keyHandle: TPM_HANDLE,
        C1: TPMS_ECC_POINT,
        C2: Vec<u8>,
        C3: Vec<u8>,
        inScheme: Option<TPMU_KDF_SCHEME>,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_ECC_Decrypt_REQUEST {
            keyHandle,
            C1,
            C2,
            C3,
            inScheme,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// NOTE 1 This command is deprecated, and TPM2_EncryptDecrypt2() is preferred. This should be
    /// reflected in platform-specific specifications.
    /// keyHandle: The symmetric key used for the operation
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// decrypt: If YES, then the operation is decryption; if NO, the operation is encryption
    /// mode: Symmetric encryption/decryption mode
    ///        this field shall match the default mode of the key or be TPM_ALG_NULL.
    /// ivIn: An initial value as required by the algorithm
    /// inData: The data to be encrypted/decrypted
    ///     outData - Encrypted or decrypted output
    ///     ivOut - Chaining value to use for IV in next round
    pub fn EncryptDecrypt_async(
        &mut self,
        keyHandle: TPM_HANDLE,
        decrypt: u8,
        mode: TPM_ALG_ID,
        ivIn: Vec<u8>,
        inData: Vec<u8>,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_EncryptDecrypt_REQUEST {
            keyHandle,
            decrypt,
            mode,
            ivIn,
            inData,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command is identical to TPM2_EncryptDecrypt(), except that the inData parameter is
    /// the first parameter. This permits inData to be parameter encrypted.
    /// keyHandle: The symmetric key used for the operation
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// inData: The data to be encrypted/decrypted
    /// decrypt: If YES, then the operation is decryption; if NO, the operation is encryption
    /// mode: Symmetric mode
    ///        this field shall match the default mode of the key or be TPM_ALG_NULL.
    /// ivIn: An initial value as required by the algorithm
    ///     outData - Encrypted or decrypted output
    ///     ivOut - Chaining value to use for IV in next round
    pub fn EncryptDecrypt2_async(
        &mut self,
        keyHandle: TPM_HANDLE,
        inData: Vec<u8>,
        decrypt: u8,
        mode: TPM_ALG_ID,
        ivIn: Vec<u8>,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_EncryptDecrypt2_REQUEST {
            keyHandle,
            inData,
            decrypt,
            mode,
            ivIn,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command performs a hash operation on a data buffer and returns the results.
    /// data: Data to be hashed
    /// hashAlg: Algorithm for the hash being computed shall not be TPM_ALG_NULL
    /// hierarchy: Hierarchy to use for the ticket (TPM_RH_NULL allowed)
    ///     outHash - Results
    ///     validation - Ticket indicating that the sequence of octets used to compute outDigest
    ///                  did not start with TPM_GENERATED_VALUE
    ///                  will be a NULL ticket if the digest may not be signed with a restricted key
    pub fn Hash_async(
        &mut self,
        data: Vec<u8>,
        hashAlg: TPM_ALG_ID,
        hierarchy: TPM_HANDLE,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_Hash_REQUEST {
            data,
            hashAlg,
            hierarchy,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command performs an HMAC on the supplied data using the indicated hash algorithm.
    /// handle: Handle for the symmetric signing key providing the HMAC key
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// buffer: HMAC data
    /// hashAlg: Algorithm to use for HMAC
    ///     outHMAC - The returned HMAC in a sized buffer
    pub fn HMAC_async(
        &mut self,
        handle: TPM_HANDLE,
        buffer: Vec<u8>,
        hashAlg: TPM_ALG_ID,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_HMAC_REQUEST {
            handle,
            buffer,
            hashAlg,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command performs an HMAC or a block cipher MAC on the supplied data using the
    /// indicated algorithm.
    /// handle: Handle for the symmetric signing key providing the MAC key
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// buffer: MAC data
    /// inScheme: Algorithm to use for MAC
    ///     outMAC - The returned MAC in a sized buffer
    pub fn MAC_async(
        &mut self,
        handle: TPM_HANDLE,
        buffer: Vec<u8>,
        inScheme: TPM_ALG_ID,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_MAC_REQUEST {
            handle,
            buffer,
            inScheme,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command returns the next bytesRequested octets from the random number generator (RNG).
    /// bytesRequested: Number of octets to return
    ///     randomBytes - The random octets
    pub fn GetRandom_async(
        &mut self,
        bytesRequested: u16,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_GetRandom_REQUEST {
            bytesRequested,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command is used to add "additional information" to the RNG state.
    /// inData: Additional information
    pub fn StirRandom_async(
        &mut self,
        inData: Vec<u8>,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_StirRandom_REQUEST {
            inData,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command starts an HMAC sequence. The TPM will create and initialize an HMAC sequence
    /// structure, assign a handle to the sequence, and set the authValue of the sequence object
    /// to the value in auth.
    /// handle: Handle of an HMAC key
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// auth: Authorization value for subsequent use of the sequence
    /// hashAlg: The hash algorithm to use for the HMAC
    ///     handle - A handle to reference the sequence
    pub fn HMAC_Start_async(
        &mut self,
        handle: TPM_HANDLE,
        auth: Vec<u8>,
        hashAlg: TPM_ALG_ID,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_HMAC_Start_REQUEST {
            handle,
            auth,
            hashAlg,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command starts a MAC sequence. The TPM will create and initialize a MAC sequence
    /// structure, assign a handle to the sequence, and set the authValue of the sequence object
    /// to the value in auth.
    /// handle: Handle of a MAC key
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// auth: Authorization value for subsequent use of the sequence
    /// inScheme: The algorithm to use for the MAC
    ///     handle - A handle to reference the sequence
    pub fn MAC_Start_async(
        &mut self,
        handle: TPM_HANDLE,
        auth: Vec<u8>,
        inScheme: TPM_ALG_ID,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_MAC_Start_REQUEST {
            handle,
            auth,
            inScheme,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command starts a hash or an Event Sequence. If hashAlg is an implemented hash, then a
    /// hash sequence is started. If hashAlg is TPM_ALG_NULL, then an Event Sequence is started.
    /// If hashAlg is neither an implemented algorithm nor TPM_ALG_NULL, then the TPM shall return
    /// TPM_RC_HASH.
    /// auth: Authorization value for subsequent use of the sequence
    /// hashAlg: The hash algorithm to use for the hash sequence
    ///        An Event Sequence starts if this is TPM_ALG_NULL.
    ///     handle - A handle to reference the sequence
    pub fn HashSequenceStart_async(
        &mut self,
        auth: Vec<u8>,
        hashAlg: TPM_ALG_ID,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_HashSequenceStart_REQUEST {
            auth,
            hashAlg,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command is used to add data to a hash or HMAC sequence. The amount of data in buffer
    /// may be any size up to the limits of the TPM.
    /// sequenceHandle: Handle for the sequence object
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// buffer: Data to be added to hash
    pub fn SequenceUpdate_async(
        &mut self,
        sequenceHandle: TPM_HANDLE,
        buffer: Vec<u8>,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_SequenceUpdate_REQUEST {
            sequenceHandle,
            buffer,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command adds the last part of data, if any, to a hash/HMAC sequence and returns the result.
    /// sequenceHandle: Authorization for the sequence
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// buffer: Data to be added to the hash/HMAC
    /// hierarchy: Hierarchy of the ticket for a hash
    ///     result - The returned HMAC or digest in a sized buffer
    ///     validation - Ticket indicating that the sequence of octets used to compute outDigest
    ///                  did not start with TPM_GENERATED_VALUE
    ///                  This is a NULL Ticket when the sequence is HMAC.
    pub fn SequenceComplete_async(
        &mut self,
        sequenceHandle: TPM_HANDLE,
        buffer: Vec<u8>,
        hierarchy: TPM_HANDLE,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_SequenceComplete_REQUEST {
            sequenceHandle,
            buffer,
            hierarchy,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command adds the last part of data, if any, to an Event Sequence and returns the
    /// result in a digest list. If pcrHandle references a PCR and not TPM_RH_NULL, then the
    /// returned digest list is processed in the same manner as the digest list input parameter to
    /// TPM2_PCR_Extend(). That is, if a bank contains a PCR associated with pcrHandle, it is
    /// extended with the associated digest value from the list.
    /// pcrHandle: PCR to be extended with the Event data
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// sequenceHandle: Authorization for the sequence
    ///        Auth Index: 2
    ///        Auth Role: USER
    /// buffer: Data to be added to the Event
    ///     results - List of digests computed for the PCR
    pub fn EventSequenceComplete_async(
        &mut self,
        pcrHandle: TPM_HANDLE,
        sequenceHandle: TPM_HANDLE,
        buffer: Vec<u8>,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_EventSequenceComplete_REQUEST {
            pcrHandle,
            sequenceHandle,
            buffer,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// The purpose of this command is to prove that an object with a specific Name is loaded in
    /// the TPM. By certifying that the object is loaded, the TPM warrants that a public area with
    /// a given Name is self-consistent and associated with a valid sensitive area. If a relying
    /// party has a public area that has the same Name as a Name certified with this command, then
    /// the values in that public area are correct.
    /// objectHandle: Handle of the object to be certified
    ///        Auth Index: 1
    ///        Auth Role: ADMIN
    /// signHandle: Handle of the key used to sign the attestation structure
    ///        Auth Index: 2
    ///        Auth Role: USER
    /// qualifyingData: User provided qualifying data
    /// inScheme: Signing scheme to use if the scheme for signHandle is TPM_ALG_NULL
    ///        One of: TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA,
    ///        TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR,
    ///        TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME.
    ///     certifyInfo - The structure that was signed
    ///     signature - The asymmetric signature over certifyInfo using the key referenced by signHandle
    pub fn Certify_async(
        &mut self,
        objectHandle: TPM_HANDLE,
        signHandle: TPM_HANDLE,
        qualifyingData: Vec<u8>,
        inScheme: Option<TPMU_SIG_SCHEME>,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_Certify_REQUEST {
            objectHandle,
            signHandle,
            qualifyingData,
            inScheme,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command is used to prove the association between an object and its creation data. The
    /// TPM will validate that the ticket was produced by the TPM and that the ticket validates
    /// the association between a loaded public area and the provided hash of the creation data
    /// (creationHash).
    /// signHandle: Handle of the key that will sign the attestation block
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// objectHandle: The object associated with the creation data
    ///        Auth Index: None
    /// qualifyingData: User-provided qualifying data
    /// creationHash: Hash of the creation data produced by TPM2_Create() or TPM2_CreatePrimary()
    /// inScheme: Signing scheme to use if the scheme for signHandle is TPM_ALG_NULL
    ///        One of: TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA,
    ///        TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR,
    ///        TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME.
    /// creationTicket: Ticket produced by TPM2_Create() or TPM2_CreatePrimary()
    ///     certifyInfo - The structure that was signed
    ///     signature - The signature over certifyInfo
    pub fn CertifyCreation_async(
        &mut self,
        signHandle: TPM_HANDLE,
        objectHandle: TPM_HANDLE,
        qualifyingData: Vec<u8>,
        creationHash: Vec<u8>,
        inScheme: Option<TPMU_SIG_SCHEME>,
        creationTicket: TPMT_TK_CREATION,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_CertifyCreation_REQUEST {
            signHandle,
            objectHandle,
            qualifyingData,
            creationHash,
            inScheme,
            creationTicket,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command is used to quote PCR values.
    /// signHandle: Handle of key that will perform signature
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// qualifyingData: Data supplied by the caller
    /// inScheme: Signing scheme to use if the scheme for signHandle is TPM_ALG_NULL
    ///        One of: TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA,
    ///        TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR,
    ///        TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME.
    /// PCRselect: PCR set to quote
    ///     quoted - The quoted information
    ///     signature - The signature over quoted
    pub fn Quote_async(
        &mut self,
        signHandle: TPM_HANDLE,
        qualifyingData: Vec<u8>,
        inScheme: Option<TPMU_SIG_SCHEME>,
        PCRselect: Vec<TPMS_PCR_SELECTION>,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_Quote_REQUEST {
            signHandle,
            qualifyingData,
            inScheme,
            PCRselect,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command returns a digital signature of the audit session digest.
    /// privacyAdminHandle: Handle of the privacy administrator (TPM_RH_ENDORSEMENT)
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// signHandle: Handle of the signing key
    ///        Auth Index: 2
    ///        Auth Role: USER
    /// sessionHandle: Handle of the audit session
    ///        Auth Index: None
    /// qualifyingData: User-provided qualifying data may be zero-length
    /// inScheme: Signing scheme to use if the scheme for signHandle is TPM_ALG_NULL
    ///        One of: TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA,
    ///        TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR,
    ///        TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME.
    ///     auditInfo - The audit information that was signed
    ///     signature - The signature over auditInfo
    pub fn GetSessionAuditDigest_async(
        &mut self,
        privacyAdminHandle: TPM_HANDLE,
        signHandle: TPM_HANDLE,
        sessionHandle: TPM_HANDLE,
        qualifyingData: Vec<u8>,
        inScheme: Option<TPMU_SIG_SCHEME>,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_GetSessionAuditDigest_REQUEST {
            privacyAdminHandle,
            signHandle,
            sessionHandle,
            qualifyingData,
            inScheme,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command returns the current value of the command audit digest, a digest of the
    /// commands being audited, and the audit hash algorithm. These values are placed in an
    /// attestation structure and signed with the key referenced by signHandle.
    /// privacyHandle: Handle of the privacy administrator (TPM_RH_ENDORSEMENT)
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// signHandle: The handle of the signing key
    ///        Auth Index: 2
    ///        Auth Role: USER
    /// qualifyingData: Other data to associate with this audit digest
    /// inScheme: Signing scheme to use if the scheme for signHandle is TPM_ALG_NULL
    ///        One of: TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA,
    ///        TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR,
    ///        TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME.
    ///     auditInfo - The auditInfo that was signed
    ///     signature - The signature over auditInfo
    pub fn GetCommandAuditDigest_async(
        &mut self,
        privacyHandle: TPM_HANDLE,
        signHandle: TPM_HANDLE,
        qualifyingData: Vec<u8>,
        inScheme: Option<TPMU_SIG_SCHEME>,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_GetCommandAuditDigest_REQUEST {
            privacyHandle,
            signHandle,
            qualifyingData,
            inScheme,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command returns the current values of Time and Clock.
    /// privacyAdminHandle: Handle of the privacy administrator (TPM_RH_ENDORSEMENT)
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// signHandle: The keyHandle identifier of a loaded key that can perform digital signatures
    ///        Auth Index: 2
    ///        Auth Role: USER
    /// qualifyingData: Data to tick stamp
    /// inScheme: Signing scheme to use if the scheme for signHandle is TPM_ALG_NULL
    ///        One of: TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA,
    ///        TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR,
    ///        TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME.
    ///     timeInfo - Standard TPM-generated attestation block
    ///     signature - The signature over timeInfo
    pub fn GetTime_async(
        &mut self,
        privacyAdminHandle: TPM_HANDLE,
        signHandle: TPM_HANDLE,
        qualifyingData: Vec<u8>,
        inScheme: Option<TPMU_SIG_SCHEME>,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_GetTime_REQUEST {
            privacyAdminHandle,
            signHandle,
            qualifyingData,
            inScheme,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// The purpose of this command is to generate an X.509 certificate that proves an object with
    /// a specific public key and attributes is loaded in the TPM. In contrast to TPM2_Certify,
    /// which uses a TCG-defined data structure to convey attestation information,
    /// TPM2_CertifyX509 encodes the attestation information in a DER-encoded X.509 certificate
    /// that is compliant with RFC5280 Internet X.509 Public Key Infrastructure Certificate and
    /// Certificate Revocation List (CRL) Profile.
    /// objectHandle: Handle of the object to be certified
    ///        Auth Index: 1
    ///        Auth Role: ADMIN
    /// signHandle: Handle of the key used to sign the attestation structure
    ///        Auth Index: 2
    ///        Auth Role: USER
    /// reserved: Shall be an Empty Buffer
    /// inScheme: Signing scheme to use if the scheme for signHandle is TPM_ALG_NULL
    ///        One of: TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA,
    ///        TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR,
    ///        TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME.
    /// partialCertificate: A DER encoded partial certificate
    ///     addedToCertificate - A DER encoded SEQUENCE containing the DER encoded fields added to
    ///                          partialCertificate to make it a complete RFC5280 TBSCertificate.
    ///     tbsDigest - The digest that was signed
    ///     signature - The signature over tbsDigest
    pub fn CertifyX509_async(
        &mut self,
        objectHandle: TPM_HANDLE,
        signHandle: TPM_HANDLE,
        reserved: Vec<u8>,
        inScheme: Option<TPMU_SIG_SCHEME>,
        partialCertificate: Vec<u8>,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_CertifyX509_REQUEST {
            objectHandle,
            signHandle,
            reserved,
            inScheme,
            partialCertificate,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// TPM2_Commit() performs the first part of an ECC anonymous signing operation. The TPM will
    /// perform the point multiplications on the provided points and return intermediate signing
    /// values. The signHandle parameter shall refer to an ECC key and the signing scheme must be
    /// anonymous (TPM_RC_SCHEME).
    /// signHandle: Handle of the key that will be used in the signing operation
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// P1: A point (M) on the curve used by signHandle
    /// s2: Octet array used to derive x-coordinate of a base point
    /// y2: Y coordinate of the point associated with s2
    ///     K - ECC point K [ds](x2, y2)
    ///     L - ECC point L [r](x2, y2)
    ///     E - ECC point E [r]P1
    ///     counter - Least-significant 16 bits of commitCount
    pub fn Commit_async(
        &mut self,
        signHandle: TPM_HANDLE,
        P1: TPMS_ECC_POINT,
        s2: Vec<u8>,
        y2: Vec<u8>,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_Commit_REQUEST {
            signHandle,
            P1,
            s2,
            y2,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// TPM2_EC_Ephemeral() creates an ephemeral key for use in a two-phase key exchange protocol.
    /// curveID: The curve for the computed ephemeral point
    ///     Q - Ephemeral public key Q [r]G
    ///     counter - Least-significant 16 bits of commitCount
    pub fn EC_Ephemeral_async(
        &mut self,
        curveID: TPM_ECC_CURVE,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_EC_Ephemeral_REQUEST {
            curveID,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command uses loaded keys to validate a signature on a message with the message digest
    /// passed to the TPM.
    /// keyHandle: Handle of public key that will be used in the validation
    ///        Auth Index: None
    /// digest: Digest of the signed message
    /// signature: Signature to be tested
    ///        One of: TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA,
    ///        TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TPMT_HA,
    ///        TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE.
    ///     validation - This ticket is produced by TPM2_VerifySignature(). This formulation is
    ///                  used for multiple ticket uses. The ticket provides evidence that the TPM
    ///                  has validated that a digest was signed by a key with the Name of keyName.
    ///                  The ticket is computed by
    pub fn VerifySignature_async(
        &mut self,
        keyHandle: TPM_HANDLE,
        digest: Vec<u8>,
        signature: Option<TPMU_SIGNATURE>,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_VerifySignature_REQUEST {
            keyHandle,
            digest,
            signature,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command causes the TPM to sign an externally provided hash with the specified
    /// symmetric or asymmetric signing key.
    /// keyHandle: Handle of key that will perform signing
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// digest: Digest to be signed
    /// inScheme: Signing scheme to use if the scheme for keyHandle is TPM_ALG_NULL
    ///        One of: TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA,
    ///        TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR,
    ///        TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME.
    /// validation: Proof that digest was created by the TPM
    ///        If keyHandle is not a restricted signing key, then this may be a NULL Ticket with
    ///        tag = TPM_ST_CHECKHASH.
    ///     signature - The signature
    pub fn Sign_async(
        &mut self,
        keyHandle: TPM_HANDLE,
        digest: Vec<u8>,
        inScheme: Option<TPMU_SIG_SCHEME>,
        validation: TPMT_TK_HASHCHECK,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_Sign_REQUEST {
            keyHandle,
            digest,
            inScheme,
            validation,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command may be used by the Privacy Administrator or platform to change the audit
    /// status of a command or to set the hash algorithm used for the audit digest, but not both
    /// at the same time.
    /// auth: TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// auditAlg: Hash algorithm for the audit digest; if TPM_ALG_NULL, then the hash is not changed
    /// setList: List of commands that will be added to those that will be audited
    /// clearList: List of commands that will no longer be audited
    pub fn SetCommandCodeAuditStatus_async(
        &mut self,
        auth: TPM_HANDLE,
        auditAlg: TPM_ALG_ID,
        setList: Vec<TPM_CC>,
        clearList: Vec<TPM_CC>,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_SetCommandCodeAuditStatus_REQUEST {
            auth,
            auditAlg,
            setList,
            clearList,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command is used to cause an update to the indicated PCR. The digests parameter
    /// contains one or more tagged digest values identified by an algorithm ID. For each digest,
    /// the PCR associated with pcrHandle is Extended into the bank identified by the tag (hashAlg).
    /// pcrHandle: Handle of the PCR
    ///        Auth Handle: 1
    ///        Auth Role: USER
    /// digests: List of tagged digest values to be extended
    pub fn PCR_Extend_async(
        &mut self,
        pcrHandle: TPM_HANDLE,
        digests: Vec<TPMT_HA>,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_PCR_Extend_REQUEST {
            pcrHandle,
            digests,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command is used to cause an update to the indicated PCR.
    /// pcrHandle: Handle of the PCR
    ///        Auth Handle: 1
    ///        Auth Role: USER
    /// eventData: Event data in sized buffer
    ///     digests - Table 80 shows the basic hash-agile structure used in this specification. To
    ///               handle hash agility, this structure uses the hashAlg parameter to indicate
    ///               the algorithm used to compute the digest and, by implication, the size of
    ///               the digest.
    pub fn PCR_Event_async(
        &mut self,
        pcrHandle: TPM_HANDLE,
        eventData: Vec<u8>,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_PCR_Event_REQUEST {
            pcrHandle,
            eventData,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command returns the values of all PCR specified in pcrSelectionIn.
    /// pcrSelectionIn: The selection of PCR to read
    ///     pcrUpdateCounter - The current value of the PCR update counter
    ///     pcrSelectionOut - The PCR in the returned list
    ///     pcrValues - The contents of the PCR indicated in pcrSelectOut-˃ pcrSelection[] as
    ///                 tagged digests
    pub fn PCR_Read_async(
        &mut self,
        pcrSelectionIn: Vec<TPMS_PCR_SELECTION>,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_PCR_Read_REQUEST {
            pcrSelectionIn,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command is used to set the desired PCR allocation of PCR and algorithms. This command
    /// requires Platform Authorization.
    /// authHandle: TPM_RH_PLATFORM+{PP}
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// pcrAllocation: The requested allocation
    ///     allocationSuccess - YES if the allocation succeeded
    ///     maxPCR - Maximum number of PCR that may be in a bank
    ///     sizeNeeded - Number of octets required to satisfy the request
    ///     sizeAvailable - Number of octets available. Computed before the allocation.
    pub fn PCR_Allocate_async(
        &mut self,
        authHandle: TPM_HANDLE,
        pcrAllocation: Vec<TPMS_PCR_SELECTION>,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_PCR_Allocate_REQUEST {
            authHandle,
            pcrAllocation,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command is used to associate a policy with a PCR or group of PCR. The policy
    /// determines the conditions under which a PCR may be extended or reset.
    /// authHandle: TPM_RH_PLATFORM+{PP}
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// authPolicy: The desired authPolicy
    /// hashAlg: The hash algorithm of the policy
    /// pcrNum: The PCR for which the policy is to be set
    pub fn PCR_SetAuthPolicy_async(
        &mut self,
        authHandle: TPM_HANDLE,
        authPolicy: Vec<u8>,
        hashAlg: TPM_ALG_ID,
        pcrNum: TPM_HANDLE,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_PCR_SetAuthPolicy_REQUEST {
            authHandle,
            authPolicy,
            hashAlg,
            pcrNum,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command changes the authValue of a PCR or group of PCR.
    /// pcrHandle: Handle for a PCR that may have an authorization value set
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// auth: The desired authorization value
    pub fn PCR_SetAuthValue_async(
        &mut self,
        pcrHandle: TPM_HANDLE,
        auth: Vec<u8>,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_PCR_SetAuthValue_REQUEST {
            pcrHandle,
            auth,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// If the attribute of a PCR allows the PCR to be reset and proper authorization is provided,
    /// then this command may be used to set the PCR in all banks to zero. The attributes of the
    /// PCR may restrict the locality that can perform the reset operation.
    /// pcrHandle: The PCR to reset
    ///        Auth Index: 1
    ///        Auth Role: USER
    pub fn PCR_Reset_async(
        &mut self,
        pcrHandle: TPM_HANDLE,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_PCR_Reset_REQUEST {
            pcrHandle,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command includes a signed authorization in a policy. The command ties the policy to a
    /// signing key by including the Name of the signing key in the policyDigest
    /// authObject: Handle for a key that will validate the signature
    ///        Auth Index: None
    /// policySession: Handle for the policy session being extended
    ///        Auth Index: None
    /// nonceTPM: The policy nonce for the session
    ///        This can be the Empty Buffer.
    /// cpHashA: Digest of the command parameters to which this authorization is limited
    ///        This is not the cpHash for this command but the cpHash for the command to which
    ///        this policy session will be applied. If it is not limited, the parameter will be
    ///        the Empty Buffer.
    /// policyRef: A reference to a policy relating to the authorization may be the Empty Buffer
    ///        Size is limited to be no larger than the nonce size supported on the TPM.
    /// expiration: Time when authorization will expire, measured in seconds from the time that
    ///        nonceTPM was generated
    ///        If expiration is non-negative, a NULL Ticket is returned. See 23.2.5.
    /// auth: Signed authorization (not optional)
    ///        One of: TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA,
    ///        TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TPMT_HA,
    ///        TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE.
    ///     timeout - Implementation-specific time value, used to indicate to the TPM when the
    ///               ticket expires
    ///               NOTE If policyTicket is a NULL Ticket, then this shall be the Empty Buffer.
    ///     policyTicket - Produced if the command succeeds and expiration in the command was
    ///                    non-zero; this ticket will use the TPMT_ST_AUTH_SIGNED structure tag.
    ///                    See 23.2.5
    pub fn PolicySigned_async(
        &mut self,
        authObject: TPM_HANDLE,
        policySession: TPM_HANDLE,
        nonceTPM: Vec<u8>,
        cpHashA: Vec<u8>,
        policyRef: Vec<u8>,
        expiration: i32,
        auth: Option<TPMU_SIGNATURE>,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_PolicySigned_REQUEST {
            authObject,
            policySession,
            nonceTPM,
            cpHashA,
            policyRef,
            expiration,
            auth,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command includes a secret-based authorization to a policy. The caller proves
    /// knowledge of the secret value using an authorization session using the authValue
    /// associated with authHandle. A password session, an HMAC session, or a policy session
    /// containing TPM2_PolicyAuthValue() or TPM2_PolicyPassword() will satisfy this requirement.
    /// authHandle: Handle for an entity providing the authorization
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// policySession: Handle for the policy session being extended
    ///        Auth Index: None
    /// nonceTPM: The policy nonce for the session
    ///        This can be the Empty Buffer.
    /// cpHashA: Digest of the command parameters to which this authorization is limited
    ///        This not the cpHash for this command but the cpHash for the command to which this
    ///        policy session will be applied. If it is not limited, the parameter will be the
    ///        Empty Buffer.
    /// policyRef: A reference to a policy relating to the authorization may be the Empty Buffer
    ///        Size is limited to be no larger than the nonce size supported on the TPM.
    /// expiration: Time when authorization will expire, measured in seconds from the time that
    ///        nonceTPM was generated
    ///        If expiration is non-negative, a NULL Ticket is returned. See 23.2.5.
    ///     timeout - Implementation-specific time value used to indicate to the TPM when the
    ///               ticket expires
    ///     policyTicket - Produced if the command succeeds and expiration in the command was
    ///                    non-zero ( See 23.2.5). This ticket will use the TPMT_ST_AUTH_SECRET
    ///                    structure tag
    pub fn PolicySecret_async(
        &mut self,
        authHandle: TPM_HANDLE,
        policySession: TPM_HANDLE,
        nonceTPM: Vec<u8>,
        cpHashA: Vec<u8>,
        policyRef: Vec<u8>,
        expiration: i32,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_PolicySecret_REQUEST {
            authHandle,
            policySession,
            nonceTPM,
            cpHashA,
            policyRef,
            expiration,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command is similar to TPM2_PolicySigned() except that it takes a ticket instead of a
    /// signed authorization. The ticket represents a validated authorization that had an
    /// expiration time associated with it.
    /// policySession: Handle for the policy session being extended
    ///        Auth Index: None
    /// timeout: Time when authorization will expire
    ///        The contents are TPM specific. This shall be the value returned when ticket was produced.
    /// cpHashA: Digest of the command parameters to which this authorization is limited
    ///        If it is not limited, the parameter will be the Empty Buffer.
    /// policyRef: Reference to a qualifier for the policy may be the Empty Buffer
    /// authName: Name of the object that provided the authorization
    /// ticket: An authorization ticket returned by the TPM in response to a TPM2_PolicySigned()
    ///        or TPM2_PolicySecret()
    pub fn PolicyTicket_async(
        &mut self,
        policySession: TPM_HANDLE,
        timeout: Vec<u8>,
        cpHashA: Vec<u8>,
        policyRef: Vec<u8>,
        authName: Vec<u8>,
        ticket: TPMT_TK_AUTH,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_PolicyTicket_REQUEST {
            policySession,
            timeout,
            cpHashA,
            policyRef,
            authName,
            ticket,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command allows options in authorizations without requiring that the TPM evaluate all
    /// of the options. If a policy may be satisfied by different sets of conditions, the TPM need
    /// only evaluate one set that satisfies the policy. This command will indicate that one of
    /// the required sets of conditions has been satisfied.
    /// policySession: Handle for the policy session being extended
    ///        Auth Index: None
    /// pHashList: The list of hashes to check for a match
    pub fn PolicyOR_async(
        &mut self,
        policySession: TPM_HANDLE,
        pHashList: Vec<TPM2B_DIGEST>,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_PolicyOR_REQUEST {
            policySession,
            pHashList,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command is used to cause conditional gating of a policy based on PCR. This command
    /// together with TPM2_PolicyOR() allows one group of authorizations to occur when PCR are in
    /// one state and a different set of authorizations when the PCR are in a different state.
    /// policySession: Handle for the policy session being extended
    ///        Auth Index: None
    /// pcrDigest: Expected digest value of the selected PCR using the hash algorithm of the
    ///        session; may be zero length
    /// pcrs: The PCR to include in the check digest
    pub fn PolicyPCR_async(
        &mut self,
        policySession: TPM_HANDLE,
        pcrDigest: Vec<u8>,
        pcrs: Vec<TPMS_PCR_SELECTION>,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_PolicyPCR_REQUEST {
            policySession,
            pcrDigest,
            pcrs,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command indicates that the authorization will be limited to a specific locality.
    /// policySession: Handle for the policy session being extended
    ///        Auth Index: None
    /// locality: The allowed localities for the policy
    pub fn PolicyLocality_async(
        &mut self,
        policySession: TPM_HANDLE,
        locality: TPMA_LOCALITY,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_PolicyLocality_REQUEST {
            policySession,
            locality,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command is used to cause conditional gating of a policy based on the contents of an
    /// NV Index. It is an immediate assertion. The NV index is validated during the
    /// TPM2_PolicyNV() command, not when the session is used for authorization.
    /// authHandle: Handle indicating the source of the authorization value
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// nvIndex: The NV Index of the area to read
    ///        Auth Index: None
    /// policySession: Handle for the policy session being extended
    ///        Auth Index: None
    /// operandB: The second operand
    /// offset: The octet offset in the NV Index for the start of operand A
    /// operation: The comparison to make
    pub fn PolicyNV_async(
        &mut self,
        authHandle: TPM_HANDLE,
        nvIndex: TPM_HANDLE,
        policySession: TPM_HANDLE,
        operandB: Vec<u8>,
        offset: u16,
        operation: TPM_EO,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_PolicyNV_REQUEST {
            authHandle,
            nvIndex,
            policySession,
            operandB,
            offset,
            operation,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command is used to cause conditional gating of a policy based on the contents of the
    /// TPMS_TIME_INFO structure.
    /// policySession: Handle for the policy session being extended
    ///        Auth Index: None
    /// operandB: The second operand
    /// offset: The octet offset in the TPMS_TIME_INFO structure for the start of operand A
    /// operation: The comparison to make
    pub fn PolicyCounterTimer_async(
        &mut self,
        policySession: TPM_HANDLE,
        operandB: Vec<u8>,
        offset: u16,
        operation: TPM_EO,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_PolicyCounterTimer_REQUEST {
            policySession,
            operandB,
            offset,
            operation,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command indicates that the authorization will be limited to a specific command code.
    /// policySession: Handle for the policy session being extended
    ///        Auth Index: None
    /// code: The allowed commandCode
    pub fn PolicyCommandCode_async(
        &mut self,
        policySession: TPM_HANDLE,
        code: TPM_CC,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_PolicyCommandCode_REQUEST {
            policySession,
            code,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command indicates that physical presence will need to be asserted at the time the
    /// authorization is performed.
    /// policySession: Handle for the policy session being extended
    ///        Auth Index: None
    pub fn PolicyPhysicalPresence_async(
        &mut self,
        policySession: TPM_HANDLE,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_PolicyPhysicalPresence_REQUEST {
            policySession,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command is used to allow a policy to be bound to a specific command and command parameters.
    /// policySession: Handle for the policy session being extended
    ///        Auth Index: None
    /// cpHashA: The cpHash added to the policy
    pub fn PolicyCpHash_async(
        &mut self,
        policySession: TPM_HANDLE,
        cpHashA: Vec<u8>,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_PolicyCpHash_REQUEST {
            policySession,
            cpHashA,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command allows a policy to be bound to a specific set of TPM entities without being
    /// bound to the parameters of the command. This is most useful for commands such as
    /// TPM2_Duplicate() and for TPM2_PCR_Event() when the referenced PCR requires a policy.
    /// policySession: Handle for the policy session being extended
    ///        Auth Index: None
    /// nameHash: The digest to be added to the policy
    pub fn PolicyNameHash_async(
        &mut self,
        policySession: TPM_HANDLE,
        nameHash: Vec<u8>,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_PolicyNameHash_REQUEST {
            policySession,
            nameHash,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command allows qualification of duplication to allow duplication to a selected new parent.
    /// policySession: Handle for the policy session being extended
    ///        Auth Index: None
    /// objectName: The Name of the object to be duplicated
    /// newParentName: The Name of the new parent
    /// includeObject: If YES, the objectName will be included in the value in policySessionpolicyDigest
    pub fn PolicyDuplicationSelect_async(
        &mut self,
        policySession: TPM_HANDLE,
        objectName: Vec<u8>,
        newParentName: Vec<u8>,
        includeObject: u8,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_PolicyDuplicationSelect_REQUEST {
            policySession,
            objectName,
            newParentName,
            includeObject,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command allows policies to change. If a policy were static, then it would be
    /// difficult to add users to a policy. This command lets a policy authority sign a new policy
    /// so that it may be used in an existing policy.
    /// policySession: Handle for the policy session being extended
    ///        Auth Index: None
    /// approvedPolicy: Digest of the policy being approved
    /// policyRef: A policy qualifier
    /// keySign: Name of a key that can sign a policy addition
    /// checkTicket: Ticket validating that approvedPolicy and policyRef were signed by keySign
    pub fn PolicyAuthorize_async(
        &mut self,
        policySession: TPM_HANDLE,
        approvedPolicy: Vec<u8>,
        policyRef: Vec<u8>,
        keySign: Vec<u8>,
        checkTicket: TPMT_TK_VERIFIED,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_PolicyAuthorize_REQUEST {
            policySession,
            approvedPolicy,
            policyRef,
            keySign,
            checkTicket,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command allows a policy to be bound to the authorization value of the authorized entity.
    /// policySession: Handle for the policy session being extended
    ///        Auth Index: None
    pub fn PolicyAuthValue_async(
        &mut self,
        policySession: TPM_HANDLE,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_PolicyAuthValue_REQUEST {
            policySession,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command allows a policy to be bound to the authorization value of the authorized object.
    /// policySession: Handle for the policy session being extended
    ///        Auth Index: None
    pub fn PolicyPassword_async(
        &mut self,
        policySession: TPM_HANDLE,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_PolicyPassword_REQUEST {
            policySession,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command returns the current policyDigest of the session. This command allows the TPM
    /// to be used to perform the actions required to pre-compute the authPolicy for an object.
    /// policySession: Handle for the policy session
    ///        Auth Index: None
    ///     policyDigest - The current value of the policySessionpolicyDigest
    pub fn PolicyGetDigest_async(
        &mut self,
        policySession: TPM_HANDLE,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_PolicyGetDigest_REQUEST {
            policySession,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command allows a policy to be bound to the TPMA_NV_WRITTEN attributes. This is a
    /// deferred assertion. Values are stored in the policy session context and checked when the
    /// policy is used for authorization.
    /// policySession: Handle for the policy session being extended
    ///        Auth Index: None
    /// writtenSet: YES if NV Index is required to have been written
    ///        NO if NV Index is required not to have been written
    pub fn PolicyNvWritten_async(
        &mut self,
        policySession: TPM_HANDLE,
        writtenSet: u8,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_PolicyNvWritten_REQUEST {
            policySession,
            writtenSet,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command allows a policy to be bound to a specific creation template. This is most
    /// useful for an object creation command such as TPM2_Create(), TPM2_CreatePrimary(), or
    /// TPM2_CreateLoaded().
    /// policySession: Handle for the policy session being extended
    ///        Auth Index: None
    /// templateHash: The digest to be added to the policy
    pub fn PolicyTemplate_async(
        &mut self,
        policySession: TPM_HANDLE,
        templateHash: Vec<u8>,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_PolicyTemplate_REQUEST {
            policySession,
            templateHash,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command provides a capability that is the equivalent of a revocable policy. With
    /// TPM2_PolicyAuthorize(), the authorization ticket never expires, so the authorization may
    /// not be withdrawn. With this command, the approved policy is kept in an NV Index location
    /// so that the policy may be changed as needed to render the old policy unusable.
    /// authHandle: Handle indicating the source of the authorization value
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// nvIndex: The NV Index of the area to read
    ///        Auth Index: None
    /// policySession: Handle for the policy session being extended
    ///        Auth Index: None
    pub fn PolicyAuthorizeNV_async(
        &mut self,
        authHandle: TPM_HANDLE,
        nvIndex: TPM_HANDLE,
        policySession: TPM_HANDLE,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_PolicyAuthorizeNV_REQUEST {
            authHandle,
            nvIndex,
            policySession,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command is used to create a Primary Object under one of the Primary Seeds or a
    /// Temporary Object under TPM_RH_NULL. The command uses a TPM2B_PUBLIC as a template for the
    /// object to be created. The size of the unique field shall not be checked for consistency
    /// with the other object parameters. The command will create and load a Primary Object. The
    /// sensitive area is not returned.
    /// primaryHandle: TPM_RH_ENDORSEMENT, TPM_RH_OWNER, TPM_RH_PLATFORM+{PP}, or TPM_RH_NULL
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// inSensitive: The sensitive data, see TPM 2.0 Part 1 Sensitive Values
    /// inPublic: The public template
    /// outsideInfo: Data that will be included in the creation data for this object to provide
    ///        permanent, verifiable linkage between this object and some object owner data
    /// creationPCR: PCR that will be used in creation data
    ///     handle - Handle of type TPM_HT_TRANSIENT for created Primary Object
    ///     outPublic - The public portion of the created object
    ///     creationData - Contains a TPMT_CREATION_DATA
    ///     creationHash - Digest of creationData using nameAlg of outPublic
    ///     creationTicket - Ticket used by TPM2_CertifyCreation() to validate that the creation
    ///                      data was produced by the TPM
    ///     name - The name of the created object
    pub fn CreatePrimary_async(
        &mut self,
        primaryHandle: TPM_HANDLE,
        inSensitive: TPMS_SENSITIVE_CREATE,
        inPublic: TPMT_PUBLIC,
        outsideInfo: Vec<u8>,
        creationPCR: Vec<TPMS_PCR_SELECTION>,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_CreatePrimary_REQUEST {
            primaryHandle,
            inSensitive,
            inPublic,
            outsideInfo,
            creationPCR,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command enables and disables use of a hierarchy and its associated NV storage. The
    /// command allows phEnable, phEnableNV, shEnable, and ehEnable to be changed when the proper
    /// authorization is provided.
    /// authHandle: TPM_RH_ENDORSEMENT, TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// enable: The enable being modified
    ///        TPM_RH_ENDORSEMENT, TPM_RH_OWNER, TPM_RH_PLATFORM, or TPM_RH_PLATFORM_NV
    /// state: YES if the enable should be SET, NO if the enable should be CLEAR
    pub fn HierarchyControl_async(
        &mut self,
        authHandle: TPM_HANDLE,
        enable: TPM_HANDLE,
        state: u8,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_HierarchyControl_REQUEST {
            authHandle,
            enable,
            state,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command allows setting of the authorization policy for the lockout (lockoutPolicy),
    /// the platform hierarchy (platformPolicy), the storage hierarchy (ownerPolicy), and the
    /// endorsement hierarchy (endorsementPolicy). On TPMs implementing Authenticated Countdown
    /// Timers (ACT), this command may also be used to set the authorization policy for an ACT.
    /// authHandle: TPM_RH_LOCKOUT, TPM_RH_ENDORSEMENT, TPM_RH_OWNER, TPMI_RH_ACT or TPM_RH_PLATFORM+{PP}
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// authPolicy: An authorization policy digest; may be the Empty Buffer
    ///        If hashAlg is TPM_ALG_NULL, then this shall be an Empty Buffer.
    /// hashAlg: The hash algorithm to use for the policy
    ///        If the authPolicy is an Empty Buffer, then this field shall be TPM_ALG_NULL.
    pub fn SetPrimaryPolicy_async(
        &mut self,
        authHandle: TPM_HANDLE,
        authPolicy: Vec<u8>,
        hashAlg: TPM_ALG_ID,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_SetPrimaryPolicy_REQUEST {
            authHandle,
            authPolicy,
            hashAlg,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This replaces the current platform primary seed (PPS) with a value from the RNG and sets
    /// platformPolicy to the default initialization value (the Empty Buffer).
    /// authHandle: TPM_RH_PLATFORM+{PP}
    ///        Auth Index: 1
    ///        Auth Role: USER
    pub fn ChangePPS_async(
        &mut self,
        authHandle: TPM_HANDLE,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_ChangePPS_REQUEST {
            authHandle,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This replaces the current endorsement primary seed (EPS) with a value from the RNG and
    /// sets the Endorsement hierarchy controls to their default initialization values: ehEnable
    /// is SET, endorsementAuth and endorsementPolicy are both set to the Empty Buffer. It will
    /// flush any resident objects (transient or persistent) in the Endorsement hierarchy and not
    /// allow objects in the hierarchy associated with the previous EPS to be loaded.
    /// authHandle: TPM_RH_PLATFORM+{PP}
    ///        Auth Handle: 1
    ///        Auth Role: USER
    pub fn ChangeEPS_async(
        &mut self,
        authHandle: TPM_HANDLE,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_ChangeEPS_REQUEST {
            authHandle,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command removes all TPM context associated with a specific Owner.
    /// authHandle: TPM_RH_LOCKOUT or TPM_RH_PLATFORM+{PP}
    ///        Auth Handle: 1
    ///        Auth Role: USER
    pub fn Clear_async(
        &mut self,
        authHandle: TPM_HANDLE,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_Clear_REQUEST {
            authHandle,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// TPM2_ClearControl() disables and enables the execution of TPM2_Clear().
    /// auth: TPM_RH_LOCKOUT or TPM_RH_PLATFORM+{PP}
    ///        Auth Handle: 1
    ///        Auth Role: USER
    /// disable: YES if the disableOwnerClear flag is to be SET, NO if the flag is to be CLEAR.
    pub fn ClearControl_async(
        &mut self,
        auth: TPM_HANDLE,
        disable: u8,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_ClearControl_REQUEST {
            auth,
            disable,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command allows the authorization secret for a hierarchy or lockout to be changed
    /// using the current authorization value as the command authorization.
    /// authHandle: TPM_RH_LOCKOUT, TPM_RH_ENDORSEMENT, TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// newAuth: New authorization value
    pub fn HierarchyChangeAuth_async(
        &mut self,
        authHandle: TPM_HANDLE,
        newAuth: Vec<u8>,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_HierarchyChangeAuth_REQUEST {
            authHandle,
            newAuth,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command cancels the effect of a TPM lockout due to a number of successive
    /// authorization failures. If this command is properly authorized, the lockout counter is set
    /// to zero.
    /// lockHandle: TPM_RH_LOCKOUT
    ///        Auth Index: 1
    ///        Auth Role: USER
    pub fn DictionaryAttackLockReset_async(
        &mut self,
        lockHandle: TPM_HANDLE,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_DictionaryAttackLockReset_REQUEST {
            lockHandle,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command changes the lockout parameters.
    /// lockHandle: TPM_RH_LOCKOUT
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// newMaxTries: Count of authorization failures before the lockout is imposed
    /// newRecoveryTime: Time in seconds before the authorization failure count is automatically decremented
    ///        A value of zero indicates that DA protection is disabled.
    /// lockoutRecovery: Time in seconds after a lockoutAuth failure before use of lockoutAuth is allowed
    ///        A value of zero indicates that a reboot is required.
    pub fn DictionaryAttackParameters_async(
        &mut self,
        lockHandle: TPM_HANDLE,
        newMaxTries: u32,
        newRecoveryTime: u32,
        lockoutRecovery: u32,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_DictionaryAttackParameters_REQUEST {
            lockHandle,
            newMaxTries,
            newRecoveryTime,
            lockoutRecovery,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command is used to determine which commands require assertion of Physical Presence
    /// (PP) in addition to platformAuth/platformPolicy.
    /// auth: TPM_RH_PLATFORM+PP
    ///        Auth Index: 1
    ///        Auth Role: USER + Physical Presence
    /// setList: List of commands to be added to those that will require that Physical Presence be
    ///        asserted
    /// clearList: List of commands that will no longer require that Physical Presence be asserted
    pub fn PP_Commands_async(
        &mut self,
        auth: TPM_HANDLE,
        setList: Vec<TPM_CC>,
        clearList: Vec<TPM_CC>,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_PP_Commands_REQUEST {
            auth,
            setList,
            clearList,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command allows the platform to change the set of algorithms that are used by the TPM.
    /// The algorithmSet setting is a vendor-dependent value.
    /// authHandle: TPM_RH_PLATFORM
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// algorithmSet: A TPM vendor-dependent value indicating the algorithm set selection
    pub fn SetAlgorithmSet_async(
        &mut self,
        authHandle: TPM_HANDLE,
        algorithmSet: u32,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_SetAlgorithmSet_REQUEST {
            authHandle,
            algorithmSet,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command uses platformPolicy and a TPM Vendor Authorization Key to authorize a Field
    /// Upgrade Manifest.
    /// authorization: TPM_RH_PLATFORM+{PP}
    ///        Auth Index:1
    ///        Auth Role: ADMIN
    /// keyHandle: Handle of a public area that contains the TPM Vendor Authorization Key that
    ///        will be used to validate manifestSignature
    ///        Auth Index: None
    /// fuDigest: Digest of the first block in the field upgrade sequence
    /// manifestSignature: Signature over fuDigest using the key associated with keyHandle (not optional)
    ///        One of: TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA,
    ///        TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TPMT_HA,
    ///        TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE.
    pub fn FieldUpgradeStart_async(
        &mut self,
        authorization: TPM_HANDLE,
        keyHandle: TPM_HANDLE,
        fuDigest: Vec<u8>,
        manifestSignature: Option<TPMU_SIGNATURE>,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_FieldUpgradeStart_REQUEST {
            authorization,
            keyHandle,
            fuDigest,
            manifestSignature,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command will take the actual field upgrade image to be installed on the TPM. The
    /// exact format of fuData is vendor-specific. This command is only possible following a
    /// successful TPM2_FieldUpgradeStart(). If the TPM has not received a properly authorized
    /// TPM2_FieldUpgradeStart(), then the TPM shall return TPM_RC_FIELDUPGRADE.
    /// fuData: Field upgrade image data
    ///     nextDigest - Tagged digest of the next block
    ///                  TPM_ALG_NULL if field update is complete
    ///     firstDigest - Tagged digest of the first block of the sequence
    pub fn FieldUpgradeData_async(
        &mut self,
        fuData: Vec<u8>,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_FieldUpgradeData_REQUEST {
            fuData,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command is used to read a copy of the current firmware installed in the TPM.
    /// sequenceNumber: The number of previous calls to this command in this sequence
    ///        set to 0 on the first call
    ///     fuData - Field upgrade image data
    pub fn FirmwareRead_async(
        &mut self,
        sequenceNumber: u32,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_FirmwareRead_REQUEST {
            sequenceNumber,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command saves a session context, object context, or sequence object context outside
    /// the TPM.
    /// saveHandle: Handle of the resource to save
    ///        Auth Index: None
    ///     context - This structure is used in TPM2_ContextLoad() and TPM2_ContextSave(). If the
    ///               values of the TPMS_CONTEXT structure in TPM2_ContextLoad() are not the same
    ///               as the values when the context was saved (TPM2_ContextSave()), then the TPM
    ///               shall not load the context.
    pub fn ContextSave_async(
        &mut self,
        saveHandle: TPM_HANDLE,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_ContextSave_REQUEST {
            saveHandle,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command is used to reload a context that has been saved by TPM2_ContextSave().
    /// context: The context blob
    ///     handle - The handle assigned to the resource after it has been successfully loaded
    pub fn ContextLoad_async(
        &mut self,
        context: TPMS_CONTEXT,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_ContextLoad_REQUEST {
            context,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command causes all context associated with a loaded object, sequence object, or
    /// session to be removed from TPM memory.
    /// flushHandle: The handle of the item to flush
    ///        NOTE This is a use of a handle as a parameter.
    pub fn FlushContext_async(
        &mut self,
        flushHandle: TPM_HANDLE,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_FlushContext_REQUEST {
            flushHandle,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command allows certain Transient Objects to be made persistent or a persistent object
    /// to be evicted.
    /// auth: TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
    ///        Auth Handle: 1
    ///        Auth Role: USER
    /// objectHandle: The handle of a loaded object
    ///        Auth Index: None
    /// persistentHandle: If objectHandle is a transient object handle, then this is the
    ///        persistent handle for the object
    ///        if objectHandle is a persistent object handle, then it shall be the same value as
    ///        persistentHandle
    pub fn EvictControl_async(
        &mut self,
        auth: TPM_HANDLE,
        objectHandle: TPM_HANDLE,
        persistentHandle: TPM_HANDLE,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_EvictControl_REQUEST {
            auth,
            objectHandle,
            persistentHandle,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command reads the current TPMS_TIME_INFO structure that contains the current setting
    /// of Time, Clock, resetCount, and restartCount.
    ///     currentTime - This structure is used in, e.g., the TPM2_GetTime() attestation and
    ///                   TPM2_ReadClock().
    pub fn ReadClock_async(
        &mut self,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_ReadClock_REQUEST::default();
        self.tpm.dispatch_async_command(req)
    }

    /// This command is used to advance the value of the TPMs Clock. The command will fail if
    /// newTime is less than the current value of Clock or if the new time is greater than
    /// FFFF00000000000016. If both of these checks succeed, Clock is set to newTime. If either of
    /// these checks fails, the TPM shall return TPM_RC_VALUE and make no change to Clock.
    /// auth: TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
    ///        Auth Handle: 1
    ///        Auth Role: USER
    /// newTime: New Clock setting in milliseconds
    pub fn ClockSet_async(
        &mut self,
        auth: TPM_HANDLE,
        newTime: u64,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_ClockSet_REQUEST {
            auth,
            newTime,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command adjusts the rate of advance of Clock and Time to provide a better
    /// approximation to real time.
    /// auth: TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
    ///        Auth Handle: 1
    ///        Auth Role: USER
    /// rateAdjust: Adjustment to current Clock update rate
    pub fn ClockRateAdjust_async(
        &mut self,
        auth: TPM_HANDLE,
        rateAdjust: TPM_CLOCK_ADJUST,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_ClockRateAdjust_REQUEST {
            auth,
            rateAdjust,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command returns various information regarding the TPM and its current state.
    /// capability: Group selection; determines the format of the response
    /// property: Further definition of information
    /// propertyCount: Number of properties of the indicated type to return
    ///     moreData - Flag to indicate if there are more values of this type
    ///     capabilityData - The capability data
    pub fn GetCapability_async(
        &mut self,
        capability: TPM_CAP,
        property: u32,
        propertyCount: u32,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_GetCapability_REQUEST {
            capability,
            property,
            propertyCount,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command is used to check to see if specific combinations of algorithm parameters are supported.
    /// parameters: Algorithm parameters to be validated
    ///        One of: TPMS_KEYEDHASH_PARMS, TPMS_SYMCIPHER_PARMS, TPMS_RSA_PARMS, TPMS_ECC_PARMS,
    ///        TPMS_ASYM_PARMS.
    pub fn TestParms_async(
        &mut self,
        parameters: Option<TPMU_PUBLIC_PARMS>,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_TestParms_REQUEST {
            parameters,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command defines the attributes of an NV Index and causes the TPM to reserve space to
    /// hold the data associated with the NV Index. If a definition already exists at the NV
    /// Index, the TPM will return TPM_RC_NV_DEFINED.
    /// authHandle: TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// auth: The authorization value
    /// publicInfo: The public parameters of the NV area
    pub fn NV_DefineSpace_async(
        &mut self,
        authHandle: TPM_HANDLE,
        auth: Vec<u8>,
        publicInfo: TPMS_NV_PUBLIC,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_NV_DefineSpace_REQUEST {
            authHandle,
            auth,
            publicInfo,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command removes an Index from the TPM.
    /// authHandle: TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// nvIndex: The NV Index to remove from NV space
    ///        Auth Index: None
    pub fn NV_UndefineSpace_async(
        &mut self,
        authHandle: TPM_HANDLE,
        nvIndex: TPM_HANDLE,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_NV_UndefineSpace_REQUEST {
            authHandle,
            nvIndex,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command allows removal of a platform-created NV Index that has TPMA_NV_POLICY_DELETE SET.
    /// nvIndex: Index to be deleted
    ///        Auth Index: 1
    ///        Auth Role: ADMIN
    /// platform: TPM_RH_PLATFORM + {PP}
    ///        Auth Index: 2
    ///        Auth Role: USER
    pub fn NV_UndefineSpaceSpecial_async(
        &mut self,
        nvIndex: TPM_HANDLE,
        platform: TPM_HANDLE,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_NV_UndefineSpaceSpecial_REQUEST {
            nvIndex,
            platform,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command is used to read the public area and Name of an NV Index. The public area of
    /// an Index is not privacy-sensitive and no authorization is required to read this data.
    /// nvIndex: The NV Index
    ///        Auth Index: None
    ///     nvPublic - The public area of the NV Index
    ///     nvName - The Name of the nvIndex
    pub fn NV_ReadPublic_async(
        &mut self,
        nvIndex: TPM_HANDLE,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_NV_ReadPublic_REQUEST {
            nvIndex,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command writes a value to an area in NV memory that was previously defined by
    /// TPM2_NV_DefineSpace().
    /// authHandle: Handle indicating the source of the authorization value
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// nvIndex: The NV Index of the area to write
    ///        Auth Index: None
    /// data: The data to write
    /// offset: The octet offset into the NV Area
    pub fn NV_Write_async(
        &mut self,
        authHandle: TPM_HANDLE,
        nvIndex: TPM_HANDLE,
        data: Vec<u8>,
        offset: u16,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_NV_Write_REQUEST {
            authHandle,
            nvIndex,
            data,
            offset,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command is used to increment the value in an NV Index that has the TPM_NT_COUNTER
    /// attribute. The data value of the NV Index is incremented by one.
    /// authHandle: Handle indicating the source of the authorization value
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// nvIndex: The NV Index to increment
    ///        Auth Index: None
    pub fn NV_Increment_async(
        &mut self,
        authHandle: TPM_HANDLE,
        nvIndex: TPM_HANDLE,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_NV_Increment_REQUEST {
            authHandle,
            nvIndex,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command extends a value to an area in NV memory that was previously defined by
    /// TPM2_NV_DefineSpace.
    /// authHandle: Handle indicating the source of the authorization value
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// nvIndex: The NV Index to extend
    ///        Auth Index: None
    /// data: The data to extend
    pub fn NV_Extend_async(
        &mut self,
        authHandle: TPM_HANDLE,
        nvIndex: TPM_HANDLE,
        data: Vec<u8>,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_NV_Extend_REQUEST {
            authHandle,
            nvIndex,
            data,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command is used to SET bits in an NV Index that was created as a bit field. Any
    /// number of bits from 0 to 64 may be SET. The contents of bits are ORed with the current
    /// contents of the NV Index.
    /// authHandle: Handle indicating the source of the authorization value
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// nvIndex: NV Index of the area in which the bit is to be set
    ///        Auth Index: None
    /// bits: The data to OR with the current contents
    pub fn NV_SetBits_async(
        &mut self,
        authHandle: TPM_HANDLE,
        nvIndex: TPM_HANDLE,
        bits: u64,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_NV_SetBits_REQUEST {
            authHandle,
            nvIndex,
            bits,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// If the TPMA_NV_WRITEDEFINE or TPMA_NV_WRITE_STCLEAR attributes of an NV location are SET,
    /// then this command may be used to inhibit further writes of the NV Index.
    /// authHandle: Handle indicating the source of the authorization value
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// nvIndex: The NV Index of the area to lock
    ///        Auth Index: None
    pub fn NV_WriteLock_async(
        &mut self,
        authHandle: TPM_HANDLE,
        nvIndex: TPM_HANDLE,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_NV_WriteLock_REQUEST {
            authHandle,
            nvIndex,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// The command will SET TPMA_NV_WRITELOCKED for all indexes that have their
    /// TPMA_NV_GLOBALLOCK attribute SET.
    /// authHandle: TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
    ///        Auth Index: 1
    ///        Auth Role: USER
    pub fn NV_GlobalWriteLock_async(
        &mut self,
        authHandle: TPM_HANDLE,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_NV_GlobalWriteLock_REQUEST {
            authHandle,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command reads a value from an area in NV memory previously defined by TPM2_NV_DefineSpace().
    /// authHandle: The handle indicating the source of the authorization value
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// nvIndex: The NV Index to be read
    ///        Auth Index: None
    /// size: Number of octets to read
    /// offset: Octet offset into the NV area
    ///        This value shall be less than or equal to the size of the nvIndex data.
    ///     data - The data read
    pub fn NV_Read_async(
        &mut self,
        authHandle: TPM_HANDLE,
        nvIndex: TPM_HANDLE,
        size: u16,
        offset: u16,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_NV_Read_REQUEST {
            authHandle,
            nvIndex,
            size,
            offset,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// If TPMA_NV_READ_STCLEAR is SET in an Index, then this command may be used to prevent
    /// further reads of the NV Index until the next TPM2_Startup (TPM_SU_CLEAR).
    /// authHandle: The handle indicating the source of the authorization value
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// nvIndex: The NV Index to be locked
    ///        Auth Index: None
    pub fn NV_ReadLock_async(
        &mut self,
        authHandle: TPM_HANDLE,
        nvIndex: TPM_HANDLE,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_NV_ReadLock_REQUEST {
            authHandle,
            nvIndex,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command allows the authorization secret for an NV Index to be changed.
    /// nvIndex: Handle of the entity
    ///        Auth Index: 1
    ///        Auth Role: ADMIN
    /// newAuth: New authorization value
    pub fn NV_ChangeAuth_async(
        &mut self,
        nvIndex: TPM_HANDLE,
        newAuth: Vec<u8>,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_NV_ChangeAuth_REQUEST {
            nvIndex,
            newAuth,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// The purpose of this command is to certify the contents of an NV Index or portion of an NV Index.
    /// signHandle: Handle of the key used to sign the attestation structure
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// authHandle: Handle indicating the source of the authorization value for the NV Index
    ///        Auth Index: 2
    ///        Auth Role: USER
    /// nvIndex: Index for the area to be certified
    ///        Auth Index: None
    /// qualifyingData: User-provided qualifying data
    /// inScheme: Signing scheme to use if the scheme for signHandle is TPM_ALG_NULL
    ///        One of: TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA,
    ///        TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR,
    ///        TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME.
    /// size: Number of octets to certify
    /// offset: Octet offset into the NV area
    ///        This value shall be less than or equal to the size of the nvIndex data.
    ///     certifyInfo - The structure that was signed
    ///     signature - The asymmetric signature over certifyInfo using the key referenced by signHandle
    pub fn NV_Certify_async(
        &mut self,
        signHandle: TPM_HANDLE,
        authHandle: TPM_HANDLE,
        nvIndex: TPM_HANDLE,
        qualifyingData: Vec<u8>,
        inScheme: Option<TPMU_SIG_SCHEME>,
        size: u16,
        offset: u16,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_NV_Certify_REQUEST {
            signHandle,
            authHandle,
            nvIndex,
            qualifyingData,
            inScheme,
            size,
            offset,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// The purpose of this command is to obtain information about an Attached Component
    /// referenced by an AC handle.
    /// ac: Handle indicating the Attached Component
    ///        Auth Index: None
    /// capability: Starting info type
    /// count: Maximum number of values to return
    ///     moreData - Flag to indicate whether there are more values
    ///     capabilitiesData - List of capabilities
    pub fn AC_GetCapability_async(
        &mut self,
        ac: TPM_HANDLE,
        capability: TPM_AT,
        count: u32,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_AC_GetCapability_REQUEST {
            ac,
            capability,
            count,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// The purpose of this command is to send (copy) a loaded object from the TPM to an Attached Component.
    /// sendObject: Handle of the object being sent to ac
    ///        Auth Index: 1
    ///        Auth Role: DUP
    /// authHandle: The handle indicating the source of the authorization value
    ///        Auth Index: 2
    ///        Auth Role: USER
    /// ac: Handle indicating the Attached Component to which the object will be sent
    ///        Auth Index: None
    /// acDataIn: Optional non sensitive information related to the object
    ///     acDataOut - May include AC specific data or information about an error.
    pub fn AC_Send_async(
        &mut self,
        sendObject: TPM_HANDLE,
        authHandle: TPM_HANDLE,
        ac: TPM_HANDLE,
        acDataIn: Vec<u8>,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_AC_Send_REQUEST {
            sendObject,
            authHandle,
            ac,
            acDataIn,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command allows qualification of the sending (copying) of an Object to an Attached
    /// Component (AC). Qualification includes selection of the receiving AC and the method of
    /// authentication for the AC, and, in certain circumstances, the Object to be sent may be specified.
    /// policySession: Handle for the policy session being extended
    ///        Auth Index: None
    /// objectName: The Name of the Object to be sent
    /// authHandleName: The Name associated with authHandle used in the TPM2_AC_Send() command
    /// acName: The Name of the Attached Component to which the Object will be sent
    /// includeObject: If SET, objectName will be included in the value in policySessionpolicyDigest
    pub fn Policy_AC_SendSelect_async(
        &mut self,
        policySession: TPM_HANDLE,
        objectName: Vec<u8>,
        authHandleName: Vec<u8>,
        acName: Vec<u8>,
        includeObject: u8,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_Policy_AC_SendSelect_REQUEST {
            policySession,
            objectName,
            authHandleName,
            acName,
            includeObject,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This command is used to set the time remaining before an Authenticated Countdown Timer
    /// (ACT) expires.
    /// actHandle: Handle of the selected ACT
    ///        Auth Index: 1
    ///        Auth Role: USER
    /// startTimeout: The start timeout value for the ACT in seconds
    pub fn ACT_SetTimeout_async(
        &mut self,
        actHandle: TPM_HANDLE,
        startTimeout: u32,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_ACT_SetTimeout_REQUEST {
            actHandle,
            startTimeout,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// This is a placeholder to allow testing of the dispatch code.
    /// inputData: Dummy data
    ///     outputData - Dummy data
    pub fn Vendor_TCG_Test_async(
        &mut self,
        inputData: Vec<u8>,
    ) -> Result<(), TpmError> {
        // Create request structure and dispatch async command
        let req = TPM2_Vendor_TCG_Test_REQUEST {
            inputData,
        };

        self.tpm.dispatch_async_command(req)
    }

    /// TPM2_Startup() is always preceded by _TPM_Init, which is the physical indication that TPM
    /// initialization is necessary because of a system-wide reset. TPM2_Startup() is only valid
    /// after _TPM_Init. Additional TPM2_Startup() commands are not allowed after it has completed
    /// successfully. If a TPM requires TPM2_Startup() and another command is received, or if the
    /// TPM receives TPM2_Startup() when it is not required, the TPM shall return TPM_RC_INITIALIZE.
    pub fn Startup_complete(
        &mut self,
    ) -> Result<(), TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = TPMS_EMPTY::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(())
    }

    /// This command is used to prepare the TPM for a power cycle. The shutdownType parameter
    /// indicates how the subsequent TPM2_Startup() will be processed.
    pub fn Shutdown_complete(
        &mut self,
    ) -> Result<(), TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = TPMS_EMPTY::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(())
    }

    /// This command causes the TPM to perform a test of its capabilities. If the fullTest is YES,
    /// the TPM will test all functions. If fullTest = NO, the TPM will only test those functions
    /// that have not previously been tested.
    pub fn SelfTest_complete(
        &mut self,
    ) -> Result<(), TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = TPMS_EMPTY::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(())
    }

    /// This command causes the TPM to perform a test of the selected algorithms.
    ///     toDoList - List of algorithms that need testing
    pub fn IncrementalSelfTest_complete(
        &mut self,
    ) -> Result<Vec<TPM_ALG_ID>, TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = IncrementalSelfTestResponse::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(resp.toDoList)
    }

    /// This command returns manufacturer-specific information regarding the results of a
    /// self-test and an indication of the test status.
    ///     outData - Test result data
    ///               contains manufacturer-specific information
    ///     testResult - TBD
    pub fn GetTestResult_complete(
        &mut self,
    ) -> Result<GetTestResultResponse, TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = GetTestResultResponse::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(resp)
    }

    /// This command is used to start an authorization session using alternative methods of
    /// establishing the session key (sessionKey). The session key is then used to derive values
    /// used for authorization and for encrypting parameters.
    ///     handle - Handle for the newly created session
    ///     nonceTPM - The initial nonce from the TPM, used in the computation of the sessionKey
    pub fn StartAuthSession_complete(
        &mut self,
    ) -> Result<StartAuthSessionResponse, TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = StartAuthSessionResponse::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(resp)
    }

    /// This command allows a policy authorization session to be returned to its initial state.
    /// This command is used after the TPM returns TPM_RC_PCR_CHANGED. That response code
    /// indicates that a policy will fail because the PCR have changed after TPM2_PolicyPCR() was
    /// executed. Restarting the session allows the authorizations to be replayed because the
    /// session restarts with the same nonceTPM. If the PCR are valid for the policy, the policy
    /// may then succeed.
    pub fn PolicyRestart_complete(
        &mut self,
    ) -> Result<(), TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = TPMS_EMPTY::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(())
    }

    /// This command is used to create an object that can be loaded into a TPM using TPM2_Load().
    /// If the command completes successfully, the TPM will create the new object and return the
    /// objects creation data (creationData), its public area (outPublic), and its encrypted
    /// sensitive area (outPrivate). Preservation of the returned data is the responsibility of
    /// the caller. The object will need to be loaded (TPM2_Load()) before it may be used. The
    /// only difference between the inPublic TPMT_PUBLIC template and the outPublic TPMT_PUBLIC
    /// object is in the unique field.
    ///     outPrivate - The private portion of the object
    ///     outPublic - The public portion of the created object
    ///     creationData - Contains a TPMS_CREATION_DATA
    ///     creationHash - Digest of creationData using nameAlg of outPublic
    ///     creationTicket - Ticket used by TPM2_CertifyCreation() to validate that the creation
    ///                      data was produced by the TPM
    pub fn Create_complete(
        &mut self,
    ) -> Result<CreateResponse, TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = CreateResponse::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(resp)
    }

    /// This command is used to load objects into the TPM. This command is used when both a
    /// TPM2B_PUBLIC and TPM2B_PRIVATE are to be loaded. If only a TPM2B_PUBLIC is to be loaded,
    /// the TPM2_LoadExternal command is used.
    ///     handle - Handle of type TPM_HT_TRANSIENT for the loaded object
    ///     name - Name of the loaded object
    pub fn Load_complete(
        &mut self,
    ) -> Result<LoadResponse, TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = LoadResponse::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(resp)
    }

    /// This command is used to load an object that is not a Protected Object into the TPM. The
    /// command allows loading of a public area or both a public and sensitive area.
    ///     handle - Handle of type TPM_HT_TRANSIENT for the loaded object
    ///     name - Name of the loaded object
    pub fn LoadExternal_complete(
        &mut self,
    ) -> Result<LoadExternalResponse, TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = LoadExternalResponse::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(resp)
    }

    /// This command allows access to the public area of a loaded object.
    ///     outPublic - Structure containing the public area of an object
    ///     name - Name of the object
    ///     qualifiedName - The Qualified Name of the object
    pub fn ReadPublic_complete(
        &mut self,
    ) -> Result<ReadPublicResponse, TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = ReadPublicResponse::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(resp)
    }

    /// This command enables the association of a credential with an object in a way that ensures
    /// that the TPM has validated the parameters of the credentialed object.
    ///     certInfo - The decrypted certificate information
    ///                the data should be no larger than the size of the digest of the nameAlg
    ///                associated with keyHandle
    pub fn ActivateCredential_complete(
        &mut self,
    ) -> Result<Vec<u8>, TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = ActivateCredentialResponse::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(resp.certInfo)
    }

    /// This command allows the TPM to perform the actions required of a Certificate Authority
    /// (CA) in creating a TPM2B_ID_OBJECT containing an activation credential.
    ///     credentialBlob - The credential
    ///     secret - Handle algorithm-dependent data that wraps the key that encrypts credentialBlob
    pub fn MakeCredential_complete(
        &mut self,
    ) -> Result<MakeCredentialResponse, TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = MakeCredentialResponse::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(resp)
    }

    /// This command returns the data in a loaded Sealed Data Object.
    ///     outData - Unsealed data
    ///               Size of outData is limited to be no more than 128 octets.
    pub fn Unseal_complete(
        &mut self,
    ) -> Result<Vec<u8>, TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = UnsealResponse::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(resp.outData)
    }

    /// This command is used to change the authorization secret for a TPM-resident object.
    ///     outPrivate - Private area containing the new authorization value
    pub fn ObjectChangeAuth_complete(
        &mut self,
    ) -> Result<TPM2B_PRIVATE, TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = ObjectChangeAuthResponse::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(resp.outPrivate)
    }

    /// This command creates an object and loads it in the TPM. This command allows creation of
    /// any type of object (Primary, Ordinary, or Derived) depending on the type of parentHandle.
    /// If parentHandle references a Primary Seed, then a Primary Object is created; if
    /// parentHandle references a Storage Parent, then an Ordinary Object is created; and if
    /// parentHandle references a Derivation Parent, then a Derived Object is generated.
    ///     handle - Handle of type TPM_HT_TRANSIENT for created object
    ///     outPrivate - The sensitive area of the object (optional)
    ///     outPublic - The public portion of the created object
    ///     name - The name of the created object
    pub fn CreateLoaded_complete(
        &mut self,
    ) -> Result<CreateLoadedResponse, TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = CreateLoadedResponse::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(resp)
    }

    /// This command duplicates a loaded object so that it may be used in a different hierarchy.
    /// The new parent key for the duplicate may be on the same or different TPM or TPM_RH_NULL.
    /// Only the public area of newParentHandle is required to be loaded.
    ///     encryptionKeyOut - If the caller provided an encryption key or if symmetricAlg was
    ///                        TPM_ALG_NULL, then this will be the Empty Buffer; otherwise, it
    ///                        shall contain the TPM-generated, symmetric encryption key for the
    ///                        inner wrapper.
    ///     duplicate - Private area that may be encrypted by encryptionKeyIn; and may be doubly encrypted
    ///     outSymSeed - Seed protected by the asymmetric algorithms of new parent (NP)
    pub fn Duplicate_complete(
        &mut self,
    ) -> Result<DuplicateResponse, TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = DuplicateResponse::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(resp)
    }

    /// This command allows the TPM to serve in the role as a Duplication Authority. If proper
    /// authorization for use of the oldParent is provided, then an HMAC key and a symmetric key
    /// are recovered from inSymSeed and used to integrity check and decrypt inDuplicate. A new
    /// protection seed value is generated according to the methods appropriate for newParent and
    /// the blob is re-encrypted and a new integrity value is computed. The re-encrypted blob is
    /// returned in outDuplicate and the symmetric key returned in outSymKey.
    ///     outDuplicate - An object encrypted using symmetric key derived from outSymSeed
    ///     outSymSeed - Seed for a symmetric key protected by newParent asymmetric key
    pub fn Rewrap_complete(
        &mut self,
    ) -> Result<RewrapResponse, TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = RewrapResponse::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(resp)
    }

    /// This command allows an object to be encrypted using the symmetric encryption values of a
    /// Storage Key. After encryption, the object may be loaded and used in the new hierarchy. The
    /// imported object (duplicate) may be singly encrypted, multiply encrypted, or unencrypted.
    ///     outPrivate - The sensitive area encrypted with the symmetric key of parentHandle
    pub fn Import_complete(
        &mut self,
    ) -> Result<TPM2B_PRIVATE, TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = ImportResponse::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(resp.outPrivate)
    }

    /// This command performs RSA encryption using the indicated padding scheme according to IETF
    /// RFC 8017. If the scheme of keyHandle is TPM_ALG_NULL, then the caller may use inScheme to
    /// specify the padding scheme. If scheme of keyHandle is not TPM_ALG_NULL, then inScheme
    /// shall either be TPM_ALG_NULL or be the same as scheme (TPM_RC_SCHEME).
    ///     outData - Encrypted output
    pub fn RSA_Encrypt_complete(
        &mut self,
    ) -> Result<Vec<u8>, TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = RSA_EncryptResponse::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(resp.outData)
    }

    /// This command performs RSA decryption using the indicated padding scheme according to IETF
    /// RFC 8017 ((PKCS#1).
    ///     message - Decrypted output
    pub fn RSA_Decrypt_complete(
        &mut self,
    ) -> Result<Vec<u8>, TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = RSA_DecryptResponse::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(resp.message)
    }

    /// This command uses the TPM to generate an ephemeral key pair (de, Qe where Qe [de]G). It
    /// uses the private ephemeral key and a loaded public key (QS) to compute the shared secret
    /// value (P [hde]QS).
    ///     zPoint - Results of P h[de]Qs
    ///     pubPoint - Generated ephemeral public point (Qe)
    pub fn ECDH_KeyGen_complete(
        &mut self,
    ) -> Result<ECDH_KeyGenResponse, TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = ECDH_KeyGenResponse::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(resp)
    }

    /// This command uses the TPM to recover the Z value from a public point (QB) and a private
    /// key (ds). It will perform the multiplication of the provided inPoint (QB) with the private
    /// key (ds) and return the coordinates of the resultant point (Z = (xZ , yZ) [hds]QB; where h
    /// is the cofactor of the curve).
    ///     outPoint - X and Y coordinates of the product of the multiplication Z = (xZ , yZ) [hdS]QB
    pub fn ECDH_ZGen_complete(
        &mut self,
    ) -> Result<TPMS_ECC_POINT, TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = ECDH_ZGenResponse::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(resp.outPoint)
    }

    /// This command returns the parameters of an ECC curve identified by its TCG-assigned curveID.
    ///     parameters - ECC parameters for the selected curve
    pub fn ECC_Parameters_complete(
        &mut self,
    ) -> Result<TPMS_ALGORITHM_DETAIL_ECC, TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = ECC_ParametersResponse::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(resp.parameters)
    }

    /// This command supports two-phase key exchange protocols. The command is used in combination
    /// with TPM2_EC_Ephemeral(). TPM2_EC_Ephemeral() generates an ephemeral key and returns the
    /// public point of that ephemeral key along with a numeric value that allows the TPM to
    /// regenerate the associated private key.
    ///     outZ1 - X and Y coordinates of the computed value (scheme dependent)
    ///     outZ2 - X and Y coordinates of the second computed value (scheme dependent)
    pub fn ZGen_2Phase_complete(
        &mut self,
    ) -> Result<ZGen_2PhaseResponse, TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = ZGen_2PhaseResponse::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(resp)
    }

    /// This command performs ECC encryption as described in Part 1, Annex D.
    ///     C1 - The public ephemeral key used for ECDH
    ///     C2 - The data block produced by the XOR process
    ///     C3 - The integrity value
    pub fn ECC_Encrypt_complete(
        &mut self,
    ) -> Result<ECC_EncryptResponse, TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = ECC_EncryptResponse::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(resp)
    }

    /// This command performs ECC decryption.
    ///     plainText - Decrypted output
    pub fn ECC_Decrypt_complete(
        &mut self,
    ) -> Result<Vec<u8>, TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = ECC_DecryptResponse::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(resp.plainText)
    }

    /// NOTE 1 This command is deprecated, and TPM2_EncryptDecrypt2() is preferred. This should be
    /// reflected in platform-specific specifications.
    ///     outData - Encrypted or decrypted output
    ///     ivOut - Chaining value to use for IV in next round
    pub fn EncryptDecrypt_complete(
        &mut self,
    ) -> Result<EncryptDecryptResponse, TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = EncryptDecryptResponse::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(resp)
    }

    /// This command is identical to TPM2_EncryptDecrypt(), except that the inData parameter is
    /// the first parameter. This permits inData to be parameter encrypted.
    ///     outData - Encrypted or decrypted output
    ///     ivOut - Chaining value to use for IV in next round
    pub fn EncryptDecrypt2_complete(
        &mut self,
    ) -> Result<EncryptDecrypt2Response, TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = EncryptDecrypt2Response::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(resp)
    }

    /// This command performs a hash operation on a data buffer and returns the results.
    ///     outHash - Results
    ///     validation - Ticket indicating that the sequence of octets used to compute outDigest
    ///                  did not start with TPM_GENERATED_VALUE
    ///                  will be a NULL ticket if the digest may not be signed with a restricted key
    pub fn Hash_complete(
        &mut self,
    ) -> Result<HashResponse, TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = HashResponse::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(resp)
    }

    /// This command performs an HMAC on the supplied data using the indicated hash algorithm.
    ///     outHMAC - The returned HMAC in a sized buffer
    pub fn HMAC_complete(
        &mut self,
    ) -> Result<Vec<u8>, TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = HMACResponse::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(resp.outHMAC)
    }

    /// This command performs an HMAC or a block cipher MAC on the supplied data using the
    /// indicated algorithm.
    ///     outMAC - The returned MAC in a sized buffer
    pub fn MAC_complete(
        &mut self,
    ) -> Result<Vec<u8>, TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = MACResponse::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(resp.outMAC)
    }

    /// This command returns the next bytesRequested octets from the random number generator (RNG).
    ///     randomBytes - The random octets
    pub fn GetRandom_complete(
        &mut self,
    ) -> Result<Vec<u8>, TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = GetRandomResponse::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(resp.randomBytes)
    }

    /// This command is used to add "additional information" to the RNG state.
    pub fn StirRandom_complete(
        &mut self,
    ) -> Result<(), TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = TPMS_EMPTY::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(())
    }

    /// This command starts an HMAC sequence. The TPM will create and initialize an HMAC sequence
    /// structure, assign a handle to the sequence, and set the authValue of the sequence object
    /// to the value in auth.
    ///     handle - A handle to reference the sequence
    pub fn HMAC_Start_complete(
        &mut self,
    ) -> Result<TPM_HANDLE, TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = HMAC_StartResponse::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(resp.handle)
    }

    /// This command starts a MAC sequence. The TPM will create and initialize a MAC sequence
    /// structure, assign a handle to the sequence, and set the authValue of the sequence object
    /// to the value in auth.
    ///     handle - A handle to reference the sequence
    pub fn MAC_Start_complete(
        &mut self,
    ) -> Result<TPM_HANDLE, TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = MAC_StartResponse::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(resp.handle)
    }

    /// This command starts a hash or an Event Sequence. If hashAlg is an implemented hash, then a
    /// hash sequence is started. If hashAlg is TPM_ALG_NULL, then an Event Sequence is started.
    /// If hashAlg is neither an implemented algorithm nor TPM_ALG_NULL, then the TPM shall return
    /// TPM_RC_HASH.
    ///     handle - A handle to reference the sequence
    pub fn HashSequenceStart_complete(
        &mut self,
    ) -> Result<TPM_HANDLE, TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = HashSequenceStartResponse::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(resp.handle)
    }

    /// This command is used to add data to a hash or HMAC sequence. The amount of data in buffer
    /// may be any size up to the limits of the TPM.
    pub fn SequenceUpdate_complete(
        &mut self,
    ) -> Result<(), TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = TPMS_EMPTY::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(())
    }

    /// This command adds the last part of data, if any, to a hash/HMAC sequence and returns the result.
    ///     result - The returned HMAC or digest in a sized buffer
    ///     validation - Ticket indicating that the sequence of octets used to compute outDigest
    ///                  did not start with TPM_GENERATED_VALUE
    ///                  This is a NULL Ticket when the sequence is HMAC.
    pub fn SequenceComplete_complete(
        &mut self,
    ) -> Result<SequenceCompleteResponse, TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = SequenceCompleteResponse::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(resp)
    }

    /// This command adds the last part of data, if any, to an Event Sequence and returns the
    /// result in a digest list. If pcrHandle references a PCR and not TPM_RH_NULL, then the
    /// returned digest list is processed in the same manner as the digest list input parameter to
    /// TPM2_PCR_Extend(). That is, if a bank contains a PCR associated with pcrHandle, it is
    /// extended with the associated digest value from the list.
    ///     results - List of digests computed for the PCR
    pub fn EventSequenceComplete_complete(
        &mut self,
    ) -> Result<Vec<TPMT_HA>, TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = EventSequenceCompleteResponse::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(resp.results)
    }

    /// The purpose of this command is to prove that an object with a specific Name is loaded in
    /// the TPM. By certifying that the object is loaded, the TPM warrants that a public area with
    /// a given Name is self-consistent and associated with a valid sensitive area. If a relying
    /// party has a public area that has the same Name as a Name certified with this command, then
    /// the values in that public area are correct.
    ///     certifyInfo - The structure that was signed
    ///     signature - The asymmetric signature over certifyInfo using the key referenced by signHandle
    pub fn Certify_complete(
        &mut self,
    ) -> Result<CertifyResponse, TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = CertifyResponse::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(resp)
    }

    /// This command is used to prove the association between an object and its creation data. The
    /// TPM will validate that the ticket was produced by the TPM and that the ticket validates
    /// the association between a loaded public area and the provided hash of the creation data
    /// (creationHash).
    ///     certifyInfo - The structure that was signed
    ///     signature - The signature over certifyInfo
    pub fn CertifyCreation_complete(
        &mut self,
    ) -> Result<CertifyCreationResponse, TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = CertifyCreationResponse::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(resp)
    }

    /// This command is used to quote PCR values.
    ///     quoted - The quoted information
    ///     signature - The signature over quoted
    pub fn Quote_complete(
        &mut self,
    ) -> Result<QuoteResponse, TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = QuoteResponse::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(resp)
    }

    /// This command returns a digital signature of the audit session digest.
    ///     auditInfo - The audit information that was signed
    ///     signature - The signature over auditInfo
    pub fn GetSessionAuditDigest_complete(
        &mut self,
    ) -> Result<GetSessionAuditDigestResponse, TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = GetSessionAuditDigestResponse::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(resp)
    }

    /// This command returns the current value of the command audit digest, a digest of the
    /// commands being audited, and the audit hash algorithm. These values are placed in an
    /// attestation structure and signed with the key referenced by signHandle.
    ///     auditInfo - The auditInfo that was signed
    ///     signature - The signature over auditInfo
    pub fn GetCommandAuditDigest_complete(
        &mut self,
    ) -> Result<GetCommandAuditDigestResponse, TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = GetCommandAuditDigestResponse::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(resp)
    }

    /// This command returns the current values of Time and Clock.
    ///     timeInfo - Standard TPM-generated attestation block
    ///     signature - The signature over timeInfo
    pub fn GetTime_complete(
        &mut self,
    ) -> Result<GetTimeResponse, TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = GetTimeResponse::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(resp)
    }

    /// The purpose of this command is to generate an X.509 certificate that proves an object with
    /// a specific public key and attributes is loaded in the TPM. In contrast to TPM2_Certify,
    /// which uses a TCG-defined data structure to convey attestation information,
    /// TPM2_CertifyX509 encodes the attestation information in a DER-encoded X.509 certificate
    /// that is compliant with RFC5280 Internet X.509 Public Key Infrastructure Certificate and
    /// Certificate Revocation List (CRL) Profile.
    ///     addedToCertificate - A DER encoded SEQUENCE containing the DER encoded fields added to
    ///                          partialCertificate to make it a complete RFC5280 TBSCertificate.
    ///     tbsDigest - The digest that was signed
    ///     signature - The signature over tbsDigest
    pub fn CertifyX509_complete(
        &mut self,
    ) -> Result<CertifyX509Response, TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = CertifyX509Response::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(resp)
    }

    /// TPM2_Commit() performs the first part of an ECC anonymous signing operation. The TPM will
    /// perform the point multiplications on the provided points and return intermediate signing
    /// values. The signHandle parameter shall refer to an ECC key and the signing scheme must be
    /// anonymous (TPM_RC_SCHEME).
    ///     K - ECC point K [ds](x2, y2)
    ///     L - ECC point L [r](x2, y2)
    ///     E - ECC point E [r]P1
    ///     counter - Least-significant 16 bits of commitCount
    pub fn Commit_complete(
        &mut self,
    ) -> Result<CommitResponse, TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = CommitResponse::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(resp)
    }

    /// TPM2_EC_Ephemeral() creates an ephemeral key for use in a two-phase key exchange protocol.
    ///     Q - Ephemeral public key Q [r]G
    ///     counter - Least-significant 16 bits of commitCount
    pub fn EC_Ephemeral_complete(
        &mut self,
    ) -> Result<EC_EphemeralResponse, TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = EC_EphemeralResponse::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(resp)
    }

    /// This command uses loaded keys to validate a signature on a message with the message digest
    /// passed to the TPM.
    ///     validation - This ticket is produced by TPM2_VerifySignature(). This formulation is
    ///                  used for multiple ticket uses. The ticket provides evidence that the TPM
    ///                  has validated that a digest was signed by a key with the Name of keyName.
    ///                  The ticket is computed by
    pub fn VerifySignature_complete(
        &mut self,
    ) -> Result<TPMT_TK_VERIFIED, TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = VerifySignatureResponse::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(resp.validation)
    }

    /// This command causes the TPM to sign an externally provided hash with the specified
    /// symmetric or asymmetric signing key.
    ///     signature - The signature
    pub fn Sign_complete(
        &mut self,
    ) -> Result<Option<TPMU_SIGNATURE>, TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = SignResponse::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(resp.signature)
    }

    /// This command may be used by the Privacy Administrator or platform to change the audit
    /// status of a command or to set the hash algorithm used for the audit digest, but not both
    /// at the same time.
    pub fn SetCommandCodeAuditStatus_complete(
        &mut self,
    ) -> Result<(), TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = TPMS_EMPTY::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(())
    }

    /// This command is used to cause an update to the indicated PCR. The digests parameter
    /// contains one or more tagged digest values identified by an algorithm ID. For each digest,
    /// the PCR associated with pcrHandle is Extended into the bank identified by the tag (hashAlg).
    pub fn PCR_Extend_complete(
        &mut self,
    ) -> Result<(), TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = TPMS_EMPTY::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(())
    }

    /// This command is used to cause an update to the indicated PCR.
    ///     digests - Table 80 shows the basic hash-agile structure used in this specification. To
    ///               handle hash agility, this structure uses the hashAlg parameter to indicate
    ///               the algorithm used to compute the digest and, by implication, the size of
    ///               the digest.
    pub fn PCR_Event_complete(
        &mut self,
    ) -> Result<Vec<TPMT_HA>, TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = PCR_EventResponse::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(resp.digests)
    }

    /// This command returns the values of all PCR specified in pcrSelectionIn.
    ///     pcrUpdateCounter - The current value of the PCR update counter
    ///     pcrSelectionOut - The PCR in the returned list
    ///     pcrValues - The contents of the PCR indicated in pcrSelectOut-˃ pcrSelection[] as
    ///                 tagged digests
    pub fn PCR_Read_complete(
        &mut self,
    ) -> Result<PCR_ReadResponse, TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = PCR_ReadResponse::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(resp)
    }

    /// This command is used to set the desired PCR allocation of PCR and algorithms. This command
    /// requires Platform Authorization.
    ///     allocationSuccess - YES if the allocation succeeded
    ///     maxPCR - Maximum number of PCR that may be in a bank
    ///     sizeNeeded - Number of octets required to satisfy the request
    ///     sizeAvailable - Number of octets available. Computed before the allocation.
    pub fn PCR_Allocate_complete(
        &mut self,
    ) -> Result<PCR_AllocateResponse, TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = PCR_AllocateResponse::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(resp)
    }

    /// This command is used to associate a policy with a PCR or group of PCR. The policy
    /// determines the conditions under which a PCR may be extended or reset.
    pub fn PCR_SetAuthPolicy_complete(
        &mut self,
    ) -> Result<(), TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = TPMS_EMPTY::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(())
    }

    /// This command changes the authValue of a PCR or group of PCR.
    pub fn PCR_SetAuthValue_complete(
        &mut self,
    ) -> Result<(), TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = TPMS_EMPTY::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(())
    }

    /// If the attribute of a PCR allows the PCR to be reset and proper authorization is provided,
    /// then this command may be used to set the PCR in all banks to zero. The attributes of the
    /// PCR may restrict the locality that can perform the reset operation.
    pub fn PCR_Reset_complete(
        &mut self,
    ) -> Result<(), TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = TPMS_EMPTY::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(())
    }

    /// This command includes a signed authorization in a policy. The command ties the policy to a
    /// signing key by including the Name of the signing key in the policyDigest
    ///     timeout - Implementation-specific time value, used to indicate to the TPM when the
    ///               ticket expires
    ///               NOTE If policyTicket is a NULL Ticket, then this shall be the Empty Buffer.
    ///     policyTicket - Produced if the command succeeds and expiration in the command was
    ///                    non-zero; this ticket will use the TPMT_ST_AUTH_SIGNED structure tag.
    ///                    See 23.2.5
    pub fn PolicySigned_complete(
        &mut self,
    ) -> Result<PolicySignedResponse, TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = PolicySignedResponse::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(resp)
    }

    /// This command includes a secret-based authorization to a policy. The caller proves
    /// knowledge of the secret value using an authorization session using the authValue
    /// associated with authHandle. A password session, an HMAC session, or a policy session
    /// containing TPM2_PolicyAuthValue() or TPM2_PolicyPassword() will satisfy this requirement.
    ///     timeout - Implementation-specific time value used to indicate to the TPM when the
    ///               ticket expires
    ///     policyTicket - Produced if the command succeeds and expiration in the command was
    ///                    non-zero ( See 23.2.5). This ticket will use the TPMT_ST_AUTH_SECRET
    ///                    structure tag
    pub fn PolicySecret_complete(
        &mut self,
    ) -> Result<PolicySecretResponse, TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = PolicySecretResponse::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(resp)
    }

    /// This command is similar to TPM2_PolicySigned() except that it takes a ticket instead of a
    /// signed authorization. The ticket represents a validated authorization that had an
    /// expiration time associated with it.
    pub fn PolicyTicket_complete(
        &mut self,
    ) -> Result<(), TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = TPMS_EMPTY::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(())
    }

    /// This command allows options in authorizations without requiring that the TPM evaluate all
    /// of the options. If a policy may be satisfied by different sets of conditions, the TPM need
    /// only evaluate one set that satisfies the policy. This command will indicate that one of
    /// the required sets of conditions has been satisfied.
    pub fn PolicyOR_complete(
        &mut self,
    ) -> Result<(), TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = TPMS_EMPTY::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(())
    }

    /// This command is used to cause conditional gating of a policy based on PCR. This command
    /// together with TPM2_PolicyOR() allows one group of authorizations to occur when PCR are in
    /// one state and a different set of authorizations when the PCR are in a different state.
    pub fn PolicyPCR_complete(
        &mut self,
    ) -> Result<(), TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = TPMS_EMPTY::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(())
    }

    /// This command indicates that the authorization will be limited to a specific locality.
    pub fn PolicyLocality_complete(
        &mut self,
    ) -> Result<(), TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = TPMS_EMPTY::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(())
    }

    /// This command is used to cause conditional gating of a policy based on the contents of an
    /// NV Index. It is an immediate assertion. The NV index is validated during the
    /// TPM2_PolicyNV() command, not when the session is used for authorization.
    pub fn PolicyNV_complete(
        &mut self,
    ) -> Result<(), TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = TPMS_EMPTY::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(())
    }

    /// This command is used to cause conditional gating of a policy based on the contents of the
    /// TPMS_TIME_INFO structure.
    pub fn PolicyCounterTimer_complete(
        &mut self,
    ) -> Result<(), TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = TPMS_EMPTY::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(())
    }

    /// This command indicates that the authorization will be limited to a specific command code.
    pub fn PolicyCommandCode_complete(
        &mut self,
    ) -> Result<(), TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = TPMS_EMPTY::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(())
    }

    /// This command indicates that physical presence will need to be asserted at the time the
    /// authorization is performed.
    pub fn PolicyPhysicalPresence_complete(
        &mut self,
    ) -> Result<(), TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = TPMS_EMPTY::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(())
    }

    /// This command is used to allow a policy to be bound to a specific command and command parameters.
    pub fn PolicyCpHash_complete(
        &mut self,
    ) -> Result<(), TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = TPMS_EMPTY::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(())
    }

    /// This command allows a policy to be bound to a specific set of TPM entities without being
    /// bound to the parameters of the command. This is most useful for commands such as
    /// TPM2_Duplicate() and for TPM2_PCR_Event() when the referenced PCR requires a policy.
    pub fn PolicyNameHash_complete(
        &mut self,
    ) -> Result<(), TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = TPMS_EMPTY::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(())
    }

    /// This command allows qualification of duplication to allow duplication to a selected new parent.
    pub fn PolicyDuplicationSelect_complete(
        &mut self,
    ) -> Result<(), TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = TPMS_EMPTY::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(())
    }

    /// This command allows policies to change. If a policy were static, then it would be
    /// difficult to add users to a policy. This command lets a policy authority sign a new policy
    /// so that it may be used in an existing policy.
    pub fn PolicyAuthorize_complete(
        &mut self,
    ) -> Result<(), TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = TPMS_EMPTY::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(())
    }

    /// This command allows a policy to be bound to the authorization value of the authorized entity.
    pub fn PolicyAuthValue_complete(
        &mut self,
    ) -> Result<(), TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = TPMS_EMPTY::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(())
    }

    /// This command allows a policy to be bound to the authorization value of the authorized object.
    pub fn PolicyPassword_complete(
        &mut self,
    ) -> Result<(), TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = TPMS_EMPTY::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(())
    }

    /// This command returns the current policyDigest of the session. This command allows the TPM
    /// to be used to perform the actions required to pre-compute the authPolicy for an object.
    ///     policyDigest - The current value of the policySessionpolicyDigest
    pub fn PolicyGetDigest_complete(
        &mut self,
    ) -> Result<Vec<u8>, TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = PolicyGetDigestResponse::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(resp.policyDigest)
    }

    /// This command allows a policy to be bound to the TPMA_NV_WRITTEN attributes. This is a
    /// deferred assertion. Values are stored in the policy session context and checked when the
    /// policy is used for authorization.
    pub fn PolicyNvWritten_complete(
        &mut self,
    ) -> Result<(), TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = TPMS_EMPTY::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(())
    }

    /// This command allows a policy to be bound to a specific creation template. This is most
    /// useful for an object creation command such as TPM2_Create(), TPM2_CreatePrimary(), or
    /// TPM2_CreateLoaded().
    pub fn PolicyTemplate_complete(
        &mut self,
    ) -> Result<(), TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = TPMS_EMPTY::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(())
    }

    /// This command provides a capability that is the equivalent of a revocable policy. With
    /// TPM2_PolicyAuthorize(), the authorization ticket never expires, so the authorization may
    /// not be withdrawn. With this command, the approved policy is kept in an NV Index location
    /// so that the policy may be changed as needed to render the old policy unusable.
    pub fn PolicyAuthorizeNV_complete(
        &mut self,
    ) -> Result<(), TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = TPMS_EMPTY::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(())
    }

    /// This command is used to create a Primary Object under one of the Primary Seeds or a
    /// Temporary Object under TPM_RH_NULL. The command uses a TPM2B_PUBLIC as a template for the
    /// object to be created. The size of the unique field shall not be checked for consistency
    /// with the other object parameters. The command will create and load a Primary Object. The
    /// sensitive area is not returned.
    ///     handle - Handle of type TPM_HT_TRANSIENT for created Primary Object
    ///     outPublic - The public portion of the created object
    ///     creationData - Contains a TPMT_CREATION_DATA
    ///     creationHash - Digest of creationData using nameAlg of outPublic
    ///     creationTicket - Ticket used by TPM2_CertifyCreation() to validate that the creation
    ///                      data was produced by the TPM
    ///     name - The name of the created object
    pub fn CreatePrimary_complete(
        &mut self,
    ) -> Result<CreatePrimaryResponse, TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = CreatePrimaryResponse::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(resp)
    }

    /// This command enables and disables use of a hierarchy and its associated NV storage. The
    /// command allows phEnable, phEnableNV, shEnable, and ehEnable to be changed when the proper
    /// authorization is provided.
    pub fn HierarchyControl_complete(
        &mut self,
    ) -> Result<(), TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = TPMS_EMPTY::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(())
    }

    /// This command allows setting of the authorization policy for the lockout (lockoutPolicy),
    /// the platform hierarchy (platformPolicy), the storage hierarchy (ownerPolicy), and the
    /// endorsement hierarchy (endorsementPolicy). On TPMs implementing Authenticated Countdown
    /// Timers (ACT), this command may also be used to set the authorization policy for an ACT.
    pub fn SetPrimaryPolicy_complete(
        &mut self,
    ) -> Result<(), TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = TPMS_EMPTY::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(())
    }

    /// This replaces the current platform primary seed (PPS) with a value from the RNG and sets
    /// platformPolicy to the default initialization value (the Empty Buffer).
    pub fn ChangePPS_complete(
        &mut self,
    ) -> Result<(), TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = TPMS_EMPTY::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(())
    }

    /// This replaces the current endorsement primary seed (EPS) with a value from the RNG and
    /// sets the Endorsement hierarchy controls to their default initialization values: ehEnable
    /// is SET, endorsementAuth and endorsementPolicy are both set to the Empty Buffer. It will
    /// flush any resident objects (transient or persistent) in the Endorsement hierarchy and not
    /// allow objects in the hierarchy associated with the previous EPS to be loaded.
    pub fn ChangeEPS_complete(
        &mut self,
    ) -> Result<(), TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = TPMS_EMPTY::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(())
    }

    /// This command removes all TPM context associated with a specific Owner.
    pub fn Clear_complete(
        &mut self,
    ) -> Result<(), TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = TPMS_EMPTY::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(())
    }

    /// TPM2_ClearControl() disables and enables the execution of TPM2_Clear().
    pub fn ClearControl_complete(
        &mut self,
    ) -> Result<(), TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = TPMS_EMPTY::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(())
    }

    /// This command allows the authorization secret for a hierarchy or lockout to be changed
    /// using the current authorization value as the command authorization.
    pub fn HierarchyChangeAuth_complete(
        &mut self,
    ) -> Result<(), TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = TPMS_EMPTY::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(())
    }

    /// This command cancels the effect of a TPM lockout due to a number of successive
    /// authorization failures. If this command is properly authorized, the lockout counter is set
    /// to zero.
    pub fn DictionaryAttackLockReset_complete(
        &mut self,
    ) -> Result<(), TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = TPMS_EMPTY::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(())
    }

    /// This command changes the lockout parameters.
    pub fn DictionaryAttackParameters_complete(
        &mut self,
    ) -> Result<(), TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = TPMS_EMPTY::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(())
    }

    /// This command is used to determine which commands require assertion of Physical Presence
    /// (PP) in addition to platformAuth/platformPolicy.
    pub fn PP_Commands_complete(
        &mut self,
    ) -> Result<(), TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = TPMS_EMPTY::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(())
    }

    /// This command allows the platform to change the set of algorithms that are used by the TPM.
    /// The algorithmSet setting is a vendor-dependent value.
    pub fn SetAlgorithmSet_complete(
        &mut self,
    ) -> Result<(), TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = TPMS_EMPTY::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(())
    }

    /// This command uses platformPolicy and a TPM Vendor Authorization Key to authorize a Field
    /// Upgrade Manifest.
    pub fn FieldUpgradeStart_complete(
        &mut self,
    ) -> Result<(), TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = TPMS_EMPTY::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(())
    }

    /// This command will take the actual field upgrade image to be installed on the TPM. The
    /// exact format of fuData is vendor-specific. This command is only possible following a
    /// successful TPM2_FieldUpgradeStart(). If the TPM has not received a properly authorized
    /// TPM2_FieldUpgradeStart(), then the TPM shall return TPM_RC_FIELDUPGRADE.
    ///     nextDigest - Tagged digest of the next block
    ///                  TPM_ALG_NULL if field update is complete
    ///     firstDigest - Tagged digest of the first block of the sequence
    pub fn FieldUpgradeData_complete(
        &mut self,
    ) -> Result<FieldUpgradeDataResponse, TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = FieldUpgradeDataResponse::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(resp)
    }

    /// This command is used to read a copy of the current firmware installed in the TPM.
    ///     fuData - Field upgrade image data
    pub fn FirmwareRead_complete(
        &mut self,
    ) -> Result<Vec<u8>, TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = FirmwareReadResponse::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(resp.fuData)
    }

    /// This command saves a session context, object context, or sequence object context outside
    /// the TPM.
    ///     context - This structure is used in TPM2_ContextLoad() and TPM2_ContextSave(). If the
    ///               values of the TPMS_CONTEXT structure in TPM2_ContextLoad() are not the same
    ///               as the values when the context was saved (TPM2_ContextSave()), then the TPM
    ///               shall not load the context.
    pub fn ContextSave_complete(
        &mut self,
    ) -> Result<TPMS_CONTEXT, TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = ContextSaveResponse::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(resp.context)
    }

    /// This command is used to reload a context that has been saved by TPM2_ContextSave().
    ///     handle - The handle assigned to the resource after it has been successfully loaded
    pub fn ContextLoad_complete(
        &mut self,
    ) -> Result<TPM_HANDLE, TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = ContextLoadResponse::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(resp.handle)
    }

    /// This command causes all context associated with a loaded object, sequence object, or
    /// session to be removed from TPM memory.
    pub fn FlushContext_complete(
        &mut self,
    ) -> Result<(), TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = TPMS_EMPTY::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(())
    }

    /// This command allows certain Transient Objects to be made persistent or a persistent object
    /// to be evicted.
    pub fn EvictControl_complete(
        &mut self,
    ) -> Result<(), TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = TPMS_EMPTY::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(())
    }

    /// This command reads the current TPMS_TIME_INFO structure that contains the current setting
    /// of Time, Clock, resetCount, and restartCount.
    ///     currentTime - This structure is used in, e.g., the TPM2_GetTime() attestation and
    ///                   TPM2_ReadClock().
    pub fn ReadClock_complete(
        &mut self,
    ) -> Result<TPMS_TIME_INFO, TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = ReadClockResponse::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(resp.currentTime)
    }

    /// This command is used to advance the value of the TPMs Clock. The command will fail if
    /// newTime is less than the current value of Clock or if the new time is greater than
    /// FFFF00000000000016. If both of these checks succeed, Clock is set to newTime. If either of
    /// these checks fails, the TPM shall return TPM_RC_VALUE and make no change to Clock.
    pub fn ClockSet_complete(
        &mut self,
    ) -> Result<(), TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = TPMS_EMPTY::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(())
    }

    /// This command adjusts the rate of advance of Clock and Time to provide a better
    /// approximation to real time.
    pub fn ClockRateAdjust_complete(
        &mut self,
    ) -> Result<(), TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = TPMS_EMPTY::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(())
    }

    /// This command returns various information regarding the TPM and its current state.
    ///     moreData - Flag to indicate if there are more values of this type
    ///     capabilityData - The capability data
    pub fn GetCapability_complete(
        &mut self,
    ) -> Result<GetCapabilityResponse, TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = GetCapabilityResponse::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(resp)
    }

    /// This command is used to check to see if specific combinations of algorithm parameters are supported.
    pub fn TestParms_complete(
        &mut self,
    ) -> Result<(), TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = TPMS_EMPTY::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(())
    }

    /// This command defines the attributes of an NV Index and causes the TPM to reserve space to
    /// hold the data associated with the NV Index. If a definition already exists at the NV
    /// Index, the TPM will return TPM_RC_NV_DEFINED.
    pub fn NV_DefineSpace_complete(
        &mut self,
    ) -> Result<(), TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = TPMS_EMPTY::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(())
    }

    /// This command removes an Index from the TPM.
    pub fn NV_UndefineSpace_complete(
        &mut self,
    ) -> Result<(), TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = TPMS_EMPTY::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(())
    }

    /// This command allows removal of a platform-created NV Index that has TPMA_NV_POLICY_DELETE SET.
    pub fn NV_UndefineSpaceSpecial_complete(
        &mut self,
    ) -> Result<(), TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = TPMS_EMPTY::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(())
    }

    /// This command is used to read the public area and Name of an NV Index. The public area of
    /// an Index is not privacy-sensitive and no authorization is required to read this data.
    ///     nvPublic - The public area of the NV Index
    ///     nvName - The Name of the nvIndex
    pub fn NV_ReadPublic_complete(
        &mut self,
    ) -> Result<NV_ReadPublicResponse, TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = NV_ReadPublicResponse::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(resp)
    }

    /// This command writes a value to an area in NV memory that was previously defined by
    /// TPM2_NV_DefineSpace().
    pub fn NV_Write_complete(
        &mut self,
    ) -> Result<(), TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = TPMS_EMPTY::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(())
    }

    /// This command is used to increment the value in an NV Index that has the TPM_NT_COUNTER
    /// attribute. The data value of the NV Index is incremented by one.
    pub fn NV_Increment_complete(
        &mut self,
    ) -> Result<(), TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = TPMS_EMPTY::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(())
    }

    /// This command extends a value to an area in NV memory that was previously defined by
    /// TPM2_NV_DefineSpace.
    pub fn NV_Extend_complete(
        &mut self,
    ) -> Result<(), TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = TPMS_EMPTY::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(())
    }

    /// This command is used to SET bits in an NV Index that was created as a bit field. Any
    /// number of bits from 0 to 64 may be SET. The contents of bits are ORed with the current
    /// contents of the NV Index.
    pub fn NV_SetBits_complete(
        &mut self,
    ) -> Result<(), TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = TPMS_EMPTY::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(())
    }

    /// If the TPMA_NV_WRITEDEFINE or TPMA_NV_WRITE_STCLEAR attributes of an NV location are SET,
    /// then this command may be used to inhibit further writes of the NV Index.
    pub fn NV_WriteLock_complete(
        &mut self,
    ) -> Result<(), TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = TPMS_EMPTY::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(())
    }

    /// The command will SET TPMA_NV_WRITELOCKED for all indexes that have their
    /// TPMA_NV_GLOBALLOCK attribute SET.
    pub fn NV_GlobalWriteLock_complete(
        &mut self,
    ) -> Result<(), TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = TPMS_EMPTY::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(())
    }

    /// This command reads a value from an area in NV memory previously defined by TPM2_NV_DefineSpace().
    ///     data - The data read
    pub fn NV_Read_complete(
        &mut self,
    ) -> Result<Vec<u8>, TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = NV_ReadResponse::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(resp.data)
    }

    /// If TPMA_NV_READ_STCLEAR is SET in an Index, then this command may be used to prevent
    /// further reads of the NV Index until the next TPM2_Startup (TPM_SU_CLEAR).
    pub fn NV_ReadLock_complete(
        &mut self,
    ) -> Result<(), TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = TPMS_EMPTY::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(())
    }

    /// This command allows the authorization secret for an NV Index to be changed.
    pub fn NV_ChangeAuth_complete(
        &mut self,
    ) -> Result<(), TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = TPMS_EMPTY::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(())
    }

    /// The purpose of this command is to certify the contents of an NV Index or portion of an NV Index.
    ///     certifyInfo - The structure that was signed
    ///     signature - The asymmetric signature over certifyInfo using the key referenced by signHandle
    pub fn NV_Certify_complete(
        &mut self,
    ) -> Result<NV_CertifyResponse, TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = NV_CertifyResponse::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(resp)
    }

    /// The purpose of this command is to obtain information about an Attached Component
    /// referenced by an AC handle.
    ///     moreData - Flag to indicate whether there are more values
    ///     capabilitiesData - List of capabilities
    pub fn AC_GetCapability_complete(
        &mut self,
    ) -> Result<AC_GetCapabilityResponse, TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = AC_GetCapabilityResponse::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(resp)
    }

    /// The purpose of this command is to send (copy) a loaded object from the TPM to an Attached Component.
    ///     acDataOut - May include AC specific data or information about an error.
    pub fn AC_Send_complete(
        &mut self,
    ) -> Result<TPMS_AC_OUTPUT, TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = AC_SendResponse::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(resp.acDataOut)
    }

    /// This command allows qualification of the sending (copying) of an Object to an Attached
    /// Component (AC). Qualification includes selection of the receiving AC and the method of
    /// authentication for the AC, and, in certain circumstances, the Object to be sent may be specified.
    pub fn Policy_AC_SendSelect_complete(
        &mut self,
    ) -> Result<(), TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = TPMS_EMPTY::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(())
    }

    /// This command is used to set the time remaining before an Authenticated Countdown Timer
    /// (ACT) expires.
    pub fn ACT_SetTimeout_complete(
        &mut self,
    ) -> Result<(), TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = TPMS_EMPTY::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(())
    }

    /// This is a placeholder to allow testing of the dispatch code.
    ///     outputData - Dummy data
    pub fn Vendor_TCG_Test_complete(
        &mut self,
    ) -> Result<Vec<u8>, TpmError> {
        // Complete async command by receiving and processing response
        let mut resp = Vendor_TCG_TestResponse::default();
        self.tpm.dispatch_async_response(&mut resp)?;
        Ok(resp.outputData)
    }

}

