/*
*  Copyright (c) Microsoft Corporation. All rights reserved.
*  Licensed under the MIT License. See the LICENSE file in the project root for full license information.
*/

/*
* NOTE: this file is partially auto generated!
*
* All code after the point marked with the '// <<AUTOGEN_BEGIN>>' comment
* is autogenerated from the TPM 2.0 Specification docs.
*
* DO NOT EDIT AUTOGENERATED PART - all manual changes will be lost!
*/

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        // <<AUTOGEN_BEGIN>>
// ------------------------------------------------------------------------------------------------
// DO NOT REMOVE the <<AUTOGEN_BEGIN>> comment!
// DO NOT MODIFY any code below this point - all manual changes will be lost!
// ------------------------------------------------------------------------------------------------

//! TPM types implementation

use crate::error::TpmError;
use crate::tpm_buffer::TpmBuffer;
use crate::tpm_types::*;
use std::collections::HashMap;
use std::convert::TryFrom;

lazy_static::lazy_static! {
    /// Maps enum type IDs to a map of values to string representations
    static ref ENUM_TO_STR_MAP: HashMap<std::any::TypeId, HashMap<u32, &'static str>> = {
    let mut map = HashMap::new();
        let  TPM_ALG_ID_map = HashMap::new();
        map.insert(std::any::TypeId::of::<TPM_ALG_ID>(), TPM_ALG_ID_map);

        let mut TPM_ECC_CURVE_map = HashMap::new();
        TPM_ECC_CURVE_map.insert(0x0, "NONE");
        TPM_ECC_CURVE_map.insert(0x1, "NIST_P192");
        TPM_ECC_CURVE_map.insert(0x2, "NIST_P224");
        TPM_ECC_CURVE_map.insert(0x3, "NIST_P256");
        TPM_ECC_CURVE_map.insert(0x4, "NIST_P384");
        TPM_ECC_CURVE_map.insert(0x5, "NIST_P521");
        TPM_ECC_CURVE_map.insert(0x10, "BN_P256");
        TPM_ECC_CURVE_map.insert(0x11, "BN_P638");
        TPM_ECC_CURVE_map.insert(0x20, "SM2_P256");
        TPM_ECC_CURVE_map.insert(0x21, "TEST_P192");
        map.insert(std::any::TypeId::of::<TPM_ECC_CURVE>(), TPM_ECC_CURVE_map);

        let mut SHA1_map = HashMap::new();
        SHA1_map.insert(0x14, "DIGEST_SIZE");
        SHA1_map.insert(0x40, "BLOCK_SIZE");
        map.insert(std::any::TypeId::of::<SHA1>(), SHA1_map);

        let mut SHA256_map = HashMap::new();
        SHA256_map.insert(0x20, "DIGEST_SIZE");
        SHA256_map.insert(0x40, "BLOCK_SIZE");
        map.insert(std::any::TypeId::of::<SHA256>(), SHA256_map);

        let mut SHA384_map = HashMap::new();
        SHA384_map.insert(0x30, "DIGEST_SIZE");
        SHA384_map.insert(0x80, "BLOCK_SIZE");
        map.insert(std::any::TypeId::of::<SHA384>(), SHA384_map);

        let mut SHA512_map = HashMap::new();
        SHA512_map.insert(0x40, "DIGEST_SIZE");
        SHA512_map.insert(0x80, "BLOCK_SIZE");
        map.insert(std::any::TypeId::of::<SHA512>(), SHA512_map);

        let mut SM3_256_map = HashMap::new();
        SM3_256_map.insert(0x20, "DIGEST_SIZE");
        SM3_256_map.insert(0x40, "BLOCK_SIZE");
        map.insert(std::any::TypeId::of::<SM3_256>(), SM3_256_map);

        let mut SHA3_256_map = HashMap::new();
        SHA3_256_map.insert(0x20, "DIGEST_SIZE");
        SHA3_256_map.insert(0x88, "BLOCK_SIZE");
        map.insert(std::any::TypeId::of::<SHA3_256>(), SHA3_256_map);

        let mut SHA3_384_map = HashMap::new();
        SHA3_384_map.insert(0x30, "DIGEST_SIZE");
        SHA3_384_map.insert(0x68, "BLOCK_SIZE");
        map.insert(std::any::TypeId::of::<SHA3_384>(), SHA3_384_map);

        let mut SHA3_512_map = HashMap::new();
        SHA3_512_map.insert(0x40, "DIGEST_SIZE");
        SHA3_512_map.insert(0x48, "BLOCK_SIZE");
        map.insert(std::any::TypeId::of::<SHA3_512>(), SHA3_512_map);

        let  Logic_map = HashMap::new();
        map.insert(std::any::TypeId::of::<Logic>(), Logic_map);

        let mut TPM_SPEC_map = HashMap::new();
        TPM_SPEC_map.insert(0x322E3000, "FAMILY");
        TPM_SPEC_map.insert(0x0, "LEVEL");
        TPM_SPEC_map.insert(0xA2, "VERSION");
        TPM_SPEC_map.insert(0x7E3, "YEAR");
        TPM_SPEC_map.insert(0x168, "DAY_OF_YEAR");
        map.insert(std::any::TypeId::of::<TPM_SPEC>(), TPM_SPEC_map);

        let mut TPM_GENERATED_map = HashMap::new();
        TPM_GENERATED_map.insert(0xFF544347, "VALUE");
        map.insert(std::any::TypeId::of::<TPM_GENERATED>(), TPM_GENERATED_map);

        let  TPM_CC_map = HashMap::new();
        map.insert(std::any::TypeId::of::<TPM_CC>(), TPM_CC_map);

        let  Implementation_Constants_map = HashMap::new();
        map.insert(std::any::TypeId::of::<ImplementationConstants>(), Implementation_Constants_map);

        let  TPM_RC_map = HashMap::new();
        map.insert(std::any::TypeId::of::<TPM_RC>(), TPM_RC_map);

        let mut TPM_CLOCK_ADJUST_map = HashMap::new();
        TPM_CLOCK_ADJUST_map.insert(0xFFFFFFFFFFFFFFFD, "COARSE_SLOWER");
        TPM_CLOCK_ADJUST_map.insert(0xFFFFFFFFFFFFFFFE, "MEDIUM_SLOWER");
        TPM_CLOCK_ADJUST_map.insert(0xFFFFFFFFFFFFFFFF, "FINE_SLOWER");
        TPM_CLOCK_ADJUST_map.insert(0x0, "NO_CHANGE");
        TPM_CLOCK_ADJUST_map.insert(0x1, "FINE_FASTER");
        TPM_CLOCK_ADJUST_map.insert(0x2, "MEDIUM_FASTER");
        TPM_CLOCK_ADJUST_map.insert(0x3, "COARSE_FASTER");
        map.insert(std::any::TypeId::of::<TPM_CLOCK_ADJUST>(), TPM_CLOCK_ADJUST_map);

        let mut TPM_EO_map = HashMap::new();
        TPM_EO_map.insert(0x0, "EQ");
        TPM_EO_map.insert(0x1, "NEQ");
        TPM_EO_map.insert(0x2, "SIGNED_GT");
        TPM_EO_map.insert(0x3, "UNSIGNED_GT");
        TPM_EO_map.insert(0x4, "SIGNED_LT");
        TPM_EO_map.insert(0x5, "UNSIGNED_LT");
        TPM_EO_map.insert(0x6, "SIGNED_GE");
        TPM_EO_map.insert(0x7, "UNSIGNED_GE");
        TPM_EO_map.insert(0x8, "SIGNED_LE");
        TPM_EO_map.insert(0x9, "UNSIGNED_LE");
        TPM_EO_map.insert(0xA, "BITSET");
        TPM_EO_map.insert(0xB, "BITCLEAR");
        map.insert(std::any::TypeId::of::<TPM_EO>(), TPM_EO_map);

        let mut TPM_ST_map = HashMap::new();
        TPM_ST_map.insert(0xC4, "RSP_COMMAND");
        TPM_ST_map.insert(0x8000, "NULL");
        TPM_ST_map.insert(0x8001, "NO_SESSIONS");
        TPM_ST_map.insert(0x8002, "SESSIONS");
        TPM_ST_map.insert(0x8014, "ATTEST_NV");
        TPM_ST_map.insert(0x8015, "ATTEST_COMMAND_AUDIT");
        TPM_ST_map.insert(0x8016, "ATTEST_SESSION_AUDIT");
        TPM_ST_map.insert(0x8017, "ATTEST_CERTIFY");
        TPM_ST_map.insert(0x8018, "ATTEST_QUOTE");
        TPM_ST_map.insert(0x8019, "ATTEST_TIME");
        TPM_ST_map.insert(0x801A, "ATTEST_CREATION");
        TPM_ST_map.insert(0x801C, "ATTEST_NV_DIGEST");
        TPM_ST_map.insert(0x8021, "CREATION");
        TPM_ST_map.insert(0x8022, "VERIFIED");
        TPM_ST_map.insert(0x8023, "AUTH_SECRET");
        TPM_ST_map.insert(0x8024, "HASHCHECK");
        TPM_ST_map.insert(0x8025, "AUTH_SIGNED");
        TPM_ST_map.insert(0x8029, "FU_MANIFEST");
        map.insert(std::any::TypeId::of::<TPM_ST>(), TPM_ST_map);

        let mut TPM_SU_map = HashMap::new();
        TPM_SU_map.insert(0x0, "CLEAR");
        TPM_SU_map.insert(0x1, "STATE");
        map.insert(std::any::TypeId::of::<TPM_SU>(), TPM_SU_map);

        let mut TPM_SE_map = HashMap::new();
        TPM_SE_map.insert(0x0, "HMAC");
        TPM_SE_map.insert(0x1, "POLICY");
        TPM_SE_map.insert(0x3, "TRIAL");
        map.insert(std::any::TypeId::of::<TPM_SE>(), TPM_SE_map);

        let  TPM_CAP_map = HashMap::new();
        map.insert(std::any::TypeId::of::<TPM_CAP>(), TPM_CAP_map);

        let mut TPM_PT_map = HashMap::new();
        TPM_PT_map.insert(0x0, "NONE");
        TPM_PT_map.insert(0x100, "PT_GROUP");
        TPM_PT_map.insert(0x100, "PT_FIXED");
        TPM_PT_map.insert(0x100, "FAMILY_INDICATOR");
        TPM_PT_map.insert(0x101, "LEVEL");
        TPM_PT_map.insert(0x102, "REVISION");
        TPM_PT_map.insert(0x103, "DAY_OF_YEAR");
        TPM_PT_map.insert(0x104, "YEAR");
        TPM_PT_map.insert(0x105, "MANUFACTURER");
        TPM_PT_map.insert(0x106, "VENDOR_STRING_1");
        TPM_PT_map.insert(0x107, "VENDOR_STRING_2");
        TPM_PT_map.insert(0x108, "VENDOR_STRING_3");
        TPM_PT_map.insert(0x109, "VENDOR_STRING_4");
        TPM_PT_map.insert(0x10A, "VENDOR_TPM_TYPE");
        TPM_PT_map.insert(0x10B, "FIRMWARE_VERSION_1");
        TPM_PT_map.insert(0x10C, "FIRMWARE_VERSION_2");
        TPM_PT_map.insert(0x10D, "INPUT_BUFFER");
        TPM_PT_map.insert(0x10E, "HR_TRANSIENT_MIN");
        TPM_PT_map.insert(0x10F, "HR_PERSISTENT_MIN");
        TPM_PT_map.insert(0x110, "HR_LOADED_MIN");
        TPM_PT_map.insert(0x111, "ACTIVE_SESSIONS_MAX");
        TPM_PT_map.insert(0x112, "PCR_COUNT");
        TPM_PT_map.insert(0x113, "PCR_SELECT_MIN");
        TPM_PT_map.insert(0x114, "CONTEXT_GAP_MAX");
        TPM_PT_map.insert(0x116, "NV_COUNTERS_MAX");
        TPM_PT_map.insert(0x117, "NV_INDEX_MAX");
        TPM_PT_map.insert(0x118, "MEMORY");
        TPM_PT_map.insert(0x119, "CLOCK_UPDATE");
        TPM_PT_map.insert(0x11A, "CONTEXT_HASH");
        TPM_PT_map.insert(0x11B, "CONTEXT_SYM");
        TPM_PT_map.insert(0x11C, "CONTEXT_SYM_SIZE");
        TPM_PT_map.insert(0x11D, "ORDERLY_COUNT");
        TPM_PT_map.insert(0x11E, "MAX_COMMAND_SIZE");
        TPM_PT_map.insert(0x11F, "MAX_RESPONSE_SIZE");
        TPM_PT_map.insert(0x120, "MAX_DIGEST");
        TPM_PT_map.insert(0x121, "MAX_OBJECT_CONTEXT");
        TPM_PT_map.insert(0x122, "MAX_SESSION_CONTEXT");
        TPM_PT_map.insert(0x123, "PS_FAMILY_INDICATOR");
        TPM_PT_map.insert(0x124, "PS_LEVEL");
        TPM_PT_map.insert(0x125, "PS_REVISION");
        TPM_PT_map.insert(0x126, "PS_DAY_OF_YEAR");
        TPM_PT_map.insert(0x127, "PS_YEAR");
        TPM_PT_map.insert(0x128, "SPLIT_MAX");
        TPM_PT_map.insert(0x129, "TOTAL_COMMANDS");
        TPM_PT_map.insert(0x12A, "LIBRARY_COMMANDS");
        TPM_PT_map.insert(0x12B, "VENDOR_COMMANDS");
        TPM_PT_map.insert(0x12C, "NV_BUFFER_MAX");
        TPM_PT_map.insert(0x12D, "MODES");
        TPM_PT_map.insert(0x12E, "MAX_CAP_BUFFER");
        TPM_PT_map.insert(0x200, "PT_VAR");
        TPM_PT_map.insert(0x200, "PERMANENT");
        TPM_PT_map.insert(0x201, "STARTUP_CLEAR");
        TPM_PT_map.insert(0x202, "HR_NV_INDEX");
        TPM_PT_map.insert(0x203, "HR_LOADED");
        TPM_PT_map.insert(0x204, "HR_LOADED_AVAIL");
        TPM_PT_map.insert(0x205, "HR_ACTIVE");
        TPM_PT_map.insert(0x206, "HR_ACTIVE_AVAIL");
        TPM_PT_map.insert(0x207, "HR_TRANSIENT_AVAIL");
        TPM_PT_map.insert(0x208, "HR_PERSISTENT");
        TPM_PT_map.insert(0x209, "HR_PERSISTENT_AVAIL");
        TPM_PT_map.insert(0x20A, "NV_COUNTERS");
        TPM_PT_map.insert(0x20B, "NV_COUNTERS_AVAIL");
        TPM_PT_map.insert(0x20C, "ALGORITHM_SET");
        TPM_PT_map.insert(0x20D, "LOADED_CURVES");
        TPM_PT_map.insert(0x20E, "LOCKOUT_COUNTER");
        TPM_PT_map.insert(0x20F, "MAX_AUTH_FAIL");
        TPM_PT_map.insert(0x210, "LOCKOUT_INTERVAL");
        TPM_PT_map.insert(0x211, "LOCKOUT_RECOVERY");
        TPM_PT_map.insert(0x212, "NV_WRITE_RECOVERY");
        TPM_PT_map.insert(0x213, "AUDIT_COUNTER_0");
        TPM_PT_map.insert(0x214, "AUDIT_COUNTER_1");
        map.insert(std::any::TypeId::of::<TPM_PT>(), TPM_PT_map);

        let  TPM_PT_PCR_map = HashMap::new();
        map.insert(std::any::TypeId::of::<TPM_PT_PCR>(), TPM_PT_PCR_map);

        let mut TPM_PS_map = HashMap::new();
        TPM_PS_map.insert(0x0, "MAIN");
        TPM_PS_map.insert(0x1, "PC");
        TPM_PS_map.insert(0x2, "PDA");
        TPM_PS_map.insert(0x3, "CELL_PHONE");
        TPM_PS_map.insert(0x4, "SERVER");
        TPM_PS_map.insert(0x5, "PERIPHERAL");
        TPM_PS_map.insert(0x6, "TSS");
        TPM_PS_map.insert(0x7, "STORAGE");
        TPM_PS_map.insert(0x8, "AUTHENTICATION");
        TPM_PS_map.insert(0x9, "EMBEDDED");
        TPM_PS_map.insert(0xA, "HARDCOPY");
        TPM_PS_map.insert(0xB, "INFRASTRUCTURE");
        TPM_PS_map.insert(0xC, "VIRTUALIZATION");
        TPM_PS_map.insert(0xD, "TNC");
        TPM_PS_map.insert(0xE, "MULTI_TENANT");
        TPM_PS_map.insert(0xF, "TC");
        map.insert(std::any::TypeId::of::<TPM_PS>(), TPM_PS_map);

        let  TPM_HT_map = HashMap::new();
        map.insert(std::any::TypeId::of::<TPM_HT>(), TPM_HT_map);

        let  TPM_RH_map = HashMap::new();
        map.insert(std::any::TypeId::of::<TPM_RH>(), TPM_RH_map);

        let mut TPM_NT_map = HashMap::new();
        TPM_NT_map.insert(0x0, "ORDINARY");
        TPM_NT_map.insert(0x1, "COUNTER");
        TPM_NT_map.insert(0x2, "BITS");
        TPM_NT_map.insert(0x4, "EXTEND");
        TPM_NT_map.insert(0x8, "PIN_FAIL");
        TPM_NT_map.insert(0x9, "PIN_PASS");
        map.insert(std::any::TypeId::of::<TPM_NT>(), TPM_NT_map);

        let mut TPM_AT_map = HashMap::new();
        TPM_AT_map.insert(0x0, "ANY");
        TPM_AT_map.insert(0x1, "ERROR");
        TPM_AT_map.insert(0x2, "PV1");
        TPM_AT_map.insert(0x80000000, "VEND");
        map.insert(std::any::TypeId::of::<TPM_AT>(), TPM_AT_map);

        let mut TPM_AE_map = HashMap::new();
        TPM_AE_map.insert(0x0, "NONE");
        map.insert(std::any::TypeId::of::<TPM_AE>(), TPM_AE_map);

        let mut PLATFORM_map = HashMap::new();
        PLATFORM_map.insert(0x322E3000, "FAMILY");
        PLATFORM_map.insert(0x0, "LEVEL");
        PLATFORM_map.insert(0xA2, "VERSION");
        PLATFORM_map.insert(0x7E3, "YEAR");
        PLATFORM_map.insert(0x168, "DAY_OF_YEAR");
        map.insert(std::any::TypeId::of::<PLATFORM>(), PLATFORM_map);

        let  Implementation_map = HashMap::new();
        map.insert(std::any::TypeId::of::<Implementation>(), Implementation_map);

        let mut TPM_HC_map = HashMap::new();
        TPM_HC_map.insert(0xFFFFFF, "HR_HANDLE_MASK");
        TPM_HC_map.insert(0xFF000000, "HR_RANGE_MASK");
        TPM_HC_map.insert(0x18, "HR_SHIFT");
        TPM_HC_map.insert(0x0, "HR_PCR");
        TPM_HC_map.insert(0x2000000, "HR_HMAC_SESSION");
        TPM_HC_map.insert(0x3000000, "HR_POLICY_SESSION");
        TPM_HC_map.insert(0x80000000, "HR_TRANSIENT");
        TPM_HC_map.insert(0x81000000, "HR_PERSISTENT");
        TPM_HC_map.insert(0x1000000, "HR_NV_INDEX");
        TPM_HC_map.insert(0x40000000, "HR_PERMANENT");
        TPM_HC_map.insert(0x0, "PCR_FIRST");
        TPM_HC_map.insert(0x17, "PCR_LAST");
        TPM_HC_map.insert(0x2000000, "HMAC_SESSION_FIRST");
        TPM_HC_map.insert(0x200003F, "HMAC_SESSION_LAST");
        TPM_HC_map.insert(0x2000000, "LOADED_SESSION_FIRST");
        TPM_HC_map.insert(0x200003F, "LOADED_SESSION_LAST");
        TPM_HC_map.insert(0x3000000, "POLICY_SESSION_FIRST");
        TPM_HC_map.insert(0x300003F, "POLICY_SESSION_LAST");
        TPM_HC_map.insert(0x80000000, "TRANSIENT_FIRST");
        TPM_HC_map.insert(0x3000000, "ACTIVE_SESSION_FIRST");
        TPM_HC_map.insert(0x300003F, "ACTIVE_SESSION_LAST");
        TPM_HC_map.insert(0x80000002, "TRANSIENT_LAST");
        TPM_HC_map.insert(0x81000000, "PERSISTENT_FIRST");
        TPM_HC_map.insert(0x81FFFFFF, "PERSISTENT_LAST");
        TPM_HC_map.insert(0x81800000, "PLATFORM_PERSISTENT");
        TPM_HC_map.insert(0x1000000, "NV_INDEX_FIRST");
        TPM_HC_map.insert(0x1FFFFFF, "NV_INDEX_LAST");
        TPM_HC_map.insert(0x40000000, "PERMANENT_FIRST");
        TPM_HC_map.insert(0x4000011F, "PERMANENT_LAST");
        TPM_HC_map.insert(0x1D00000, "HR_NV_AC");
        TPM_HC_map.insert(0x1D00000, "NV_AC_FIRST");
        TPM_HC_map.insert(0x1D0FFFF, "NV_AC_LAST");
        TPM_HC_map.insert(0x90000000, "HR_AC");
        TPM_HC_map.insert(0x90000000, "AC_FIRST");
        TPM_HC_map.insert(0x9000FFFF, "AC_LAST");
        map.insert(std::any::TypeId::of::<TPM_HC>(), TPM_HC_map);

        let mut TPMA_ALGORITHM_map = HashMap::new();
        TPMA_ALGORITHM_map.insert(0x1, "asymmetric");
        TPMA_ALGORITHM_map.insert(0x2, "symmetric");
        TPMA_ALGORITHM_map.insert(0x4, "hash");
        TPMA_ALGORITHM_map.insert(0x8, "object");
        TPMA_ALGORITHM_map.insert(0x100, "signing");
        TPMA_ALGORITHM_map.insert(0x200, "encrypting");
        TPMA_ALGORITHM_map.insert(0x400, "method");
        map.insert(std::any::TypeId::of::<TPMA_ALGORITHM>(), TPMA_ALGORITHM_map);

        let  TPMA_OBJECT_map = HashMap::new();
        map.insert(std::any::TypeId::of::<TPMA_OBJECT>(), TPMA_OBJECT_map);

        let mut TPMA_SESSION_map = HashMap::new();
        TPMA_SESSION_map.insert(0x1, "continueSession");
        TPMA_SESSION_map.insert(0x2, "auditExclusive");
        TPMA_SESSION_map.insert(0x4, "auditReset");
        TPMA_SESSION_map.insert(0x20, "decrypt");
        TPMA_SESSION_map.insert(0x40, "encrypt");
        TPMA_SESSION_map.insert(0x80, "audit");
        map.insert(std::any::TypeId::of::<TPMA_SESSION>(), TPMA_SESSION_map);

        let mut TPMA_LOCALITY_map = HashMap::new();
        TPMA_LOCALITY_map.insert(0x1, "LOC_ZERO");
        TPMA_LOCALITY_map.insert(0x2, "LOC_ONE");
        TPMA_LOCALITY_map.insert(0x4, "LOC_TWO");
        TPMA_LOCALITY_map.insert(0x8, "LOC_THREE");
        TPMA_LOCALITY_map.insert(0x10, "LOC_FOUR");
        map.insert(std::any::TypeId::of::<TPMA_LOCALITY>(), TPMA_LOCALITY_map);

        let mut TPMA_PERMANENT_map = HashMap::new();
        TPMA_PERMANENT_map.insert(0x1, "ownerAuthSet");
        TPMA_PERMANENT_map.insert(0x2, "endorsementAuthSet");
        TPMA_PERMANENT_map.insert(0x4, "lockoutAuthSet");
        TPMA_PERMANENT_map.insert(0x100, "disableClear");
        TPMA_PERMANENT_map.insert(0x200, "inLockout");
        TPMA_PERMANENT_map.insert(0x400, "tpmGeneratedEPS");
        map.insert(std::any::TypeId::of::<TPMA_PERMANENT>(), TPMA_PERMANENT_map);

        let mut TPMA_STARTUP_CLEAR_map = HashMap::new();
        TPMA_STARTUP_CLEAR_map.insert(0x1, "phEnable");
        TPMA_STARTUP_CLEAR_map.insert(0x2, "shEnable");
        TPMA_STARTUP_CLEAR_map.insert(0x4, "ehEnable");
        TPMA_STARTUP_CLEAR_map.insert(0x8, "phEnableNV");
        TPMA_STARTUP_CLEAR_map.insert(0xFFFFFFFF80000000, "orderly");
        map.insert(std::any::TypeId::of::<TPMA_STARTUP_CLEAR>(), TPMA_STARTUP_CLEAR_map);

        let mut TPMA_MEMORY_map = HashMap::new();
        TPMA_MEMORY_map.insert(0x1, "sharedRAM");
        TPMA_MEMORY_map.insert(0x2, "sharedNV");
        TPMA_MEMORY_map.insert(0x4, "objectCopiedToRam");
        map.insert(std::any::TypeId::of::<TPMA_MEMORY>(), TPMA_MEMORY_map);

        let mut TPMA_CC_map = HashMap::new();
        TPMA_CC_map.insert(0x400000, "nv");
        TPMA_CC_map.insert(0x800000, "extensive");
        TPMA_CC_map.insert(0x1000000, "flushed");
        TPMA_CC_map.insert(0x10000000, "rHandle");
        TPMA_CC_map.insert(0x20000000, "V");
        map.insert(std::any::TypeId::of::<TPMA_CC>(), TPMA_CC_map);

        let mut TPMA_MODES_map = HashMap::new();
        TPMA_MODES_map.insert(0x1, "FIPS_140_2");
        map.insert(std::any::TypeId::of::<TPMA_MODES>(), TPMA_MODES_map);

        let  TPMA_X509_KEY_USAGE_map = HashMap::new();
        map.insert(std::any::TypeId::of::<TPMA_X509_KEY_USAGE>(), TPMA_X509_KEY_USAGE_map);

        let mut TPMA_ACT_map = HashMap::new();
        TPMA_ACT_map.insert(0x1, "signaled");
        TPMA_ACT_map.insert(0x2, "preserveSignaled");
        map.insert(std::any::TypeId::of::<TPMA_ACT>(), TPMA_ACT_map);

        let  TPM_NV_INDEX_map = HashMap::new();
        map.insert(std::any::TypeId::of::<TPM_NV_INDEX>(), TPM_NV_INDEX_map);

        let  TPMA_NV_map = HashMap::new();
        map.insert(std::any::TypeId::of::<TPMA_NV>(), TPMA_NV_map);

        map
    };

    /// Maps enum type IDs to a map of string representations to values
    static ref STR_TO_ENUM_MAP: HashMap<std::any::TypeId, HashMap<&'static str, u32>> = {
    let mut map = HashMap::new();
        let  TPM_ALG_ID_map = HashMap::new();
        map.insert(std::any::TypeId::of::<TPM_ALG_ID>(), TPM_ALG_ID_map);

        let mut TPM_ECC_CURVE_map = HashMap::new();
        TPM_ECC_CURVE_map.insert("NONE", 0x0);
        TPM_ECC_CURVE_map.insert("NIST_P192", 0x1);
        TPM_ECC_CURVE_map.insert("NIST_P224", 0x2);
        TPM_ECC_CURVE_map.insert("NIST_P256", 0x3);
        TPM_ECC_CURVE_map.insert("NIST_P384", 0x4);
        TPM_ECC_CURVE_map.insert("NIST_P521", 0x5);
        TPM_ECC_CURVE_map.insert("BN_P256", 0x10);
        TPM_ECC_CURVE_map.insert("BN_P638", 0x11);
        TPM_ECC_CURVE_map.insert("SM2_P256", 0x20);
        TPM_ECC_CURVE_map.insert("TEST_P192", 0x21);
        map.insert(std::any::TypeId::of::<TPM_ECC_CURVE>(), TPM_ECC_CURVE_map);

        let mut SHA1_map = HashMap::new();
        SHA1_map.insert("DIGEST_SIZE", 0x14);
        SHA1_map.insert("BLOCK_SIZE", 0x40);
        map.insert(std::any::TypeId::of::<SHA1>(), SHA1_map);

        let mut SHA256_map = HashMap::new();
        SHA256_map.insert("DIGEST_SIZE", 0x20);
        SHA256_map.insert("BLOCK_SIZE", 0x40);
        map.insert(std::any::TypeId::of::<SHA256>(), SHA256_map);

        let mut SHA384_map = HashMap::new();
        SHA384_map.insert("DIGEST_SIZE", 0x30);
        SHA384_map.insert("BLOCK_SIZE", 0x80);
        map.insert(std::any::TypeId::of::<SHA384>(), SHA384_map);

        let mut SHA512_map = HashMap::new();
        SHA512_map.insert("DIGEST_SIZE", 0x40);
        SHA512_map.insert("BLOCK_SIZE", 0x80);
        map.insert(std::any::TypeId::of::<SHA512>(), SHA512_map);

        let mut SM3_256_map = HashMap::new();
        SM3_256_map.insert("DIGEST_SIZE", 0x20);
        SM3_256_map.insert("BLOCK_SIZE", 0x40);
        map.insert(std::any::TypeId::of::<SM3_256>(), SM3_256_map);

        let mut SHA3_256_map = HashMap::new();
        SHA3_256_map.insert("DIGEST_SIZE", 0x20);
        SHA3_256_map.insert("BLOCK_SIZE", 0x88);
        map.insert(std::any::TypeId::of::<SHA3_256>(), SHA3_256_map);

        let mut SHA3_384_map = HashMap::new();
        SHA3_384_map.insert("DIGEST_SIZE", 0x30);
        SHA3_384_map.insert("BLOCK_SIZE", 0x68);
        map.insert(std::any::TypeId::of::<SHA3_384>(), SHA3_384_map);

        let mut SHA3_512_map = HashMap::new();
        SHA3_512_map.insert("DIGEST_SIZE", 0x40);
        SHA3_512_map.insert("BLOCK_SIZE", 0x48);
        map.insert(std::any::TypeId::of::<SHA3_512>(), SHA3_512_map);

        let  Logic_map = HashMap::new();
        map.insert(std::any::TypeId::of::<Logic>(), Logic_map);

        let mut TPM_SPEC_map = HashMap::new();
        TPM_SPEC_map.insert("FAMILY", 0x322E3000);
        TPM_SPEC_map.insert("LEVEL", 0x0);
        TPM_SPEC_map.insert("VERSION", 0xA2);
        TPM_SPEC_map.insert("YEAR", 0x7E3);
        TPM_SPEC_map.insert("DAY_OF_YEAR", 0x168);
        map.insert(std::any::TypeId::of::<TPM_SPEC>(), TPM_SPEC_map);

        let mut TPM_GENERATED_map = HashMap::new();
        TPM_GENERATED_map.insert("VALUE", 0xFF544347);
        map.insert(std::any::TypeId::of::<TPM_GENERATED>(), TPM_GENERATED_map);

        let  TPM_CC_map = HashMap::new();
        map.insert(std::any::TypeId::of::<TPM_CC>(), TPM_CC_map);

        let  Implementation_Constants_map = HashMap::new();
        map.insert(std::any::TypeId::of::<ImplementationConstants>(), Implementation_Constants_map);

        let  TPM_RC_map = HashMap::new();
        map.insert(std::any::TypeId::of::<TPM_RC>(), TPM_RC_map);

        let mut TPM_CLOCK_ADJUST_map = HashMap::new();
        TPM_CLOCK_ADJUST_map.insert("COARSE_SLOWER", 0xFFFFFFFFFFFFFFFD);
        TPM_CLOCK_ADJUST_map.insert("MEDIUM_SLOWER", 0xFFFFFFFFFFFFFFFE);
        TPM_CLOCK_ADJUST_map.insert("FINE_SLOWER", 0xFFFFFFFFFFFFFFFF);
        TPM_CLOCK_ADJUST_map.insert("NO_CHANGE", 0x0);
        TPM_CLOCK_ADJUST_map.insert("FINE_FASTER", 0x1);
        TPM_CLOCK_ADJUST_map.insert("MEDIUM_FASTER", 0x2);
        TPM_CLOCK_ADJUST_map.insert("COARSE_FASTER", 0x3);
        map.insert(std::any::TypeId::of::<TPM_CLOCK_ADJUST>(), TPM_CLOCK_ADJUST_map);

        let mut TPM_EO_map = HashMap::new();
        TPM_EO_map.insert("EQ", 0x0);
        TPM_EO_map.insert("NEQ", 0x1);
        TPM_EO_map.insert("SIGNED_GT", 0x2);
        TPM_EO_map.insert("UNSIGNED_GT", 0x3);
        TPM_EO_map.insert("SIGNED_LT", 0x4);
        TPM_EO_map.insert("UNSIGNED_LT", 0x5);
        TPM_EO_map.insert("SIGNED_GE", 0x6);
        TPM_EO_map.insert("UNSIGNED_GE", 0x7);
        TPM_EO_map.insert("SIGNED_LE", 0x8);
        TPM_EO_map.insert("UNSIGNED_LE", 0x9);
        TPM_EO_map.insert("BITSET", 0xA);
        TPM_EO_map.insert("BITCLEAR", 0xB);
        map.insert(std::any::TypeId::of::<TPM_EO>(), TPM_EO_map);

        let mut TPM_ST_map = HashMap::new();
        TPM_ST_map.insert("RSP_COMMAND", 0xC4);
        TPM_ST_map.insert("NULL", 0x8000);
        TPM_ST_map.insert("NO_SESSIONS", 0x8001);
        TPM_ST_map.insert("SESSIONS", 0x8002);
        TPM_ST_map.insert("ATTEST_NV", 0x8014);
        TPM_ST_map.insert("ATTEST_COMMAND_AUDIT", 0x8015);
        TPM_ST_map.insert("ATTEST_SESSION_AUDIT", 0x8016);
        TPM_ST_map.insert("ATTEST_CERTIFY", 0x8017);
        TPM_ST_map.insert("ATTEST_QUOTE", 0x8018);
        TPM_ST_map.insert("ATTEST_TIME", 0x8019);
        TPM_ST_map.insert("ATTEST_CREATION", 0x801A);
        TPM_ST_map.insert("ATTEST_NV_DIGEST", 0x801C);
        TPM_ST_map.insert("CREATION", 0x8021);
        TPM_ST_map.insert("VERIFIED", 0x8022);
        TPM_ST_map.insert("AUTH_SECRET", 0x8023);
        TPM_ST_map.insert("HASHCHECK", 0x8024);
        TPM_ST_map.insert("AUTH_SIGNED", 0x8025);
        TPM_ST_map.insert("FU_MANIFEST", 0x8029);
        map.insert(std::any::TypeId::of::<TPM_ST>(), TPM_ST_map);

        let mut TPM_SU_map = HashMap::new();
        TPM_SU_map.insert("CLEAR", 0x0);
        TPM_SU_map.insert("STATE", 0x1);
        map.insert(std::any::TypeId::of::<TPM_SU>(), TPM_SU_map);

        let mut TPM_SE_map = HashMap::new();
        TPM_SE_map.insert("HMAC", 0x0);
        TPM_SE_map.insert("POLICY", 0x1);
        TPM_SE_map.insert("TRIAL", 0x3);
        map.insert(std::any::TypeId::of::<TPM_SE>(), TPM_SE_map);

        let  TPM_CAP_map = HashMap::new();
        map.insert(std::any::TypeId::of::<TPM_CAP>(), TPM_CAP_map);

        let mut TPM_PT_map = HashMap::new();
        TPM_PT_map.insert("NONE", 0x0);
        TPM_PT_map.insert("PT_GROUP", 0x100);
        TPM_PT_map.insert("PT_FIXED", 0x100);
        TPM_PT_map.insert("FAMILY_INDICATOR", 0x100);
        TPM_PT_map.insert("LEVEL", 0x101);
        TPM_PT_map.insert("REVISION", 0x102);
        TPM_PT_map.insert("DAY_OF_YEAR", 0x103);
        TPM_PT_map.insert("YEAR", 0x104);
        TPM_PT_map.insert("MANUFACTURER", 0x105);
        TPM_PT_map.insert("VENDOR_STRING_1", 0x106);
        TPM_PT_map.insert("VENDOR_STRING_2", 0x107);
        TPM_PT_map.insert("VENDOR_STRING_3", 0x108);
        TPM_PT_map.insert("VENDOR_STRING_4", 0x109);
        TPM_PT_map.insert("VENDOR_TPM_TYPE", 0x10A);
        TPM_PT_map.insert("FIRMWARE_VERSION_1", 0x10B);
        TPM_PT_map.insert("FIRMWARE_VERSION_2", 0x10C);
        TPM_PT_map.insert("INPUT_BUFFER", 0x10D);
        TPM_PT_map.insert("HR_TRANSIENT_MIN", 0x10E);
        TPM_PT_map.insert("HR_PERSISTENT_MIN", 0x10F);
        TPM_PT_map.insert("HR_LOADED_MIN", 0x110);
        TPM_PT_map.insert("ACTIVE_SESSIONS_MAX", 0x111);
        TPM_PT_map.insert("PCR_COUNT", 0x112);
        TPM_PT_map.insert("PCR_SELECT_MIN", 0x113);
        TPM_PT_map.insert("CONTEXT_GAP_MAX", 0x114);
        TPM_PT_map.insert("NV_COUNTERS_MAX", 0x116);
        TPM_PT_map.insert("NV_INDEX_MAX", 0x117);
        TPM_PT_map.insert("MEMORY", 0x118);
        TPM_PT_map.insert("CLOCK_UPDATE", 0x119);
        TPM_PT_map.insert("CONTEXT_HASH", 0x11A);
        TPM_PT_map.insert("CONTEXT_SYM", 0x11B);
        TPM_PT_map.insert("CONTEXT_SYM_SIZE", 0x11C);
        TPM_PT_map.insert("ORDERLY_COUNT", 0x11D);
        TPM_PT_map.insert("MAX_COMMAND_SIZE", 0x11E);
        TPM_PT_map.insert("MAX_RESPONSE_SIZE", 0x11F);
        TPM_PT_map.insert("MAX_DIGEST", 0x120);
        TPM_PT_map.insert("MAX_OBJECT_CONTEXT", 0x121);
        TPM_PT_map.insert("MAX_SESSION_CONTEXT", 0x122);
        TPM_PT_map.insert("PS_FAMILY_INDICATOR", 0x123);
        TPM_PT_map.insert("PS_LEVEL", 0x124);
        TPM_PT_map.insert("PS_REVISION", 0x125);
        TPM_PT_map.insert("PS_DAY_OF_YEAR", 0x126);
        TPM_PT_map.insert("PS_YEAR", 0x127);
        TPM_PT_map.insert("SPLIT_MAX", 0x128);
        TPM_PT_map.insert("TOTAL_COMMANDS", 0x129);
        TPM_PT_map.insert("LIBRARY_COMMANDS", 0x12A);
        TPM_PT_map.insert("VENDOR_COMMANDS", 0x12B);
        TPM_PT_map.insert("NV_BUFFER_MAX", 0x12C);
        TPM_PT_map.insert("MODES", 0x12D);
        TPM_PT_map.insert("MAX_CAP_BUFFER", 0x12E);
        TPM_PT_map.insert("PT_VAR", 0x200);
        TPM_PT_map.insert("PERMANENT", 0x200);
        TPM_PT_map.insert("STARTUP_CLEAR", 0x201);
        TPM_PT_map.insert("HR_NV_INDEX", 0x202);
        TPM_PT_map.insert("HR_LOADED", 0x203);
        TPM_PT_map.insert("HR_LOADED_AVAIL", 0x204);
        TPM_PT_map.insert("HR_ACTIVE", 0x205);
        TPM_PT_map.insert("HR_ACTIVE_AVAIL", 0x206);
        TPM_PT_map.insert("HR_TRANSIENT_AVAIL", 0x207);
        TPM_PT_map.insert("HR_PERSISTENT", 0x208);
        TPM_PT_map.insert("HR_PERSISTENT_AVAIL", 0x209);
        TPM_PT_map.insert("NV_COUNTERS", 0x20A);
        TPM_PT_map.insert("NV_COUNTERS_AVAIL", 0x20B);
        TPM_PT_map.insert("ALGORITHM_SET", 0x20C);
        TPM_PT_map.insert("LOADED_CURVES", 0x20D);
        TPM_PT_map.insert("LOCKOUT_COUNTER", 0x20E);
        TPM_PT_map.insert("MAX_AUTH_FAIL", 0x20F);
        TPM_PT_map.insert("LOCKOUT_INTERVAL", 0x210);
        TPM_PT_map.insert("LOCKOUT_RECOVERY", 0x211);
        TPM_PT_map.insert("NV_WRITE_RECOVERY", 0x212);
        TPM_PT_map.insert("AUDIT_COUNTER_0", 0x213);
        TPM_PT_map.insert("AUDIT_COUNTER_1", 0x214);
        map.insert(std::any::TypeId::of::<TPM_PT>(), TPM_PT_map);

        let  TPM_PT_PCR_map = HashMap::new();
        map.insert(std::any::TypeId::of::<TPM_PT_PCR>(), TPM_PT_PCR_map);

        let mut TPM_PS_map = HashMap::new();
        TPM_PS_map.insert("MAIN", 0x0);
        TPM_PS_map.insert("PC", 0x1);
        TPM_PS_map.insert("PDA", 0x2);
        TPM_PS_map.insert("CELL_PHONE", 0x3);
        TPM_PS_map.insert("SERVER", 0x4);
        TPM_PS_map.insert("PERIPHERAL", 0x5);
        TPM_PS_map.insert("TSS", 0x6);
        TPM_PS_map.insert("STORAGE", 0x7);
        TPM_PS_map.insert("AUTHENTICATION", 0x8);
        TPM_PS_map.insert("EMBEDDED", 0x9);
        TPM_PS_map.insert("HARDCOPY", 0xA);
        TPM_PS_map.insert("INFRASTRUCTURE", 0xB);
        TPM_PS_map.insert("VIRTUALIZATION", 0xC);
        TPM_PS_map.insert("TNC", 0xD);
        TPM_PS_map.insert("MULTI_TENANT", 0xE);
        TPM_PS_map.insert("TC", 0xF);
        map.insert(std::any::TypeId::of::<TPM_PS>(), TPM_PS_map);

        let  TPM_HT_map = HashMap::new();
        map.insert(std::any::TypeId::of::<TPM_HT>(), TPM_HT_map);

        let  TPM_RH_map = HashMap::new();
        map.insert(std::any::TypeId::of::<TPM_RH>(), TPM_RH_map);

        let mut TPM_NT_map = HashMap::new();
        TPM_NT_map.insert("ORDINARY", 0x0);
        TPM_NT_map.insert("COUNTER", 0x1);
        TPM_NT_map.insert("BITS", 0x2);
        TPM_NT_map.insert("EXTEND", 0x4);
        TPM_NT_map.insert("PIN_FAIL", 0x8);
        TPM_NT_map.insert("PIN_PASS", 0x9);
        map.insert(std::any::TypeId::of::<TPM_NT>(), TPM_NT_map);

        let mut TPM_AT_map = HashMap::new();
        TPM_AT_map.insert("ANY", 0x0);
        TPM_AT_map.insert("ERROR", 0x1);
        TPM_AT_map.insert("PV1", 0x2);
        TPM_AT_map.insert("VEND", 0x80000000);
        map.insert(std::any::TypeId::of::<TPM_AT>(), TPM_AT_map);

        let mut TPM_AE_map = HashMap::new();
        TPM_AE_map.insert("NONE", 0x0);
        map.insert(std::any::TypeId::of::<TPM_AE>(), TPM_AE_map);

        let mut PLATFORM_map = HashMap::new();
        PLATFORM_map.insert("FAMILY", 0x322E3000);
        PLATFORM_map.insert("LEVEL", 0x0);
        PLATFORM_map.insert("VERSION", 0xA2);
        PLATFORM_map.insert("YEAR", 0x7E3);
        PLATFORM_map.insert("DAY_OF_YEAR", 0x168);
        map.insert(std::any::TypeId::of::<PLATFORM>(), PLATFORM_map);

        let  Implementation_map = HashMap::new();
        map.insert(std::any::TypeId::of::<Implementation>(), Implementation_map);

        let mut TPM_HC_map = HashMap::new();
        TPM_HC_map.insert("HR_HANDLE_MASK", 0xFFFFFF);
        TPM_HC_map.insert("HR_RANGE_MASK", 0xFF000000);
        TPM_HC_map.insert("HR_SHIFT", 0x18);
        TPM_HC_map.insert("HR_PCR", 0x0);
        TPM_HC_map.insert("HR_HMAC_SESSION", 0x2000000);
        TPM_HC_map.insert("HR_POLICY_SESSION", 0x3000000);
        TPM_HC_map.insert("HR_TRANSIENT", 0x80000000);
        TPM_HC_map.insert("HR_PERSISTENT", 0x81000000);
        TPM_HC_map.insert("HR_NV_INDEX", 0x1000000);
        TPM_HC_map.insert("HR_PERMANENT", 0x40000000);
        TPM_HC_map.insert("PCR_FIRST", 0x0);
        TPM_HC_map.insert("PCR_LAST", 0x17);
        TPM_HC_map.insert("HMAC_SESSION_FIRST", 0x2000000);
        TPM_HC_map.insert("HMAC_SESSION_LAST", 0x200003F);
        TPM_HC_map.insert("LOADED_SESSION_FIRST", 0x2000000);
        TPM_HC_map.insert("LOADED_SESSION_LAST", 0x200003F);
        TPM_HC_map.insert("POLICY_SESSION_FIRST", 0x3000000);
        TPM_HC_map.insert("POLICY_SESSION_LAST", 0x300003F);
        TPM_HC_map.insert("TRANSIENT_FIRST", 0x80000000);
        TPM_HC_map.insert("ACTIVE_SESSION_FIRST", 0x3000000);
        TPM_HC_map.insert("ACTIVE_SESSION_LAST", 0x300003F);
        TPM_HC_map.insert("TRANSIENT_LAST", 0x80000002);
        TPM_HC_map.insert("PERSISTENT_FIRST", 0x81000000);
        TPM_HC_map.insert("PERSISTENT_LAST", 0x81FFFFFF);
        TPM_HC_map.insert("PLATFORM_PERSISTENT", 0x81800000);
        TPM_HC_map.insert("NV_INDEX_FIRST", 0x1000000);
        TPM_HC_map.insert("NV_INDEX_LAST", 0x1FFFFFF);
        TPM_HC_map.insert("PERMANENT_FIRST", 0x40000000);
        TPM_HC_map.insert("PERMANENT_LAST", 0x4000011F);
        TPM_HC_map.insert("HR_NV_AC", 0x1D00000);
        TPM_HC_map.insert("NV_AC_FIRST", 0x1D00000);
        TPM_HC_map.insert("NV_AC_LAST", 0x1D0FFFF);
        TPM_HC_map.insert("HR_AC", 0x90000000);
        TPM_HC_map.insert("AC_FIRST", 0x90000000);
        TPM_HC_map.insert("AC_LAST", 0x9000FFFF);
        map.insert(std::any::TypeId::of::<TPM_HC>(), TPM_HC_map);

        let mut TPMA_ALGORITHM_map = HashMap::new();
        TPMA_ALGORITHM_map.insert("asymmetric", 0x1);
        TPMA_ALGORITHM_map.insert("symmetric", 0x2);
        TPMA_ALGORITHM_map.insert("hash", 0x4);
        TPMA_ALGORITHM_map.insert("object", 0x8);
        TPMA_ALGORITHM_map.insert("signing", 0x100);
        TPMA_ALGORITHM_map.insert("encrypting", 0x200);
        TPMA_ALGORITHM_map.insert("method", 0x400);
        map.insert(std::any::TypeId::of::<TPMA_ALGORITHM>(), TPMA_ALGORITHM_map);

        let  TPMA_OBJECT_map = HashMap::new();
        map.insert(std::any::TypeId::of::<TPMA_OBJECT>(), TPMA_OBJECT_map);

        let mut TPMA_SESSION_map = HashMap::new();
        TPMA_SESSION_map.insert("continueSession", 0x1);
        TPMA_SESSION_map.insert("auditExclusive", 0x2);
        TPMA_SESSION_map.insert("auditReset", 0x4);
        TPMA_SESSION_map.insert("decrypt", 0x20);
        TPMA_SESSION_map.insert("encrypt", 0x40);
        TPMA_SESSION_map.insert("audit", 0x80);
        map.insert(std::any::TypeId::of::<TPMA_SESSION>(), TPMA_SESSION_map);

        let mut TPMA_LOCALITY_map = HashMap::new();
        TPMA_LOCALITY_map.insert("LOC_ZERO", 0x1);
        TPMA_LOCALITY_map.insert("LOC_ONE", 0x2);
        TPMA_LOCALITY_map.insert("LOC_TWO", 0x4);
        TPMA_LOCALITY_map.insert("LOC_THREE", 0x8);
        TPMA_LOCALITY_map.insert("LOC_FOUR", 0x10);
        map.insert(std::any::TypeId::of::<TPMA_LOCALITY>(), TPMA_LOCALITY_map);

        let mut TPMA_PERMANENT_map = HashMap::new();
        TPMA_PERMANENT_map.insert("ownerAuthSet", 0x1);
        TPMA_PERMANENT_map.insert("endorsementAuthSet", 0x2);
        TPMA_PERMANENT_map.insert("lockoutAuthSet", 0x4);
        TPMA_PERMANENT_map.insert("disableClear", 0x100);
        TPMA_PERMANENT_map.insert("inLockout", 0x200);
        TPMA_PERMANENT_map.insert("tpmGeneratedEPS", 0x400);
        map.insert(std::any::TypeId::of::<TPMA_PERMANENT>(), TPMA_PERMANENT_map);

        let mut TPMA_STARTUP_CLEAR_map = HashMap::new();
        TPMA_STARTUP_CLEAR_map.insert("phEnable", 0x1);
        TPMA_STARTUP_CLEAR_map.insert("shEnable", 0x2);
        TPMA_STARTUP_CLEAR_map.insert("ehEnable", 0x4);
        TPMA_STARTUP_CLEAR_map.insert("phEnableNV", 0x8);
        TPMA_STARTUP_CLEAR_map.insert("orderly", 0xFFFFFFFF80000000);
        map.insert(std::any::TypeId::of::<TPMA_STARTUP_CLEAR>(), TPMA_STARTUP_CLEAR_map);

        let mut TPMA_MEMORY_map = HashMap::new();
        TPMA_MEMORY_map.insert("sharedRAM", 0x1);
        TPMA_MEMORY_map.insert("sharedNV", 0x2);
        TPMA_MEMORY_map.insert("objectCopiedToRam", 0x4);
        map.insert(std::any::TypeId::of::<TPMA_MEMORY>(), TPMA_MEMORY_map);

        let mut TPMA_CC_map = HashMap::new();
        TPMA_CC_map.insert("nv", 0x400000);
        TPMA_CC_map.insert("extensive", 0x800000);
        TPMA_CC_map.insert("flushed", 0x1000000);
        TPMA_CC_map.insert("rHandle", 0x10000000);
        TPMA_CC_map.insert("V", 0x20000000);
        map.insert(std::any::TypeId::of::<TPMA_CC>(), TPMA_CC_map);

        let mut TPMA_MODES_map = HashMap::new();
        TPMA_MODES_map.insert("FIPS_140_2", 0x1);
        map.insert(std::any::TypeId::of::<TPMA_MODES>(), TPMA_MODES_map);

        let  TPMA_X509_KEY_USAGE_map = HashMap::new();
        map.insert(std::any::TypeId::of::<TPMA_X509_KEY_USAGE>(), TPMA_X509_KEY_USAGE_map);

        let mut TPMA_ACT_map = HashMap::new();
        TPMA_ACT_map.insert("signaled", 0x1);
        TPMA_ACT_map.insert("preserveSignaled", 0x2);
        map.insert(std::any::TypeId::of::<TPMA_ACT>(), TPMA_ACT_map);

        let  TPM_NV_INDEX_map = HashMap::new();
        map.insert(std::any::TypeId::of::<TPM_NV_INDEX>(), TPM_NV_INDEX_map);

        let  TPMA_NV_map = HashMap::new();
        map.insert(std::any::TypeId::of::<TPMA_NV>(), TPMA_NV_map);

        map
    };

}

/// Factory for creating TPM union types from selector values
pub struct UnionFactory;

impl UnionFactory {
    /// Creates a new union instance based on the selector value
    pub fn create<U: TpmUnion>(selector: u32) -> Option<Box<dyn TpmUnion>> {
        let type_id = std::any::TypeId::of::<U>();

        if type_id == std::any::TypeId::of::<TPMU_CAPABILITIES>() {
            match selector {
                TPM_CAP::ALGS => Some(Box::new(TPMU_CAPABILITIES::algorithms(TPML_ALG_PROPERTY::default()))),
                TPM_CAP::HANDLES => Some(Box::new(TPMU_CAPABILITIES::handles(TPML_HANDLE::default()))),
                TPM_CAP::COMMANDS => Some(Box::new(TPMU_CAPABILITIES::command(TPML_CCA::default()))),
                TPM_CAP::PP_COMMANDS => Some(Box::new(TPMU_CAPABILITIES::ppCommands(TPML_CC::default()))),
                TPM_CAP::AUDIT_COMMANDS => Some(Box::new(TPMU_CAPABILITIES::auditCommands(TPML_CC::default()))),
                TPM_CAP::PCRS => Some(Box::new(TPMU_CAPABILITIES::assignedPCR(TPML_PCR_SELECTION::default()))),
                TPM_CAP::TPM_PROPERTIES => Some(Box::new(TPMU_CAPABILITIES::tpmProperties(TPML_TAGGED_TPM_PROPERTY::default()))),
                TPM_CAP::PCR_PROPERTIES => Some(Box::new(TPMU_CAPABILITIES::pcrProperties(TPML_TAGGED_PCR_PROPERTY::default()))),
                TPM_CAP::ECC_CURVES => Some(Box::new(TPMU_CAPABILITIES::eccCurves(TPML_ECC_CURVE::default()))),
                TPM_CAP::AUTH_POLICIES => Some(Box::new(TPMU_CAPABILITIES::authPolicies(TPML_TAGGED_POLICY::default()))),
                TPM_CAP::ACT => Some(Box::new(TPMU_CAPABILITIES::actData(TPML_ACT_DATA::default()))),
                _ => None,
            }

        } else 

        if type_id == std::any::TypeId::of::<TPMU_ATTEST>() {
            match selector {
                TPM_ST::ATTEST_CERTIFY => Some(Box::new(TPMU_ATTEST::certify(TPMS_CERTIFY_INFO::default()))),
                TPM_ST::ATTEST_CREATION => Some(Box::new(TPMU_ATTEST::creation(TPMS_CREATION_INFO::default()))),
                TPM_ST::ATTEST_QUOTE => Some(Box::new(TPMU_ATTEST::quote(TPMS_QUOTE_INFO::default()))),
                TPM_ST::ATTEST_COMMAND_AUDIT => Some(Box::new(TPMU_ATTEST::commandAudit(TPMS_COMMAND_AUDIT_INFO::default()))),
                TPM_ST::ATTEST_SESSION_AUDIT => Some(Box::new(TPMU_ATTEST::sessionAudit(TPMS_SESSION_AUDIT_INFO::default()))),
                TPM_ST::ATTEST_TIME => Some(Box::new(TPMU_ATTEST::time(TPMS_TIME_ATTEST_INFO::default()))),
                TPM_ST::ATTEST_NV => Some(Box::new(TPMU_ATTEST::nv(TPMS_NV_CERTIFY_INFO::default()))),
                TPM_ST::ATTEST_NV_DIGEST => Some(Box::new(TPMU_ATTEST::nvDigest(TPMS_NV_DIGEST_CERTIFY_INFO::default()))),
                _ => None,
            }

        } else 

        if type_id == std::any::TypeId::of::<TPMU_SYM_DETAILS>() {
            match selector {
                TPM_ALG_ID::TDES => Some(Box::new(TPMU_SYM_DETAILS::tdes(TPMS_TDES_SYM_DETAILS::default()))),
                TPM_ALG_ID::AES => Some(Box::new(TPMU_SYM_DETAILS::aes(TPMS_AES_SYM_DETAILS::default()))),
                TPM_ALG_ID::SM4 => Some(Box::new(TPMU_SYM_DETAILS::sm4(TPMS_SM4_SYM_DETAILS::default()))),
                TPM_ALG_ID::CAMELLIA => Some(Box::new(TPMU_SYM_DETAILS::camellia(TPMS_CAMELLIA_SYM_DETAILS::default()))),
                TPM_ALG_ID::ANY => Some(Box::new(TPMU_SYM_DETAILS::sym(TPMS_ANY_SYM_DETAILS::default()))),
                TPM_ALG_ID::XOR => Some(Box::new(TPMU_SYM_DETAILS::xor(TPMS_XOR_SYM_DETAILS::default()))),
                TPM_ALG_ID::NULL => Some(Box::new(TPMU_SYM_DETAILS::null(TPMS_NULL_SYM_DETAILS::default()))),
                _ => None,
            }

        } else 

        if type_id == std::any::TypeId::of::<TPMU_SENSITIVE_CREATE>() {
            match selector {
                TPM_ALG_ID::ANY => Some(Box::new(TPMU_SENSITIVE_CREATE::create)),
                TPM_ALG_ID::ANY2 => Some(Box::new(TPMU_SENSITIVE_CREATE::derive(TPMS_DERIVE::default()))),
                _ => None,
            }

        } else 

        if type_id == std::any::TypeId::of::<TPMU_SCHEME_KEYEDHASH>() {
            match selector {
                TPM_ALG_ID::HMAC => Some(Box::new(TPMU_SCHEME_KEYEDHASH::hmac(TPMS_SCHEME_HMAC::default()))),
                TPM_ALG_ID::XOR => Some(Box::new(TPMU_SCHEME_KEYEDHASH::xor(TPMS_SCHEME_XOR::default()))),
                TPM_ALG_ID::NULL => Some(Box::new(TPMU_SCHEME_KEYEDHASH::null(TPMS_NULL_SCHEME_KEYEDHASH::default()))),
                _ => None,
            }

        } else 

        if type_id == std::any::TypeId::of::<TPMU_SIG_SCHEME>() {
            match selector {
                TPM_ALG_ID::RSASSA => Some(Box::new(TPMU_SIG_SCHEME::rsassa(TPMS_SIG_SCHEME_RSASSA::default()))),
                TPM_ALG_ID::RSAPSS => Some(Box::new(TPMU_SIG_SCHEME::rsapss(TPMS_SIG_SCHEME_RSAPSS::default()))),
                TPM_ALG_ID::ECDSA => Some(Box::new(TPMU_SIG_SCHEME::ecdsa(TPMS_SIG_SCHEME_ECDSA::default()))),
                TPM_ALG_ID::ECDAA => Some(Box::new(TPMU_SIG_SCHEME::ecdaa(TPMS_SIG_SCHEME_ECDAA::default()))),
                TPM_ALG_ID::SM2 => Some(Box::new(TPMU_SIG_SCHEME::sm2(TPMS_SIG_SCHEME_SM2::default()))),
                TPM_ALG_ID::ECSCHNORR => Some(Box::new(TPMU_SIG_SCHEME::ecschnorr(TPMS_SIG_SCHEME_ECSCHNORR::default()))),
                TPM_ALG_ID::HMAC => Some(Box::new(TPMU_SIG_SCHEME::hmac(TPMS_SCHEME_HMAC::default()))),
                TPM_ALG_ID::ANY => Some(Box::new(TPMU_SIG_SCHEME::any(TPMS_SCHEME_HASH::default()))),
                TPM_ALG_ID::NULL => Some(Box::new(TPMU_SIG_SCHEME::null(TPMS_NULL_SIG_SCHEME::default()))),
                _ => None,
            }

        } else 

        if type_id == std::any::TypeId::of::<TPMU_KDF_SCHEME>() {
            match selector {
                TPM_ALG_ID::MGF1 => Some(Box::new(TPMU_KDF_SCHEME::mgf1(TPMS_KDF_SCHEME_MGF1::default()))),
                TPM_ALG_ID::KDF1_SP800_56A => Some(Box::new(TPMU_KDF_SCHEME::kdf1_sp800_56a(TPMS_KDF_SCHEME_KDF1_SP800_56A::default()))),
                TPM_ALG_ID::KDF2 => Some(Box::new(TPMU_KDF_SCHEME::kdf2(TPMS_KDF_SCHEME_KDF2::default()))),
                TPM_ALG_ID::KDF1_SP800_108 => Some(Box::new(TPMU_KDF_SCHEME::kdf1_sp800_108(TPMS_KDF_SCHEME_KDF1_SP800_108::default()))),
                TPM_ALG_ID::ANY => Some(Box::new(TPMU_KDF_SCHEME::anyKdf(TPMS_SCHEME_HASH::default()))),
                TPM_ALG_ID::NULL => Some(Box::new(TPMU_KDF_SCHEME::null(TPMS_NULL_KDF_SCHEME::default()))),
                _ => None,
            }

        } else 

        if type_id == std::any::TypeId::of::<TPMU_ASYM_SCHEME>() {
            match selector {
                TPM_ALG_ID::ECDH => Some(Box::new(TPMU_ASYM_SCHEME::ecdh(TPMS_KEY_SCHEME_ECDH::default()))),
                TPM_ALG_ID::ECMQV => Some(Box::new(TPMU_ASYM_SCHEME::ecmqv(TPMS_KEY_SCHEME_ECMQV::default()))),
                TPM_ALG_ID::RSASSA => Some(Box::new(TPMU_ASYM_SCHEME::rsassa(TPMS_SIG_SCHEME_RSASSA::default()))),
                TPM_ALG_ID::RSAPSS => Some(Box::new(TPMU_ASYM_SCHEME::rsapss(TPMS_SIG_SCHEME_RSAPSS::default()))),
                TPM_ALG_ID::ECDSA => Some(Box::new(TPMU_ASYM_SCHEME::ecdsa(TPMS_SIG_SCHEME_ECDSA::default()))),
                TPM_ALG_ID::ECDAA => Some(Box::new(TPMU_ASYM_SCHEME::ecdaa(TPMS_SIG_SCHEME_ECDAA::default()))),
                TPM_ALG_ID::SM2 => Some(Box::new(TPMU_ASYM_SCHEME::sm2(TPMS_SIG_SCHEME_SM2::default()))),
                TPM_ALG_ID::ECSCHNORR => Some(Box::new(TPMU_ASYM_SCHEME::ecschnorr(TPMS_SIG_SCHEME_ECSCHNORR::default()))),
                TPM_ALG_ID::RSAES => Some(Box::new(TPMU_ASYM_SCHEME::rsaes(TPMS_ENC_SCHEME_RSAES::default()))),
                TPM_ALG_ID::OAEP => Some(Box::new(TPMU_ASYM_SCHEME::oaep(TPMS_ENC_SCHEME_OAEP::default()))),
                TPM_ALG_ID::ANY => Some(Box::new(TPMU_ASYM_SCHEME::anySig(TPMS_SCHEME_HASH::default()))),
                TPM_ALG_ID::NULL => Some(Box::new(TPMU_ASYM_SCHEME::null(TPMS_NULL_ASYM_SCHEME::default()))),
                _ => None,
            }

        } else 

        if type_id == std::any::TypeId::of::<TPMU_SIGNATURE>() {
            match selector {
                TPM_ALG_ID::RSASSA => Some(Box::new(TPMU_SIGNATURE::rsassa(TPMS_SIGNATURE_RSASSA::default()))),
                TPM_ALG_ID::RSAPSS => Some(Box::new(TPMU_SIGNATURE::rsapss(TPMS_SIGNATURE_RSAPSS::default()))),
                TPM_ALG_ID::ECDSA => Some(Box::new(TPMU_SIGNATURE::ecdsa(TPMS_SIGNATURE_ECDSA::default()))),
                TPM_ALG_ID::ECDAA => Some(Box::new(TPMU_SIGNATURE::ecdaa(TPMS_SIGNATURE_ECDAA::default()))),
                TPM_ALG_ID::SM2 => Some(Box::new(TPMU_SIGNATURE::sm2(TPMS_SIGNATURE_SM2::default()))),
                TPM_ALG_ID::ECSCHNORR => Some(Box::new(TPMU_SIGNATURE::ecschnorr(TPMS_SIGNATURE_ECSCHNORR::default()))),
                TPM_ALG_ID::HMAC => Some(Box::new(TPMU_SIGNATURE::hmac(TPMT_HA::default()))),
                TPM_ALG_ID::ANY => Some(Box::new(TPMU_SIGNATURE::any(TPMS_SCHEME_HASH::default()))),
                TPM_ALG_ID::NULL => Some(Box::new(TPMU_SIGNATURE::null(TPMS_NULL_SIGNATURE::default()))),
                _ => None,
            }

        } else 

        if type_id == std::any::TypeId::of::<TPMU_PUBLIC_ID>() {
            match selector {
                TPM_ALG_ID::KEYEDHASH => Some(Box::new(TPMU_PUBLIC_ID::keyedHash(TPM2B_DIGEST_KEYEDHASH::default()))),
                TPM_ALG_ID::SYMCIPHER => Some(Box::new(TPMU_PUBLIC_ID::sym(TPM2B_DIGEST_SYMCIPHER::default()))),
                TPM_ALG_ID::RSA => Some(Box::new(TPMU_PUBLIC_ID::rsa(TPM2B_PUBLIC_KEY_RSA::default()))),
                TPM_ALG_ID::ECC => Some(Box::new(TPMU_PUBLIC_ID::ecc(TPMS_ECC_POINT::default()))),
                TPM_ALG_ID::ANY => Some(Box::new(TPMU_PUBLIC_ID::derive(TPMS_DERIVE::default()))),
                _ => None,
            }

        } else 

        if type_id == std::any::TypeId::of::<TPMU_PUBLIC_PARMS>() {
            match selector {
                TPM_ALG_ID::KEYEDHASH => Some(Box::new(TPMU_PUBLIC_PARMS::keyedHashDetail(TPMS_KEYEDHASH_PARMS::default()))),
                TPM_ALG_ID::SYMCIPHER => Some(Box::new(TPMU_PUBLIC_PARMS::symDetail(TPMS_SYMCIPHER_PARMS::default()))),
                TPM_ALG_ID::RSA => Some(Box::new(TPMU_PUBLIC_PARMS::rsaDetail(TPMS_RSA_PARMS::default()))),
                TPM_ALG_ID::ECC => Some(Box::new(TPMU_PUBLIC_PARMS::eccDetail(TPMS_ECC_PARMS::default()))),
                TPM_ALG_ID::ANY => Some(Box::new(TPMU_PUBLIC_PARMS::asymDetail(TPMS_ASYM_PARMS::default()))),
                _ => None,
            }

        } else 

        if type_id == std::any::TypeId::of::<TPMU_SENSITIVE_COMPOSITE>() {
            match selector {
                TPM_ALG_ID::RSA => Some(Box::new(TPMU_SENSITIVE_COMPOSITE::rsa(TPM2B_PRIVATE_KEY_RSA::default()))),
                TPM_ALG_ID::ECC => Some(Box::new(TPMU_SENSITIVE_COMPOSITE::ecc(TPM2B_ECC_PARAMETER::default()))),
                TPM_ALG_ID::KEYEDHASH => Some(Box::new(TPMU_SENSITIVE_COMPOSITE::bits(TPM2B_SENSITIVE_DATA::default()))),
                TPM_ALG_ID::SYMCIPHER => Some(Box::new(TPMU_SENSITIVE_COMPOSITE::sym(TPM2B_SYM_KEY::default()))),
                TPM_ALG_ID::ANY => Some(Box::new(TPMU_SENSITIVE_COMPOSITE::any(TPM2B_PRIVATE_VENDOR_SPECIFIC::default()))),
                _ => None,
            }

        } else 

        {
        None
        }

    }

}

impl TPM_HANDLE {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u32(self.handle)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.handle = buffer.read_u32()?;
        Ok(())
    }

}

impl TPMS_NULL_UNION {
    // Implement serialization/deserialization
    /// No fields to serialize/deserialize
    pub fn serialize(&self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

    pub fn deserialize(&mut self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

}

impl TPMS_EMPTY {
    // Implement serialization/deserialization
    /// No fields to serialize/deserialize
    pub fn serialize(&self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

    pub fn deserialize(&mut self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

}

impl TPMS_ALGORITHM_DESCRIPTION {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u32(self.alg.get_value())?;
        buffer.write_u32(self.attributes.get_value())?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        let alg_value = buffer.read_u32()?;
        self.alg = TPM_ALG_ID::try_from(alg_value as i16)?;
        let attributes_value = buffer.read_u32()?;
        self.attributes = TPMA_ALGORITHM::try_from(attributes_value)?;
        Ok(())
    }

}

impl TPMT_HA {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u32(self.hash_Alg.get_value())?;
        buffer.write_u8(self.digest)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        let hash_Alg_value = buffer.read_u32()?;
        self.hash_Alg = TPM_ALG_ID::try_from(hash_Alg_value)?;
        self.digest = buffer.read_u8()?;
        Ok(())
    }

}

impl TPM2B_DIGEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.buffer)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.buffer = buffer.read_u8()?;
        Ok(())
    }

}

impl TPM2B_DATA {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.buffer)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.buffer = buffer.read_u8()?;
        Ok(())
    }

}

impl TPM2B_EVENT {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.buffer)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.buffer = buffer.read_u8()?;
        Ok(())
    }

}

impl TPM2B_MAX_BUFFER {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.buffer)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.buffer = buffer.read_u8()?;
        Ok(())
    }

}

impl TPM2B_MAX_NV_BUFFER {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.buffer)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.buffer = buffer.read_u8()?;
        Ok(())
    }

}

impl TPM2B_TIMEOUT {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.buffer)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.buffer = buffer.read_u8()?;
        Ok(())
    }

}

impl TPM2B_IV {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.buffer)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.buffer = buffer.read_u8()?;
        Ok(())
    }

}

impl TPM2B_NAME {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.name)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.name = buffer.read_u8()?;
        Ok(())
    }

}

impl TPMS_PCR_SELECT {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.pcr_Select)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.pcr_Select = buffer.read_u8()?;
        Ok(())
    }

}

impl TPMS_PCR_SELECTION {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u32(self.hash.get_value())?;
        buffer.write_u8(self.pcr_Select)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        let hash_value = buffer.read_u32()?;
        self.hash = TPM_ALG_ID::try_from(hash_value)?;
        self.pcr_Select = buffer.read_u8()?;
        Ok(())
    }

}

impl TPMT_TK_CREATION {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        // Constant value: TPM_ST::CREATION
        buffer.write_u32(TPM_ST::CREATION)?;
        self.hierarchy.serialize(buffer)?;
        buffer.write_u8(self.digest)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        // Constant value: TPM_ST::CREATION
        let tag = buffer.read_u32()?;
        if tag != TPM_ST::CREATION {
        return Err(TpmError::IncorrectTag(TPM_ST::CREATION, tag));
        }

        self.hierarchy.deserialize(buffer)?;
        self.digest = buffer.read_u8()?;
        Ok(())
    }

}

impl TPMT_TK_VERIFIED {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        // Constant value: TPM_ST::VERIFIED
        buffer.write_u32(TPM_ST::VERIFIED)?;
        self.hierarchy.serialize(buffer)?;
        buffer.write_u8(self.digest)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        // Constant value: TPM_ST::VERIFIED
        let tag = buffer.read_u32()?;
        if tag != TPM_ST::VERIFIED {
        return Err(TpmError::IncorrectTag(TPM_ST::VERIFIED, tag));
        }

        self.hierarchy.deserialize(buffer)?;
        self.digest = buffer.read_u8()?;
        Ok(())
    }

}

impl TPMT_TK_AUTH {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u32(self.tag.get_value())?;
        self.hierarchy.serialize(buffer)?;
        buffer.write_u8(self.digest)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        let tag_value = buffer.read_u32()?;
        self.tag = TPM_ST::try_from(tag_value)?;
        self.hierarchy.deserialize(buffer)?;
        self.digest = buffer.read_u8()?;
        Ok(())
    }

}

impl TPMT_TK_HASHCHECK {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        // Constant value: TPM_ST::HASHCHECK
        buffer.write_u32(TPM_ST::HASHCHECK)?;
        self.hierarchy.serialize(buffer)?;
        buffer.write_u8(self.digest)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        // Constant value: TPM_ST::HASHCHECK
        let tag = buffer.read_u32()?;
        if tag != TPM_ST::HASHCHECK {
        return Err(TpmError::IncorrectTag(TPM_ST::HASHCHECK, tag));
        }

        self.hierarchy.deserialize(buffer)?;
        self.digest = buffer.read_u8()?;
        Ok(())
    }

}

impl TPMS_ALG_PROPERTY {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u32(self.alg.get_value())?;
        buffer.write_u32(self.alg_Properties.get_value())?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        let alg_value = buffer.read_u32()?;
        self.alg = TPM_ALG_ID::try_from(alg_value as i16)?;
        let alg_Properties_value = buffer.read_u32()?;
        self.alg_Properties = TPMA_ALGORITHM::try_from(alg_Properties_value)?;
        Ok(())
    }

}

impl TPMS_TAGGED_PROPERTY {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u32(self.property.get_value())?;
        buffer.write_u32(self.value)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        let property_value = buffer.read_u32()?;
        self.property = TPM_PT::try_from(property_value)?;
        self.value = buffer.read_u32()?;
        Ok(())
    }

}

impl TPMS_TAGGED_PCR_SELECT {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u32(self.tag.get_value())?;
        buffer.write_u8(self.pcr_Select)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        let tag_value = buffer.read_u32()?;
        self.tag = TPM_PT_PCR::try_from(tag_value as i32)?;
        self.pcr_Select = buffer.read_u8()?;
        Ok(())
    }

}

impl TPMS_TAGGED_POLICY {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.handle.serialize(buffer)?;
        self.policy_Hash.serialize(buffer)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.handle.deserialize(buffer)?;
        self.policy_Hash.deserialize(buffer)?;
        Ok(())
    }

}

impl TPMS_ACT_DATA {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.handle.serialize(buffer)?;
        buffer.write_u32(self.timeout)?;
        buffer.write_u32(self.attributes.get_value())?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.handle.deserialize(buffer)?;
        self.timeout = buffer.read_u32()?;
        let attributes_value = buffer.read_u32()?;
        self.attributes = TPMA_ACT::try_from(attributes_value)?;
        Ok(())
    }

}

impl TPML_CC {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u32(self.command_Codes.get_value())?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        let command_Codes_value = buffer.read_u32()?;
        self.command_Codes = Vec<TPM_CC>::try_from(command_Codes_value as i32)?;
        Ok(())
    }

}

impl TPML_CCA {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u32(self.command_Attributes.get_value())?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        let command_Attributes_value = buffer.read_u32()?;
        self.command_Attributes = Vec<TPMA_CC>::try_from(command_Attributes_value)?;
        Ok(())
    }

}

impl TPML_ALG {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u32(self.algorithms.get_value())?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        let algorithms_value = buffer.read_u32()?;
        self.algorithms = Vec<TPM_ALG_ID>::try_from(algorithms_value as i16)?;
        Ok(())
    }

}

impl TPML_HANDLE {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        // List count
        buffer.write_u32(self.handle.len() as u32)?;
        for item in &self.handle {
            item.serialize(buffer)?;
        }

        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        // List count
        let handle_count = buffer.read_u32()? as usize;
        self.handle.clear();
        for _ in 0..handle_count {
            let mut item = TPM_HANDLE::default();
            item.deserialize(buffer)?;
            self.handle.push(item);
        }

        Ok(())
    }

}

impl TPML_DIGEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        // List count
        buffer.write_u32(self.digests.len() as u32)?;
        for item in &self.digests {
            item.serialize(buffer)?;
        }

        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        // List count
        let digests_count = buffer.read_u32()? as usize;
        self.digests.clear();
        for _ in 0..digests_count {
            let mut item = TPM2B_DIGEST::default();
            item.deserialize(buffer)?;
            self.digests.push(item);
        }

        Ok(())
    }

}

impl TPML_DIGEST_VALUES {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        // List count
        buffer.write_u32(self.digests.len() as u32)?;
        for item in &self.digests {
            item.serialize(buffer)?;
        }

        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        // List count
        let digests_count = buffer.read_u32()? as usize;
        self.digests.clear();
        for _ in 0..digests_count {
            let mut item = TPMT_HA::default();
            item.deserialize(buffer)?;
            self.digests.push(item);
        }

        Ok(())
    }

}

impl TPML_PCR_SELECTION {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        // List count
        buffer.write_u32(self.pcr_Selections.len() as u32)?;
        for item in &self.pcr_Selections {
            item.serialize(buffer)?;
        }

        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        // List count
        let pcr_Selections_count = buffer.read_u32()? as usize;
        self.pcr_Selections.clear();
        for _ in 0..pcr_Selections_count {
            let mut item = TPMS_PCR_SELECTION::default();
            item.deserialize(buffer)?;
            self.pcr_Selections.push(item);
        }

        Ok(())
    }

}

impl TPML_ALG_PROPERTY {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        // List count
        buffer.write_u32(self.alg_Properties.len() as u32)?;
        for item in &self.alg_Properties {
            item.serialize(buffer)?;
        }

        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        // List count
        let alg_Properties_count = buffer.read_u32()? as usize;
        self.alg_Properties.clear();
        for _ in 0..alg_Properties_count {
            let mut item = TPMS_ALG_PROPERTY::default();
            item.deserialize(buffer)?;
            self.alg_Properties.push(item);
        }

        Ok(())
    }

}

impl TPML_TAGGED_TPM_PROPERTY {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        // List count
        buffer.write_u32(self.tpm_Property.len() as u32)?;
        for item in &self.tpm_Property {
            item.serialize(buffer)?;
        }

        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        // List count
        let tpm_Property_count = buffer.read_u32()? as usize;
        self.tpm_Property.clear();
        for _ in 0..tpm_Property_count {
            let mut item = TPMS_TAGGED_PROPERTY::default();
            item.deserialize(buffer)?;
            self.tpm_Property.push(item);
        }

        Ok(())
    }

}

impl TPML_TAGGED_PCR_PROPERTY {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        // List count
        buffer.write_u32(self.pcr_Property.len() as u32)?;
        for item in &self.pcr_Property {
            item.serialize(buffer)?;
        }

        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        // List count
        let pcr_Property_count = buffer.read_u32()? as usize;
        self.pcr_Property.clear();
        for _ in 0..pcr_Property_count {
            let mut item = TPMS_TAGGED_PCR_SELECT::default();
            item.deserialize(buffer)?;
            self.pcr_Property.push(item);
        }

        Ok(())
    }

}

impl TPML_ECC_CURVE {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u32(self.ecc_Curves.get_value())?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        let ecc_Curves_value = buffer.read_u32()?;
        self.ecc_Curves = Vec<TPM_ECC_CURVE>::try_from(ecc_Curves_value)?;
        Ok(())
    }

}

impl TPML_TAGGED_POLICY {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        // List count
        buffer.write_u32(self.policies.len() as u32)?;
        for item in &self.policies {
            item.serialize(buffer)?;
        }

        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        // List count
        let policies_count = buffer.read_u32()? as usize;
        self.policies.clear();
        for _ in 0..policies_count {
            let mut item = TPMS_TAGGED_POLICY::default();
            item.deserialize(buffer)?;
            self.policies.push(item);
        }

        Ok(())
    }

}

impl TPML_ACT_DATA {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        // List count
        buffer.write_u32(self.act_Data.len() as u32)?;
        for item in &self.act_Data {
            item.serialize(buffer)?;
        }

        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        // List count
        let act_Data_count = buffer.read_u32()? as usize;
        self.act_Data.clear();
        for _ in 0..act_Data_count {
            let mut item = TPMS_ACT_DATA::default();
            item.deserialize(buffer)?;
            self.act_Data.push(item);
        }

        Ok(())
    }

}

impl TPMS_CAPABILITY_DATA {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u32(self.capability().get_value())?;
        if let Some(union_obj) = &self.data {
            buffer.write_union(union_obj.as_ref())?;
        } else {

            buffer.write_u32(0)?;
        }

        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        let capability_value = buffer.read_u32()?;
        selector_values.insert("capability", capability_value);
        let selector_value = *selector_values.get("capability").unwrap_or(&0);
        self.data = if selector_value != 0 {
            let mut obj = UnionFactory::create::<TPMU_CAPABILITIES>(selector_value)
            .ok_or(TpmError::InvalidUnion)?;
            buffer.read_union(obj.as_mut())?;
            Some(obj)
        } else {
            None
        };

        Ok(())
    }

}

impl TPMS_CLOCK_INFO {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u64(self.clock)?;
        buffer.write_u32(self.reset_Count)?;
        buffer.write_u32(self.restart_Count)?;
        buffer.write_u8(self.safe)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.clock = buffer.read_u64()?;
        self.reset_Count = buffer.read_u32()?;
        self.restart_Count = buffer.read_u32()?;
        self.safe = buffer.read_u8()?;
        Ok(())
    }

}

impl TPMS_TIME_INFO {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u64(self.time)?;
        self.clock_Info.serialize(buffer)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.time = buffer.read_u64()?;
        self.clock_Info.deserialize(buffer)?;
        Ok(())
    }

}

impl TPMS_TIME_ATTEST_INFO {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.time.serialize(buffer)?;
        buffer.write_u64(self.firmware_Version)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.time.deserialize(buffer)?;
        self.firmware_Version = buffer.read_u64()?;
        Ok(())
    }

}

impl TPMS_CERTIFY_INFO {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.name)?;
        buffer.write_u8(self.qualified_Name)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.name = buffer.read_u8()?;
        self.qualified_Name = buffer.read_u8()?;
        Ok(())
    }

}

impl TPMS_QUOTE_INFO {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        // List count
        buffer.write_u32(self.pcr_Select.len() as u32)?;
        for item in &self.pcr_Select {
            item.serialize(buffer)?;
        }

        buffer.write_u8(self.pcr_Digest)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        // List count
        let pcr_Select_count = buffer.read_u32()? as usize;
        self.pcr_Select.clear();
        for _ in 0..pcr_Select_count {
            let mut item = TPMS_PCR_SELECTION::default();
            item.deserialize(buffer)?;
            self.pcr_Select.push(item);
        }

        self.pcr_Digest = buffer.read_u8()?;
        Ok(())
    }

}

impl TPMS_COMMAND_AUDIT_INFO {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u64(self.audit_Counter)?;
        buffer.write_u32(self.digest_Alg.get_value())?;
        buffer.write_u8(self.audit_Digest)?;
        buffer.write_u8(self.command_Digest)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.audit_Counter = buffer.read_u64()?;
        let digest_Alg_value = buffer.read_u32()?;
        self.digest_Alg = TPM_ALG_ID::try_from(digest_Alg_value as i16)?;
        self.audit_Digest = buffer.read_u8()?;
        self.command_Digest = buffer.read_u8()?;
        Ok(())
    }

}

impl TPMS_SESSION_AUDIT_INFO {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.exclusive_Session)?;
        buffer.write_u8(self.session_Digest)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.exclusive_Session = buffer.read_u8()?;
        self.session_Digest = buffer.read_u8()?;
        Ok(())
    }

}

impl TPMS_CREATION_INFO {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.object_Name)?;
        buffer.write_u8(self.creation_Hash)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.object_Name = buffer.read_u8()?;
        self.creation_Hash = buffer.read_u8()?;
        Ok(())
    }

}

impl TPMS_NV_CERTIFY_INFO {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.index_Name)?;
        buffer.write_u16(self.offset)?;
        buffer.write_u8(self.nv_Contents)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.index_Name = buffer.read_u8()?;
        self.offset = buffer.read_u16()?;
        self.nv_Contents = buffer.read_u8()?;
        Ok(())
    }

}

impl TPMS_NV_DIGEST_CERTIFY_INFO {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.index_Name)?;
        buffer.write_u8(self.nv_Digest)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.index_Name = buffer.read_u8()?;
        self.nv_Digest = buffer.read_u8()?;
        Ok(())
    }

}

impl TPMS_ATTEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u32(self.magic.get_value())?;
        buffer.write_u32(self.type().get_value())?;
        buffer.write_u8(self.qualified_Signer)?;
        buffer.write_u8(self.extra_Data)?;
        self.clock_Info.serialize(buffer)?;
        buffer.write_u64(self.firmware_Version)?;
        if let Some(union_obj) = &self.attested {
            buffer.write_union(union_obj.as_ref())?;
        } else {

            buffer.write_u32(0)?;
        }

        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        let magic_value = buffer.read_u32()?;
        self.magic = TPM_GENERATED::try_from(magic_value)?;
        let type_value = buffer.read_u32()?;
        selector_values.insert("type", type_value);
        self.qualified_Signer = buffer.read_u8()?;
        self.extra_Data = buffer.read_u8()?;
        self.clock_Info.deserialize(buffer)?;
        self.firmware_Version = buffer.read_u64()?;
        let selector_value = *selector_values.get("type").unwrap_or(&0);
        self.attested = if selector_value != 0 {
            let mut obj = UnionFactory::create::<TPMU_ATTEST>(selector_value)
            .ok_or(TpmError::InvalidUnion)?;
            buffer.read_union(obj.as_mut())?;
            Some(obj)
        } else {
            None
        };

        Ok(())
    }

}

impl TPM2B_ATTEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.attestation_Data.serialize(buffer)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.attestation_Data.deserialize(buffer)?;
        Ok(())
    }

}

impl TPMS_AUTH_COMMAND {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.session_Handle.serialize(buffer)?;
        buffer.write_u8(self.nonce)?;
        buffer.write_u32(self.session_Attributes.get_value())?;
        buffer.write_u8(self.hmac)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.session_Handle.deserialize(buffer)?;
        self.nonce = buffer.read_u8()?;
        let session_Attributes_value = buffer.read_u32()?;
        self.session_Attributes = TPMA_SESSION::try_from(session_Attributes_value)?;
        self.hmac = buffer.read_u8()?;
        Ok(())
    }

}

impl TPMS_AUTH_RESPONSE {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.nonce)?;
        buffer.write_u32(self.session_Attributes.get_value())?;
        buffer.write_u8(self.hmac)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.nonce = buffer.read_u8()?;
        let session_Attributes_value = buffer.read_u32()?;
        self.session_Attributes = TPMA_SESSION::try_from(session_Attributes_value)?;
        self.hmac = buffer.read_u8()?;
        Ok(())
    }

}

impl TPMS_TDES_SYM_DETAILS {
    // Implement serialization/deserialization
    /// No fields to serialize/deserialize
    pub fn serialize(&self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

    pub fn deserialize(&mut self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

}

impl TPMS_AES_SYM_DETAILS {
    // Implement serialization/deserialization
    /// No fields to serialize/deserialize
    pub fn serialize(&self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

    pub fn deserialize(&mut self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

}

impl TPMS_SM4_SYM_DETAILS {
    // Implement serialization/deserialization
    /// No fields to serialize/deserialize
    pub fn serialize(&self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

    pub fn deserialize(&mut self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

}

impl TPMS_CAMELLIA_SYM_DETAILS {
    // Implement serialization/deserialization
    /// No fields to serialize/deserialize
    pub fn serialize(&self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

    pub fn deserialize(&mut self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

}

impl TPMS_ANY_SYM_DETAILS {
    // Implement serialization/deserialization
    /// No fields to serialize/deserialize
    pub fn serialize(&self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

    pub fn deserialize(&mut self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

}

impl TPMS_XOR_SYM_DETAILS {
    // Implement serialization/deserialization
    /// No fields to serialize/deserialize
    pub fn serialize(&self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

    pub fn deserialize(&mut self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

}

impl TPMS_NULL_SYM_DETAILS {
    // Implement serialization/deserialization
    /// No fields to serialize/deserialize
    pub fn serialize(&self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

    pub fn deserialize(&mut self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

}

impl TPMT_SYM_DEF {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u32(self.algorithm.get_value())?;
        buffer.write_u16(self.key_Bits)?;
        buffer.write_u32(self.mode.get_value())?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        let algorithm_value = buffer.read_u32()?;
        self.algorithm = TPM_ALG_ID::try_from(algorithm_value as i16)?;
        self.key_Bits = buffer.read_u16()?;
        let mode_value = buffer.read_u32()?;
        self.mode = TPM_ALG_ID::try_from(mode_value as i16)?;
        Ok(())
    }

}

impl TPMT_SYM_DEF_OBJECT {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u32(self.algorithm.get_value())?;
        buffer.write_u16(self.key_Bits)?;
        buffer.write_u32(self.mode.get_value())?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        let algorithm_value = buffer.read_u32()?;
        self.algorithm = TPM_ALG_ID::try_from(algorithm_value as i16)?;
        self.key_Bits = buffer.read_u16()?;
        let mode_value = buffer.read_u32()?;
        self.mode = TPM_ALG_ID::try_from(mode_value as i16)?;
        Ok(())
    }

}

impl TPM2B_SYM_KEY {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.buffer)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.buffer = buffer.read_u8()?;
        Ok(())
    }

}

impl TPMS_SYMCIPHER_PARMS {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.sym.serialize(buffer)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.sym.deserialize(buffer)?;
        Ok(())
    }

}

impl TPM2B_LABEL {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.buffer)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.buffer = buffer.read_u8()?;
        Ok(())
    }

}

impl TPMS_DERIVE {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.label)?;
        buffer.write_u8(self.context)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.label = buffer.read_u8()?;
        self.context = buffer.read_u8()?;
        Ok(())
    }

}

impl TPM2B_DERIVE {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.buffer.serialize(buffer)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.buffer.deserialize(buffer)?;
        Ok(())
    }

}

impl TPM2B_SENSITIVE_DATA {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.buffer)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.buffer = buffer.read_u8()?;
        Ok(())
    }

}

impl TPMS_SENSITIVE_CREATE {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.user_Auth)?;
        buffer.write_u8(self.data)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.user_Auth = buffer.read_u8()?;
        self.data = buffer.read_u8()?;
        Ok(())
    }

}

impl TPM2B_SENSITIVE_CREATE {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.sensitive.serialize(buffer)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.sensitive.deserialize(buffer)?;
        Ok(())
    }

}

impl TPMS_SCHEME_HASH {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u32(self.hash_Alg.get_value())?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        let hash_Alg_value = buffer.read_u32()?;
        self.hash_Alg = TPM_ALG_ID::try_from(hash_Alg_value)?;
        Ok(())
    }

}

impl TPMS_SCHEME_ECDAA {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u32(self.hash_Alg.get_value())?;
        buffer.write_u16(self.count)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        let hash_Alg_value = buffer.read_u32()?;
        self.hash_Alg = TPM_ALG_ID::try_from(hash_Alg_value)?;
        self.count = buffer.read_u16()?;
        Ok(())
    }

}

impl TPMS_SCHEME_HMAC {
    // Implement serialization/deserialization
    /// No fields to serialize/deserialize
    pub fn serialize(&self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

    pub fn deserialize(&mut self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

}

impl TPMS_SCHEME_XOR {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u32(self.hash_Alg.get_value())?;
        buffer.write_u32(self.kdf.get_value())?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        let hash_Alg_value = buffer.read_u32()?;
        self.hash_Alg = TPM_ALG_ID::try_from(hash_Alg_value)?;
        let kdf_value = buffer.read_u32()?;
        self.kdf = TPM_ALG_ID::try_from(kdf_value)?;
        Ok(())
    }

}

impl TPMS_NULL_SCHEME_KEYEDHASH {
    // Implement serialization/deserialization
    /// No fields to serialize/deserialize
    pub fn serialize(&self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

    pub fn deserialize(&mut self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

}

impl TPMT_KEYEDHASH_SCHEME {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u32(self.scheme().get_value())?;
        if let Some(union_obj) = &self.details {
            buffer.write_union(union_obj.as_ref())?;
        } else {

            buffer.write_u32(TPM_ALG_ID::NULL)?;
        }

        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        let scheme_value = buffer.read_u32()?;
        selector_values.insert("scheme", scheme_value);
        let selector_value = *selector_values.get("scheme").unwrap_or(&0);
        self.details = if selector_value != 0 {
            let mut obj = UnionFactory::create::<TPMU_SCHEME_KEYEDHASH>(selector_value)
            .ok_or(TpmError::InvalidUnion)?;
            buffer.read_union(obj.as_mut())?;
            Some(obj)
        } else {
            None
        };

        Ok(())
    }

}

impl TPMS_SIG_SCHEME_RSASSA {
    // Implement serialization/deserialization
    /// No fields to serialize/deserialize
    pub fn serialize(&self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

    pub fn deserialize(&mut self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

}

impl TPMS_SIG_SCHEME_RSAPSS {
    // Implement serialization/deserialization
    /// No fields to serialize/deserialize
    pub fn serialize(&self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

    pub fn deserialize(&mut self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

}

impl TPMS_SIG_SCHEME_ECDSA {
    // Implement serialization/deserialization
    /// No fields to serialize/deserialize
    pub fn serialize(&self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

    pub fn deserialize(&mut self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

}

impl TPMS_SIG_SCHEME_SM2 {
    // Implement serialization/deserialization
    /// No fields to serialize/deserialize
    pub fn serialize(&self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

    pub fn deserialize(&mut self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

}

impl TPMS_SIG_SCHEME_ECSCHNORR {
    // Implement serialization/deserialization
    /// No fields to serialize/deserialize
    pub fn serialize(&self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

    pub fn deserialize(&mut self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

}

impl TPMS_SIG_SCHEME_ECDAA {
    // Implement serialization/deserialization
    /// No fields to serialize/deserialize
    pub fn serialize(&self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

    pub fn deserialize(&mut self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

}

impl TPMS_NULL_SIG_SCHEME {
    // Implement serialization/deserialization
    /// No fields to serialize/deserialize
    pub fn serialize(&self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

    pub fn deserialize(&mut self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

}

impl TPMT_SIG_SCHEME {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u32(self.scheme().get_value())?;
        if let Some(union_obj) = &self.details {
            buffer.write_union(union_obj.as_ref())?;
        } else {

            buffer.write_u32(TPM_ALG_ID::NULL)?;
        }

        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        let scheme_value = buffer.read_u32()?;
        selector_values.insert("scheme", scheme_value);
        let selector_value = *selector_values.get("scheme").unwrap_or(&0);
        self.details = if selector_value != 0 {
            let mut obj = UnionFactory::create::<TPMU_SIG_SCHEME>(selector_value)
            .ok_or(TpmError::InvalidUnion)?;
            buffer.read_union(obj.as_mut())?;
            Some(obj)
        } else {
            None
        };

        Ok(())
    }

}

impl TPMS_ENC_SCHEME_OAEP {
    // Implement serialization/deserialization
    /// No fields to serialize/deserialize
    pub fn serialize(&self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

    pub fn deserialize(&mut self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

}

impl TPMS_ENC_SCHEME_RSAES {
    // Implement serialization/deserialization
    /// No fields to serialize/deserialize
    pub fn serialize(&self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

    pub fn deserialize(&mut self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

}

impl TPMS_KEY_SCHEME_ECDH {
    // Implement serialization/deserialization
    /// No fields to serialize/deserialize
    pub fn serialize(&self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

    pub fn deserialize(&mut self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

}

impl TPMS_KEY_SCHEME_ECMQV {
    // Implement serialization/deserialization
    /// No fields to serialize/deserialize
    pub fn serialize(&self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

    pub fn deserialize(&mut self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

}

impl TPMS_KDF_SCHEME_MGF1 {
    // Implement serialization/deserialization
    /// No fields to serialize/deserialize
    pub fn serialize(&self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

    pub fn deserialize(&mut self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

}

impl TPMS_KDF_SCHEME_KDF1_SP800_56A {
    // Implement serialization/deserialization
    /// No fields to serialize/deserialize
    pub fn serialize(&self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

    pub fn deserialize(&mut self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

}

impl TPMS_KDF_SCHEME_KDF2 {
    // Implement serialization/deserialization
    /// No fields to serialize/deserialize
    pub fn serialize(&self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

    pub fn deserialize(&mut self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

}

impl TPMS_KDF_SCHEME_KDF1_SP800_108 {
    // Implement serialization/deserialization
    /// No fields to serialize/deserialize
    pub fn serialize(&self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

    pub fn deserialize(&mut self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

}

impl TPMS_NULL_KDF_SCHEME {
    // Implement serialization/deserialization
    /// No fields to serialize/deserialize
    pub fn serialize(&self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

    pub fn deserialize(&mut self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

}

impl TPMT_KDF_SCHEME {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u32(self.scheme().get_value())?;
        if let Some(union_obj) = &self.details {
            buffer.write_union(union_obj.as_ref())?;
        } else {

            buffer.write_u32(TPM_ALG_ID::NULL)?;
        }

        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        let scheme_value = buffer.read_u32()?;
        selector_values.insert("scheme", scheme_value);
        let selector_value = *selector_values.get("scheme").unwrap_or(&0);
        self.details = if selector_value != 0 {
            let mut obj = UnionFactory::create::<TPMU_KDF_SCHEME>(selector_value)
            .ok_or(TpmError::InvalidUnion)?;
            buffer.read_union(obj.as_mut())?;
            Some(obj)
        } else {
            None
        };

        Ok(())
    }

}

impl TPMS_NULL_ASYM_SCHEME {
    // Implement serialization/deserialization
    /// No fields to serialize/deserialize
    pub fn serialize(&self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

    pub fn deserialize(&mut self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

}

impl TPMT_ASYM_SCHEME {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u32(self.scheme().get_value())?;
        if let Some(union_obj) = &self.details {
            buffer.write_union(union_obj.as_ref())?;
        } else {

            buffer.write_u32(TPM_ALG_ID::NULL)?;
        }

        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        let scheme_value = buffer.read_u32()?;
        selector_values.insert("scheme", scheme_value);
        let selector_value = *selector_values.get("scheme").unwrap_or(&0);
        self.details = if selector_value != 0 {
            let mut obj = UnionFactory::create::<TPMU_ASYM_SCHEME>(selector_value)
            .ok_or(TpmError::InvalidUnion)?;
            buffer.read_union(obj.as_mut())?;
            Some(obj)
        } else {
            None
        };

        Ok(())
    }

}

impl TPMT_RSA_SCHEME {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u32(self.scheme().get_value())?;
        if let Some(union_obj) = &self.details {
            buffer.write_union(union_obj.as_ref())?;
        } else {

            buffer.write_u32(TPM_ALG_ID::NULL)?;
        }

        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        let scheme_value = buffer.read_u32()?;
        selector_values.insert("scheme", scheme_value);
        let selector_value = *selector_values.get("scheme").unwrap_or(&0);
        self.details = if selector_value != 0 {
            let mut obj = UnionFactory::create::<TPMU_ASYM_SCHEME>(selector_value)
            .ok_or(TpmError::InvalidUnion)?;
            buffer.read_union(obj.as_mut())?;
            Some(obj)
        } else {
            None
        };

        Ok(())
    }

}

impl TPMT_RSA_DECRYPT {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u32(self.scheme().get_value())?;
        if let Some(union_obj) = &self.details {
            buffer.write_union(union_obj.as_ref())?;
        } else {

            buffer.write_u32(TPM_ALG_ID::NULL)?;
        }

        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        let scheme_value = buffer.read_u32()?;
        selector_values.insert("scheme", scheme_value);
        let selector_value = *selector_values.get("scheme").unwrap_or(&0);
        self.details = if selector_value != 0 {
            let mut obj = UnionFactory::create::<TPMU_ASYM_SCHEME>(selector_value)
            .ok_or(TpmError::InvalidUnion)?;
            buffer.read_union(obj.as_mut())?;
            Some(obj)
        } else {
            None
        };

        Ok(())
    }

}

impl TPM2B_PUBLIC_KEY_RSA {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.buffer)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.buffer = buffer.read_u8()?;
        Ok(())
    }

}

impl TPM2B_PRIVATE_KEY_RSA {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.buffer)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.buffer = buffer.read_u8()?;
        Ok(())
    }

}

impl TPM2B_ECC_PARAMETER {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.buffer)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.buffer = buffer.read_u8()?;
        Ok(())
    }

}

impl TPMS_ECC_POINT {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.x)?;
        buffer.write_u8(self.y)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.x = buffer.read_u8()?;
        self.y = buffer.read_u8()?;
        Ok(())
    }

}

impl TPM2B_ECC_POINT {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.point.serialize(buffer)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.point.deserialize(buffer)?;
        Ok(())
    }

}

impl TPMT_ECC_SCHEME {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u32(self.scheme().get_value())?;
        if let Some(union_obj) = &self.details {
            buffer.write_union(union_obj.as_ref())?;
        } else {

            buffer.write_u32(TPM_ALG_ID::NULL)?;
        }

        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        let scheme_value = buffer.read_u32()?;
        selector_values.insert("scheme", scheme_value);
        let selector_value = *selector_values.get("scheme").unwrap_or(&0);
        self.details = if selector_value != 0 {
            let mut obj = UnionFactory::create::<TPMU_ASYM_SCHEME>(selector_value)
            .ok_or(TpmError::InvalidUnion)?;
            buffer.read_union(obj.as_mut())?;
            Some(obj)
        } else {
            None
        };

        Ok(())
    }

}

impl TPMS_ALGORITHM_DETAIL_ECC {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u32(self.curve_ID.get_value())?;
        buffer.write_u16(self.key_Size)?;
        buffer.write_u32(self.kdf_Scheme().get_value())?;
        if let Some(union_obj) = &self.kdf {
            buffer.write_union(union_obj.as_ref())?;
        } else {

            buffer.write_u32(TPM_ALG_ID::NULL)?;
        }

        buffer.write_u32(self.sign_Scheme().get_value())?;
        if let Some(union_obj) = &self.sign {
            buffer.write_union(union_obj.as_ref())?;
        } else {

            buffer.write_u32(TPM_ALG_ID::NULL)?;
        }

        buffer.write_u8(self.p)?;
        buffer.write_u8(self.a)?;
        buffer.write_u8(self.b)?;
        buffer.write_u8(self.gX)?;
        buffer.write_u8(self.gY)?;
        buffer.write_u8(self.n)?;
        buffer.write_u8(self.h)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        let curve_ID_value = buffer.read_u32()?;
        self.curve_ID = TPM_ECC_CURVE::try_from(curve_ID_value)?;
        self.key_Size = buffer.read_u16()?;
        let kdf_Scheme_value = buffer.read_u32()?;
        selector_values.insert("kdfScheme", kdf_Scheme_value);
        let selector_value = *selector_values.get("kdfScheme").unwrap_or(&0);
        self.kdf = if selector_value != 0 {
            let mut obj = UnionFactory::create::<TPMU_KDF_SCHEME>(selector_value)
            .ok_or(TpmError::InvalidUnion)?;
            buffer.read_union(obj.as_mut())?;
            Some(obj)
        } else {
            None
        };

        let sign_Scheme_value = buffer.read_u32()?;
        selector_values.insert("signScheme", sign_Scheme_value);
        let selector_value = *selector_values.get("signScheme").unwrap_or(&0);
        self.sign = if selector_value != 0 {
            let mut obj = UnionFactory::create::<TPMU_ASYM_SCHEME>(selector_value)
            .ok_or(TpmError::InvalidUnion)?;
            buffer.read_union(obj.as_mut())?;
            Some(obj)
        } else {
            None
        };

        self.p = buffer.read_u8()?;
        self.a = buffer.read_u8()?;
        self.b = buffer.read_u8()?;
        self.gX = buffer.read_u8()?;
        self.gY = buffer.read_u8()?;
        self.n = buffer.read_u8()?;
        self.h = buffer.read_u8()?;
        Ok(())
    }

}

impl TPMS_SIGNATURE_RSA {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u32(self.hash.get_value())?;
        buffer.write_u8(self.sig)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        let hash_value = buffer.read_u32()?;
        self.hash = TPM_ALG_ID::try_from(hash_value)?;
        self.sig = buffer.read_u8()?;
        Ok(())
    }

}

impl TPMS_SIGNATURE_RSASSA {
    // Implement serialization/deserialization
    /// No fields to serialize/deserialize
    pub fn serialize(&self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

    pub fn deserialize(&mut self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

}

impl TPMS_SIGNATURE_RSAPSS {
    // Implement serialization/deserialization
    /// No fields to serialize/deserialize
    pub fn serialize(&self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

    pub fn deserialize(&mut self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

}

impl TPMS_SIGNATURE_ECC {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u32(self.hash.get_value())?;
        buffer.write_u8(self.signature_R)?;
        buffer.write_u8(self.signature_S)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        let hash_value = buffer.read_u32()?;
        self.hash = TPM_ALG_ID::try_from(hash_value)?;
        self.signature_R = buffer.read_u8()?;
        self.signature_S = buffer.read_u8()?;
        Ok(())
    }

}

impl TPMS_SIGNATURE_ECDSA {
    // Implement serialization/deserialization
    /// No fields to serialize/deserialize
    pub fn serialize(&self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

    pub fn deserialize(&mut self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

}

impl TPMS_SIGNATURE_ECDAA {
    // Implement serialization/deserialization
    /// No fields to serialize/deserialize
    pub fn serialize(&self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

    pub fn deserialize(&mut self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

}

impl TPMS_SIGNATURE_SM2 {
    // Implement serialization/deserialization
    /// No fields to serialize/deserialize
    pub fn serialize(&self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

    pub fn deserialize(&mut self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

}

impl TPMS_SIGNATURE_ECSCHNORR {
    // Implement serialization/deserialization
    /// No fields to serialize/deserialize
    pub fn serialize(&self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

    pub fn deserialize(&mut self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

}

impl TPMS_NULL_SIGNATURE {
    // Implement serialization/deserialization
    /// No fields to serialize/deserialize
    pub fn serialize(&self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

    pub fn deserialize(&mut self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

}

impl TPMT_SIGNATURE {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u32(self.sig_Alg().get_value())?;
        if let Some(union_obj) = &self.signature {
            buffer.write_union(union_obj.as_ref())?;
        } else {

            buffer.write_u32(TPM_ALG_ID::NULL)?;
        }

        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        let sig_Alg_value = buffer.read_u32()?;
        selector_values.insert("sigAlg", sig_Alg_value);
        let selector_value = *selector_values.get("sigAlg").unwrap_or(&0);
        self.signature = if selector_value != 0 {
            let mut obj = UnionFactory::create::<TPMU_SIGNATURE>(selector_value)
            .ok_or(TpmError::InvalidUnion)?;
            buffer.read_union(obj.as_mut())?;
            Some(obj)
        } else {
            None
        };

        Ok(())
    }

}

impl TPM2B_ENCRYPTED_SECRET {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.secret)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.secret = buffer.read_u8()?;
        Ok(())
    }

}

impl TPMS_KEYEDHASH_PARMS {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u32(self.scheme_Scheme().get_value())?;
        if let Some(union_obj) = &self.scheme {
            buffer.write_union(union_obj.as_ref())?;
        } else {

            buffer.write_u32(TPM_ALG_ID::NULL)?;
        }

        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        let scheme_Scheme_value = buffer.read_u32()?;
        selector_values.insert("schemeScheme", scheme_Scheme_value);
        let selector_value = *selector_values.get("schemeScheme").unwrap_or(&0);
        self.scheme = if selector_value != 0 {
            let mut obj = UnionFactory::create::<TPMU_SCHEME_KEYEDHASH>(selector_value)
            .ok_or(TpmError::InvalidUnion)?;
            buffer.read_union(obj.as_mut())?;
            Some(obj)
        } else {
            None
        };

        Ok(())
    }

}

impl TPMS_ASYM_PARMS {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.symmetric.serialize(buffer)?;
        buffer.write_u32(self.scheme_Scheme().get_value())?;
        if let Some(union_obj) = &self.scheme {
            buffer.write_union(union_obj.as_ref())?;
        } else {

            buffer.write_u32(TPM_ALG_ID::NULL)?;
        }

        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.symmetric.deserialize(buffer)?;
        let scheme_Scheme_value = buffer.read_u32()?;
        selector_values.insert("schemeScheme", scheme_Scheme_value);
        let selector_value = *selector_values.get("schemeScheme").unwrap_or(&0);
        self.scheme = if selector_value != 0 {
            let mut obj = UnionFactory::create::<TPMU_ASYM_SCHEME>(selector_value)
            .ok_or(TpmError::InvalidUnion)?;
            buffer.read_union(obj.as_mut())?;
            Some(obj)
        } else {
            None
        };

        Ok(())
    }

}

impl TPMS_RSA_PARMS {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.symmetric.serialize(buffer)?;
        buffer.write_u32(self.scheme_Scheme().get_value())?;
        if let Some(union_obj) = &self.scheme {
            buffer.write_union(union_obj.as_ref())?;
        } else {

            buffer.write_u32(TPM_ALG_ID::NULL)?;
        }

        buffer.write_u16(self.key_Bits)?;
        buffer.write_u32(self.exponent)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.symmetric.deserialize(buffer)?;
        let scheme_Scheme_value = buffer.read_u32()?;
        selector_values.insert("schemeScheme", scheme_Scheme_value);
        let selector_value = *selector_values.get("schemeScheme").unwrap_or(&0);
        self.scheme = if selector_value != 0 {
            let mut obj = UnionFactory::create::<TPMU_ASYM_SCHEME>(selector_value)
            .ok_or(TpmError::InvalidUnion)?;
            buffer.read_union(obj.as_mut())?;
            Some(obj)
        } else {
            None
        };

        self.key_Bits = buffer.read_u16()?;
        self.exponent = buffer.read_u32()?;
        Ok(())
    }

}

impl TPMS_ECC_PARMS {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.symmetric.serialize(buffer)?;
        buffer.write_u32(self.scheme_Scheme().get_value())?;
        if let Some(union_obj) = &self.scheme {
            buffer.write_union(union_obj.as_ref())?;
        } else {

            buffer.write_u32(TPM_ALG_ID::NULL)?;
        }

        buffer.write_u32(self.curve_ID.get_value())?;
        buffer.write_u32(self.kdf_Scheme().get_value())?;
        if let Some(union_obj) = &self.kdf {
            buffer.write_union(union_obj.as_ref())?;
        } else {

            buffer.write_u32(TPM_ALG_ID::NULL)?;
        }

        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.symmetric.deserialize(buffer)?;
        let scheme_Scheme_value = buffer.read_u32()?;
        selector_values.insert("schemeScheme", scheme_Scheme_value);
        let selector_value = *selector_values.get("schemeScheme").unwrap_or(&0);
        self.scheme = if selector_value != 0 {
            let mut obj = UnionFactory::create::<TPMU_ASYM_SCHEME>(selector_value)
            .ok_or(TpmError::InvalidUnion)?;
            buffer.read_union(obj.as_mut())?;
            Some(obj)
        } else {
            None
        };

        let curve_ID_value = buffer.read_u32()?;
        self.curve_ID = TPM_ECC_CURVE::try_from(curve_ID_value)?;
        let kdf_Scheme_value = buffer.read_u32()?;
        selector_values.insert("kdfScheme", kdf_Scheme_value);
        let selector_value = *selector_values.get("kdfScheme").unwrap_or(&0);
        self.kdf = if selector_value != 0 {
            let mut obj = UnionFactory::create::<TPMU_KDF_SCHEME>(selector_value)
            .ok_or(TpmError::InvalidUnion)?;
            buffer.read_union(obj.as_mut())?;
            Some(obj)
        } else {
            None
        };

        Ok(())
    }

}

impl TPMT_PUBLIC_PARMS {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u32(self.type().get_value())?;
        if let Some(union_obj) = &self.parameters {
            buffer.write_union(union_obj.as_ref())?;
        } else {

            buffer.write_u32(0)?;
        }

        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        let type_value = buffer.read_u32()?;
        selector_values.insert("type", type_value);
        let selector_value = *selector_values.get("type").unwrap_or(&0);
        self.parameters = if selector_value != 0 {
            let mut obj = UnionFactory::create::<TPMU_PUBLIC_PARMS>(selector_value)
            .ok_or(TpmError::InvalidUnion)?;
            buffer.read_union(obj.as_mut())?;
            Some(obj)
        } else {
            None
        };

        Ok(())
    }

}

impl TPMT_PUBLIC {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u32(self.type().get_value())?;
        buffer.write_u32(self.name_Alg.get_value())?;
        buffer.write_u32(self.object_Attributes.get_value())?;
        buffer.write_u8(self.auth_Policy)?;
        if let Some(union_obj) = &self.parameters {
            buffer.write_union(union_obj.as_ref())?;
        } else {

            buffer.write_u32(0)?;
        }

        if let Some(union_obj) = &self.unique {
            buffer.write_union(union_obj.as_ref())?;
        } else {

            buffer.write_u32(0)?;
        }

        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        let type_value = buffer.read_u32()?;
        selector_values.insert("type", type_value);
        let name_Alg_value = buffer.read_u32()?;
        self.name_Alg = TPM_ALG_ID::try_from(name_Alg_value)?;
        let object_Attributes_value = buffer.read_u32()?;
        self.object_Attributes = TPMA_OBJECT::try_from(object_Attributes_value)?;
        self.auth_Policy = buffer.read_u8()?;
        let selector_value = *selector_values.get("type").unwrap_or(&0);
        self.parameters = if selector_value != 0 {
            let mut obj = UnionFactory::create::<TPMU_PUBLIC_PARMS>(selector_value)
            .ok_or(TpmError::InvalidUnion)?;
            buffer.read_union(obj.as_mut())?;
            Some(obj)
        } else {
            None
        };

        let selector_value = *selector_values.get("type").unwrap_or(&0);
        self.unique = if selector_value != 0 {
            let mut obj = UnionFactory::create::<TPMU_PUBLIC_ID>(selector_value)
            .ok_or(TpmError::InvalidUnion)?;
            buffer.read_union(obj.as_mut())?;
            Some(obj)
        } else {
            None
        };

        Ok(())
    }

}

impl TPM2B_PUBLIC {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.public_Area.serialize(buffer)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.public_Area.deserialize(buffer)?;
        Ok(())
    }

}

impl TPM2B_TEMPLATE {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.buffer)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.buffer = buffer.read_u8()?;
        Ok(())
    }

}

impl TPM2B_PRIVATE_VENDOR_SPECIFIC {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.buffer)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.buffer = buffer.read_u8()?;
        Ok(())
    }

}

impl TPMT_SENSITIVE {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u32(self.sensitive_Type().get_value())?;
        buffer.write_u8(self.auth_Value)?;
        buffer.write_u8(self.seed_Value)?;
        if let Some(union_obj) = &self.sensitive {
            buffer.write_union(union_obj.as_ref())?;
        } else {

            buffer.write_u32(0)?;
        }

        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        let sensitive_Type_value = buffer.read_u32()?;
        selector_values.insert("sensitiveType", sensitive_Type_value);
        self.auth_Value = buffer.read_u8()?;
        self.seed_Value = buffer.read_u8()?;
        let selector_value = *selector_values.get("sensitiveType").unwrap_or(&0);
        self.sensitive = if selector_value != 0 {
            let mut obj = UnionFactory::create::<TPMU_SENSITIVE_COMPOSITE>(selector_value)
            .ok_or(TpmError::InvalidUnion)?;
            buffer.read_union(obj.as_mut())?;
            Some(obj)
        } else {
            None
        };

        Ok(())
    }

}

impl TPM2B_SENSITIVE {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.sensitive_Area.serialize(buffer)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.sensitive_Area.deserialize(buffer)?;
        Ok(())
    }

}

impl _PRIVATE {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.integrity_Outer)?;
        buffer.write_u8(self.integrity_Inner)?;
        self.sensitive.serialize(buffer)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.integrity_Outer = buffer.read_u8()?;
        self.integrity_Inner = buffer.read_u8()?;
        self.sensitive.deserialize(buffer)?;
        Ok(())
    }

}

impl TPM2B_PRIVATE {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.buffer)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.buffer = buffer.read_u8()?;
        Ok(())
    }

}

impl TPMS_ID_OBJECT {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.integrity_HMAC)?;
        buffer.write_u8(self.enc_Identity)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.integrity_HMAC = buffer.read_u8()?;
        self.enc_Identity = buffer.read_u8()?;
        Ok(())
    }

}

impl TPM2B_ID_OBJECT {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.credential.serialize(buffer)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.credential.deserialize(buffer)?;
        Ok(())
    }

}

impl TPMS_NV_PIN_COUNTER_PARAMETERS {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u32(self.pin_Count)?;
        buffer.write_u32(self.pin_Limit)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.pin_Count = buffer.read_u32()?;
        self.pin_Limit = buffer.read_u32()?;
        Ok(())
    }

}

impl TPMS_NV_PUBLIC {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.nv_Index.serialize(buffer)?;
        buffer.write_u32(self.name_Alg.get_value())?;
        buffer.write_u32(self.attributes.get_value())?;
        buffer.write_u8(self.auth_Policy)?;
        buffer.write_u16(self.data_Size)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.nv_Index.deserialize(buffer)?;
        let name_Alg_value = buffer.read_u32()?;
        self.name_Alg = TPM_ALG_ID::try_from(name_Alg_value)?;
        let attributes_value = buffer.read_u32()?;
        self.attributes = TPMA_NV::try_from(attributes_value)?;
        self.auth_Policy = buffer.read_u8()?;
        self.data_Size = buffer.read_u16()?;
        Ok(())
    }

}

impl TPM2B_NV_PUBLIC {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.nv_Public.serialize(buffer)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.nv_Public.deserialize(buffer)?;
        Ok(())
    }

}

impl TPM2B_CONTEXT_SENSITIVE {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.buffer)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.buffer = buffer.read_u8()?;
        Ok(())
    }

}

impl TPMS_CONTEXT_DATA {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.integrity)?;
        buffer.write_u8(self.encrypted)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.integrity = buffer.read_u8()?;
        self.encrypted = buffer.read_u8()?;
        Ok(())
    }

}

impl TPM2B_CONTEXT_DATA {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.buffer.serialize(buffer)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.buffer.deserialize(buffer)?;
        Ok(())
    }

}

impl TPMS_CONTEXT {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u64(self.sequence)?;
        self.saved_Handle.serialize(buffer)?;
        self.hierarchy.serialize(buffer)?;
        self.context_Blob.serialize(buffer)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.sequence = buffer.read_u64()?;
        self.saved_Handle.deserialize(buffer)?;
        self.hierarchy.deserialize(buffer)?;
        self.context_Blob.deserialize(buffer)?;
        Ok(())
    }

}

impl TPMS_CREATION_DATA {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        // List count
        buffer.write_u32(self.pcr_Select.len() as u32)?;
        for item in &self.pcr_Select {
            item.serialize(buffer)?;
        }

        buffer.write_u8(self.pcr_Digest)?;
        buffer.write_u32(self.locality.get_value())?;
        buffer.write_u32(self.parent_Name_Alg.get_value())?;
        buffer.write_u8(self.parent_Name)?;
        buffer.write_u8(self.parent_Qualified_Name)?;
        buffer.write_u8(self.outside_Info)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        // List count
        let pcr_Select_count = buffer.read_u32()? as usize;
        self.pcr_Select.clear();
        for _ in 0..pcr_Select_count {
            let mut item = TPMS_PCR_SELECTION::default();
            item.deserialize(buffer)?;
            self.pcr_Select.push(item);
        }

        self.pcr_Digest = buffer.read_u8()?;
        let locality_value = buffer.read_u32()?;
        self.locality = TPMA_LOCALITY::try_from(locality_value)?;
        let parent_Name_Alg_value = buffer.read_u32()?;
        self.parent_Name_Alg = TPM_ALG_ID::try_from(parent_Name_Alg_value as i16)?;
        self.parent_Name = buffer.read_u8()?;
        self.parent_Qualified_Name = buffer.read_u8()?;
        self.outside_Info = buffer.read_u8()?;
        Ok(())
    }

}

impl TPM2B_CREATION_DATA {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.creation_Data.serialize(buffer)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.creation_Data.deserialize(buffer)?;
        Ok(())
    }

}

impl TPMS_AC_OUTPUT {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u32(self.tag.get_value())?;
        buffer.write_u32(self.data)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        let tag_value = buffer.read_u32()?;
        self.tag = TPM_AT::try_from(tag_value)?;
        self.data = buffer.read_u32()?;
        Ok(())
    }

}

impl TPML_AC_CAPABILITIES {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        // List count
        buffer.write_u32(self.ac_Capabilities.len() as u32)?;
        for item in &self.ac_Capabilities {
            item.serialize(buffer)?;
        }

        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        // List count
        let ac_Capabilities_count = buffer.read_u32()? as usize;
        self.ac_Capabilities.clear();
        for _ in 0..ac_Capabilities_count {
            let mut item = TPMS_AC_OUTPUT::default();
            item.deserialize(buffer)?;
            self.ac_Capabilities.push(item);
        }

        Ok(())
    }

}

impl TPM2_Startup_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u32(self.startup_Type.get_value())?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        let startup_Type_value = buffer.read_u32()?;
        self.startup_Type = TPM_SU::try_from(startup_Type_value)?;
        Ok(())
    }

}

impl TPM2_Shutdown_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u32(self.shutdown_Type.get_value())?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        let shutdown_Type_value = buffer.read_u32()?;
        self.shutdown_Type = TPM_SU::try_from(shutdown_Type_value)?;
        Ok(())
    }

}

impl TPM2_SelfTest_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.full_Test)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.full_Test = buffer.read_u8()?;
        Ok(())
    }

}

impl TPM2_IncrementalSelfTest_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u32(self.to_Test.get_value())?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        let to_Test_value = buffer.read_u32()?;
        self.to_Test = Vec<TPM_ALG_ID>::try_from(to_Test_value as i16)?;
        Ok(())
    }

}

impl IncrementalSelfTestResponse {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u32(self.to_Do_List.get_value())?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        let to_Do_List_value = buffer.read_u32()?;
        self.to_Do_List = Vec<TPM_ALG_ID>::try_from(to_Do_List_value as i16)?;
        Ok(())
    }

}

impl TPM2_GetTestResult_REQUEST {
    // Implement serialization/deserialization
    /// No fields to serialize/deserialize
    pub fn serialize(&self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

    pub fn deserialize(&mut self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

}

impl GetTestResultResponse {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.out_Data)?;
        buffer.write_u32(self.test_Result.get_value())?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.out_Data = buffer.read_u8()?;
        let test_Result_value = buffer.read_u32()?;
        self.test_Result = TPM_RC::try_from(test_Result_value as i32)?;
        Ok(())
    }

}

impl TPM2_StartAuthSession_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.nonce_Caller)?;
        buffer.write_u8(self.encrypted_Salt)?;
        buffer.write_u32(self.session_Type.get_value())?;
        self.symmetric.serialize(buffer)?;
        buffer.write_u32(self.auth_Hash.get_value())?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.nonce_Caller = buffer.read_u8()?;
        self.encrypted_Salt = buffer.read_u8()?;
        let session_Type_value = buffer.read_u32()?;
        self.session_Type = TPM_SE::try_from(session_Type_value)?;
        self.symmetric.deserialize(buffer)?;
        let auth_Hash_value = buffer.read_u32()?;
        self.auth_Hash = TPM_ALG_ID::try_from(auth_Hash_value)?;
        Ok(())
    }

}

impl StartAuthSessionResponse {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.nonce_TPM)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.nonce_TPM = buffer.read_u8()?;
        Ok(())
    }

}

impl TPM2_PolicyRestart_REQUEST {
    // Implement serialization/deserialization
    /// No fields to serialize/deserialize
    pub fn serialize(&self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

    pub fn deserialize(&mut self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

}

impl TPM2_Create_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.in_Sensitive.serialize(buffer)?;
        self.in_Public.serialize(buffer)?;
        buffer.write_u8(self.outside_Info)?;
        // List count
        buffer.write_u32(self.creation_PCR.len() as u32)?;
        for item in &self.creation_PCR {
            item.serialize(buffer)?;
        }

        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.in_Sensitive.deserialize(buffer)?;
        self.in_Public.deserialize(buffer)?;
        self.outside_Info = buffer.read_u8()?;
        // List count
        let creation_PCR_count = buffer.read_u32()? as usize;
        self.creation_PCR.clear();
        for _ in 0..creation_PCR_count {
            let mut item = TPMS_PCR_SELECTION::default();
            item.deserialize(buffer)?;
            self.creation_PCR.push(item);
        }

        Ok(())
    }

}

impl CreateResponse {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.out_Private.serialize(buffer)?;
        self.out_Public.serialize(buffer)?;
        self.creation_Data.serialize(buffer)?;
        buffer.write_u8(self.creation_Hash)?;
        self.creation_Ticket.serialize(buffer)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.out_Private.deserialize(buffer)?;
        self.out_Public.deserialize(buffer)?;
        self.creation_Data.deserialize(buffer)?;
        self.creation_Hash = buffer.read_u8()?;
        self.creation_Ticket.deserialize(buffer)?;
        Ok(())
    }

}

impl TPM2_Load_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.in_Private.serialize(buffer)?;
        self.in_Public.serialize(buffer)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.in_Private.deserialize(buffer)?;
        self.in_Public.deserialize(buffer)?;
        Ok(())
    }

}

impl LoadResponse {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.name)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.name = buffer.read_u8()?;
        Ok(())
    }

}

impl TPM2_LoadExternal_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.in_Private.serialize(buffer)?;
        self.in_Public.serialize(buffer)?;
        self.hierarchy.serialize(buffer)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.in_Private.deserialize(buffer)?;
        self.in_Public.deserialize(buffer)?;
        self.hierarchy.deserialize(buffer)?;
        Ok(())
    }

}

impl LoadExternalResponse {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.name)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.name = buffer.read_u8()?;
        Ok(())
    }

}

impl TPM2_ReadPublic_REQUEST {
    // Implement serialization/deserialization
    /// No fields to serialize/deserialize
    pub fn serialize(&self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

    pub fn deserialize(&mut self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

}

impl ReadPublicResponse {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.out_Public.serialize(buffer)?;
        buffer.write_u8(self.name)?;
        buffer.write_u8(self.qualified_Name)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.out_Public.deserialize(buffer)?;
        self.name = buffer.read_u8()?;
        self.qualified_Name = buffer.read_u8()?;
        Ok(())
    }

}

impl TPM2_ActivateCredential_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.credential_Blob.serialize(buffer)?;
        buffer.write_u8(self.secret)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.credential_Blob.deserialize(buffer)?;
        self.secret = buffer.read_u8()?;
        Ok(())
    }

}

impl ActivateCredentialResponse {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.cert_Info)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.cert_Info = buffer.read_u8()?;
        Ok(())
    }

}

impl TPM2_MakeCredential_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.credential)?;
        buffer.write_u8(self.object_Name)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.credential = buffer.read_u8()?;
        self.object_Name = buffer.read_u8()?;
        Ok(())
    }

}

impl MakeCredentialResponse {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.credential_Blob.serialize(buffer)?;
        buffer.write_u8(self.secret)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.credential_Blob.deserialize(buffer)?;
        self.secret = buffer.read_u8()?;
        Ok(())
    }

}

impl TPM2_Unseal_REQUEST {
    // Implement serialization/deserialization
    /// No fields to serialize/deserialize
    pub fn serialize(&self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

    pub fn deserialize(&mut self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

}

impl UnsealResponse {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.out_Data)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.out_Data = buffer.read_u8()?;
        Ok(())
    }

}

impl TPM2_ObjectChangeAuth_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.new_Auth)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.new_Auth = buffer.read_u8()?;
        Ok(())
    }

}

impl ObjectChangeAuthResponse {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.out_Private.serialize(buffer)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.out_Private.deserialize(buffer)?;
        Ok(())
    }

}

impl TPM2_CreateLoaded_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.in_Sensitive.serialize(buffer)?;
        buffer.write_u8(self.in_Public)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.in_Sensitive.deserialize(buffer)?;
        self.in_Public = buffer.read_u8()?;
        Ok(())
    }

}

impl CreateLoadedResponse {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.out_Private.serialize(buffer)?;
        self.out_Public.serialize(buffer)?;
        buffer.write_u8(self.name)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.out_Private.deserialize(buffer)?;
        self.out_Public.deserialize(buffer)?;
        self.name = buffer.read_u8()?;
        Ok(())
    }

}

impl TPM2_Duplicate_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.encryption_Key_In)?;
        self.symmetric_Alg.serialize(buffer)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.encryption_Key_In = buffer.read_u8()?;
        self.symmetric_Alg.deserialize(buffer)?;
        Ok(())
    }

}

impl DuplicateResponse {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.encryption_Key_Out)?;
        self.duplicate.serialize(buffer)?;
        buffer.write_u8(self.out_Sym_Seed)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.encryption_Key_Out = buffer.read_u8()?;
        self.duplicate.deserialize(buffer)?;
        self.out_Sym_Seed = buffer.read_u8()?;
        Ok(())
    }

}

impl TPM2_Rewrap_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.in_Duplicate.serialize(buffer)?;
        buffer.write_u8(self.name)?;
        buffer.write_u8(self.in_Sym_Seed)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.in_Duplicate.deserialize(buffer)?;
        self.name = buffer.read_u8()?;
        self.in_Sym_Seed = buffer.read_u8()?;
        Ok(())
    }

}

impl RewrapResponse {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.out_Duplicate.serialize(buffer)?;
        buffer.write_u8(self.out_Sym_Seed)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.out_Duplicate.deserialize(buffer)?;
        self.out_Sym_Seed = buffer.read_u8()?;
        Ok(())
    }

}

impl TPM2_Import_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.encryption_Key)?;
        self.object_Public.serialize(buffer)?;
        self.duplicate.serialize(buffer)?;
        buffer.write_u8(self.in_Sym_Seed)?;
        self.symmetric_Alg.serialize(buffer)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.encryption_Key = buffer.read_u8()?;
        self.object_Public.deserialize(buffer)?;
        self.duplicate.deserialize(buffer)?;
        self.in_Sym_Seed = buffer.read_u8()?;
        self.symmetric_Alg.deserialize(buffer)?;
        Ok(())
    }

}

impl ImportResponse {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.out_Private.serialize(buffer)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.out_Private.deserialize(buffer)?;
        Ok(())
    }

}

impl TPM2_RSA_Encrypt_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.message)?;
        buffer.write_u32(self.in_Scheme_Scheme().get_value())?;
        if let Some(union_obj) = &self.in_Scheme {
            buffer.write_union(union_obj.as_ref())?;
        } else {

            buffer.write_u32(TPM_ALG_ID::NULL)?;
        }

        buffer.write_u8(self.label)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.message = buffer.read_u8()?;
        let in_Scheme_Scheme_value = buffer.read_u32()?;
        selector_values.insert("inSchemeScheme", in_Scheme_Scheme_value);
        let selector_value = *selector_values.get("inSchemeScheme").unwrap_or(&0);
        self.in_Scheme = if selector_value != 0 {
            let mut obj = UnionFactory::create::<TPMU_ASYM_SCHEME>(selector_value)
            .ok_or(TpmError::InvalidUnion)?;
            buffer.read_union(obj.as_mut())?;
            Some(obj)
        } else {
            None
        };

        self.label = buffer.read_u8()?;
        Ok(())
    }

}

impl RSA_EncryptResponse {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.out_Data)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.out_Data = buffer.read_u8()?;
        Ok(())
    }

}

impl TPM2_RSA_Decrypt_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.cipher_Text)?;
        buffer.write_u32(self.in_Scheme_Scheme().get_value())?;
        if let Some(union_obj) = &self.in_Scheme {
            buffer.write_union(union_obj.as_ref())?;
        } else {

            buffer.write_u32(TPM_ALG_ID::NULL)?;
        }

        buffer.write_u8(self.label)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.cipher_Text = buffer.read_u8()?;
        let in_Scheme_Scheme_value = buffer.read_u32()?;
        selector_values.insert("inSchemeScheme", in_Scheme_Scheme_value);
        let selector_value = *selector_values.get("inSchemeScheme").unwrap_or(&0);
        self.in_Scheme = if selector_value != 0 {
            let mut obj = UnionFactory::create::<TPMU_ASYM_SCHEME>(selector_value)
            .ok_or(TpmError::InvalidUnion)?;
            buffer.read_union(obj.as_mut())?;
            Some(obj)
        } else {
            None
        };

        self.label = buffer.read_u8()?;
        Ok(())
    }

}

impl RSA_DecryptResponse {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.message)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.message = buffer.read_u8()?;
        Ok(())
    }

}

impl TPM2_ECDH_KeyGen_REQUEST {
    // Implement serialization/deserialization
    /// No fields to serialize/deserialize
    pub fn serialize(&self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

    pub fn deserialize(&mut self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

}

impl ECDH_KeyGenResponse {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.zPoint.serialize(buffer)?;
        self.pub_Point.serialize(buffer)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.zPoint.deserialize(buffer)?;
        self.pub_Point.deserialize(buffer)?;
        Ok(())
    }

}

impl TPM2_ECDH_ZGen_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.in_Point.serialize(buffer)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.in_Point.deserialize(buffer)?;
        Ok(())
    }

}

impl ECDH_ZGenResponse {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.out_Point.serialize(buffer)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.out_Point.deserialize(buffer)?;
        Ok(())
    }

}

impl TPM2_ECC_Parameters_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u32(self.curve_ID.get_value())?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        let curve_ID_value = buffer.read_u32()?;
        self.curve_ID = TPM_ECC_CURVE::try_from(curve_ID_value)?;
        Ok(())
    }

}

impl ECC_ParametersResponse {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.parameters.serialize(buffer)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.parameters.deserialize(buffer)?;
        Ok(())
    }

}

impl TPM2_ZGen_2Phase_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.in_Qs_B.serialize(buffer)?;
        self.in_Qe_B.serialize(buffer)?;
        buffer.write_u32(self.in_Scheme.get_value())?;
        buffer.write_u16(self.counter)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.in_Qs_B.deserialize(buffer)?;
        self.in_Qe_B.deserialize(buffer)?;
        let in_Scheme_value = buffer.read_u32()?;
        self.in_Scheme = TPM_ALG_ID::try_from(in_Scheme_value)?;
        self.counter = buffer.read_u16()?;
        Ok(())
    }

}

impl ZGen_2PhaseResponse {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.out_Z1.serialize(buffer)?;
        self.out_Z2.serialize(buffer)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.out_Z1.deserialize(buffer)?;
        self.out_Z2.deserialize(buffer)?;
        Ok(())
    }

}

impl TPM2_ECC_Encrypt_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.plain_Text)?;
        buffer.write_u32(self.in_Scheme_Scheme().get_value())?;
        if let Some(union_obj) = &self.in_Scheme {
            buffer.write_union(union_obj.as_ref())?;
        } else {

            buffer.write_u32(TPM_ALG_ID::NULL)?;
        }

        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.plain_Text = buffer.read_u8()?;
        let in_Scheme_Scheme_value = buffer.read_u32()?;
        selector_values.insert("inSchemeScheme", in_Scheme_Scheme_value);
        let selector_value = *selector_values.get("inSchemeScheme").unwrap_or(&0);
        self.in_Scheme = if selector_value != 0 {
            let mut obj = UnionFactory::create::<TPMU_KDF_SCHEME>(selector_value)
            .ok_or(TpmError::InvalidUnion)?;
            buffer.read_union(obj.as_mut())?;
            Some(obj)
        } else {
            None
        };

        Ok(())
    }

}

impl ECC_EncryptResponse {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.C1.serialize(buffer)?;
        buffer.write_u8(self.C2)?;
        buffer.write_u8(self.C3)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.C1.deserialize(buffer)?;
        self.C2 = buffer.read_u8()?;
        self.C3 = buffer.read_u8()?;
        Ok(())
    }

}

impl TPM2_ECC_Decrypt_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.C1.serialize(buffer)?;
        buffer.write_u8(self.C2)?;
        buffer.write_u8(self.C3)?;
        buffer.write_u32(self.in_Scheme_Scheme().get_value())?;
        if let Some(union_obj) = &self.in_Scheme {
            buffer.write_union(union_obj.as_ref())?;
        } else {

            buffer.write_u32(TPM_ALG_ID::NULL)?;
        }

        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.C1.deserialize(buffer)?;
        self.C2 = buffer.read_u8()?;
        self.C3 = buffer.read_u8()?;
        let in_Scheme_Scheme_value = buffer.read_u32()?;
        selector_values.insert("inSchemeScheme", in_Scheme_Scheme_value);
        let selector_value = *selector_values.get("inSchemeScheme").unwrap_or(&0);
        self.in_Scheme = if selector_value != 0 {
            let mut obj = UnionFactory::create::<TPMU_KDF_SCHEME>(selector_value)
            .ok_or(TpmError::InvalidUnion)?;
            buffer.read_union(obj.as_mut())?;
            Some(obj)
        } else {
            None
        };

        Ok(())
    }

}

impl ECC_DecryptResponse {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.plain_Text)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.plain_Text = buffer.read_u8()?;
        Ok(())
    }

}

impl TPM2_EncryptDecrypt_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.decrypt)?;
        buffer.write_u32(self.mode.get_value())?;
        buffer.write_u8(self.iv_In)?;
        buffer.write_u8(self.in_Data)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.decrypt = buffer.read_u8()?;
        let mode_value = buffer.read_u32()?;
        self.mode = TPM_ALG_ID::try_from(mode_value)?;
        self.iv_In = buffer.read_u8()?;
        self.in_Data = buffer.read_u8()?;
        Ok(())
    }

}

impl EncryptDecryptResponse {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.out_Data)?;
        buffer.write_u8(self.iv_Out)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.out_Data = buffer.read_u8()?;
        self.iv_Out = buffer.read_u8()?;
        Ok(())
    }

}

impl TPM2_EncryptDecrypt2_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.in_Data)?;
        buffer.write_u8(self.decrypt)?;
        buffer.write_u32(self.mode.get_value())?;
        buffer.write_u8(self.iv_In)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.in_Data = buffer.read_u8()?;
        self.decrypt = buffer.read_u8()?;
        let mode_value = buffer.read_u32()?;
        self.mode = TPM_ALG_ID::try_from(mode_value)?;
        self.iv_In = buffer.read_u8()?;
        Ok(())
    }

}

impl EncryptDecrypt2Response {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.out_Data)?;
        buffer.write_u8(self.iv_Out)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.out_Data = buffer.read_u8()?;
        self.iv_Out = buffer.read_u8()?;
        Ok(())
    }

}

impl TPM2_Hash_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.data)?;
        buffer.write_u32(self.hash_Alg.get_value())?;
        self.hierarchy.serialize(buffer)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.data = buffer.read_u8()?;
        let hash_Alg_value = buffer.read_u32()?;
        self.hash_Alg = TPM_ALG_ID::try_from(hash_Alg_value)?;
        self.hierarchy.deserialize(buffer)?;
        Ok(())
    }

}

impl HashResponse {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.out_Hash)?;
        self.validation.serialize(buffer)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.out_Hash = buffer.read_u8()?;
        self.validation.deserialize(buffer)?;
        Ok(())
    }

}

impl TPM2_HMAC_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.buffer)?;
        buffer.write_u32(self.hash_Alg.get_value())?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.buffer = buffer.read_u8()?;
        let hash_Alg_value = buffer.read_u32()?;
        self.hash_Alg = TPM_ALG_ID::try_from(hash_Alg_value)?;
        Ok(())
    }

}

impl HMACResponse {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.out_HMAC)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.out_HMAC = buffer.read_u8()?;
        Ok(())
    }

}

impl TPM2_MAC_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.buffer)?;
        buffer.write_u32(self.in_Scheme.get_value())?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.buffer = buffer.read_u8()?;
        let in_Scheme_value = buffer.read_u32()?;
        self.in_Scheme = TPM_ALG_ID::try_from(in_Scheme_value)?;
        Ok(())
    }

}

impl MACResponse {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.out_MAC)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.out_MAC = buffer.read_u8()?;
        Ok(())
    }

}

impl TPM2_GetRandom_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u16(self.bytes_Requested)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.bytes_Requested = buffer.read_u16()?;
        Ok(())
    }

}

impl GetRandomResponse {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.random_Bytes)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.random_Bytes = buffer.read_u8()?;
        Ok(())
    }

}

impl TPM2_StirRandom_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.in_Data)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.in_Data = buffer.read_u8()?;
        Ok(())
    }

}

impl TPM2_HMAC_Start_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.auth)?;
        buffer.write_u32(self.hash_Alg.get_value())?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.auth = buffer.read_u8()?;
        let hash_Alg_value = buffer.read_u32()?;
        self.hash_Alg = TPM_ALG_ID::try_from(hash_Alg_value)?;
        Ok(())
    }

}

impl HMAC_StartResponse {
    // Implement serialization/deserialization
    /// No fields to serialize/deserialize
    pub fn serialize(&self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

    pub fn deserialize(&mut self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

}

impl TPM2_MAC_Start_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.auth)?;
        buffer.write_u32(self.in_Scheme.get_value())?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.auth = buffer.read_u8()?;
        let in_Scheme_value = buffer.read_u32()?;
        self.in_Scheme = TPM_ALG_ID::try_from(in_Scheme_value)?;
        Ok(())
    }

}

impl MAC_StartResponse {
    // Implement serialization/deserialization
    /// No fields to serialize/deserialize
    pub fn serialize(&self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

    pub fn deserialize(&mut self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

}

impl TPM2_HashSequenceStart_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.auth)?;
        buffer.write_u32(self.hash_Alg.get_value())?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.auth = buffer.read_u8()?;
        let hash_Alg_value = buffer.read_u32()?;
        self.hash_Alg = TPM_ALG_ID::try_from(hash_Alg_value)?;
        Ok(())
    }

}

impl HashSequenceStartResponse {
    // Implement serialization/deserialization
    /// No fields to serialize/deserialize
    pub fn serialize(&self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

    pub fn deserialize(&mut self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

}

impl TPM2_SequenceUpdate_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.buffer)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.buffer = buffer.read_u8()?;
        Ok(())
    }

}

impl TPM2_SequenceComplete_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.buffer)?;
        self.hierarchy.serialize(buffer)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.buffer = buffer.read_u8()?;
        self.hierarchy.deserialize(buffer)?;
        Ok(())
    }

}

impl SequenceCompleteResponse {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.result)?;
        self.validation.serialize(buffer)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.result = buffer.read_u8()?;
        self.validation.deserialize(buffer)?;
        Ok(())
    }

}

impl TPM2_EventSequenceComplete_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.buffer)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.buffer = buffer.read_u8()?;
        Ok(())
    }

}

impl EventSequenceCompleteResponse {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        // List count
        buffer.write_u32(self.results.len() as u32)?;
        for item in &self.results {
            item.serialize(buffer)?;
        }

        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        // List count
        let results_count = buffer.read_u32()? as usize;
        self.results.clear();
        for _ in 0..results_count {
            let mut item = TPMT_HA::default();
            item.deserialize(buffer)?;
            self.results.push(item);
        }

        Ok(())
    }

}

impl TPM2_Certify_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.qualifying_Data)?;
        buffer.write_u32(self.in_Scheme_Scheme().get_value())?;
        if let Some(union_obj) = &self.in_Scheme {
            buffer.write_union(union_obj.as_ref())?;
        } else {

            buffer.write_u32(TPM_ALG_ID::NULL)?;
        }

        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.qualifying_Data = buffer.read_u8()?;
        let in_Scheme_Scheme_value = buffer.read_u32()?;
        selector_values.insert("inSchemeScheme", in_Scheme_Scheme_value);
        let selector_value = *selector_values.get("inSchemeScheme").unwrap_or(&0);
        self.in_Scheme = if selector_value != 0 {
            let mut obj = UnionFactory::create::<TPMU_SIG_SCHEME>(selector_value)
            .ok_or(TpmError::InvalidUnion)?;
            buffer.read_union(obj.as_mut())?;
            Some(obj)
        } else {
            None
        };

        Ok(())
    }

}

impl CertifyResponse {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.certify_Info.serialize(buffer)?;
        buffer.write_u32(self.signature_Sig_Alg().get_value())?;
        if let Some(union_obj) = &self.signature {
            buffer.write_union(union_obj.as_ref())?;
        } else {

            buffer.write_u32(TPM_ALG_ID::NULL)?;
        }

        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.certify_Info.deserialize(buffer)?;
        let signature_Sig_Alg_value = buffer.read_u32()?;
        selector_values.insert("signatureSigAlg", signature_Sig_Alg_value);
        let selector_value = *selector_values.get("signatureSigAlg").unwrap_or(&0);
        self.signature = if selector_value != 0 {
            let mut obj = UnionFactory::create::<TPMU_SIGNATURE>(selector_value)
            .ok_or(TpmError::InvalidUnion)?;
            buffer.read_union(obj.as_mut())?;
            Some(obj)
        } else {
            None
        };

        Ok(())
    }

}

impl TPM2_CertifyCreation_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.qualifying_Data)?;
        buffer.write_u8(self.creation_Hash)?;
        buffer.write_u32(self.in_Scheme_Scheme().get_value())?;
        if let Some(union_obj) = &self.in_Scheme {
            buffer.write_union(union_obj.as_ref())?;
        } else {

            buffer.write_u32(TPM_ALG_ID::NULL)?;
        }

        self.creation_Ticket.serialize(buffer)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.qualifying_Data = buffer.read_u8()?;
        self.creation_Hash = buffer.read_u8()?;
        let in_Scheme_Scheme_value = buffer.read_u32()?;
        selector_values.insert("inSchemeScheme", in_Scheme_Scheme_value);
        let selector_value = *selector_values.get("inSchemeScheme").unwrap_or(&0);
        self.in_Scheme = if selector_value != 0 {
            let mut obj = UnionFactory::create::<TPMU_SIG_SCHEME>(selector_value)
            .ok_or(TpmError::InvalidUnion)?;
            buffer.read_union(obj.as_mut())?;
            Some(obj)
        } else {
            None
        };

        self.creation_Ticket.deserialize(buffer)?;
        Ok(())
    }

}

impl CertifyCreationResponse {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.certify_Info.serialize(buffer)?;
        buffer.write_u32(self.signature_Sig_Alg().get_value())?;
        if let Some(union_obj) = &self.signature {
            buffer.write_union(union_obj.as_ref())?;
        } else {

            buffer.write_u32(TPM_ALG_ID::NULL)?;
        }

        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.certify_Info.deserialize(buffer)?;
        let signature_Sig_Alg_value = buffer.read_u32()?;
        selector_values.insert("signatureSigAlg", signature_Sig_Alg_value);
        let selector_value = *selector_values.get("signatureSigAlg").unwrap_or(&0);
        self.signature = if selector_value != 0 {
            let mut obj = UnionFactory::create::<TPMU_SIGNATURE>(selector_value)
            .ok_or(TpmError::InvalidUnion)?;
            buffer.read_union(obj.as_mut())?;
            Some(obj)
        } else {
            None
        };

        Ok(())
    }

}

impl TPM2_Quote_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.qualifying_Data)?;
        buffer.write_u32(self.in_Scheme_Scheme().get_value())?;
        if let Some(union_obj) = &self.in_Scheme {
            buffer.write_union(union_obj.as_ref())?;
        } else {

            buffer.write_u32(TPM_ALG_ID::NULL)?;
        }

        // List count
        buffer.write_u32(self.PCRselect.len() as u32)?;
        for item in &self.PCRselect {
            item.serialize(buffer)?;
        }

        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.qualifying_Data = buffer.read_u8()?;
        let in_Scheme_Scheme_value = buffer.read_u32()?;
        selector_values.insert("inSchemeScheme", in_Scheme_Scheme_value);
        let selector_value = *selector_values.get("inSchemeScheme").unwrap_or(&0);
        self.in_Scheme = if selector_value != 0 {
            let mut obj = UnionFactory::create::<TPMU_SIG_SCHEME>(selector_value)
            .ok_or(TpmError::InvalidUnion)?;
            buffer.read_union(obj.as_mut())?;
            Some(obj)
        } else {
            None
        };

        // List count
        let PCRselect_count = buffer.read_u32()? as usize;
        self.PCRselect.clear();
        for _ in 0..PCRselect_count {
            let mut item = TPMS_PCR_SELECTION::default();
            item.deserialize(buffer)?;
            self.PCRselect.push(item);
        }

        Ok(())
    }

}

impl QuoteResponse {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.quoted.serialize(buffer)?;
        buffer.write_u32(self.signature_Sig_Alg().get_value())?;
        if let Some(union_obj) = &self.signature {
            buffer.write_union(union_obj.as_ref())?;
        } else {

            buffer.write_u32(TPM_ALG_ID::NULL)?;
        }

        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.quoted.deserialize(buffer)?;
        let signature_Sig_Alg_value = buffer.read_u32()?;
        selector_values.insert("signatureSigAlg", signature_Sig_Alg_value);
        let selector_value = *selector_values.get("signatureSigAlg").unwrap_or(&0);
        self.signature = if selector_value != 0 {
            let mut obj = UnionFactory::create::<TPMU_SIGNATURE>(selector_value)
            .ok_or(TpmError::InvalidUnion)?;
            buffer.read_union(obj.as_mut())?;
            Some(obj)
        } else {
            None
        };

        Ok(())
    }

}

impl TPM2_GetSessionAuditDigest_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.qualifying_Data)?;
        buffer.write_u32(self.in_Scheme_Scheme().get_value())?;
        if let Some(union_obj) = &self.in_Scheme {
            buffer.write_union(union_obj.as_ref())?;
        } else {

            buffer.write_u32(TPM_ALG_ID::NULL)?;
        }

        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.qualifying_Data = buffer.read_u8()?;
        let in_Scheme_Scheme_value = buffer.read_u32()?;
        selector_values.insert("inSchemeScheme", in_Scheme_Scheme_value);
        let selector_value = *selector_values.get("inSchemeScheme").unwrap_or(&0);
        self.in_Scheme = if selector_value != 0 {
            let mut obj = UnionFactory::create::<TPMU_SIG_SCHEME>(selector_value)
            .ok_or(TpmError::InvalidUnion)?;
            buffer.read_union(obj.as_mut())?;
            Some(obj)
        } else {
            None
        };

        Ok(())
    }

}

impl GetSessionAuditDigestResponse {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.audit_Info.serialize(buffer)?;
        buffer.write_u32(self.signature_Sig_Alg().get_value())?;
        if let Some(union_obj) = &self.signature {
            buffer.write_union(union_obj.as_ref())?;
        } else {

            buffer.write_u32(TPM_ALG_ID::NULL)?;
        }

        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.audit_Info.deserialize(buffer)?;
        let signature_Sig_Alg_value = buffer.read_u32()?;
        selector_values.insert("signatureSigAlg", signature_Sig_Alg_value);
        let selector_value = *selector_values.get("signatureSigAlg").unwrap_or(&0);
        self.signature = if selector_value != 0 {
            let mut obj = UnionFactory::create::<TPMU_SIGNATURE>(selector_value)
            .ok_or(TpmError::InvalidUnion)?;
            buffer.read_union(obj.as_mut())?;
            Some(obj)
        } else {
            None
        };

        Ok(())
    }

}

impl TPM2_GetCommandAuditDigest_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.qualifying_Data)?;
        buffer.write_u32(self.in_Scheme_Scheme().get_value())?;
        if let Some(union_obj) = &self.in_Scheme {
            buffer.write_union(union_obj.as_ref())?;
        } else {

            buffer.write_u32(TPM_ALG_ID::NULL)?;
        }

        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.qualifying_Data = buffer.read_u8()?;
        let in_Scheme_Scheme_value = buffer.read_u32()?;
        selector_values.insert("inSchemeScheme", in_Scheme_Scheme_value);
        let selector_value = *selector_values.get("inSchemeScheme").unwrap_or(&0);
        self.in_Scheme = if selector_value != 0 {
            let mut obj = UnionFactory::create::<TPMU_SIG_SCHEME>(selector_value)
            .ok_or(TpmError::InvalidUnion)?;
            buffer.read_union(obj.as_mut())?;
            Some(obj)
        } else {
            None
        };

        Ok(())
    }

}

impl GetCommandAuditDigestResponse {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.audit_Info.serialize(buffer)?;
        buffer.write_u32(self.signature_Sig_Alg().get_value())?;
        if let Some(union_obj) = &self.signature {
            buffer.write_union(union_obj.as_ref())?;
        } else {

            buffer.write_u32(TPM_ALG_ID::NULL)?;
        }

        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.audit_Info.deserialize(buffer)?;
        let signature_Sig_Alg_value = buffer.read_u32()?;
        selector_values.insert("signatureSigAlg", signature_Sig_Alg_value);
        let selector_value = *selector_values.get("signatureSigAlg").unwrap_or(&0);
        self.signature = if selector_value != 0 {
            let mut obj = UnionFactory::create::<TPMU_SIGNATURE>(selector_value)
            .ok_or(TpmError::InvalidUnion)?;
            buffer.read_union(obj.as_mut())?;
            Some(obj)
        } else {
            None
        };

        Ok(())
    }

}

impl TPM2_GetTime_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.qualifying_Data)?;
        buffer.write_u32(self.in_Scheme_Scheme().get_value())?;
        if let Some(union_obj) = &self.in_Scheme {
            buffer.write_union(union_obj.as_ref())?;
        } else {

            buffer.write_u32(TPM_ALG_ID::NULL)?;
        }

        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.qualifying_Data = buffer.read_u8()?;
        let in_Scheme_Scheme_value = buffer.read_u32()?;
        selector_values.insert("inSchemeScheme", in_Scheme_Scheme_value);
        let selector_value = *selector_values.get("inSchemeScheme").unwrap_or(&0);
        self.in_Scheme = if selector_value != 0 {
            let mut obj = UnionFactory::create::<TPMU_SIG_SCHEME>(selector_value)
            .ok_or(TpmError::InvalidUnion)?;
            buffer.read_union(obj.as_mut())?;
            Some(obj)
        } else {
            None
        };

        Ok(())
    }

}

impl GetTimeResponse {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.time_Info.serialize(buffer)?;
        buffer.write_u32(self.signature_Sig_Alg().get_value())?;
        if let Some(union_obj) = &self.signature {
            buffer.write_union(union_obj.as_ref())?;
        } else {

            buffer.write_u32(TPM_ALG_ID::NULL)?;
        }

        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.time_Info.deserialize(buffer)?;
        let signature_Sig_Alg_value = buffer.read_u32()?;
        selector_values.insert("signatureSigAlg", signature_Sig_Alg_value);
        let selector_value = *selector_values.get("signatureSigAlg").unwrap_or(&0);
        self.signature = if selector_value != 0 {
            let mut obj = UnionFactory::create::<TPMU_SIGNATURE>(selector_value)
            .ok_or(TpmError::InvalidUnion)?;
            buffer.read_union(obj.as_mut())?;
            Some(obj)
        } else {
            None
        };

        Ok(())
    }

}

impl TPM2_CertifyX509_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.reserved)?;
        buffer.write_u32(self.in_Scheme_Scheme().get_value())?;
        if let Some(union_obj) = &self.in_Scheme {
            buffer.write_union(union_obj.as_ref())?;
        } else {

            buffer.write_u32(TPM_ALG_ID::NULL)?;
        }

        buffer.write_u8(self.partial_Certificate)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.reserved = buffer.read_u8()?;
        let in_Scheme_Scheme_value = buffer.read_u32()?;
        selector_values.insert("inSchemeScheme", in_Scheme_Scheme_value);
        let selector_value = *selector_values.get("inSchemeScheme").unwrap_or(&0);
        self.in_Scheme = if selector_value != 0 {
            let mut obj = UnionFactory::create::<TPMU_SIG_SCHEME>(selector_value)
            .ok_or(TpmError::InvalidUnion)?;
            buffer.read_union(obj.as_mut())?;
            Some(obj)
        } else {
            None
        };

        self.partial_Certificate = buffer.read_u8()?;
        Ok(())
    }

}

impl CertifyX509Response {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.added_To_Certificate)?;
        buffer.write_u8(self.tbs_Digest)?;
        buffer.write_u32(self.signature_Sig_Alg().get_value())?;
        if let Some(union_obj) = &self.signature {
            buffer.write_union(union_obj.as_ref())?;
        } else {

            buffer.write_u32(TPM_ALG_ID::NULL)?;
        }

        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.added_To_Certificate = buffer.read_u8()?;
        self.tbs_Digest = buffer.read_u8()?;
        let signature_Sig_Alg_value = buffer.read_u32()?;
        selector_values.insert("signatureSigAlg", signature_Sig_Alg_value);
        let selector_value = *selector_values.get("signatureSigAlg").unwrap_or(&0);
        self.signature = if selector_value != 0 {
            let mut obj = UnionFactory::create::<TPMU_SIGNATURE>(selector_value)
            .ok_or(TpmError::InvalidUnion)?;
            buffer.read_union(obj.as_mut())?;
            Some(obj)
        } else {
            None
        };

        Ok(())
    }

}

impl TPM2_Commit_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.P1.serialize(buffer)?;
        buffer.write_u8(self.s2)?;
        buffer.write_u8(self.y2)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.P1.deserialize(buffer)?;
        self.s2 = buffer.read_u8()?;
        self.y2 = buffer.read_u8()?;
        Ok(())
    }

}

impl CommitResponse {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.K.serialize(buffer)?;
        self.L.serialize(buffer)?;
        self.E.serialize(buffer)?;
        buffer.write_u16(self.counter)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.K.deserialize(buffer)?;
        self.L.deserialize(buffer)?;
        self.E.deserialize(buffer)?;
        self.counter = buffer.read_u16()?;
        Ok(())
    }

}

impl TPM2_EC_Ephemeral_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u32(self.curve_ID.get_value())?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        let curve_ID_value = buffer.read_u32()?;
        self.curve_ID = TPM_ECC_CURVE::try_from(curve_ID_value)?;
        Ok(())
    }

}

impl EC_EphemeralResponse {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.Q.serialize(buffer)?;
        buffer.write_u16(self.counter)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.Q.deserialize(buffer)?;
        self.counter = buffer.read_u16()?;
        Ok(())
    }

}

impl TPM2_VerifySignature_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.digest)?;
        buffer.write_u32(self.signature_Sig_Alg().get_value())?;
        if let Some(union_obj) = &self.signature {
            buffer.write_union(union_obj.as_ref())?;
        } else {

            buffer.write_u32(TPM_ALG_ID::NULL)?;
        }

        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.digest = buffer.read_u8()?;
        let signature_Sig_Alg_value = buffer.read_u32()?;
        selector_values.insert("signatureSigAlg", signature_Sig_Alg_value);
        let selector_value = *selector_values.get("signatureSigAlg").unwrap_or(&0);
        self.signature = if selector_value != 0 {
            let mut obj = UnionFactory::create::<TPMU_SIGNATURE>(selector_value)
            .ok_or(TpmError::InvalidUnion)?;
            buffer.read_union(obj.as_mut())?;
            Some(obj)
        } else {
            None
        };

        Ok(())
    }

}

impl VerifySignatureResponse {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.validation.serialize(buffer)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.validation.deserialize(buffer)?;
        Ok(())
    }

}

impl TPM2_Sign_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.digest)?;
        buffer.write_u32(self.in_Scheme_Scheme().get_value())?;
        if let Some(union_obj) = &self.in_Scheme {
            buffer.write_union(union_obj.as_ref())?;
        } else {

            buffer.write_u32(TPM_ALG_ID::NULL)?;
        }

        self.validation.serialize(buffer)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.digest = buffer.read_u8()?;
        let in_Scheme_Scheme_value = buffer.read_u32()?;
        selector_values.insert("inSchemeScheme", in_Scheme_Scheme_value);
        let selector_value = *selector_values.get("inSchemeScheme").unwrap_or(&0);
        self.in_Scheme = if selector_value != 0 {
            let mut obj = UnionFactory::create::<TPMU_SIG_SCHEME>(selector_value)
            .ok_or(TpmError::InvalidUnion)?;
            buffer.read_union(obj.as_mut())?;
            Some(obj)
        } else {
            None
        };

        self.validation.deserialize(buffer)?;
        Ok(())
    }

}

impl SignResponse {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u32(self.signature_Sig_Alg().get_value())?;
        if let Some(union_obj) = &self.signature {
            buffer.write_union(union_obj.as_ref())?;
        } else {

            buffer.write_u32(TPM_ALG_ID::NULL)?;
        }

        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        let signature_Sig_Alg_value = buffer.read_u32()?;
        selector_values.insert("signatureSigAlg", signature_Sig_Alg_value);
        let selector_value = *selector_values.get("signatureSigAlg").unwrap_or(&0);
        self.signature = if selector_value != 0 {
            let mut obj = UnionFactory::create::<TPMU_SIGNATURE>(selector_value)
            .ok_or(TpmError::InvalidUnion)?;
            buffer.read_union(obj.as_mut())?;
            Some(obj)
        } else {
            None
        };

        Ok(())
    }

}

impl TPM2_SetCommandCodeAuditStatus_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u32(self.audit_Alg.get_value())?;
        buffer.write_u32(self.set_List.get_value())?;
        buffer.write_u32(self.clear_List.get_value())?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        let audit_Alg_value = buffer.read_u32()?;
        self.audit_Alg = TPM_ALG_ID::try_from(audit_Alg_value)?;
        let set_List_value = buffer.read_u32()?;
        self.set_List = Vec<TPM_CC>::try_from(set_List_value as i32)?;
        let clear_List_value = buffer.read_u32()?;
        self.clear_List = Vec<TPM_CC>::try_from(clear_List_value as i32)?;
        Ok(())
    }

}

impl TPM2_PCR_Extend_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        // List count
        buffer.write_u32(self.digests.len() as u32)?;
        for item in &self.digests {
            item.serialize(buffer)?;
        }

        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        // List count
        let digests_count = buffer.read_u32()? as usize;
        self.digests.clear();
        for _ in 0..digests_count {
            let mut item = TPMT_HA::default();
            item.deserialize(buffer)?;
            self.digests.push(item);
        }

        Ok(())
    }

}

impl TPM2_PCR_Event_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.event_Data)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.event_Data = buffer.read_u8()?;
        Ok(())
    }

}

impl PCR_EventResponse {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        // List count
        buffer.write_u32(self.digests.len() as u32)?;
        for item in &self.digests {
            item.serialize(buffer)?;
        }

        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        // List count
        let digests_count = buffer.read_u32()? as usize;
        self.digests.clear();
        for _ in 0..digests_count {
            let mut item = TPMT_HA::default();
            item.deserialize(buffer)?;
            self.digests.push(item);
        }

        Ok(())
    }

}

impl TPM2_PCR_Read_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        // List count
        buffer.write_u32(self.pcr_Selection_In.len() as u32)?;
        for item in &self.pcr_Selection_In {
            item.serialize(buffer)?;
        }

        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        // List count
        let pcr_Selection_In_count = buffer.read_u32()? as usize;
        self.pcr_Selection_In.clear();
        for _ in 0..pcr_Selection_In_count {
            let mut item = TPMS_PCR_SELECTION::default();
            item.deserialize(buffer)?;
            self.pcr_Selection_In.push(item);
        }

        Ok(())
    }

}

impl PCR_ReadResponse {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u32(self.pcr_Update_Counter)?;
        // List count
        buffer.write_u32(self.pcr_Selection_Out.len() as u32)?;
        for item in &self.pcr_Selection_Out {
            item.serialize(buffer)?;
        }

        // List count
        buffer.write_u32(self.pcr_Values.len() as u32)?;
        for item in &self.pcr_Values {
            item.serialize(buffer)?;
        }

        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.pcr_Update_Counter = buffer.read_u32()?;
        // List count
        let pcr_Selection_Out_count = buffer.read_u32()? as usize;
        self.pcr_Selection_Out.clear();
        for _ in 0..pcr_Selection_Out_count {
            let mut item = TPMS_PCR_SELECTION::default();
            item.deserialize(buffer)?;
            self.pcr_Selection_Out.push(item);
        }

        // List count
        let pcr_Values_count = buffer.read_u32()? as usize;
        self.pcr_Values.clear();
        for _ in 0..pcr_Values_count {
            let mut item = TPM2B_DIGEST::default();
            item.deserialize(buffer)?;
            self.pcr_Values.push(item);
        }

        Ok(())
    }

}

impl TPM2_PCR_Allocate_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        // List count
        buffer.write_u32(self.pcr_Allocation.len() as u32)?;
        for item in &self.pcr_Allocation {
            item.serialize(buffer)?;
        }

        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        // List count
        let pcr_Allocation_count = buffer.read_u32()? as usize;
        self.pcr_Allocation.clear();
        for _ in 0..pcr_Allocation_count {
            let mut item = TPMS_PCR_SELECTION::default();
            item.deserialize(buffer)?;
            self.pcr_Allocation.push(item);
        }

        Ok(())
    }

}

impl PCR_AllocateResponse {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.allocation_Success)?;
        buffer.write_u32(self.max_PCR)?;
        buffer.write_u32(self.size_Needed)?;
        buffer.write_u32(self.size_Available)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.allocation_Success = buffer.read_u8()?;
        self.max_PCR = buffer.read_u32()?;
        self.size_Needed = buffer.read_u32()?;
        self.size_Available = buffer.read_u32()?;
        Ok(())
    }

}

impl TPM2_PCR_SetAuthPolicy_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.auth_Policy)?;
        buffer.write_u32(self.hash_Alg.get_value())?;
        self.pcr_Num.serialize(buffer)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.auth_Policy = buffer.read_u8()?;
        let hash_Alg_value = buffer.read_u32()?;
        self.hash_Alg = TPM_ALG_ID::try_from(hash_Alg_value)?;
        self.pcr_Num.deserialize(buffer)?;
        Ok(())
    }

}

impl TPM2_PCR_SetAuthValue_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.auth)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.auth = buffer.read_u8()?;
        Ok(())
    }

}

impl TPM2_PCR_Reset_REQUEST {
    // Implement serialization/deserialization
    /// No fields to serialize/deserialize
    pub fn serialize(&self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

    pub fn deserialize(&mut self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

}

impl TPM2_PolicySigned_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.nonce_TPM)?;
        buffer.write_u8(self.cp_Hash_A)?;
        buffer.write_u8(self.policy_Ref)?;
        buffer.write_u32(self.expiration)?;
        buffer.write_u32(self.auth_Sig_Alg().get_value())?;
        if let Some(union_obj) = &self.auth {
            buffer.write_union(union_obj.as_ref())?;
        } else {

            buffer.write_u32(TPM_ALG_ID::NULL)?;
        }

        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.nonce_TPM = buffer.read_u8()?;
        self.cp_Hash_A = buffer.read_u8()?;
        self.policy_Ref = buffer.read_u8()?;
        self.expiration = buffer.read_u32()?;
        let auth_Sig_Alg_value = buffer.read_u32()?;
        selector_values.insert("authSigAlg", auth_Sig_Alg_value);
        let selector_value = *selector_values.get("authSigAlg").unwrap_or(&0);
        self.auth = if selector_value != 0 {
            let mut obj = UnionFactory::create::<TPMU_SIGNATURE>(selector_value)
            .ok_or(TpmError::InvalidUnion)?;
            buffer.read_union(obj.as_mut())?;
            Some(obj)
        } else {
            None
        };

        Ok(())
    }

}

impl PolicySignedResponse {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.timeout)?;
        self.policy_Ticket.serialize(buffer)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.timeout = buffer.read_u8()?;
        self.policy_Ticket.deserialize(buffer)?;
        Ok(())
    }

}

impl TPM2_PolicySecret_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.nonce_TPM)?;
        buffer.write_u8(self.cp_Hash_A)?;
        buffer.write_u8(self.policy_Ref)?;
        buffer.write_u32(self.expiration)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.nonce_TPM = buffer.read_u8()?;
        self.cp_Hash_A = buffer.read_u8()?;
        self.policy_Ref = buffer.read_u8()?;
        self.expiration = buffer.read_u32()?;
        Ok(())
    }

}

impl PolicySecretResponse {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.timeout)?;
        self.policy_Ticket.serialize(buffer)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.timeout = buffer.read_u8()?;
        self.policy_Ticket.deserialize(buffer)?;
        Ok(())
    }

}

impl TPM2_PolicyTicket_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.timeout)?;
        buffer.write_u8(self.cp_Hash_A)?;
        buffer.write_u8(self.policy_Ref)?;
        buffer.write_u8(self.auth_Name)?;
        self.ticket.serialize(buffer)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.timeout = buffer.read_u8()?;
        self.cp_Hash_A = buffer.read_u8()?;
        self.policy_Ref = buffer.read_u8()?;
        self.auth_Name = buffer.read_u8()?;
        self.ticket.deserialize(buffer)?;
        Ok(())
    }

}

impl TPM2_PolicyOR_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        // List count
        buffer.write_u32(self.pHashList.len() as u32)?;
        for item in &self.pHashList {
            item.serialize(buffer)?;
        }

        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        // List count
        let pHashList_count = buffer.read_u32()? as usize;
        self.pHashList.clear();
        for _ in 0..pHashList_count {
            let mut item = TPM2B_DIGEST::default();
            item.deserialize(buffer)?;
            self.pHashList.push(item);
        }

        Ok(())
    }

}

impl TPM2_PolicyPCR_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.pcr_Digest)?;
        // List count
        buffer.write_u32(self.pcrs.len() as u32)?;
        for item in &self.pcrs {
            item.serialize(buffer)?;
        }

        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.pcr_Digest = buffer.read_u8()?;
        // List count
        let pcrs_count = buffer.read_u32()? as usize;
        self.pcrs.clear();
        for _ in 0..pcrs_count {
            let mut item = TPMS_PCR_SELECTION::default();
            item.deserialize(buffer)?;
            self.pcrs.push(item);
        }

        Ok(())
    }

}

impl TPM2_PolicyLocality_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u32(self.locality.get_value())?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        let locality_value = buffer.read_u32()?;
        self.locality = TPMA_LOCALITY::try_from(locality_value)?;
        Ok(())
    }

}

impl TPM2_PolicyNV_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.operand_B)?;
        buffer.write_u16(self.offset)?;
        buffer.write_u32(self.operation.get_value())?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.operand_B = buffer.read_u8()?;
        self.offset = buffer.read_u16()?;
        let operation_value = buffer.read_u32()?;
        self.operation = TPM_EO::try_from(operation_value)?;
        Ok(())
    }

}

impl TPM2_PolicyCounterTimer_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.operand_B)?;
        buffer.write_u16(self.offset)?;
        buffer.write_u32(self.operation.get_value())?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.operand_B = buffer.read_u8()?;
        self.offset = buffer.read_u16()?;
        let operation_value = buffer.read_u32()?;
        self.operation = TPM_EO::try_from(operation_value)?;
        Ok(())
    }

}

impl TPM2_PolicyCommandCode_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u32(self.code.get_value())?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        let code_value = buffer.read_u32()?;
        self.code = TPM_CC::try_from(code_value as i32)?;
        Ok(())
    }

}

impl TPM2_PolicyPhysicalPresence_REQUEST {
    // Implement serialization/deserialization
    /// No fields to serialize/deserialize
    pub fn serialize(&self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

    pub fn deserialize(&mut self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

}

impl TPM2_PolicyCpHash_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.cp_Hash_A)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.cp_Hash_A = buffer.read_u8()?;
        Ok(())
    }

}

impl TPM2_PolicyNameHash_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.name_Hash)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.name_Hash = buffer.read_u8()?;
        Ok(())
    }

}

impl TPM2_PolicyDuplicationSelect_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.object_Name)?;
        buffer.write_u8(self.new_Parent_Name)?;
        buffer.write_u8(self.include_Object)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.object_Name = buffer.read_u8()?;
        self.new_Parent_Name = buffer.read_u8()?;
        self.include_Object = buffer.read_u8()?;
        Ok(())
    }

}

impl TPM2_PolicyAuthorize_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.approved_Policy)?;
        buffer.write_u8(self.policy_Ref)?;
        buffer.write_u8(self.key_Sign)?;
        self.check_Ticket.serialize(buffer)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.approved_Policy = buffer.read_u8()?;
        self.policy_Ref = buffer.read_u8()?;
        self.key_Sign = buffer.read_u8()?;
        self.check_Ticket.deserialize(buffer)?;
        Ok(())
    }

}

impl TPM2_PolicyAuthValue_REQUEST {
    // Implement serialization/deserialization
    /// No fields to serialize/deserialize
    pub fn serialize(&self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

    pub fn deserialize(&mut self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

}

impl TPM2_PolicyPassword_REQUEST {
    // Implement serialization/deserialization
    /// No fields to serialize/deserialize
    pub fn serialize(&self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

    pub fn deserialize(&mut self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

}

impl TPM2_PolicyGetDigest_REQUEST {
    // Implement serialization/deserialization
    /// No fields to serialize/deserialize
    pub fn serialize(&self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

    pub fn deserialize(&mut self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

}

impl PolicyGetDigestResponse {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.policy_Digest)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.policy_Digest = buffer.read_u8()?;
        Ok(())
    }

}

impl TPM2_PolicyNvWritten_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.written_Set)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.written_Set = buffer.read_u8()?;
        Ok(())
    }

}

impl TPM2_PolicyTemplate_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.template_Hash)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.template_Hash = buffer.read_u8()?;
        Ok(())
    }

}

impl TPM2_PolicyAuthorizeNV_REQUEST {
    // Implement serialization/deserialization
    /// No fields to serialize/deserialize
    pub fn serialize(&self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

    pub fn deserialize(&mut self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

}

impl TPM2_CreatePrimary_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.in_Sensitive.serialize(buffer)?;
        self.in_Public.serialize(buffer)?;
        buffer.write_u8(self.outside_Info)?;
        // List count
        buffer.write_u32(self.creation_PCR.len() as u32)?;
        for item in &self.creation_PCR {
            item.serialize(buffer)?;
        }

        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.in_Sensitive.deserialize(buffer)?;
        self.in_Public.deserialize(buffer)?;
        self.outside_Info = buffer.read_u8()?;
        // List count
        let creation_PCR_count = buffer.read_u32()? as usize;
        self.creation_PCR.clear();
        for _ in 0..creation_PCR_count {
            let mut item = TPMS_PCR_SELECTION::default();
            item.deserialize(buffer)?;
            self.creation_PCR.push(item);
        }

        Ok(())
    }

}

impl CreatePrimaryResponse {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.out_Public.serialize(buffer)?;
        self.creation_Data.serialize(buffer)?;
        buffer.write_u8(self.creation_Hash)?;
        self.creation_Ticket.serialize(buffer)?;
        buffer.write_u8(self.name)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.out_Public.deserialize(buffer)?;
        self.creation_Data.deserialize(buffer)?;
        self.creation_Hash = buffer.read_u8()?;
        self.creation_Ticket.deserialize(buffer)?;
        self.name = buffer.read_u8()?;
        Ok(())
    }

}

impl TPM2_HierarchyControl_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.enable.serialize(buffer)?;
        buffer.write_u8(self.state)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.enable.deserialize(buffer)?;
        self.state = buffer.read_u8()?;
        Ok(())
    }

}

impl TPM2_SetPrimaryPolicy_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.auth_Policy)?;
        buffer.write_u32(self.hash_Alg.get_value())?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.auth_Policy = buffer.read_u8()?;
        let hash_Alg_value = buffer.read_u32()?;
        self.hash_Alg = TPM_ALG_ID::try_from(hash_Alg_value)?;
        Ok(())
    }

}

impl TPM2_ChangePPS_REQUEST {
    // Implement serialization/deserialization
    /// No fields to serialize/deserialize
    pub fn serialize(&self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

    pub fn deserialize(&mut self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

}

impl TPM2_ChangeEPS_REQUEST {
    // Implement serialization/deserialization
    /// No fields to serialize/deserialize
    pub fn serialize(&self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

    pub fn deserialize(&mut self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

}

impl TPM2_Clear_REQUEST {
    // Implement serialization/deserialization
    /// No fields to serialize/deserialize
    pub fn serialize(&self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

    pub fn deserialize(&mut self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

}

impl TPM2_ClearControl_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.disable)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.disable = buffer.read_u8()?;
        Ok(())
    }

}

impl TPM2_HierarchyChangeAuth_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.new_Auth)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.new_Auth = buffer.read_u8()?;
        Ok(())
    }

}

impl TPM2_DictionaryAttackLockReset_REQUEST {
    // Implement serialization/deserialization
    /// No fields to serialize/deserialize
    pub fn serialize(&self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

    pub fn deserialize(&mut self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

}

impl TPM2_DictionaryAttackParameters_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u32(self.new_Max_Tries)?;
        buffer.write_u32(self.new_Recovery_Time)?;
        buffer.write_u32(self.lockout_Recovery)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.new_Max_Tries = buffer.read_u32()?;
        self.new_Recovery_Time = buffer.read_u32()?;
        self.lockout_Recovery = buffer.read_u32()?;
        Ok(())
    }

}

impl TPM2_PP_Commands_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u32(self.set_List.get_value())?;
        buffer.write_u32(self.clear_List.get_value())?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        let set_List_value = buffer.read_u32()?;
        self.set_List = Vec<TPM_CC>::try_from(set_List_value as i32)?;
        let clear_List_value = buffer.read_u32()?;
        self.clear_List = Vec<TPM_CC>::try_from(clear_List_value as i32)?;
        Ok(())
    }

}

impl TPM2_SetAlgorithmSet_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u32(self.algorithm_Set)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.algorithm_Set = buffer.read_u32()?;
        Ok(())
    }

}

impl TPM2_FieldUpgradeStart_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.fu_Digest)?;
        buffer.write_u32(self.manifest_Signature_Sig_Alg().get_value())?;
        if let Some(union_obj) = &self.manifest_Signature {
            buffer.write_union(union_obj.as_ref())?;
        } else {

            buffer.write_u32(TPM_ALG_ID::NULL)?;
        }

        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.fu_Digest = buffer.read_u8()?;
        let manifest_Signature_Sig_Alg_value = buffer.read_u32()?;
        selector_values.insert("manifestSignatureSigAlg", manifest_Signature_Sig_Alg_value);
        let selector_value = *selector_values.get("manifestSignatureSigAlg").unwrap_or(&0);
        self.manifest_Signature = if selector_value != 0 {
            let mut obj = UnionFactory::create::<TPMU_SIGNATURE>(selector_value)
            .ok_or(TpmError::InvalidUnion)?;
            buffer.read_union(obj.as_mut())?;
            Some(obj)
        } else {
            None
        };

        Ok(())
    }

}

impl TPM2_FieldUpgradeData_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.fu_Data)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.fu_Data = buffer.read_u8()?;
        Ok(())
    }

}

impl FieldUpgradeDataResponse {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.next_Digest.serialize(buffer)?;
        self.first_Digest.serialize(buffer)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.next_Digest.deserialize(buffer)?;
        self.first_Digest.deserialize(buffer)?;
        Ok(())
    }

}

impl TPM2_FirmwareRead_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u32(self.sequence_Number)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.sequence_Number = buffer.read_u32()?;
        Ok(())
    }

}

impl FirmwareReadResponse {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.fu_Data)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.fu_Data = buffer.read_u8()?;
        Ok(())
    }

}

impl TPM2_ContextSave_REQUEST {
    // Implement serialization/deserialization
    /// No fields to serialize/deserialize
    pub fn serialize(&self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

    pub fn deserialize(&mut self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

}

impl ContextSaveResponse {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.context.serialize(buffer)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.context.deserialize(buffer)?;
        Ok(())
    }

}

impl TPM2_ContextLoad_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.context.serialize(buffer)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.context.deserialize(buffer)?;
        Ok(())
    }

}

impl ContextLoadResponse {
    // Implement serialization/deserialization
    /// No fields to serialize/deserialize
    pub fn serialize(&self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

    pub fn deserialize(&mut self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

}

impl TPM2_FlushContext_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.flush_Handle.serialize(buffer)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.flush_Handle.deserialize(buffer)?;
        Ok(())
    }

}

impl TPM2_EvictControl_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.persistent_Handle.serialize(buffer)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.persistent_Handle.deserialize(buffer)?;
        Ok(())
    }

}

impl TPM2_ReadClock_REQUEST {
    // Implement serialization/deserialization
    /// No fields to serialize/deserialize
    pub fn serialize(&self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

    pub fn deserialize(&mut self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

}

impl ReadClockResponse {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.current_Time.serialize(buffer)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.current_Time.deserialize(buffer)?;
        Ok(())
    }

}

impl TPM2_ClockSet_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u64(self.new_Time)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.new_Time = buffer.read_u64()?;
        Ok(())
    }

}

impl TPM2_ClockRateAdjust_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u32(self.rate_Adjust.get_value())?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        let rate_Adjust_value = buffer.read_u32()?;
        self.rate_Adjust = TPM_CLOCK_ADJUST::try_from(rate_Adjust_value)?;
        Ok(())
    }

}

impl TPM2_GetCapability_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u32(self.capability.get_value())?;
        buffer.write_u32(self.property)?;
        buffer.write_u32(self.property_Count)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        let capability_value = buffer.read_u32()?;
        self.capability = TPM_CAP::try_from(capability_value as i32)?;
        self.property = buffer.read_u32()?;
        self.property_Count = buffer.read_u32()?;
        Ok(())
    }

}

impl GetCapabilityResponse {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.more_Data)?;
        buffer.write_u32(self.capability_Data_Capability().get_value())?;
        if let Some(union_obj) = &self.capability_Data {
            buffer.write_union(union_obj.as_ref())?;
        } else {

            buffer.write_u32(0)?;
        }

        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.more_Data = buffer.read_u8()?;
        let capability_Data_Capability_value = buffer.read_u32()?;
        selector_values.insert("capabilityDataCapability", capability_Data_Capability_value);
        let selector_value = *selector_values.get("capabilityDataCapability").unwrap_or(&0);
        self.capability_Data = if selector_value != 0 {
            let mut obj = UnionFactory::create::<TPMU_CAPABILITIES>(selector_value)
            .ok_or(TpmError::InvalidUnion)?;
            buffer.read_union(obj.as_mut())?;
            Some(obj)
        } else {
            None
        };

        Ok(())
    }

}

impl TPM2_TestParms_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u32(self.parameters_Type().get_value())?;
        if let Some(union_obj) = &self.parameters {
            buffer.write_union(union_obj.as_ref())?;
        } else {

            buffer.write_u32(0)?;
        }

        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        let parameters_Type_value = buffer.read_u32()?;
        selector_values.insert("parametersType", parameters_Type_value);
        let selector_value = *selector_values.get("parametersType").unwrap_or(&0);
        self.parameters = if selector_value != 0 {
            let mut obj = UnionFactory::create::<TPMU_PUBLIC_PARMS>(selector_value)
            .ok_or(TpmError::InvalidUnion)?;
            buffer.read_union(obj.as_mut())?;
            Some(obj)
        } else {
            None
        };

        Ok(())
    }

}

impl TPM2_NV_DefineSpace_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.auth)?;
        self.public_Info.serialize(buffer)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.auth = buffer.read_u8()?;
        self.public_Info.deserialize(buffer)?;
        Ok(())
    }

}

impl TPM2_NV_UndefineSpace_REQUEST {
    // Implement serialization/deserialization
    /// No fields to serialize/deserialize
    pub fn serialize(&self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

    pub fn deserialize(&mut self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

}

impl TPM2_NV_UndefineSpaceSpecial_REQUEST {
    // Implement serialization/deserialization
    /// No fields to serialize/deserialize
    pub fn serialize(&self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

    pub fn deserialize(&mut self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

}

impl TPM2_NV_ReadPublic_REQUEST {
    // Implement serialization/deserialization
    /// No fields to serialize/deserialize
    pub fn serialize(&self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

    pub fn deserialize(&mut self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

}

impl NV_ReadPublicResponse {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.nv_Public.serialize(buffer)?;
        buffer.write_u8(self.nv_Name)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.nv_Public.deserialize(buffer)?;
        self.nv_Name = buffer.read_u8()?;
        Ok(())
    }

}

impl TPM2_NV_Write_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.data)?;
        buffer.write_u16(self.offset)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.data = buffer.read_u8()?;
        self.offset = buffer.read_u16()?;
        Ok(())
    }

}

impl TPM2_NV_Increment_REQUEST {
    // Implement serialization/deserialization
    /// No fields to serialize/deserialize
    pub fn serialize(&self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

    pub fn deserialize(&mut self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

}

impl TPM2_NV_Extend_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.data)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.data = buffer.read_u8()?;
        Ok(())
    }

}

impl TPM2_NV_SetBits_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u64(self.bits)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.bits = buffer.read_u64()?;
        Ok(())
    }

}

impl TPM2_NV_WriteLock_REQUEST {
    // Implement serialization/deserialization
    /// No fields to serialize/deserialize
    pub fn serialize(&self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

    pub fn deserialize(&mut self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

}

impl TPM2_NV_GlobalWriteLock_REQUEST {
    // Implement serialization/deserialization
    /// No fields to serialize/deserialize
    pub fn serialize(&self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

    pub fn deserialize(&mut self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

}

impl TPM2_NV_Read_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u16(self.size)?;
        buffer.write_u16(self.offset)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.size = buffer.read_u16()?;
        self.offset = buffer.read_u16()?;
        Ok(())
    }

}

impl NV_ReadResponse {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.data)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.data = buffer.read_u8()?;
        Ok(())
    }

}

impl TPM2_NV_ReadLock_REQUEST {
    // Implement serialization/deserialization
    /// No fields to serialize/deserialize
    pub fn serialize(&self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

    pub fn deserialize(&mut self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

}

impl TPM2_NV_ChangeAuth_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.new_Auth)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.new_Auth = buffer.read_u8()?;
        Ok(())
    }

}

impl TPM2_NV_Certify_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.qualifying_Data)?;
        buffer.write_u32(self.in_Scheme_Scheme().get_value())?;
        if let Some(union_obj) = &self.in_Scheme {
            buffer.write_union(union_obj.as_ref())?;
        } else {

            buffer.write_u32(TPM_ALG_ID::NULL)?;
        }

        buffer.write_u16(self.size)?;
        buffer.write_u16(self.offset)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.qualifying_Data = buffer.read_u8()?;
        let in_Scheme_Scheme_value = buffer.read_u32()?;
        selector_values.insert("inSchemeScheme", in_Scheme_Scheme_value);
        let selector_value = *selector_values.get("inSchemeScheme").unwrap_or(&0);
        self.in_Scheme = if selector_value != 0 {
            let mut obj = UnionFactory::create::<TPMU_SIG_SCHEME>(selector_value)
            .ok_or(TpmError::InvalidUnion)?;
            buffer.read_union(obj.as_mut())?;
            Some(obj)
        } else {
            None
        };

        self.size = buffer.read_u16()?;
        self.offset = buffer.read_u16()?;
        Ok(())
    }

}

impl NV_CertifyResponse {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.certify_Info.serialize(buffer)?;
        buffer.write_u32(self.signature_Sig_Alg().get_value())?;
        if let Some(union_obj) = &self.signature {
            buffer.write_union(union_obj.as_ref())?;
        } else {

            buffer.write_u32(TPM_ALG_ID::NULL)?;
        }

        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.certify_Info.deserialize(buffer)?;
        let signature_Sig_Alg_value = buffer.read_u32()?;
        selector_values.insert("signatureSigAlg", signature_Sig_Alg_value);
        let selector_value = *selector_values.get("signatureSigAlg").unwrap_or(&0);
        self.signature = if selector_value != 0 {
            let mut obj = UnionFactory::create::<TPMU_SIGNATURE>(selector_value)
            .ok_or(TpmError::InvalidUnion)?;
            buffer.read_union(obj.as_mut())?;
            Some(obj)
        } else {
            None
        };

        Ok(())
    }

}

impl TPM2_AC_GetCapability_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u32(self.capability.get_value())?;
        buffer.write_u32(self.count)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        let capability_value = buffer.read_u32()?;
        self.capability = TPM_AT::try_from(capability_value)?;
        self.count = buffer.read_u32()?;
        Ok(())
    }

}

impl AC_GetCapabilityResponse {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.more_Data)?;
        // List count
        buffer.write_u32(self.capabilities_Data.len() as u32)?;
        for item in &self.capabilities_Data {
            item.serialize(buffer)?;
        }

        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.more_Data = buffer.read_u8()?;
        // List count
        let capabilities_Data_count = buffer.read_u32()? as usize;
        self.capabilities_Data.clear();
        for _ in 0..capabilities_Data_count {
            let mut item = TPMS_AC_OUTPUT::default();
            item.deserialize(buffer)?;
            self.capabilities_Data.push(item);
        }

        Ok(())
    }

}

impl TPM2_AC_Send_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.ac_Data_In)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.ac_Data_In = buffer.read_u8()?;
        Ok(())
    }

}

impl AC_SendResponse {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.ac_Data_Out.serialize(buffer)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.ac_Data_Out.deserialize(buffer)?;
        Ok(())
    }

}

impl TPM2_Policy_AC_SendSelect_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.object_Name)?;
        buffer.write_u8(self.auth_Handle_Name)?;
        buffer.write_u8(self.ac_Name)?;
        buffer.write_u8(self.include_Object)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.object_Name = buffer.read_u8()?;
        self.auth_Handle_Name = buffer.read_u8()?;
        self.ac_Name = buffer.read_u8()?;
        self.include_Object = buffer.read_u8()?;
        Ok(())
    }

}

impl TPM2_ACT_SetTimeout_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u32(self.start_Timeout)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.start_Timeout = buffer.read_u32()?;
        Ok(())
    }

}

impl TPM2_Vendor_TCG_Test_REQUEST {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.input_Data)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.input_Data = buffer.read_u8()?;
        Ok(())
    }

}

impl Vendor_TCG_TestResponse {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.output_Data)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.output_Data = buffer.read_u8()?;
        Ok(())
    }

}

impl TssObject {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.Public.serialize(buffer)?;
        self.Sensitive.serialize(buffer)?;
        self.Private.serialize(buffer)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.Public.deserialize(buffer)?;
        self.Sensitive.deserialize(buffer)?;
        self.Private.deserialize(buffer)?;
        Ok(())
    }

}

impl PcrValue {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u32(self.index)?;
        self.value.serialize(buffer)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.index = buffer.read_u32()?;
        self.value.deserialize(buffer)?;
        Ok(())
    }

}

impl SessionIn {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.handle.serialize(buffer)?;
        buffer.write_u8(self.nonce_Caller)?;
        buffer.write_u32(self.attributes.get_value())?;
        buffer.write_u8(self.auth)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.handle.deserialize(buffer)?;
        self.nonce_Caller = buffer.read_u8()?;
        let attributes_value = buffer.read_u32()?;
        self.attributes = TPMA_SESSION::try_from(attributes_value)?;
        self.auth = buffer.read_u8()?;
        Ok(())
    }

}

impl SessionOut {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u8(self.nonce_Tpm)?;
        buffer.write_u32(self.attributes.get_value())?;
        buffer.write_u8(self.auth)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.nonce_Tpm = buffer.read_u8()?;
        let attributes_value = buffer.read_u32()?;
        self.attributes = TPMA_SESSION::try_from(attributes_value)?;
        self.auth = buffer.read_u8()?;
        Ok(())
    }

}

impl CommandHeader {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        buffer.write_u32(self.Tag.get_value())?;
        buffer.write_u32(self.Command_Size)?;
        buffer.write_u32(self.Command_Code.get_value())?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        let Tag_value = buffer.read_u32()?;
        self.Tag = TPM_ST::try_from(Tag_value)?;
        self.Command_Size = buffer.read_u32()?;
        let Command_Code_value = buffer.read_u32()?;
        self.Command_Code = TPM_CC::try_from(Command_Code_value as i32)?;
        Ok(())
    }

}

impl TSS_KEY {
    // Implement serialization/deserialization
    pub fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Serialize fields
        self.public_Part.serialize(buffer)?;
        buffer.write_u8(self.private_Part)?;
        Ok(())
    }

    pub fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        // Deserialize fields
        // Track selector values for unions
        let mut selector_values = std::collections::HashMap::new();

        self.public_Part.deserialize(buffer)?;
        self.private_Part = buffer.read_u8()?;
        Ok(())
    }

}

impl TPM2B_DIGEST_SYMCIPHER {
    // Implement serialization/deserialization
    /// No fields to serialize/deserialize
    pub fn serialize(&self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

    pub fn deserialize(&mut self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

}

impl TPM2B_DIGEST_KEYEDHASH {
    // Implement serialization/deserialization
    /// No fields to serialize/deserialize
    pub fn serialize(&self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

    pub fn deserialize(&mut self, _buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        Ok(())
    }

}

/// Trait for structures that can be marshaled to/from TPM wire format
pub trait TpmStructure: Sized {
    /// Serialize the structure to a TPM buffer
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError>;

    /// Deserialize the structure from a TPM buffer
    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError>;
}

// Implement TpmStructure trait for all TPM structs
impl TpmStructure for TPM_HANDLE {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMS_NULL_UNION {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMS_EMPTY {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMS_ALGORITHM_DESCRIPTION {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMT_HA {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2B_DIGEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2B_DATA {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2B_EVENT {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2B_MAX_BUFFER {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2B_MAX_NV_BUFFER {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2B_TIMEOUT {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2B_IV {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2B_NAME {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMS_PCR_SELECT {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMS_PCR_SELECTION {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMT_TK_CREATION {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMT_TK_VERIFIED {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMT_TK_AUTH {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMT_TK_HASHCHECK {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMS_ALG_PROPERTY {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMS_TAGGED_PROPERTY {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMS_TAGGED_PCR_SELECT {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMS_TAGGED_POLICY {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMS_ACT_DATA {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPML_CC {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPML_CCA {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPML_ALG {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPML_HANDLE {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPML_DIGEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPML_DIGEST_VALUES {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPML_PCR_SELECTION {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPML_ALG_PROPERTY {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPML_TAGGED_TPM_PROPERTY {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPML_TAGGED_PCR_PROPERTY {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPML_ECC_CURVE {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPML_TAGGED_POLICY {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPML_ACT_DATA {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMS_CAPABILITY_DATA {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMS_CLOCK_INFO {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMS_TIME_INFO {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMS_TIME_ATTEST_INFO {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMS_CERTIFY_INFO {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMS_QUOTE_INFO {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMS_COMMAND_AUDIT_INFO {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMS_SESSION_AUDIT_INFO {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMS_CREATION_INFO {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMS_NV_CERTIFY_INFO {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMS_NV_DIGEST_CERTIFY_INFO {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMS_ATTEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2B_ATTEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMS_AUTH_COMMAND {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMS_AUTH_RESPONSE {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMS_TDES_SYM_DETAILS {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMS_AES_SYM_DETAILS {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMS_SM4_SYM_DETAILS {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMS_CAMELLIA_SYM_DETAILS {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMS_ANY_SYM_DETAILS {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMS_XOR_SYM_DETAILS {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMS_NULL_SYM_DETAILS {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMT_SYM_DEF {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMT_SYM_DEF_OBJECT {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2B_SYM_KEY {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMS_SYMCIPHER_PARMS {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2B_LABEL {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMS_DERIVE {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2B_DERIVE {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2B_SENSITIVE_DATA {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMS_SENSITIVE_CREATE {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2B_SENSITIVE_CREATE {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMS_SCHEME_HASH {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMS_SCHEME_ECDAA {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMS_SCHEME_HMAC {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMS_SCHEME_XOR {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMS_NULL_SCHEME_KEYEDHASH {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMT_KEYEDHASH_SCHEME {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMS_SIG_SCHEME_RSASSA {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMS_SIG_SCHEME_RSAPSS {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMS_SIG_SCHEME_ECDSA {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMS_SIG_SCHEME_SM2 {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMS_SIG_SCHEME_ECSCHNORR {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMS_SIG_SCHEME_ECDAA {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMS_NULL_SIG_SCHEME {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMT_SIG_SCHEME {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMS_ENC_SCHEME_OAEP {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMS_ENC_SCHEME_RSAES {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMS_KEY_SCHEME_ECDH {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMS_KEY_SCHEME_ECMQV {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMS_KDF_SCHEME_MGF1 {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMS_KDF_SCHEME_KDF1_SP800_56A {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMS_KDF_SCHEME_KDF2 {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMS_KDF_SCHEME_KDF1_SP800_108 {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMS_NULL_KDF_SCHEME {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMT_KDF_SCHEME {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMS_NULL_ASYM_SCHEME {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMT_ASYM_SCHEME {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMT_RSA_SCHEME {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMT_RSA_DECRYPT {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2B_PUBLIC_KEY_RSA {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2B_PRIVATE_KEY_RSA {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2B_ECC_PARAMETER {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMS_ECC_POINT {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2B_ECC_POINT {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMT_ECC_SCHEME {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMS_ALGORITHM_DETAIL_ECC {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMS_SIGNATURE_RSA {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMS_SIGNATURE_RSASSA {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMS_SIGNATURE_RSAPSS {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMS_SIGNATURE_ECC {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMS_SIGNATURE_ECDSA {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMS_SIGNATURE_ECDAA {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMS_SIGNATURE_SM2 {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMS_SIGNATURE_ECSCHNORR {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMS_NULL_SIGNATURE {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMT_SIGNATURE {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2B_ENCRYPTED_SECRET {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMS_KEYEDHASH_PARMS {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMS_ASYM_PARMS {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMS_RSA_PARMS {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMS_ECC_PARMS {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMT_PUBLIC_PARMS {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMT_PUBLIC {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2B_PUBLIC {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2B_TEMPLATE {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2B_PRIVATE_VENDOR_SPECIFIC {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMT_SENSITIVE {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2B_SENSITIVE {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for _PRIVATE {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2B_PRIVATE {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMS_ID_OBJECT {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2B_ID_OBJECT {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMS_NV_PIN_COUNTER_PARAMETERS {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMS_NV_PUBLIC {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2B_NV_PUBLIC {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2B_CONTEXT_SENSITIVE {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMS_CONTEXT_DATA {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2B_CONTEXT_DATA {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMS_CONTEXT {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMS_CREATION_DATA {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2B_CREATION_DATA {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPMS_AC_OUTPUT {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPML_AC_CAPABILITIES {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_Startup_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_Shutdown_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_SelfTest_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_IncrementalSelfTest_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for IncrementalSelfTestResponse {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_GetTestResult_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for GetTestResultResponse {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_StartAuthSession_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for StartAuthSessionResponse {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_PolicyRestart_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_Create_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for CreateResponse {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_Load_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for LoadResponse {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_LoadExternal_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for LoadExternalResponse {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_ReadPublic_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for ReadPublicResponse {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_ActivateCredential_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for ActivateCredentialResponse {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_MakeCredential_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for MakeCredentialResponse {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_Unseal_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for UnsealResponse {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_ObjectChangeAuth_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for ObjectChangeAuthResponse {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_CreateLoaded_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for CreateLoadedResponse {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_Duplicate_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for DuplicateResponse {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_Rewrap_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for RewrapResponse {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_Import_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for ImportResponse {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_RSA_Encrypt_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for RSA_EncryptResponse {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_RSA_Decrypt_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for RSA_DecryptResponse {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_ECDH_KeyGen_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for ECDH_KeyGenResponse {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_ECDH_ZGen_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for ECDH_ZGenResponse {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_ECC_Parameters_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for ECC_ParametersResponse {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_ZGen_2Phase_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for ZGen_2PhaseResponse {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_ECC_Encrypt_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for ECC_EncryptResponse {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_ECC_Decrypt_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for ECC_DecryptResponse {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_EncryptDecrypt_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for EncryptDecryptResponse {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_EncryptDecrypt2_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for EncryptDecrypt2Response {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_Hash_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for HashResponse {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_HMAC_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for HMACResponse {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_MAC_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for MACResponse {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_GetRandom_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for GetRandomResponse {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_StirRandom_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_HMAC_Start_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for HMAC_StartResponse {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_MAC_Start_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for MAC_StartResponse {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_HashSequenceStart_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for HashSequenceStartResponse {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_SequenceUpdate_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_SequenceComplete_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for SequenceCompleteResponse {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_EventSequenceComplete_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for EventSequenceCompleteResponse {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_Certify_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for CertifyResponse {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_CertifyCreation_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for CertifyCreationResponse {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_Quote_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for QuoteResponse {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_GetSessionAuditDigest_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for GetSessionAuditDigestResponse {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_GetCommandAuditDigest_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for GetCommandAuditDigestResponse {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_GetTime_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for GetTimeResponse {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_CertifyX509_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for CertifyX509Response {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_Commit_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for CommitResponse {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_EC_Ephemeral_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for EC_EphemeralResponse {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_VerifySignature_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for VerifySignatureResponse {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_Sign_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for SignResponse {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_SetCommandCodeAuditStatus_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_PCR_Extend_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_PCR_Event_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for PCR_EventResponse {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_PCR_Read_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for PCR_ReadResponse {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_PCR_Allocate_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for PCR_AllocateResponse {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_PCR_SetAuthPolicy_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_PCR_SetAuthValue_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_PCR_Reset_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_PolicySigned_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for PolicySignedResponse {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_PolicySecret_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for PolicySecretResponse {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_PolicyTicket_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_PolicyOR_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_PolicyPCR_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_PolicyLocality_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_PolicyNV_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_PolicyCounterTimer_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_PolicyCommandCode_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_PolicyPhysicalPresence_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_PolicyCpHash_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_PolicyNameHash_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_PolicyDuplicationSelect_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_PolicyAuthorize_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_PolicyAuthValue_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_PolicyPassword_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_PolicyGetDigest_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for PolicyGetDigestResponse {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_PolicyNvWritten_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_PolicyTemplate_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_PolicyAuthorizeNV_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_CreatePrimary_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for CreatePrimaryResponse {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_HierarchyControl_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_SetPrimaryPolicy_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_ChangePPS_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_ChangeEPS_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_Clear_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_ClearControl_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_HierarchyChangeAuth_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_DictionaryAttackLockReset_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_DictionaryAttackParameters_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_PP_Commands_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_SetAlgorithmSet_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_FieldUpgradeStart_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_FieldUpgradeData_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for FieldUpgradeDataResponse {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_FirmwareRead_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for FirmwareReadResponse {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_ContextSave_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for ContextSaveResponse {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_ContextLoad_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for ContextLoadResponse {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_FlushContext_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_EvictControl_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_ReadClock_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for ReadClockResponse {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_ClockSet_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_ClockRateAdjust_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_GetCapability_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for GetCapabilityResponse {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_TestParms_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_NV_DefineSpace_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_NV_UndefineSpace_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_NV_UndefineSpaceSpecial_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_NV_ReadPublic_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for NV_ReadPublicResponse {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_NV_Write_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_NV_Increment_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_NV_Extend_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_NV_SetBits_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_NV_WriteLock_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_NV_GlobalWriteLock_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_NV_Read_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for NV_ReadResponse {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_NV_ReadLock_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_NV_ChangeAuth_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_NV_Certify_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for NV_CertifyResponse {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_AC_GetCapability_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for AC_GetCapabilityResponse {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_AC_Send_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for AC_SendResponse {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_Policy_AC_SendSelect_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_ACT_SetTimeout_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2_Vendor_TCG_Test_REQUEST {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for Vendor_TCG_TestResponse {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TssObject {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for PcrValue {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for SessionIn {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for SessionOut {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for CommandHeader {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TSS_KEY {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2B_DIGEST_SYMCIPHER {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

impl TpmStructure for TPM2B_DIGEST_KEYEDHASH {
    fn serialize(&self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.serialize(buffer)
    }

    fn deserialize(&mut self, buffer: &mut TpmBuffer) -> Result<(), TpmError> {
        self.deserialize(buffer)
    }

}

